{"version":3,"file":"value_for_type_node.js","sourceRoot":"","sources":["../value_for_type_node.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright 2020 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport * as ts from 'typescript';\n\nimport {nodeIsReadOnlyArrayInterfaceReference, nodeIsReadOnlyInterfaceReference} from './walk_tree';\n\nexport const nodeIsPrimitive = (node: ts.TypeNode): boolean => {\n  return [\n    ts.SyntaxKind.NumberKeyword,\n    ts.SyntaxKind.StringKeyword,\n    ts.SyntaxKind.BooleanKeyword,\n    ts.SyntaxKind.AnyKeyword,\n    ts.SyntaxKind.UnknownKeyword,\n    ts.SyntaxKind.VoidKeyword,\n  ].includes(node.kind);\n};\n\nexport const valueForTypeNode = (node: ts.TypeNode, isFunctionParam: boolean = false): string => {\n  let value = '';\n\n  if (ts.isTypeReferenceNode(node)) {\n    /* These check for Readonly<X> or ReadonlyArray<X> and unwrap them\n     * so we parse out the inner type instead.\n     */\n    if (nodeIsReadOnlyInterfaceReference(node) && node.typeArguments) {\n      return valueForTypeNode(node.typeArguments[0], isFunctionParam);\n    }\n    if (nodeIsReadOnlyArrayInterfaceReference(node) && node.typeArguments) {\n      /* The structure of a ReadonlyArray node is different to that of an Array node.\n       * Rather than duplicate the logic for handling an array, we can instead construct\n       * an array node from the inner type of the ReadonlyArray and recurse with that.\n       */\n      const arrayNode = ts.factory.createArrayTypeNode(node.typeArguments[0]);\n      return valueForTypeNode(arrayNode, isFunctionParam);\n    }\n    if (ts.isIdentifier(node.typeName)) {\n      value = node.typeName.escapedText.toString();\n      /* For both Maps and Sets we make an assumption that the value within\n         * needs a non-nullable ! prefixed. This is a bit of a simplification\n         * where we assume the value needs a ! if it is not a primitive. There\n         * could be times where this is incorrect. However a search of the\n         * DevTools codebase found no usages of a Map without a `!` for the\n         * value type. So rather than invest in the work now, let's wait until\n         * it causes us a problem and we can revisit.\n         */\n      if (value === 'Map' && node.typeArguments) {\n        const keyType = valueForTypeNode(node.typeArguments[0]);\n        let valueType = valueForTypeNode(node.typeArguments[1]);\n        if (!nodeIsPrimitive(node.typeArguments[1])) {\n          valueType = `!${valueType}`;\n        }\n        value = `Map<${keyType}, ${valueType}>`;\n      } else if (value === 'Set' && node.typeArguments) {\n        let valueType = valueForTypeNode(node.typeArguments[0]);\n        if (!nodeIsPrimitive(node.typeArguments[0])) {\n          valueType = `!${valueType}`;\n        }\n        value = `Set<${valueType}>`;\n      }\n    } else if (ts.isIdentifier(node.typeName.left)) {\n      value = node.typeName.left.escapedText.toString();\n    } else {\n      throw new Error('Internal error: cannot map a node to value.');\n    }\n  } else if (ts.isArrayTypeNode(node)) {\n    const isPrimitive = nodeIsPrimitive(node.elementType);\n    const modifier = isPrimitive ? '' : '!';\n    value = `Array.<${modifier}${valueForTypeNode(node.elementType)}>`;\n  } else if (node.kind === ts.SyntaxKind.NumberKeyword) {\n    value = 'number';\n  } else if (node.kind === ts.SyntaxKind.StringKeyword) {\n    value = 'string';\n  } else if (node.kind === ts.SyntaxKind.BooleanKeyword) {\n    value = 'boolean';\n  } else if (node.kind === ts.SyntaxKind.UndefinedKeyword) {\n    value = 'undefined';\n  } else if (node.kind === ts.SyntaxKind.UnknownKeyword || node.kind === ts.SyntaxKind.AnyKeyword) {\n    value = '*';\n  } else if (node.kind === ts.SyntaxKind.VoidKeyword) {\n    value = 'void';\n  } else if (ts.isUnionTypeNode(node)) {\n    const isNullUnion = node.types.some(node => {\n      return ts.isLiteralTypeNode(node) && node.literal.kind === ts.SyntaxKind.NullKeyword;\n    });\n    if (isNullUnion) {\n      if (node.types.length > 2) {\n        /* decided to defer support for complex types like string | number | null until we hit a legitimate case to use them */\n        throw new Error('Union types with null and > 1 other types are not yet supported.');\n      }\n\n      const notNullNode = node.types.find(n => n.kind !== ts.SyntaxKind.NullKeyword);\n\n      if (!notNullNode) {\n        throw new Error('Found null union without a not null node.');\n      }\n\n      const value = valueForTypeNode(notNullNode);\n      return `?${value}`;\n    }\n\n    const parts = node.types.map(n => valueForTypeNode(n, isFunctionParam));\n    return parts.join('|');\n  } else if (ts.isFunctionTypeNode(node)) {\n    let returnType = valueForTypeNode(node.type);\n\n    /* If the function returns a union, and we are in a function param, we need to wrap it in parens to satisfy the Closure parser\n     * e.g. it wants: someFunc: function(string): (string|undefined)\n     *   rather than: someFunc: function(string): string|undefined\n     */\n    if (returnType.includes('|')) {\n      returnType = `(${returnType})`;\n    }\n\n    const params = node.parameters\n                       .map(param => {\n                         if (!param.type) {\n                           return '';\n                         }\n\n                         const valueForParam = valueForTypeNode(param.type, true);\n\n                         if (nodeIsPrimitive(param.type)) {\n                           // A primitive never has a ! at the start, but does have a = at the end if it's optional.\n                           return param.questionToken ? `${valueForParam}=` : valueForParam;\n                         }\n\n                         // If it's not a primitive, it's a type ref and needs a\n                         // non-nullable ! at the start and a = at the end if\n                         // it's optional.\n                         return [\n                           '!',\n                           valueForTypeNode(param.type, true),\n                           param.questionToken ? '=' : '',\n                         ].join('');\n                       })\n                       .join(', ');\n\n    value = `function(${params}):${returnType}`;\n  } else if (ts.isTypeLiteralNode(node)) {\n    const members = node.members\n                        .map(member => {\n                          if (ts.isPropertySignature(member) && member.type) {\n                            let requiredOptionalFlag = '';\n\n                            if (ts.isTypeReferenceNode(member.type) || ts.isArrayTypeNode(member.type)) {\n                              requiredOptionalFlag = !!member.questionToken ? '?' : '!';\n                            }\n                            return {\n                              name: (member.name as ts.Identifier).escapedText.toString(),\n                              value: requiredOptionalFlag + valueForTypeNode(member.type, isFunctionParam),\n                            };\n                          }\n\n                          return null;\n                        })\n                        .map(member => {\n                          return member ? `${member.name}: ${member.value}` : null;\n                        })\n                        .filter(Boolean)\n                        .join(', ');\n\n    return `{${members}}`;\n  } else if (ts.isLiteralTypeNode(node)) {\n    if (ts.isStringLiteral(node.literal)) {\n      return `\"${node.literal.text}\"`;\n    }\n    throw new Error(`Unsupported literal node kind: ${ts.SyntaxKind[node.literal.kind]}`);\n  } else if (node.kind === ts.SyntaxKind.NullKeyword) {\n    value = 'null';\n  } else {\n    throw new Error(`Unsupported node kind: ${ts.SyntaxKind[node.kind]}`);\n  }\n  return value;\n};\n"]}