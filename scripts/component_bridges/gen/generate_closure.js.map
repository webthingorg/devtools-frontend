{"version":3,"file":"generate_closure.js","sourceRoot":"","sources":["../generate_closure.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright 2020 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\nimport * as ts from 'typescript';\n\nimport {findNodeForTypeReferenceName} from './utils.js';\nimport {nodeIsPrimitive, valueForTypeNode} from './value_for_type_node.js';\nimport {WalkerState} from './walk_tree.js';\n\nexport const generateCreatorFunction = (state: WalkerState): string[] => {\n  if (!state.componentClass || !state.componentClass.name || !state.customElementsDefineCall) {\n    throw new Error('No component class or custom elements define call found: cannot generate creator function.');\n  }\n  const componentClassName = state.componentClass.name.escapedText.toString();\n\n  const call = state.customElementsDefineCall.expression as ts.CallExpression;\n  const customElementTagArgument = call.arguments[0] as ts.StringLiteral;\n  const customElementTagName = customElementTagArgument.text;\n  const componentClassCamelCased = componentClassName[0].toUpperCase() + componentClassName.slice(1);\n\n  const interfaceName = generatedClassInterfaceName(state.componentClass);\n\n  const output: string[] = [\n    '/**',\n    `* @return {!${interfaceName}}`,\n    '*/',\n    `export function create${componentClassCamelCased}() {`,\n    `  return /** @type {!${interfaceName}} */ (document.createElement('${customElementTagName}'));`,\n    '}',\n  ];\n  return output;\n};\n\nconst generatedClassInterfaceName = (componentClass: ts.ClassDeclaration): string => {\n  const className = componentClass.name && componentClass.name.escapedText;\n  // the name needs to differ from the TypeScript name so there's no TS/Closure conflicts\n  return `${className}ClosureInterface`;\n};\n\nconst indent = (str: string, amountOfSpaces: number): string => {\n  return ' '.repeat(amountOfSpaces) + str;\n};\n\nconst paramIsMarkedAsOptionalOrRequired = (param: string) => {\n  const startChars = ['!', '?'];\n  return startChars.some(c => param.startsWith(c));\n};\n\ninterface TypeNodeToJSDocOptions {\n  paramName: string;\n  nodeIsOptional: boolean;\n  docType: 'param'|'return';\n}\n\nconst typeNodeToJSDocClosureType = (node: ts.TypeNode, options: TypeNodeToJSDocOptions): string => {\n  const paramValue = valueForTypeNode(node, true);\n  const {nodeIsOptional, paramName, docType} = options;\n\n  const paramNameIfRequired = docType === 'param' ? ` ${paramName}` : '';\n\n  /* the rules for ? or ! inside params are subtle when we are given\n   * an interface that's optional in TypeScript land we need to tell\n   * Closure that it's optional _but not nullable_.?Foo in Closure\n   * would let Foo be null so instead we go for {!Foo=} which states\n   * it's optional but not nullable. but note that if we pass a\n   * union of Foo | Null, that should become {?Foo}, which is dealt\n   * with within valueForTypeNode().\n   *\n   * additionally, primitive optionals in TS aren't as\n   * straightforward as throwing a ? on it as that makes it\n   * nullable, not optional\n   *\n   * we also don't need a ! at the start of primitive non-optional\n   * types, but do need the ! at the start of non-optional\n   * interfaces\n   *\n   * TS                    <|> Closure\n   * person?: Person       <|> {!Person=}\n   * person: Person | null <|> {?Person}\n   * name?: string         <|> {(string|undefined)=}\n   */\n\n  if (ts.isTypeReferenceNode(node)) {\n    const paramString = ['!', paramValue, nodeIsOptional ? '=' : ''].join('');\n    return `* @${docType} {${paramString}}${paramNameIfRequired}`;\n  }\n\n  if (ts.isArrayTypeNode(node)) {\n    /* a required array = !Array.<!Foo>\n     * an optional array = (!Array.<!Foo>|undefined)=\n     * so we first construct the param as if it was required\n     * because if it's optional we just add |undefined and wrap in braces\n     */\n\n    let output = '!Array.<';\n\n    const internalType = node.elementType;\n    if (nodeIsPrimitive(internalType)) {\n      output += valueForTypeNode(internalType, true);\n    } else if (ts.isTypeReferenceNode(internalType)) {\n      // interfaces need the ! so they are non-nullable in Closure land\n      output += `!${valueForTypeNode(internalType, true)}`;\n    } else {\n      throw new Error(`Unsupported Array<X> type: ${ts.SyntaxKind[internalType.kind]}`);\n    }\n    output += '>';\n\n    if (nodeIsOptional) {\n      output = `(${output}|undefined)=`;\n    }\n\n    return `* @${docType} {${output}}${paramNameIfRequired}`;\n  }\n\n\n  // valueForTypeNode() may have added a ! or ? in which case we don't need to.\n  const needsOptionalModifier = paramIsMarkedAsOptionalOrRequired(paramValue) === false;\n\n  if (nodeIsOptional) {\n    const paramString = ['(', paramValue, '|', 'undefined', ')='].join('');\n    return `* @${docType} {${paramString}}${paramNameIfRequired}`;\n  }\n\n  let paramOptionalModifier = '';\n  if (needsOptionalModifier) {\n    if (nodeIsOptional) {\n      paramOptionalModifier = '?';\n    } else if (nodeIsPrimitive(node) || ts.isTypeLiteralNode(node)) {\n      /* primitive types don't need an explicit ! when they are required\n       * and type literals (object literals) don't either.\n       */\n      paramOptionalModifier = '';\n    } else {\n      paramOptionalModifier = '!';\n    }\n  }\n\n  return `* @${docType} {${paramOptionalModifier}${paramValue}}${paramNameIfRequired}`;\n};\n\nexport const generateClosureClass = (state: WalkerState): string[] => {\n  const customElementClass = state.componentClass;\n  if (!customElementClass) {\n    throw new Error('No component class: cannot generate Closure class.');\n  }\n  const output: string[] = [];\n  const generatedClassName = generatedClassInterfaceName(customElementClass);\n  // the line is used as a Closure typedoc so it is used\n  output.push('// eslint-disable-next-line no-unused-vars');\n  output.push(`export class ${generatedClassName} extends HTMLElement {`);\n\n  state.publicMethods.forEach(method => {\n    let methodName = '';\n    if (ts.isIdentifier(method.name)) {\n      methodName = method.name.escapedText.toString();\n    }\n\n    // get the arguments for the function so we can place them in the definition\n    const argsForFunc = method.parameters\n                            .map(param => {\n                              return (param.name as ts.Identifier).escapedText.toString();\n                            })\n                            .join(', ');\n\n    let jsDocForFunc = ['/**'];\n    method.parameters.forEach(param => {\n      if (!param.type) {\n        return;\n      }\n      const paramName = (param.name as ts.Identifier).escapedText.toString();\n      const parsedParam = typeNodeToJSDocClosureType(param.type, {\n        paramName,\n        nodeIsOptional: !!param.questionToken,\n        docType: 'param',\n      });\n\n      jsDocForFunc.push(parsedParam);\n    });\n\n    if (method.type) {\n      const parsedReturnType = typeNodeToJSDocClosureType(method.type, {\n        nodeIsOptional: false,\n        paramName: 'return type',\n        docType: 'return',\n      });\n      jsDocForFunc.push(parsedReturnType);\n    }\n\n    jsDocForFunc.push('*/');\n    jsDocForFunc = jsDocForFunc.map(line => indent(line, 2));\n\n    output.push(jsDocForFunc.join('\\n'));\n    output.push(indent(`${methodName}(${argsForFunc}) {`, 2));\n    /**\n     * If we have a function that returns a value, in the bridge we will get\n     * TypeScript errors saying that a function is defined and returns a value,\n     * but the implementation is empty. This is fine, because the actual\n     * implementation doesn't live in the bridge file, but we need to satisfy\n     * TS. Adding an error that it thrown will keep it happy and it's safe\n     * because the bridge code is never actually executed; it exists only to\n     * keep Closure happy.\n     */\n    if (method.type && method.type.kind !== ts.SyntaxKind.VoidKeyword) {\n      output.push(indent('throw new Error(\\'Not implemented in _bridge.js\\');', 4));\n    }\n    /* We split the closing brace onto its own line as that's how Clang format\n     * does things - so doing it here means we save an extra change when the presubmit\n     * checks run Clang and reformat the braces.\n     */\n    output.push(indent('}', 2));\n  });\n\n  state.getters.forEach(getter => {\n    let jsDocForFunc = ['/**'];\n    const getterName = (getter.name as ts.Identifier).escapedText.toString();\n\n    if (!getter.type) {\n      throw new Error(`Found invalid getter with no return type: ${getterName}`);\n    }\n\n    const returnTypeClosure = typeNodeToJSDocClosureType(getter.type, {\n      paramName: getterName,\n      /* return types in TypeScript are never optional\n       * you can do Foo | null but that's not optional, that's a union type\n       */\n      nodeIsOptional: false,\n      docType: 'return',\n    });\n\n    jsDocForFunc.push(returnTypeClosure);\n    jsDocForFunc.push('*/');\n    jsDocForFunc = jsDocForFunc.map(line => indent(line, 2));\n\n    output.push(jsDocForFunc.join('\\n'));\n    output.push(indent(`get ${getterName}() {`, 2));\n    output.push(indent('throw new Error(\\'Not implemented in _bridge.js\\');', 4));\n    output.push(indent('}', 2));\n  });\n\n  state.setters.forEach(setter => {\n    let jsDocForFunc = ['/**'];\n    const setterName = (setter.name as ts.Identifier).escapedText.toString();\n\n    if (setter.parameters.length === 0) {\n      throw new Error(`Found invalid setter with no parameter: ${setterName}`);\n    }\n\n    const setterParamName = (setter.parameters[0].name as ts.Identifier).escapedText.toString();\n    const setterParamType = setter.parameters[0].type;\n\n    if (!setterParamType) {\n      throw new Error(`Found invalid setter with no explicit parameter type: ${setterName}`);\n    }\n\n    const parsedType = typeNodeToJSDocClosureType(setterParamType, {\n      docType: 'param',\n      nodeIsOptional: !!setter.parameters[0].questionToken,\n      paramName: setterParamName,\n    });\n\n    jsDocForFunc.push(parsedType);\n    jsDocForFunc.push('*/');\n    jsDocForFunc = jsDocForFunc.map(line => indent(line, 2));\n    output.push(jsDocForFunc.join('\\n'));\n\n    output.push(indent(`set ${setterName}(${setterParamName}) {`, 2));\n    output.push(indent('}', 2));\n  });\n\n  output.push('}');\n  return output;\n};\n\n\nconst generateInterfaceMembers =\n    (members: ts.NodeArray<ts.TypeElement|ts.TypeNode>|Array<ts.TypeElement|ts.TypeNode>, interfaceName: string):\n        string[] => {\n          const output: string[] = [];\n\n          members.forEach(member => {\n            if (ts.isPropertySignature(member)) {\n              if (!member.type) {\n                throw new Error(`Interface member ${ts.SyntaxKind[member.kind]} did not have a type key, aborting.`);\n              }\n\n              const keyIdentifer = member.name as ts.Identifier;\n              const memberIsOptional = !!member.questionToken;\n              const keyName = keyIdentifer.escapedText;\n              let nodeValue = valueForTypeNode(member.type);\n\n              if (ts.isLiteralTypeNode(member.type) && ts.isStringLiteral(member.type.literal)) {\n                throw new Error(`Error: type ${interfaceName} has string literal key ${keyName}: ${nodeValue}`);\n              }\n\n              if (ts.isUnionTypeNode(member.type)) {\n                checkUnionTypeValid(member.type, `${interfaceName}.${keyName}`);\n              }\n\n              if (memberIsOptional) {\n                if (nodeIsPrimitive(member.type)) {\n                  nodeValue = `(${nodeValue}|undefined)`;\n                } else {\n                  nodeValue = `(!${nodeValue}|undefined)`;\n                }\n              } else if (ts.isTypeReferenceNode(member.type) || ts.isArrayTypeNode(member.type)) {\n                /* If the member not optional and is a reference to another type, or an Array,\n                  * it needs an explicit ! at the beginning\n                  */\n                nodeValue = `!${nodeValue}`;\n              }\n              output.push(`* ${keyName}:${nodeValue},`);\n            }\n          });\n\n          return output;\n        };\n\n/**\n * Takes a type reference node, looks up the state of found interface for it,\n * and returns its members.\n */\nconst membersForTypeReference =\n    (state: WalkerState, typeReference: ts.TypeReferenceNode): ts.NodeArray<ts.TypeElement|ts.TypeNode> => {\n      if (!ts.isIdentifierOrPrivateIdentifier(typeReference.typeName)) {\n        throw new Error('Unexpected type reference without an identifier.');\n      }\n      const interfaceName = typeReference.typeName.escapedText.toString();\n\n      const interfaceOrTypeAlias = findNodeForTypeReferenceName(state, interfaceName);\n\n      if (!interfaceOrTypeAlias) {\n        throw new Error(`Could not find interface or type alias: ${interfaceName}`);\n      }\n\n      if (ts.isInterfaceDeclaration(interfaceOrTypeAlias)) {\n        return interfaceOrTypeAlias.members;\n      }\n\n      if (ts.isTypeAliasDeclaration(interfaceOrTypeAlias) && ts.isUnionTypeNode(interfaceOrTypeAlias.type)) {\n        return interfaceOrTypeAlias.type.types;\n      }\n\n      if (ts.isTypeAliasDeclaration(interfaceOrTypeAlias) && ts.isTypeLiteralNode(interfaceOrTypeAlias.type)) {\n        return interfaceOrTypeAlias.type.members;\n      }\n\n      throw new Error(`Unexpected type reference: ${ts.SyntaxKind[interfaceOrTypeAlias.kind]}`);\n    };\n\nconst gatherMembersForInterface =\n    (state: WalkerState, currentInterface: ts.InterfaceDeclaration):\n        (ts.TypeElement|ts.TypeNode)[] => {\n          const allMembers: (ts.TypeNode|ts.TypeElement)[] = [];\n\n          // first, we gather all the members of any interfaces this interface extends\n          // e.g. if we have interface X extends Y, Z, we recurse to find members of Y and Z.\n          if (currentInterface.heritageClauses) {\n            currentInterface.heritageClauses.forEach(heritageClause => {\n              const extendNames = heritageClause.types.map(heritageClauseName => {\n                if (ts.isIdentifier(heritageClauseName.expression)) {\n                  return heritageClauseName.expression.escapedText.toString();\n                }\n                throw new Error('Unexpected heritageClauseName with no identifier.');\n              });\n\n              extendNames.forEach(interfaceName => {\n                const interfaceDec = findNodeForTypeReferenceName(state, interfaceName);\n                if (!interfaceDec) {\n                  throw new Error(`Could not find interface or type alias: ${interfaceName}`);\n                }\n                if (!ts.isInterfaceDeclaration(interfaceDec)) {\n                  throw new Error('Found invalid TypeScript: an interface cannot extend a type.');\n                }\n\n                if (interfaceDec.heritageClauses) {\n                  allMembers.push(...gatherMembersForInterface(state, interfaceDec));\n                } else {\n                  allMembers.push(...interfaceDec.members);\n                }\n              });\n            });\n          }\n\n          // now, gather the members of the actual interface itself\n          allMembers.push(...currentInterface.members);\n          return allMembers;\n        };\n\nconst checkUnionTypeValid = (node: ts.UnionTypeNode, typeName: string) => {\n  node.types.forEach(unionTypeMember => {\n    if (ts.isLiteralTypeNode(unionTypeMember) && ts.isStringLiteral(unionTypeMember.literal)) {\n      const actualLiteralValue = unionTypeMember.literal.text;\n      throw new Error(`Error: union type ${typeName} has a string literal member: \"${actualLiteralValue}\"`);\n    }\n  });\n};\n\nconst checkInterfaceMembersValid =\n    (state: WalkerState, members: ts.NodeArray<ts.TypeElement|ts.TypeNode>|Array<ts.TypeElement|ts.TypeNode>,\n     interfaceName: string) => {\n      members.forEach(member => {\n        if (ts.isPropertySignature(member)) {\n          if (!member.type) {\n            throw new Error(`Interface member ${ts.SyntaxKind[member.kind]} did not have a type key, aborting.`);\n          }\n          if (ts.isTypeReferenceNode(member.type) && ts.isQualifiedName(member.type.typeName)) {\n            const leftType = member.type.typeName.left as ts.Identifier;\n            const leftNode = findNodeForTypeReferenceName(state, leftType.escapedText.toString());\n            if (!leftNode || !state.foundEnums.has(leftNode as ts.EnumDeclaration)) {\n              throw new Error(`Invalid member ${ts.SyntaxKind[member.kind]} of interface ${interfaceName} found.`);\n            }\n          }\n        }\n      });\n    };\n\nconst generateClosureForInterface =\n    (state: WalkerState, interfaceName: string): string[] => {\n      const typeReferenceNode = findNodeForTypeReferenceName(state, interfaceName);\n\n      if (!typeReferenceNode) {\n        throw new Error(`Could not find definition for reference: ${interfaceName}`);\n      }\n\n      if (ts.isEnumDeclaration(typeReferenceNode)) {\n        return generateEnumOutput(typeReferenceNode);\n      }\n\n      const interfaceBits: string[] = ['/**'];\n\n      if (ts.isInterfaceDeclaration(typeReferenceNode)) {\n        interfaceBits.push('* @typedef {{');\n        const allMembersOfInterface = gatherMembersForInterface(state, typeReferenceNode);\n        checkInterfaceMembersValid(state, allMembersOfInterface, interfaceName);\n        interfaceBits.push(...generateInterfaceMembers(allMembersOfInterface, interfaceName));\n        interfaceBits.push('* }}');\n        interfaceBits.push('*/');\n      } else if (ts.isTypeAliasDeclaration(typeReferenceNode) && ts.isUnionTypeNode(typeReferenceNode.type)) {\n        checkUnionTypeValid(typeReferenceNode.type, interfaceName);\n        // e.g. type X = A|B, type Y = string|number, etc\n        const unionTypeConverted = typeReferenceNode.type.types.map(v => valueForTypeNode(v)).join('|');\n        interfaceBits.push(`* @typedef {${unionTypeConverted}}`);\n        interfaceBits.push('*/');\n      } else if (ts.isTypeAliasDeclaration(typeReferenceNode) && ts.isTypeLiteralNode(typeReferenceNode.type)) {\n        // e.g. type X = { name: string; }\n        interfaceBits.push('* @typedef {{');\n        checkInterfaceMembersValid(state, typeReferenceNode.type.members, interfaceName);\n        interfaceBits.push(...generateInterfaceMembers(typeReferenceNode.type.members, interfaceName));\n        interfaceBits.push('* }}');\n        interfaceBits.push('*/');\n      } else if (ts.isTypeAliasDeclaration(typeReferenceNode) && ts.isIntersectionTypeNode(typeReferenceNode.type)) {\n        // e.g. type Foo = Bar & {...}\n        /* Closure types don't support being extended, so in this case we define the type Foo\n      * in Closure as all the members of Foo and all the members of Bar\n      */\n        interfaceBits.push('* @typedef {{');\n        const allMembers: (ts.TypeNode|ts.TypeElement)[] = [];\n        typeReferenceNode.type.types.forEach(typePart => {\n          if (ts.isTypeLiteralNode(typePart)) {\n            allMembers.push(...typePart.members);\n          } else if (ts.isTypeReferenceNode(typePart)) {\n            /** This means it's a reference to either an interface or a type alias\n         * So we need to find that object in the interfaces that the tree walker found\n         * And then parse out the members to Closure.\n         */\n            const members = membersForTypeReference(state, typePart);\n            allMembers.push(...members);\n          } else {\n            throw new Error(`Unsupported: a type extended something that the bridges generator doesn't understand: ${\n                ts.SyntaxKind[typePart.kind]}`);\n          }\n        });\n\n        /**\n          * Now we have all the members, we need to check if any override each other.\n          * e.g.:\n          * type Person = { name: string }\n          * type Jack = Person & { name: 'jack' }\n          *\n          * Should generate a typedef with one `name` key, set to the string \"jack\".\n          *\n          * Because we populate the array of allMembers from left to right, that\n          * means we can loop over them now and set the keys in the map as we\n          * go. Any that are overriden will have their entry in the map\n          * overriden accordingly\n          * and then we can take the final list of members and convert those to Closure syntax.\n          */\n        const membersToOutput = new Map<string, ts.TypeNode|ts.TypeElement>();\n        allMembers.forEach(member => {\n          if (!ts.isPropertySignature(member)) {\n            throw new Error(`Unexpected member without a property signature: ${ts.SyntaxKind[member.kind]}`);\n          }\n          const keyIdentifer = (member.name as ts.Identifier).escapedText.toString();\n          membersToOutput.set(keyIdentifer, member);\n        });\n        const finalMembers = ts.createNodeArray([...membersToOutput.values()]);\n        checkInterfaceMembersValid(state, finalMembers, interfaceName);\n        interfaceBits.push(...generateInterfaceMembers(finalMembers, interfaceName));\n\n        interfaceBits.push('* }}');\n        interfaceBits.push('*/');\n      } else {\n        throw new Error(`Unsupported type alias nested type: ${ts.SyntaxKind[typeReferenceNode.type.kind]}.`);\n      }\n\n      interfaceBits.push('// @ts-ignore we export this for Closure not TS');\n      interfaceBits.push(`export let ${interfaceName};`);\n\n      return interfaceBits;\n    };\n\nexport const generateTypeReferences = (state: WalkerState): Array<string[]> => {\n  const finalCode: Array<string[]> = [];\n\n  state.typeReferencesToConvert.forEach(interfaceName => {\n    finalCode.push(generateClosureForInterface(state, interfaceName));\n  });\n\n  return finalCode;\n};\n\nconst getEnumType = (node: ts.EnumDeclaration): 'string'|'number' => {\n  const firstMember = node.members[0];\n  const enumName = node.name.escapedText.toString();\n\n  if (!firstMember.initializer) {\n    throw new Error(`Enum ${enumName} has an unitialized member.`);\n  }\n\n  if (ts.isStringLiteral(firstMember.initializer)) {\n    return 'string';\n  }\n  if (ts.isNumericLiteral(firstMember.initializer)) {\n    return 'number';\n  }\n\n  throw new Error(`Enum ${enumName} has a member whose type is not string or number.`);\n};\n\nconst generateEnumOutput = (enumDeclaration: ts.EnumDeclaration): string[] => {\n  const enumOutput: string[] = [];\n  const enumType = getEnumType(enumDeclaration);\n  enumOutput.push('/**');\n  enumOutput.push(`* @enum {${enumType}}`);\n  enumOutput.push('*/');\n  const enumName = enumDeclaration.name.escapedText.toString();\n  enumOutput.push('// @ts-ignore we export this for Closure not TS');\n  enumOutput.push(`export let ${enumName} = {`);\n  enumDeclaration.members.forEach(member => {\n    if (!ts.isIdentifier(member.name)) {\n      throw new Error(`Unexpected: member of enum ${enumName} does not have an identifier`);\n    }\n    const enumKey = member.name.escapedText.toString();\n    const enumValue = member.initializer && (member.initializer as ts.StringLiteral | ts.NumericLiteral).text;\n    const valueToOutput = enumType === 'string' ? `'${enumValue}'` : enumValue;\n    enumOutput.push(`  ${enumKey}: ${valueToOutput},`);\n  });\n  enumOutput.push('};');\n\n  return enumOutput;\n};\n\nexport interface GeneratedCode {\n  types: string[][];\n  closureClass: string[];\n  creatorFunction: string[];\n}\n\nexport const generateClosureBridge = (state: WalkerState): GeneratedCode => {\n  const result: GeneratedCode = {\n    types: generateTypeReferences(state),\n    closureClass: generateClosureClass(state),\n    creatorFunction: generateCreatorFunction(state),\n  };\n\n  return result;\n};\n"]}