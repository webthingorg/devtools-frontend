{"version":3,"file":"walk_tree.js","sourceRoot":"","sources":["walk_tree.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright 2020 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport * as fs from 'fs';\nimport * as path from 'path';\nimport * as ts from 'typescript';\nimport {findNodeForTypeReferenceName} from './utils';\n\ninterface ExternalImport {\n  namedImports: Set<string>;\n  filePath: string;\n}\n\ninterface NamespaceImport {\n  filePath: string;\n  namespace: string;\n}\n\nexport interface WalkerState {\n  /* Whilst these are technically different things, for the bridge generation we\n   * can treat them the same - the Closure output is similar for both - and the\n   * overhead of an extra piece of state and another set to check isn't worth it\n   */\n  foundInterfaces: Set<ts.InterfaceDeclaration|ts.TypeAliasDeclaration>;\n  foundEnums: Set<ts.EnumDeclaration>;\n  typeReferencesToConvert: Set<string>;\n  componentClass?: ts.ClassDeclaration;\n  publicMethods: Set<ts.MethodDeclaration>;\n  customElementsDefineCall?: ts.ExpressionStatement;\n  // Stores any usage of legacy interfaces - e.g. Common.Color.Color\n  // Currently only supports \"common\" but can be extended if needed to other legacy classes.\n  legacyInterfaceReferences: Set<'common'>;\n  imports: Set<ExternalImport|NamespaceImport>;\n  getters: Set<ts.GetAccessorDeclaration>;\n  setters: Set<ts.SetAccessorDeclaration>;\n}\n\nconst classExtendsHTMLElement = (classNode: ts.ClassDeclaration): boolean => {\n  if (!classNode.heritageClauses) {\n    return false;\n  }\n\n  return classNode.heritageClauses.some(clause => {\n    return clause.types.find(clauseType => {\n      if (ts.isIdentifier(clauseType.expression)) {\n        return clauseType.expression.escapedText === 'HTMLElement';\n      }\n      return false;\n    });\n  });\n};\n\n/*\n * Detects if a Node is of type Readonly<X>.\n */\nexport const nodeIsReadOnlyInterfaceReference = (node: ts.Node): node is ts.TypeReferenceNode => {\n  return ts.isTypeReferenceNode(node) && ts.isIdentifier(node.typeName) && node.typeName.escapedText === 'Readonly';\n};\n/*\n * Detects if a Node is of type ReadonlyArray<X>.\n */\nexport const nodeIsReadOnlyArrayInterfaceReference = (node: ts.Node): node is ts.TypeReferenceNode => {\n  return ts.isTypeReferenceNode(node) && ts.isIdentifier(node.typeName) &&\n      node.typeName.escapedText === 'ReadonlyArray';\n};\n\n/**\n * Takes a Node and looks for any type references within that Node. This is done\n * so that if an interface references another within its definition, that other\n * interface is found and generated within the bridge.\n */\nconst findTypeReferencesWithinNode = (state: WalkerState, node: ts.Node): Set<string> => {\n  const foundInterfaces = new Set<string>();\n  /*\n   * If the Node is ReadOnly<X>, then we want to ditch the ReadOnly and recurse to\n   * parse the inner type to check if that's an interface.\n   */\n  if (nodeIsReadOnlyInterfaceReference(node) || nodeIsReadOnlyArrayInterfaceReference(node)) {\n    if (!node.typeArguments) {\n      throw new Error('Found ReadOnly interface with no type arguments; invalid TS detected.');\n    }\n    return findTypeReferencesWithinNode(state, node.typeArguments[0]);\n  }\n\n  if (ts.isArrayTypeNode(node) && ts.isTypeReferenceNode(node.elementType) &&\n      ts.isIdentifier(node.elementType.typeName)) {\n    foundInterfaces.add(node.elementType.typeName.escapedText.toString());\n\n  } else if (ts.isTypeReferenceNode(node) && ts.isIdentifier(node.typeName)) {\n    if (node.typeName.escapedText === 'Map' || node.typeName.escapedText === 'Set') {\n      // Map<X, Y> or Set<X> - we need to check the type arguments for any references>\n      if (!node.typeArguments) {\n        throw new Error(`Found a ${node.typeName.escapedText} without type arguments.`);\n      }\n      const referencesWithinGenerics =\n          node.typeArguments.flatMap(node => [...findTypeReferencesWithinNode(state, node)]);\n      referencesWithinGenerics.forEach(r => foundInterfaces.add(r));\n    } else {\n      foundInterfaces.add(node.typeName.escapedText.toString());\n    }\n  } else if (ts.isTypeReferenceNode(node) && ts.isQualifiedName(node.typeName)) {\n    // We will need only the left type to support enum member references (e.g., 'MyEnum.Member').\n    const left = node.typeName.left;\n    if (ts.isQualifiedName(left)) {\n      if (ts.isIdentifier(left.left)) {\n        const firstPartOfName = left.left.escapedText.toString();\n        /**\n        * The bridges generator doesn't understand deeply nested structures, e.g. Common.Color.Color.\n        * We use Common.X.X quite a lot in the codebase, so if we hit upon a \"Common.X\", just ignore it and don't try to save it.\n        *\n        * If it's not common, throw an error.\n        * We can extend this if required to allow use of other legacy interfaces.\n        */\n        if (firstPartOfName === 'Common') {\n          state.legacyInterfaceReferences.add('common');\n        } else {\n          throw new Error(`Found deeply nested interface, starting with \\`${firstPartOfName}\\`.`);\n        }\n      }\n    } else if (ts.isIdentifier(left)) {\n      foundInterfaces.add(left.escapedText.toString());\n    }\n  } else if (ts.isUnionTypeNode(node)) {\n    /**\n     * If the param is something like `x: Foo|null` we want to loop over each type\n     * because we need to pull the `Foo` out.\n     */\n    node.types.forEach(unionTypeMember => {\n      findTypeReferencesWithinNode(state, unionTypeMember).forEach(i => foundInterfaces.add(i));\n    });\n  } else if (ts.isTypeLiteralNode(node)) {\n    /* type literal here means it's an object: data: { x: string; y: number, z: SomeInterface , ... }\n     * so we loop over each member and recurse to find any references we need\n     */\n    node.members.forEach(member => {\n      if (ts.isPropertySignature(member) && member.type) {\n        const extraInterfaces = findTypeReferencesWithinNode(state, member.type);\n        extraInterfaces.forEach(i => foundInterfaces.add(i));\n      }\n    });\n  }\n\n  return foundInterfaces;\n};\n\nconst isPrivate = (node: ts.MethodDeclaration|ts.GetAccessorDeclaration|ts.SetAccessorDeclaration): boolean => {\n  return node.modifiers && node.modifiers.some(modifier => modifier.kind === ts.SyntaxKind.PrivateKeyword) || false;\n};\n\n// We want to check that the identifier is either LitHtml.html or just html.\n// If it's not a LitHtml.html call, we don't care about this node.\nconst taggedTemplateExpressionIsLitHtmlCall = (node: ts.TaggedTemplateExpression): boolean => {\n  // This means it's .y`blah` - so need to check if X.y is LitHtml.html\n  if (ts.isPropertyAccessExpression(node.tag) && ts.isIdentifier(node.tag.expression) &&\n      ts.isIdentifier(node.tag.name)) {\n    const objectName = node.tag.expression.escapedText.toString();\n    const propertyName = node.tag.name.escapedText.toString();\n    return objectName === 'LitHtml' && propertyName === 'html';\n  }\n\n  // This means it's just x`blah` - so check if x is named `html`.\n  if (ts.isIdentifier(node.tag)) {\n    return node.tag.escapedText.toString() === 'html';\n  }\n\n  return false;\n};\n\nconst checkTemplateSpanForTypeCastOfData = (matchingSpan: ts.TemplateSpan) => {\n  const spanHasTypeCast = ts.isAsExpression(matchingSpan.expression);\n  if (!spanHasTypeCast) {\n    throw new Error('Error: found a lit-html .data= without an `as X` typecast.');\n  }\n\n  const typeCastIsTypeReference =\n      ts.isAsExpression(matchingSpan.expression) && ts.isTypeReferenceNode(matchingSpan.expression.type);\n  if (!typeCastIsTypeReference) {\n    throw new Error('Error: found a lit-html .data= with an object literal typecast.');\n  }\n};\n\n\nconst CUSTOM_ELEMENTS_LIFECYCLE_METHODS = new Set([\n  'connectedCallback',\n  'disconnectedCallback',\n  'adoptedCallback',\n  'attributeChangedCallback',\n]);\n\nconst walkNode = (node: ts.Node, startState?: WalkerState): WalkerState => {\n  const state: WalkerState = startState || {\n    foundInterfaces: new Set(),\n    foundEnums: new Set(),\n    publicMethods: new Set(),\n    typeReferencesToConvert: new Set(),\n    componentClass: undefined,\n    customElementsDefineCall: undefined,\n    legacyInterfaceReferences: new Set(),\n    imports: new Set(),\n    getters: new Set(),\n    setters: new Set(),\n\n  };\n\n  if (ts.isClassDeclaration(node)) {\n    const extendsHtmlElement = classExtendsHTMLElement(node);\n\n    if (extendsHtmlElement) {\n      state.componentClass = node;\n      // now we know this is the component, hunt for its public methods\n      node.members.forEach(member => {\n        if (ts.isMethodDeclaration(member)) {\n          if (isPrivate(member)) {\n            return;\n          }\n          const methodName = (member.name as ts.Identifier).escapedText.toString();\n          if (CUSTOM_ELEMENTS_LIFECYCLE_METHODS.has(methodName) === false) {\n            /* We skip custom element lifecycle methods. Whilst they are public,\n            they are never called from user code, so the bridge file does not\n            need to include them.*/\n\n            if (!member.type) {\n              throw new Error(`Public method ${methodName} needs an explicit return type annotation.`);\n            }\n\n            /* If the method returns an interface, we should include it as an\n             * interface to convert. Note that this has limitations: it will\n             * only work with type references, not if the type is defined\n             * literally in the return type annotation. This is an accepted\n             * restriction for now; we can revisit if it causes problems.\n             */\n            if (member.type && ts.isTypeReferenceNode(member.type) && ts.isIdentifier(member.type.typeName)) {\n              state.typeReferencesToConvert.add(member.type.typeName.escapedText.toString());\n            }\n            state.publicMethods.add(member);\n          }\n\n          // now find its interfaces that we need to make public from the method parmeters\n          member.parameters.forEach(param => {\n            if (!param.type) {\n              return;\n            }\n            const foundTypeReferences = findTypeReferencesWithinNode(state, param.type);\n            foundTypeReferences.forEach(i => state.typeReferencesToConvert.add(i));\n          });\n        } else if (ts.isGetAccessorDeclaration(member)) {\n          if (isPrivate(member)) {\n            return;\n          }\n\n          state.getters.add(member);\n\n          if (member.type) {\n            const foundTypeReferences = findTypeReferencesWithinNode(state, member.type);\n            foundTypeReferences.forEach(i => state.typeReferencesToConvert.add(i));\n          }\n        } else if (ts.isSetAccessorDeclaration(member)) {\n          if (isPrivate(member)) {\n            return;\n          }\n\n          state.setters.add(member);\n\n          if (member.parameters[0]) {\n            const setterParamType = member.parameters[0].type;\n            if (setterParamType) {\n              /* We require that setters are of the form:\n               * set data(data: SomeInterface)\n               * rather than defining the interface inline as an object literal.\n               */\n              const setterName = ts.isIdentifier(member.name) ? member.name.escapedText.toString() : '(unknown)';\n              if (!ts.isTypeReferenceNode(setterParamType)) {\n                throw new Error(`Setter ${setterName} has an argument whose type is not a direct type reference.`);\n              }\n              const foundTypeReferences = findTypeReferencesWithinNode(state, setterParamType);\n              foundTypeReferences.forEach(i => state.typeReferencesToConvert.add(i));\n            }\n          }\n        }\n      });\n    }\n\n  } else if (ts.isInterfaceDeclaration(node)) {\n    const interfaceName = node.name.escapedText.toString();\n    if (builtInTypeScriptTypes.has(interfaceName)) {\n      throw new Error(`Found interface ${\n          interfaceName} that conflicts with TypeScript's built-in type. Please choose a different name!`);\n    }\n    state.foundInterfaces.add(node);\n  } else if (ts.isTypeAliasDeclaration(node)) {\n    const typeName = node.name.escapedText.toString();\n    if (builtInTypeScriptTypes.has(typeName)) {\n      throw new Error(\n          `Found type ${typeName} that conflicts with TypeScript's built-in type. Please choose a different name!`);\n    }\n    state.foundInterfaces.add(node);\n  } else if (ts.isEnumDeclaration(node)) {\n    const isConstEnum = node.modifiers && node.modifiers.some(modifier => modifier.kind === ts.SyntaxKind.ConstKeyword);\n    if (!isConstEnum) {\n      throw new Error(`Found enum ${node.name.escapedText.toString()} that is not a const enum.`);\n    }\n\n    const allMembersAreExplictlyInitialized = node.members.every(enumMember => {\n      return enumMember.initializer !== undefined;\n    });\n    if (!allMembersAreExplictlyInitialized) {\n      throw new Error(\n          `Found enum ${node.name.escapedText.toString()} whose members do not have manually defined values.`);\n    }\n\n    state.foundEnums.add(node);\n  } else if (ts.isImportDeclaration(node)) {\n    const filePath = (node.moduleSpecifier as ts.StringLiteral).text;\n\n    const fileWithoutExt = path.basename(filePath, '.js');\n    const sourceFile = `${fileWithoutExt}.ts`;\n\n    if (node.importClause && node.importClause.namedBindings && ts.isNamedImports(node.importClause.namedBindings)) {\n      const namedImports = node.importClause.namedBindings.elements.map(namedImport => {\n        return namedImport.name.escapedText.toString();\n      });\n      state.imports.add({\n        filePath: sourceFile,\n        namedImports: new Set(namedImports),\n      });\n    } else if (\n        node.importClause && node.importClause.namedBindings && ts.isNamespaceImport(node.importClause.namedBindings)) {\n      // This means it's import * as Foo from '../foo/foo.js'. We care\n      // about this, because if the component uses these imports for a type (e.g.\n      // Common.Color.Color), we need that import in the generated bridge.\n      const namespace = node.importClause.namedBindings.name.escapedText.toString();\n      const filePath = (node.moduleSpecifier as ts.StringLiteral).text;\n      state.imports.add({\n        filePath,\n        namespace,\n      });\n    }\n  } else if (ts.isExpressionStatement(node) && ts.isCallExpression(node.expression)) {\n    if (ts.isPropertyAccessExpression(node.expression.expression)) {\n      const propertyAccess = node.expression.expression;\n\n      if (ts.isIdentifier(propertyAccess.expression) && ts.isIdentifier(propertyAccess.name)) {\n        const leftSideText = propertyAccess.expression.escapedText.toString();\n        const rightSideText = propertyAccess.name.escapedText.toString();\n        if (leftSideText === 'customElements' && rightSideText === 'define') {\n          state.customElementsDefineCall = node;\n        }\n      }\n    }\n  } else if (ts.isTaggedTemplateExpression(node)) {\n    if (taggedTemplateExpressionIsLitHtmlCall(node) && ts.isTemplateExpression(node.template)) {\n      // Search for a template part that ends in .data=\n      const dataSetterText = '.data=';\n\n      /* This is the easy case: the template starts with it, so we grab the\n       * first template span and check that.\n       *\n       * Here the AST will look something like:\n       * TemplateExpression\n       * - head: \"<devtools-foo .data=\"\n       * TemplateSpans\n       * - 0: AST representing { foo: 'foo' } as X code\n      */\n      if (node.template.head.text.endsWith(dataSetterText)) {\n        const matchingSpan = node.template.templateSpans[0];\n        checkTemplateSpanForTypeCastOfData(matchingSpan);\n      } else {\n        /* Slightly harder case, it's not at the start, so we need to look\n        * through each template span to find a template middle that ends with\n        * `.data=`. A TemplateSpan contains an expression (the part being\n        * interpolated) and a \"middle\", which is the raw text that leads up to\n        * the next interpolation. Here the AST will look something like: head:\n        * \"foo\" TemplateSpans\n        * - 0:\n        *   - expression representing the interpolation\n        *   - middle: \"<devtools-foo .data=\"\n        * - 1:\n        *   - AST representing { foo: 'foo' } as X\n        *\n        * So we want to find a TemplateSpan whose \"middle\" ends with \".data=\",\n        * and then look at the expression in the next TemplateSpan.\n        */\n        node.template.templateSpans.forEach((templateSpan, index) => {\n          if (templateSpan.literal.text.endsWith(dataSetterText) && ts.isTemplateExpression(node.template)) {\n            // Now we found the span with the literal text, the next span will\n            // have the expression within.\n            const spanWithExpression = node.template.templateSpans[index + 1];\n            checkTemplateSpanForTypeCastOfData(spanWithExpression);\n          }\n        });\n      }\n    }\n  }\n\n  node.forEachChild(node => {\n    walkNode(node, state);\n  });\n\n\n  return state;\n};\n\nexport const filePathToTypeScriptSourceFile = (filePath: string): ts.SourceFile => {\n  return ts.createSourceFile(filePath, fs.readFileSync(filePath, {encoding: 'utf8'}), ts.ScriptTarget.ESNext);\n};\n\nconst findNestedInterfacesInInterface =\n    (state: WalkerState, interfaceDec: ts.InterfaceDeclaration|ts.TypeLiteralNode): Set<string> => {\n      const foundNestedInterfaceNames = new Set<string>();\n\n      interfaceDec.members.forEach(member => {\n        if (ts.isPropertySignature(member)) {\n          if (!member.type) {\n            return;\n          }\n          const nestedInterfacesForMember = findTypeReferencesWithinNode(state, member.type);\n          nestedInterfacesForMember.forEach(nested => foundNestedInterfaceNames.add(nested));\n        }\n      });\n\n      return foundNestedInterfaceNames;\n    };\n\nconst findNestedReferencesForTypeReference =\n    (state: WalkerState,\n     interfaceOrTypeAliasDeclaration: ts.InterfaceDeclaration|ts.TypeAliasDeclaration): Set<string> => {\n      const foundNestedReferences = new Set<string>();\n      if (ts.isTypeAliasDeclaration(interfaceOrTypeAliasDeclaration)) {\n        if (ts.isTypeLiteralNode(interfaceOrTypeAliasDeclaration.type)) {\n          /* this means it's a type Person = { name: string } */\n          const nestedInterfaces = findNestedInterfacesInInterface(state, interfaceOrTypeAliasDeclaration.type);\n          nestedInterfaces.forEach(nestedInterface => foundNestedReferences.add(nestedInterface));\n        } else if (ts.isUnionTypeNode(interfaceOrTypeAliasDeclaration.type)) {\n          interfaceOrTypeAliasDeclaration.type.types.forEach(unionTypeMember => {\n            if (ts.isTypeReferenceNode(unionTypeMember) &&\n                ts.isIdentifierOrPrivateIdentifier(unionTypeMember.typeName)) {\n              foundNestedReferences.add(unionTypeMember.typeName.escapedText.toString());\n            }\n          });\n        } else if (ts.isIntersectionTypeNode(interfaceOrTypeAliasDeclaration.type)) {\n          /**\n      * This means it's something like:\n      *\n      * type NamedThing = { foo: Foo }\n      * type Person = NamedThing & { name: 'jack' };\n      *\n      * The bridges generator will inline types when they are extended, so we\n      * _don't_ need `NamedThing` to be defined in the bridge. But `NamedThing`\n      * mentions `Foo`, so we do need to include `Foo` in the bridge.\n      */\n          interfaceOrTypeAliasDeclaration.type.types.forEach(nestedType => {\n            if (ts.isTypeLiteralNode(nestedType)) {\n              // this is any `& { name: string }` parts of the type alias.\n              const nestedInterfaces = findNestedInterfacesInInterface(state, nestedType);\n              nestedInterfaces.forEach(nestedInterface => foundNestedReferences.add(nestedInterface));\n            } else if (ts.isTypeReferenceNode(nestedType) && ts.isIdentifierOrPrivateIdentifier(nestedType.typeName)) {\n              // This means we have a reference to another interface so we have to\n              // find the interface and check for any nested interfaces within it.\n              const typeReferenceName = nestedType.typeName.escapedText.toString();\n              const nestedTypeReference = findNodeForTypeReferenceName(state, typeReferenceName);\n              if (!nestedTypeReference) {\n                throw new Error(`Could not find definition for type reference ${typeReferenceName}.`);\n              }\n\n              if (ts.isEnumDeclaration(nestedTypeReference)) {\n                state.typeReferencesToConvert.add(nestedTypeReference.name.escapedText.toString());\n              } else {\n                // Recurse on the nested interface because if it references any other\n                // interfaces we need to include those in the bridge.\n                findNestedReferencesForTypeReference(state, nestedTypeReference)\n                    .forEach(nested => foundNestedReferences.add(nested));\n              }\n            }\n          });\n        }\n      } else {\n        // If it wasn't a type alias, it's an interface, so walk through the interface and add any found nested types.\n        const nestedInterfaces = findNestedInterfacesInInterface(state, interfaceOrTypeAliasDeclaration);\n        nestedInterfaces.forEach(nestedInterface => foundNestedReferences.add(nestedInterface));\n\n        // if the interface has any extensions, we need to dive into those too\n        // e.g. interface X extends Y means we have to check Y for any additional type references\n        if (interfaceOrTypeAliasDeclaration.heritageClauses) {\n          interfaceOrTypeAliasDeclaration.heritageClauses.forEach(heritageClause => {\n            const extendNames = heritageClause.types.map(heritageClauseName => {\n              if (ts.isIdentifier(heritageClauseName.expression)) {\n                return heritageClauseName.expression.escapedText.toString();\n              }\n              throw new Error('Unexpected heritageClauseName with no identifier.');\n            });\n\n            extendNames.forEach(interfaceName => {\n              const interfaceDec = findNodeForTypeReferenceName(state, interfaceName);\n              if (!interfaceDec) {\n                throw new Error(`Could not find interface: ${interfaceName}`);\n              }\n              if (!ts.isInterfaceDeclaration(interfaceDec)) {\n                throw new Error('Found invalid TypeScript: an interface cannot extend a type.');\n              }\n              const nestedInterfaces = findNestedInterfacesInInterface(state, interfaceDec);\n              nestedInterfaces.forEach(nestedInterface => foundNestedReferences.add(nestedInterface));\n            });\n          });\n        }\n      }\n      return foundNestedReferences;\n    };\n\nconst populateTypeReferencesToConvert = (state: WalkerState): WalkerState => {\n  state.typeReferencesToConvert.forEach(typeReferenceName => {\n    const typeDeclaration = findNodeForTypeReferenceName(state, typeReferenceName);\n\n    // if the interface isn't found, it might be imported, so just move on.\n    if (!typeDeclaration) {\n      return;\n    }\n\n    if (ts.isEnumDeclaration(typeDeclaration)) {\n      // Enums can't have any types nested within them so we can stop at this point.\n      return;\n    }\n\n    const nestedReferences = findNestedReferencesForTypeReference(state, typeDeclaration);\n    nestedReferences.forEach(nested => state.typeReferencesToConvert.add(nested));\n  });\n\n  return state;\n};\n\n\n// This is a list of types that TS + Closure understand that aren't defined by\n// the user and therefore we don't need to generate typedefs for them, and\n// just convert them into Closure Note that built-in types that take generics\n// are not in this list (e.g. Map, Set) because we special case parsing them\n// because of the generics.\nconst builtInTypeScriptTypes = new Set([\n  'CanvasRenderingContext2D',\n  'Element',\n  'HTMLElement',\n  'HTMLDivElement',\n  'HTMLTextAreaElement',\n  'HTMLInputElement',\n  'HTMLSelectElement',\n  'HTMLOptionElement',\n  'HTMLCanvasElement',\n  'Object',\n  'Uint8Array',\n]);\n\nexport const walkTree = (startNode: ts.SourceFile, resolvedFilePath: string): WalkerState => {\n  let state = walkNode(startNode);\n  /**\n   * Now we have a list of top level interfaces we need to convert, we need to\n   * go through each one and look for any interfaces referenced within e.g.:\n   *\n   * ```\n   * interface Baz {...}\n   *\n   * interface Foo {\n   *   x: Baz\n   * }\n   *\n   * // in the component\n   * set data(data: { foo: Foo }) {}\n   * ```\n   *\n   * We know we have to convert the Foo interface in the _bridge.js, but we need\n   * to also convert Baz because Foo references it.\n   */\n  state = populateTypeReferencesToConvert(state);\n\n  /* if we are here and found an interface passed to a public method\n   * that we didn't find the definition for, that means it's imported\n   * so we now need to walk that imported file\n   */\n  const allFoundTypeReferencesNames = new Set([\n    ...Array.from(\n        state.foundInterfaces,\n        foundInterface => {\n          return foundInterface.name.escapedText.toString();\n        }),\n    ...Array.from(\n        state.foundEnums,\n        foundEnum => {\n          return foundEnum.name.escapedText.toString();\n        }),\n  ]);\n\n  const missingTypeReferences = Array.from(state.typeReferencesToConvert).filter(name => {\n    return allFoundTypeReferencesNames.has(name) === false;\n  });\n  /* now look at all the imports and see if we have the name of the missing interface\n   * and if we do, walk that file to find the interface\n   * else, error loudly\n   */\n  const importsToCheck = new Set<string>();\n\n  missingTypeReferences.forEach(missingInterfaceName => {\n    if (builtInTypeScriptTypes.has(missingInterfaceName)) {\n      return;\n    }\n\n    const importForMissingInterface =\n        Array.from(state.imports).find(imp => 'namedImports' in imp && imp.namedImports.has(missingInterfaceName));\n\n    if (!importForMissingInterface) {\n      throw new Error(`Could not find definition for type reference ${\n          missingInterfaceName} in the source file or any of its imports.`);\n    }\n\n    importsToCheck.add(path.join(path.dirname(resolvedFilePath), importForMissingInterface.filePath));\n  });\n\n  importsToCheck.forEach(fullPathToImport => {\n    const sourceFile = filePathToTypeScriptSourceFile(fullPathToImport);\n    const stateFromSubFile = walkTree(sourceFile, fullPathToImport);\n\n    // now merge the foundInterfaces part\n    stateFromSubFile.foundInterfaces.forEach(foundInterface => {\n      state.foundInterfaces.add(foundInterface);\n    });\n\n    stateFromSubFile.foundEnums.forEach(foundEnum => {\n      state.foundEnums.add(foundEnum);\n    });\n\n    stateFromSubFile.typeReferencesToConvert.forEach(interfaceToConvert => {\n      state.typeReferencesToConvert.add(interfaceToConvert);\n    });\n  });\n\n\n  // We did this before parsing any imports from other files, but we now do it\n  // again. If we found a definition in another module that we care about, we\n  // need to parse it to check its nested state. This could be more efficient\n  // (we have to do two passes, before and after parsing 3rd party imports), but\n  // given component bridges are not going to be around forever, we will defer\n  // any performance concerns here until they start slowing us down day to day.\n  state = populateTypeReferencesToConvert(state);\n\n  // If we found any nested references that reference built-in TS types we can\n  // just delete them.\n  builtInTypeScriptTypes.forEach(builtIn => state.typeReferencesToConvert.delete(builtIn));\n\n  return state;\n};\n"]}