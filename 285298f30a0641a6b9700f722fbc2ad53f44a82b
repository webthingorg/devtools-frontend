{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "45d0dc65_ac9b7941",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 3
      },
      "lineNbr": 0,
      "author": {
        "id": 1175471
      },
      "writtenOn": "2021-04-06T15:00:21Z",
      "side": 1,
      "message": "caseq: This removes dependency #1 in https://docs.google.com/document/d/1UzCTrkSJJZGELq3P784DNgFrw8fLsmkxFMtmSUdqUqA/edit#heading\u003dh.7nki9mck5t64, WDYT?",
      "revId": "285298f30a0641a6b9700f722fbc2ad53f44a82b",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "38f8c55a_bc585ef7",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 3
      },
      "lineNbr": 0,
      "author": {
        "id": 1115876
      },
      "writtenOn": "2021-04-09T04:15:13Z",
      "side": 1,
      "message": "Thanks for the patch! We need some proper front-end owners here, my front-end memories are a bit rusty and I\u0027m not event an owner these days, so +Sigurd and Benedikt.",
      "revId": "285298f30a0641a6b9700f722fbc2ad53f44a82b",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "c2015b4b_671ae998",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 3
      },
      "lineNbr": 0,
      "author": {
        "id": 1115999
      },
      "writtenOn": "2021-04-09T05:16:12Z",
      "side": 1,
      "message": "Heads up: I don\u0027t think this is going to fly. Both |targetId| and |frameId| are constants - CDP assumes main frame is retained throughout navigations. There is no event that would say \u0027Main frame in this target was swapped\u0027 and introducing one would be a breaking CDP change. The coupling was due to the matching lifetimes of the objects, so it was baked into CDP.\n\nI don\u0027t have a solution for you, just pointing out that the current one is incompatible with CDP. So I guess you need to draw how the new CDP contract would look like and what transition / opt-in into the new mode would look like. +dgozman for ideas.",
      "revId": "285298f30a0641a6b9700f722fbc2ad53f44a82b",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "1126b582_e60d9785",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 3
      },
      "lineNbr": 0,
      "author": {
        "id": 1175471
      },
      "writtenOn": "2021-04-09T12:40:57Z",
      "side": 1,
      "message": "Thanks Pavel! I\u0027m not sure if you\u0027ve already read this document [1], but a breaking change of some kind is necessary due to MPArch and activation. There\u0027s also a discussion thread in devtools-dev about this. I\u0027m hoping we can stage any such breaking changes behind feature flags (initially prerendering, which will be the main consumer of MPArch that actually does activation). I\u0027d really appreciate your thoughts/ideas on that doc as well.\n\n[1] https://docs.google.com/document/d/1l-SeBl7m8zESdJMJlT4oNVFiJ65bjfPa8RHF_WYFuIQ/edit?pli\u003d1#heading\u003dh.6bhxt8glx2jg",
      "parentUuid": "c2015b4b_671ae998",
      "revId": "285298f30a0641a6b9700f722fbc2ad53f44a82b",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "1b47cb78_3b109e72",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 3
      },
      "lineNbr": 0,
      "author": {
        "id": 1115999
      },
      "writtenOn": "2021-04-09T17:30:41Z",
      "side": 1,
      "message": "A breaking change behind a feature flag would mean that this flag will not be enabled by default, which I don\u0027t think it the plan. I wonder if there is a way to opt into this new behavior, so that CDP does not break. Persistent frame is very core to CDP, we can\u0027t just add a new event - it will simply break the world.\n\nI would encourage you to speak to the CDP owners that maintain target infrastructure - dgozman@ and caseq@. This is not the first challenging problem that we face in this area, so I am sure we work something out to unblock you.",
      "parentUuid": "1126b582_e60d9785",
      "revId": "285298f30a0641a6b9700f722fbc2ad53f44a82b",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "67345ca4_479c2ee2",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 3
      },
      "lineNbr": 0,
      "author": {
        "id": 1175471
      },
      "writtenOn": "2021-04-15T21:18:06Z",
      "side": 1,
      "message": "Andrey/Dmitry, do you have anything to add to this? If having a constant frameId associated to a target is an invariant we cannot break, I might have to try another way to handle activation: probably update the frame token in the activated page\u0027s renderer when it activates, so that the main target always reports the same frameId. This might break some features that rely on a renderer always reporting the same frameId throughout its lifetime (but I guess we can fix them incrementally) and they would only break during activation.",
      "parentUuid": "1b47cb78_3b109e72",
      "revId": "285298f30a0641a6b9700f722fbc2ad53f44a82b",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "242aaff6_ce0310a2",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 3
      },
      "lineNbr": 0,
      "author": {
        "id": 1000379
      },
      "writtenOn": "2021-04-15T21:47:36Z",
      "side": 1,
      "message": "We discussed this offline with Andrey. Some thoughts:\n\n- IIUC, with the proposed changes, in the case of BFCache navigation the main frame gets a new RFH and thus a new frameId? This breaks the invariant that main frame id stays the same, and this is even more fundamental then targetId\u003d\u003dframeId assumption made by clients. I do not think this is ever going to fly.\n\n- Based on the above, there could be two solutions:\n  1. Disable BFCache when DevTools client attaches. Then we can probably enable it over protocol and make specific clients (mostly DevTools frontend) work with whatever changes that requires, like changing main frame id.\n  2. Treat BFCache similarly to cross-process navigation, where we already have two RFHs (old and new) that share the same frameId (equal to FTN\u0027s devtools_frame_token). With BFCache, we\u0027ll get a similar navigation from one RFH to another RFH, and the only difference is that the new RFH is not empty (while it is empty in regular cross-process navigation). We can try reattaching to this new RFH like we do today, and make sure that all domains handle that as expected (e.g. report the new frame tree on attach).\n  Variant 1 seems like more work, but variant 2 has some unknowns around various inspector agents not handling reattach properly.\n\n- For portals and other frame tree reshakes, it seems like a separate event that will inform about frame tree reordering is necessary anyway. Therefore, most clients should be able to handle this case based on the event, and we can try to keep targetId\u003d\u003dframeId invariant. For example, when portal is activated, the client should treat another target as a \"tab\" target, and the old \"tab\" target becomes a \"portal child\". WDYT? Note that clients that do not handle this event will break anyway, and I don\u0027t see a sane way around that. Given that these features are rare, perhaps that\u0027s ok.\n\nAndrey, does that capture our discussion well enough?",
      "parentUuid": "67345ca4_479c2ee2",
      "revId": "285298f30a0641a6b9700f722fbc2ad53f44a82b",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "b4e0587d_53850fd2",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 3
      },
      "lineNbr": 0,
      "author": {
        "id": 1175471
      },
      "writtenOn": "2021-04-15T22:23:24Z",
      "side": 1,
      "message": "\u003e We discussed this offline with Andrey. Some thoughts:\n\u003e \n\u003e - IIUC, with the proposed changes, in the case of BFCache navigation the main frame gets a new RFH and thus a new frameId? This breaks the invariant that main frame id stays the same, and this is even more fundamental then targetId\u003d\u003dframeId assumption made by clients. I do not think this is ever going to fly.\n\u003e \n\nActually BFCache navigations on their own aren\u0027t problematic (or rather it isn\u0027t why I wrote this change). The new RFH is just restored to the same FrameTreeNode that it used to be the current_render_frame_host for (so it doesn\u0027t move between targets). The problematic scenario is activations (so prerendering/portals) where a RFH moves from one FTN to another (so it effectively moves between two targets). So the way things currently are, the main frame id reported from the main target to clients, changes when we activate a prerendered page. \n \n\u003e - Based on the above, there could be two solutions:\n\u003e   1. Disable BFCache when DevTools client attaches. Then we can probably enable it over protocol and make specific clients (mostly DevTools frontend) work with whatever changes that requires, like changing main frame id.\n\u003e   2. Treat BFCache similarly to cross-process navigation, where we already have two RFHs (old and new) that share the same frameId (equal to FTN\u0027s devtools_frame_token). With BFCache, we\u0027ll get a similar navigation from one RFH to another RFH, and the only difference is that the new RFH is not empty (while it is empty in regular cross-process navigation). We can try reattaching to this new RFH like we do today, and make sure that all domains handle that as expected (e.g. report the new frame tree on attach).\n\u003e   Variant 1 seems like more work, but variant 2 has some unknowns around various inspector agents not handling reattach properly.\n\nVariant 2 is actually exactly what\u0027s happening for BFCache right now, and I\u0027ve been slowly landing a few fixes to the frontend to make it handle things correctly.\n\n\u003e \n\u003e - For portals and other frame tree reshakes, it seems like a separate event that will inform about frame tree reordering is necessary anyway. Therefore, most clients should be able to handle this case based on the event, and we can try to keep targetId\u003d\u003dframeId invariant. For example, when portal is activated, the client should treat another target as a \"tab\" target, and the old \"tab\" target becomes a \"portal child\". WDYT? Note that clients that do not handle this event will break anyway, and I don\u0027t see a sane way around that. Given that these features are rare, perhaps that\u0027s ok.\n\nI think portals currently do this actually (they have to because we use a multiple WebContents architecture right now, so we\u0027re actually connecting to a new tab). But there are things that completely break (like remote debugging for example) because we are creating a new session when we switch targets, instead of reusing an existing session which is what happens when we do a regular navigation. So we\u0027d have to implement a way to change the main target associated with a devtools session without closing the session (might not be impossible, its just that we don\u0027t currently have a way of doing it).\n\nAlso with this, I think we\u0027d still have the problem of the main target reporting a different main frame id before and after activation (the target_id \u003d\u003d frame_id will not break however).",
      "parentUuid": "242aaff6_ce0310a2",
      "revId": "285298f30a0641a6b9700f722fbc2ad53f44a82b",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "833557bd_9d7942ef",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 3
      },
      "lineNbr": 0,
      "author": {
        "id": 1000379
      },
      "writtenOn": "2021-04-15T22:45:28Z",
      "side": 1,
      "message": "\u003e So the way things currently are, the main frame id reported from the main target to clients, changes when we activate a prerendered page.\n\nIs that because we attach to both the \"current\" page (whatever that means for prerendering) and the prerendered page? If not, perhaps (a wild idea) we can inherit devtools_frame_token and thus the frame id to the prerender page, similar to BFCache?\n\n\u003e Variant 2 is actually exactly what\u0027s happening for BFCache right now, and I\u0027ve been slowly landing a few fixes to the frontend to make it handle things correctly.\n\nWonderful! Looking forward to it. I am surprised that changes are on the frontend side - that means every other client will break. Could you point me to some examples?\n\n\u003e I think portals currently do this actually (they have to because we use a multiple WebContents architecture right now, so we\u0027re actually connecting to a new tab). But there are things that completely break (like remote debugging for example) because we are creating a new session when we switch targets, instead of reusing an existing session which is what happens when we do a regular navigation. So we\u0027d have to implement a way to change the main target associated with a devtools session without closing the session (might not be impossible, its just that we don\u0027t currently have a way of doing it).\n\nI see, this is an interesting observation. I can imagine something like Target.childTargetBecameTheRoot event, and then moving sessions between RFDTAH? Sounds somewhat scary, but worth exploring.\n\n\u003e Also with this, I think we\u0027d still have the problem of the main target reporting a different main frame id before and after activation (the target_id \u003d\u003d frame_id will not break however).\n\nYep, but at least that would be in the much more rare case of portals and such, with a dedicated event.",
      "parentUuid": "b4e0587d_53850fd2",
      "revId": "285298f30a0641a6b9700f722fbc2ad53f44a82b",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "463f9a37_e0033771",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 3
      },
      "lineNbr": 0,
      "author": {
        "id": 1175471
      },
      "writtenOn": "2021-04-16T13:11:08Z",
      "side": 1,
      "message": "\u003e Is that because we attach to both the \"current\" page (whatever that means for prerendering) and the prerendered page? If not, perhaps (a wild idea) we can inherit devtools_frame_token and thus the frame id to the prerender page, similar to BFCache?\n\u003e \n\nWe send a devtools_frame_token to the renderer regardless of whether DevTools is attached or not. So currently, we don\u0027t attach to the prerendering page until we activate it (although we probably will have to support this in the future, but maybe not my default). But we do still give it a separate frame token while it is still a prerendering page (it has its own FrameTreeNode at this point). During activation time, we move it from its old FTN to a new FTN (the old main page\u0027s FTN). https://docs.google.com/document/d/1l-SeBl7m8zESdJMJlT4oNVFiJ65bjfPa8RHF_WYFuIQ/edit?pli\u003d1#heading\u003dh.6bhxt8glx2jg has a couple of diagrams that try to illustrate this.\n\nSo inheriting the devtools_frame_token is actually what I meant by \"update the frame token in the activated page\u0027s renderer when it activates\" a couple of comments earlier (if I understand what you mean by \"inherit\" correctly).\n\n\u003e Wonderful! Looking forward to it. I am surprised that changes are on the frontend side - that means every other client will break. Could you point me to some examples?\n\u003e \n\nAh sorry that was a misleading statement, there have been both frontend \u0026 backend changes involved so far:\n\nhttps://crrev.com/c/2727915\nhttps://crrev.com/c/2739835\nhttps://crrev.com/c/2784921\nhttps://crrev.com/c/2826573\n\n\u003e I see, this is an interesting observation. I can imagine something like Target.childTargetBecameTheRoot event, and then moving sessions between RFDTAH? Sounds somewhat scary, but worth exploring.\n\u003e \n\nAnother problem with this approach is the fact that RFDAH are 1:1 with a FTN, and this approach requires reassociating a RFDAH with a new FTN which would also break a bunch of other invariants in our code.\n\n\u003e Yep, but at least that would be in the much more rare case of portals and such, with a dedicated event.\n\nAh I see, that makes sense.",
      "parentUuid": "833557bd_9d7942ef",
      "revId": "285298f30a0641a6b9700f722fbc2ad53f44a82b",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "bde8a069_c1154e82",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 3
      },
      "lineNbr": 0,
      "author": {
        "id": 1000379
      },
      "writtenOn": "2021-04-16T17:39:45Z",
      "side": 1,
      "message": "\u003e So inheriting the devtools_frame_token is actually what I meant by \"update the frame token in the activated page\u0027s renderer when it activates\" a couple of comments earlier (if I understand what you mean by \"inherit\" correctly).\n\nI was thinking about creating a prerendering FTN with the same token as the old page\u0027s FTN.\n\n\u003e Another problem with this approach is the fact that RFDAH are 1:1 with a FTN, and this approach requires reassociating a RFDAH with a new FTN which would also break a bunch of other invariants in our code.\n\nHmm... I was thinking about switching from one RFDTAH to another (IIRC, that\u0027s what we do today for portals already), so that we keep FTN\u003d\u003dRFDTAH. Changing FTN on the fly sounds pretty bad - it does not reflect what the browser does under the hood (changing RFH and keeping the same FTN).",
      "parentUuid": "463f9a37_e0033771",
      "revId": "285298f30a0641a6b9700f722fbc2ad53f44a82b",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "b339878c_52912304",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 3
      },
      "lineNbr": 0,
      "author": {
        "id": 1175471
      },
      "writtenOn": "2021-04-16T19:21:08Z",
      "side": 1,
      "message": "\u003e I was thinking about creating a prerendering FTN with the same token as the old page\u0027s FTN.\n\nAh okay, in that case, if we do attach devtools to a prerendering page (while it\u0027s prerendering), we\u0027d have two targets reporting a root frame with the same frame id. Maybe clients can differentiate between them based on the target that\u0027s reporting them, but it seems over-complicated.\n \n\u003e Hmm... I was thinking about switching from one RFDTAH to another (IIRC, that\u0027s what we do today for portals already), so that we keep FTN\u003d\u003dRFDTAH. Changing FTN on the fly sounds pretty bad - it does not reflect what the browser does under the hood (changing RFH and keeping the same FTN).\n\nThe reason it works for portals today is that activation is actually swapping WebContents, so swapping the frame trees entirely. We have the same RFDAH observing the activated page\u0027s FTN before and after activation, we just tell the browser devtools_ui_bindings to disconnect from the old FTN\u0027s RFDAH and connect to the activated page\u0027s RFDAH. But in the case of MPArch, we actually delete the activated page\u0027s FTN during activation (which probably means its RFDAH will either be deleted or we change the FTN the RFDAH is associated with).",
      "parentUuid": "bde8a069_c1154e82",
      "revId": "285298f30a0641a6b9700f722fbc2ad53f44a82b",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "9d292cc4_0c5b5bc1",
        "filename": "front_end/core/sdk/DOMModel.js",
        "patchSetId": 3
      },
      "lineNbr": 1396,
      "author": {
        "id": 1115876
      },
      "writtenOn": "2021-04-09T04:15:13Z",
      "side": 1,
      "message": "Why does this have to be async? Considering we\u0027re talking to the same target, I would expect the frame already be reported, is that not the case?",
      "revId": "285298f30a0641a6b9700f722fbc2ad53f44a82b",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "b0d00f02_5ab56b72",
        "filename": "front_end/core/sdk/DOMModel.js",
        "patchSetId": 3
      },
      "lineNbr": 1396,
      "author": {
        "id": 1175471
      },
      "writtenOn": "2021-04-09T12:40:57Z",
      "side": 1,
      "message": "That is not the case, it seems like responses from different domains can race (I had some tests flaking).",
      "parentUuid": "9d292cc4_0c5b5bc1",
      "revId": "285298f30a0641a6b9700f722fbc2ad53f44a82b",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "88bd93c7_5654ebb8",
        "filename": "front_end/core/sdk/FrameManager.js",
        "patchSetId": 3
      },
      "lineNbr": 192,
      "author": {
        "id": 1115876
      },
      "writtenOn": "2021-04-09T04:15:13Z",
      "side": 1,
      "message": "This looks fine to me for test usage, but feels a bit scary for the prod usage, considering it may never resolve if we pass a wrong id, or if the same is gone as a result of some race. Can we avoid exposing it for general use and instead implement within its only client (Node._childDocumentPromiseForTesting) instead, so that it\u0027s not accidentally used in production code? We may also want to convert the latter into a function, considering it\u0027s becoming non-trivial to compute.",
      "revId": "285298f30a0641a6b9700f722fbc2ad53f44a82b",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "032ff1c2_a22609b9",
        "filename": "front_end/core/sdk/FrameManager.js",
        "patchSetId": 3
      },
      "lineNbr": 192,
      "author": {
        "id": 1175471
      },
      "writtenOn": "2021-04-09T12:40:57Z",
      "side": 1,
      "message": "Yeah, the wrong id case is worrisome, and one of the main advantages to adding frameId to TargetInfo (a main frame\u0027s frameId would be available immediately and we wouldn\u0027t have to wait for the Page.getFrameTree roundtrip). But I\u0027ll move this into the file itself.",
      "parentUuid": "88bd93c7_5654ebb8",
      "revId": "285298f30a0641a6b9700f722fbc2ad53f44a82b",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    }
  ]
}