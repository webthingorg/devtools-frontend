{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "7e4b691e_cc6e1f63",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 26
      },
      "lineNbr": 0,
      "author": {
        "id": 1341658
      },
      "writtenOn": "2024-06-19T00:15:12Z",
      "side": 1,
      "message": "pushed some updates, appreciate your feedback!",
      "revId": "f85959ae4390139c40ad2eb960dd22ba31017368",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "f14eb5e4_9dabba79",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 26
      },
      "lineNbr": 0,
      "author": {
        "id": 1396442
      },
      "writtenOn": "2024-06-21T15:59:44Z",
      "side": 1,
      "message": "hope you don\u0027t mind me jumping in - Paul asked me to take a look ðŸ˜Š\n\nOne other thought - we might have some parts of the codebase where we assume that if an event\u0027s type is not SyntheticNetworkRequest, then it is not on the network track. I think some of our recent work around overlays will be affected by this, and in particular the selected entry overlay in the performance panel. Can you make sure that this works OK and they are positioned accurately when you select a web socket event? This changed very recently (start of this week) so make sure you rebase.\n\nIf we define a type of `NetworkTrackEntry` which is the union of the synthetic network request and the websocket entry(s), that would avoid the duplication and long union types repeated in the network appender, and also mean we could land an `isNetworkTrackEntry()` method which would be handy.",
      "revId": "f85959ae4390139c40ad2eb960dd22ba31017368",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "fb2c6191_02612fa3",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 26
      },
      "lineNbr": 0,
      "author": {
        "id": 1396442
      },
      "writtenOn": "2024-06-21T16:12:40Z",
      "side": 1,
      "message": "We also need a test for NetworkRequestsHandler please that loads in a trace with a web socket and asserts that we parse out the expected events.",
      "revId": "f85959ae4390139c40ad2eb960dd22ba31017368",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "f194c905_2ada8cd8",
        "filename": "front_end/models/trace/handlers/NetworkRequestsHandler.ts",
        "patchSetId": 26
      },
      "lineNbr": 498,
      "author": {
        "id": 1396442
      },
      "writtenOn": "2024-06-21T16:12:40Z",
      "side": 1,
      "message": "I am finding this really hard to understand...\n\nso we go through each web socket we found, and create a synthetic event, and shift it onto the beginning, so that each entry in `webSocketData` will look roughly like:\n\n```\n// other fields\nevents: [syntheticEvent, the rest of the events...]\n```\n\nis that correct? \n\nagain, a comment or two might be useful here to try to break this down.\n\nor potentially a nicer structure would be either making the synthetic event contain all the others (but I can see why that might not be ideal), or having:\n\n```\n{\n  syntheticEvent: event,\n  childEvents: [events],\n}\n```\n\nor similar",
      "range": {
        "startLine": 498,
        "startChar": 2,
        "endLine": 498,
        "endChar": 5
      },
      "revId": "f85959ae4390139c40ad2eb960dd22ba31017368",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "5ce1676e_b5b56337",
        "filename": "front_end/models/trace/handlers/NetworkRequestsHandler.ts",
        "patchSetId": 26
      },
      "lineNbr": 511,
      "author": {
        "id": 1396442
      },
      "writtenOn": "2024-06-21T16:12:40Z",
      "side": 1,
      "message": "just `webSockets` would be fine for the key here",
      "range": {
        "startLine": 511,
        "startChar": 4,
        "endLine": 511,
        "endChar": 22
      },
      "revId": "f85959ae4390139c40ad2eb960dd22ba31017368",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "c8fe1ed8_c17d1274",
        "filename": "front_end/models/trace/handlers/NetworkRequestsHandler.ts",
        "patchSetId": 26
      },
      "lineNbr": 519,
      "author": {
        "id": 1396442
      },
      "writtenOn": "2024-06-21T16:12:40Z",
      "side": 1,
      "message": "could we add some documentation (jsdoc is fine) to this file to explain how we use all the various web socket events?\n\nfrom my understanding, it seems that the synthetic event represents the entire duration of the connection, and then you can use its identifier to find all the events that happened during its lifecycle. is that accurate?\n\nAlso, if we put into `args.data` the set of all \"child\" events, could we change the data we export from this handler into being:\n\n```\nsockets: SyntheticWebSocketConnection[]\n```\n\nand then have less complexity elsewhere? wdyt?",
      "range": {
        "startLine": 519,
        "startChar": 0,
        "endLine": 519,
        "endChar": 49
      },
      "revId": "f85959ae4390139c40ad2eb960dd22ba31017368",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "adf6dd86_b9c8a1fe",
        "filename": "front_end/models/trace/types/TraceEvents.ts",
        "patchSetId": 26
      },
      "lineNbr": 412,
      "author": {
        "id": 1396442
      },
      "writtenOn": "2024-06-21T15:59:44Z",
      "side": 1,
      "message": "why do we need this vs just exposing the interface which we already do?",
      "range": {
        "startLine": 412,
        "startChar": 0,
        "endLine": 412,
        "endChar": 75
      },
      "revId": "f85959ae4390139c40ad2eb960dd22ba31017368",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "fe93b810_27000f95",
        "filename": "front_end/panels/timeline/NetworkTrackAppender.ts",
        "patchSetId": 26
      },
      "lineNbr": 136,
      "author": {
        "id": 1396442
      },
      "writtenOn": "2024-06-21T15:59:44Z",
      "side": 1,
      "message": "this check is confusing me: the type def says the event is either `TraceEventData|SyntheticWebSocketConnectionEvent`, so why do we check for `isWebSocketTraceEvent` and `isSyntheticWebSocketConnectionEvent` ?",
      "range": {
        "startLine": 135,
        "startChar": 3,
        "endLine": 136,
        "endChar": 85
      },
      "revId": "f85959ae4390139c40ad2eb960dd22ba31017368",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "ddce3636_eb5b1c6f",
        "filename": "front_end/panels/timeline/NetworkTrackAppender.ts",
        "patchSetId": 26
      },
      "lineNbr": 184,
      "author": {
        "id": 1396442
      },
      "writtenOn": "2024-06-21T15:59:44Z",
      "side": 1,
      "message": "would probably define `type NetworkTrackEvent \u003d this union` to avoid repeating this a bunch",
      "range": {
        "startLine": 184,
        "startChar": 14,
        "endLine": 184,
        "endChar": 114
      },
      "revId": "f85959ae4390139c40ad2eb960dd22ba31017368",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "0ebc32d1_a79b23f6",
        "filename": "front_end/panels/timeline/NetworkTrackAppender.ts",
        "patchSetId": 26
      },
      "lineNbr": 214,
      "author": {
        "id": 1396442
      },
      "writtenOn": "2024-06-21T16:12:40Z",
      "side": 1,
      "message": "given that this method is about filtering an existing timeline, would we actually ever hit the `else` case here where we don\u0027t have a level set for a given web socket identifier?",
      "range": {
        "startLine": 209,
        "startChar": 8,
        "endLine": 214,
        "endChar": 9
      },
      "revId": "f85959ae4390139c40ad2eb960dd22ba31017368",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "c91f5bae_bdd39185",
        "filename": "front_end/panels/timeline/TimelineFlameChartNetworkDataProvider.ts",
        "patchSetId": 26
      },
      "lineNbr": 253,
      "author": {
        "id": 1396442
      },
      "writtenOn": "2024-06-21T15:59:44Z",
      "side": 1,
      "message": "nit: can this be a JS private method please? (same with `decorateNetworkRequest` too)",
      "range": {
        "startLine": 253,
        "startChar": 18,
        "endLine": 253,
        "endChar": 59
      },
      "revId": "f85959ae4390139c40ad2eb960dd22ba31017368",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "3a42e92a_ba5265bf",
        "filename": "front_end/panels/timeline/TimelineFlameChartNetworkDataProvider.ts",
        "patchSetId": 26
      },
      "lineNbr": 373,
      "author": {
        "id": 1396442
      },
      "writtenOn": "2024-06-21T16:12:40Z",
      "side": 1,
      "message": "sorry, probably a silly question for my understanding, why do we need this? if the socket is in the view, it will be drawn anyway? what scenario does this fix/avoid?",
      "range": {
        "startLine": 370,
        "startChar": 0,
        "endLine": 373,
        "endChar": 3
      },
      "revId": "f85959ae4390139c40ad2eb960dd22ba31017368",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "cda88d20_fdee29ab",
        "filename": "front_end/ui/legacy/components/perf_ui/FlameChart.ts",
        "patchSetId": 26
      },
      "lineNbr": 2284,
      "author": {
        "id": 1396442
      },
      "writtenOn": "2024-06-21T15:59:44Z",
      "side": 1,
      "message": "took me a minute to understand this conditional\n\nhow do you feel about:\n\n```\nconst levelForcedDrawable \u003d Boolean(this.dataProvider.forceDrawableLevel?.(level));\nif(entryOffsetRight \u003c\u003d this.chartViewport.windowLeftTime \u0026\u0026 !levelForcedDrawable) {}\n```\n\n(or similar)",
      "range": {
        "startLine": 2283,
        "startChar": 7,
        "endLine": 2284,
        "endChar": 101
      },
      "revId": "f85959ae4390139c40ad2eb960dd22ba31017368",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    }
  ]
}