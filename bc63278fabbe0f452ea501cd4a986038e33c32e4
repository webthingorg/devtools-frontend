{
  "comments": [
    {
      "key": {
        "uuid": "86f287a8_6ade6e5a",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 3
      },
      "lineNbr": 0,
      "author": {
        "id": 1396454
      },
      "writtenOn": "2020-07-20T11:59:14Z",
      "side": 1,
      "message": "PTanotherL",
      "revId": "bc63278fabbe0f452ea501cd4a986038e33c32e4",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "372cbf64_20100b93",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 3
      },
      "lineNbr": 0,
      "author": {
        "id": 1119600
      },
      "writtenOn": "2020-07-20T12:42:12Z",
      "side": 1,
      "message": "I think this is already much better, thanks! Do you think the code would become easier to read if you formulated it recursively and used array.pop() (you need to clone the selection then)? That would do away with the indices.",
      "revId": "bc63278fabbe0f452ea501cd4a986038e33c32e4",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "27d35e70_e73ea3af",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 3
      },
      "lineNbr": 0,
      "author": {
        "id": 1396454
      },
      "writtenOn": "2020-07-20T14:14:48Z",
      "side": 1,
      "message": "My initial approach was to use recursion, but without constructing `elementPath` beforehand. Instead I wanted to recurse to the root node and then expand elements on the way back up. But for this to work it would require to recursive function to return (a) value(s) to be used in the next outer iteration.\n\nI looked into doing it the way you suggested:\n\n  _expandLastRecursive(selection, elementPath) {\n    if (!selection.length || !elementPath.length) return;\n    const element \u003d elementPath.pop();\n    if (element.itemURL \u003d\u003d\u003d selection.pop()) {\n      if (!element.expanded) {\n        if (elementPath.length \u003e 0) {\n          element.expand();\n        }\n        element.select();\n      }\n      this._expandLastRecursive(selection, elementPath);\n    }\n  }\n\nFor me, the iterative approach using indices is easier to follow. What do you think?",
      "parentUuid": "372cbf64_20100b93",
      "revId": "bc63278fabbe0f452ea501cd4a986038e33c32e4",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "f4c4fddc_ad18e298",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 3
      },
      "lineNbr": 0,
      "author": {
        "id": 1119600
      },
      "writtenOn": "2020-07-20T14:30:09Z",
      "side": 1,
      "message": "OK, this doesn\u0027t seem any better to read, thanks for considering!",
      "parentUuid": "27d35e70_e73ea3af",
      "revId": "bc63278fabbe0f452ea501cd4a986038e33c32e4",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "ba42fd98_180ec86c",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 3
      },
      "lineNbr": 0,
      "author": {
        "id": 1119600
      },
      "writtenOn": "2020-07-20T14:30:09Z",
      "side": 1,
      "message": "LGTM % question, thanks!",
      "revId": "bc63278fabbe0f452ea501cd4a986038e33c32e4",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "64b2543f_0f3320d4",
        "filename": "front_end/resources/ApplicationPanelSidebar.js",
        "patchSetId": 3
      },
      "lineNbr": 375,
      "author": {
        "id": 1119600
      },
      "writtenOn": "2020-07-20T14:30:09Z",
      "side": 1,
      "message": "What is this accomplishing? If we haven\u0027t arrived at the element we are looking for, we keep expanding (but we are not expanding the element we want to select?)\n\nI wonder if we can unconditionally expand the element.",
      "range": {
        "startLine": 375,
        "startChar": 11,
        "endLine": 375,
        "endChar": 18
      },
      "revId": "bc63278fabbe0f452ea501cd4a986038e33c32e4",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "fe05f57c_446bb002",
        "filename": "front_end/resources/ApplicationPanelSidebar.js",
        "patchSetId": 3
      },
      "lineNbr": 375,
      "author": {
        "id": 1396454
      },
      "writtenOn": "2020-07-20T14:50:18Z",
      "side": 1,
      "message": "Exactly, we are expanding all elements up to the previously selected and persisted element, but not this element itself. This is how the previous implementation handled it and I was confused about this at first too. But I think it makes sense and is consistent since clicking on/selecting an element does not expand it either. And there could be situations where the selected element has a lot of children potentially adding visual noise.",
      "parentUuid": "64b2543f_0f3320d4",
      "range": {
        "startLine": 375,
        "startChar": 11,
        "endLine": 375,
        "endChar": 18
      },
      "revId": "bc63278fabbe0f452ea501cd4a986038e33c32e4",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "28617f6c_66f0d2a4",
        "filename": "front_end/resources/ApplicationPanelSidebar.js",
        "patchSetId": 3
      },
      "lineNbr": 375,
      "author": {
        "id": 1119600
      },
      "writtenOn": "2020-07-20T15:05:42Z",
      "side": 1,
      "message": "SGTM, thanks!",
      "parentUuid": "fe05f57c_446bb002",
      "range": {
        "startLine": 375,
        "startChar": 11,
        "endLine": 375,
        "endChar": 18
      },
      "revId": "bc63278fabbe0f452ea501cd4a986038e33c32e4",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    }
  ]
}