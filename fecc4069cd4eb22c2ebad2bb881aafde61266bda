{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "c7e1d2a0_e97d8705",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 14
      },
      "lineNbr": 0,
      "author": {
        "id": 1524702
      },
      "writtenOn": "2022-12-21T09:54:28Z",
      "side": 1,
      "message": "LGTM with one nit :)\n\nI have a comment regarding clamping but we can take care of it later ðŸ¥³",
      "revId": "fecc4069cd4eb22c2ebad2bb881aafde61266bda",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "259743df_26cdf4ef",
        "filename": "front_end/core/common/Color.ts",
        "patchSetId": 14
      },
      "lineNbr": 792,
      "author": {
        "id": 1524702
      },
      "writtenOn": "2022-12-21T09:25:45Z",
      "side": 1,
      "message": "I have two comments regarding clamping:\n* Should we do clamping at all?\n* Should it be in the constructor or in the parsing side?\n\nI\u0027m slowly getting into the idea that we shouldn\u0027t do clamping at all. The conversion functions can work in an unbounded space (citation needed ðŸ˜…) and a color that is out of gamut of one color space can be in gamut of another color space.\n\nFor example, `color(xyz-d50 74 63 27)` is a valid color. However, when you convert this to `lch` it becomes `lch(100 206.58 49.08)` which is the lightness value clamped version of the same color. Even though the first color is shown as white in the `xyz-d50` color space by the browser, it is shown as red when that is converted to `lch` which is wrong because we expect the colors to not change only with color space conversions.\n\nEven if we want colors to change, then we\u0027ll probably need to do proper gamut mapping to the corresponding space.\n\nIn my opinion, we shouldn\u0027t do any clamping.\n\n---\nIf we want to do clamping, the question is where we should do it? For that, I think we\u0027d need to think about why we need clamping. Why should we have clamping?\n\n---\nFor the sake of this CL, I think we can move forward like this (and not intersect the changes with your vacation ðŸ˜‚) and in the meantime, before the M111 branch point, we can update clamping related things. WDYT?",
      "revId": "fecc4069cd4eb22c2ebad2bb881aafde61266bda",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "e62e9b75_97ed1362",
        "filename": "front_end/core/common/Color.ts",
        "patchSetId": 14
      },
      "lineNbr": 792,
      "author": {
        "id": 1372423
      },
      "writtenOn": "2022-12-21T10:46:47Z",
      "side": 1,
      "message": "My plan here was to have a Color object always represent a valid color as an invariant. That\u0027s why I moved the clamping to the constructor so that colors are valid both when they\u0027re coming from parsing as well as from conversion. It seems useful however for a Color object to _know_ when it came from an invalid source, which is what I was adding in the dependend CL (needs a proper rebase currently). That will also be important when we add a conversion UI, where we\u0027ll want to disable or at least point out invalid conersions.\n\nI considered adding gamut mapping, too, but I\u0027ve used clamping here so that parsing and converting behave the same. Clamping during parsing is the spec\u0027ed behavior, but we can certainly rethink what to do for conversion. One question is if we ever show out-of-gamut converted colors to the user (if this conversion is disabled, they can\u0027t actually get there).\n\nThe colors in your example are both white for me, am I holding it wrong? A nice thing about the conversions as they\u0027re implemented here is that we aren\u0027t discarding information. Even if clamping happens, we retain the original color also. Additional conversions will not work on lost information, it\u0027s just the asString that returns the clamped result.",
      "parentUuid": "259743df_26cdf4ef",
      "revId": "fecc4069cd4eb22c2ebad2bb881aafde61266bda",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "e49ff784_2df87bae",
        "filename": "test/unittests/front_end/core/common/Color_test.ts",
        "patchSetId": 14
      },
      "lineNbr": 704,
      "author": {
        "id": 1524702
      },
      "writtenOn": "2022-12-21T09:54:28Z",
      "side": 1,
      "message": "(nit): Can we add a comment on how the test logic works?\n\nAFAIU it gives a code to all the color spaces and stubs color converter functions to accept a color space code and return an expected color space code.\n\nThen, it in the assertions, we\u0027re checking that chain of conversions from one color space to the other lead to correct result.\n\n(IMO this is a brilliant idea to test this behavior with chains included ðŸ˜‚)",
      "revId": "fecc4069cd4eb22c2ebad2bb881aafde61266bda",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "fff7f217_fedbd66c",
        "filename": "test/unittests/front_end/core/common/Color_test.ts",
        "patchSetId": 14
      },
      "lineNbr": 704,
      "author": {
        "id": 1372423
      },
      "writtenOn": "2022-12-21T13:20:09Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "e49ff784_2df87bae",
      "revId": "fecc4069cd4eb22c2ebad2bb881aafde61266bda",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    }
  ]
}