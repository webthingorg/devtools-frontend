// @ts-nocheck - Prevent tsc stepping into any required bundles.
/*!
 * Lighthouse v8.1.0 860cb292d48b7c8a1a44874152b6c0ec47642ffd (July 14th 2021)
 * 
 * Automated auditing, performance metrics, and best practices for the web.
 * 
 * @homepage https://github.com/GoogleChrome/lighthouse#readme
 * @author   The Lighthouse Authors
 * @license  Apache-2.0
 */
globalThis.require=(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({"../audits/accessibility/accesskeys":[function(require,module,exports){
(function (__filename){(function (){
/**
 * @license Copyright 2017 The Lighthouse Authors. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.
 */
'use strict';

/**
 * @fileoverview Ensures accesskey values are unique.
 * See base class in axe-audit.js for audit() implementation.
 */

const AxeAudit = require('./axe-audit.js');
const i18n = require('../../lib/i18n/i18n.js');

const UIStrings = {
  /** Title of an accesibility audit that evaluates if the accesskey HTML attribute values are unique across all elements. This title is descriptive of the successful state and is shown to users when no user action is required. */
  title: '`[accesskey]` values are unique',
  /** Title of an accesibility audit that evaluates if the ARIA HTML attributes are misaligned with the aria-role HTML attribute specificed on the element, such mismatches are invalid. This title is descriptive of the failing state and is shown to users when there is a failure that needs to be addressed. */
  failureTitle: '`[accesskey]` values are not unique',
  /** Description of a Lighthouse audit that tells the user *why* they should try to pass. This is displayed after a user expands the section to see more. No character length limits. 'Learn More' becomes link text to additional documentation. */
  description: 'Access keys let users quickly focus a part of the page. For proper ' +
      'navigation, each access key must be unique. ' +
      '[Learn more](https://web.dev/accesskeys/).',
};

const str_ = i18n.createMessageInstanceIdFn(__filename, UIStrings);

class Accesskeys extends AxeAudit {
  /**
   * @return {LH.Audit.Meta}
   */
  static get meta() {
    return {
      id: 'accesskeys',
      title: str_(UIStrings.title),
      failureTitle: str_(UIStrings.failureTitle),
      description: str_(UIStrings.description),
      requiredArtifacts: ['Accessibility'],
    };
  }
}

module.exports = Accesskeys;
module.exports.UIStrings = UIStrings;

}).call(this)}).call(this,"/lighthouse-core/audits/accessibility/accesskeys.js")
},{"../../lib/i18n/i18n.js":96,"./axe-audit.js":2}],"../audits/accessibility/aria-allowed-attr":[function(require,module,exports){
(function (__filename){(function (){
/**
 * @license Copyright 2017 The Lighthouse Authors. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.
 */
'use strict';

/**
 * @fileoverview Ensures ARIA attributes are allowed for an element's role.
 * See base class in axe-audit.js for audit() implementation.
 */

const AxeAudit = require('./axe-audit.js');
const i18n = require('../../lib/i18n/i18n.js');

const UIStrings = {
  /** Title of an accesibility audit that evaluates if the ARIA HTML attributes are misaligned with the aria-role HTML attribute specificed on the element, such mismatches are invalid. This title is descriptive of the successful state and is shown to users when no user action is required. */
  title: '`[aria-*]` attributes match their roles',
  /** Title of an accesibility audit that evaluates if the ARIA HTML attributes are misaligned with the aria-role HTML attribute specificed on the element, such mismatches are invalid. This title is descriptive of the failing state and is shown to users when there is a failure that needs to be addressed. */
  failureTitle: '`[aria-*]` attributes do not match their roles',
  /** Description of a Lighthouse audit that tells the user *why* they should try to pass. This is displayed after a user expands the section to see more. No character length limits. 'Learn More' becomes link text to additional documentation. */
  description: 'Each ARIA `role` supports a specific subset of `aria-*` attributes. ' +
      'Mismatching these invalidates the `aria-*` attributes. [Learn ' +
      'more](https://web.dev/aria-allowed-attr/).',
};

const str_ = i18n.createMessageInstanceIdFn(__filename, UIStrings);

class ARIAAllowedAttr extends AxeAudit {
  /**
   * @return {LH.Audit.Meta}
   */
  static get meta() {
    return {
      id: 'aria-allowed-attr',
      title: str_(UIStrings.title),
      failureTitle: str_(UIStrings.failureTitle),
      description: str_(UIStrings.description),
      requiredArtifacts: ['Accessibility'],
    };
  }
}

module.exports = ARIAAllowedAttr;
module.exports.UIStrings = UIStrings;

}).call(this)}).call(this,"/lighthouse-core/audits/accessibility/aria-allowed-attr.js")
},{"../../lib/i18n/i18n.js":96,"./axe-audit.js":2}],"../audits/accessibility/aria-command-name":[function(require,module,exports){
(function (__filename){(function (){
/**
 * @license Copyright 2020 The Lighthouse Authors. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.
 */
'use strict';

/**
 * @fileoverview Ensures every ARIA button, link and menuitem element has an accessible name
 * See base class in axe-audit.js for audit() implementation.
 */

const AxeAudit = require('./axe-audit.js');
const i18n = require('../../lib/i18n/i18n.js');

const UIStrings = {
  /** Title of an accessibility audit that evaluates if important HTML elements have an accessible name. This title is descriptive of the successful state and is shown to users when no user action is required. */
  title: '`button`, `link`, and `menuitem` elements have accessible names',
  /** Title of an accessibility audit that evaluates if important HTML elements do not have accessible names. This title is descriptive of the failing state and is shown to users when there is a failure that needs to be addressed. */
  failureTitle: '`button`, `link`, and `menuitem` elements do not have accessible names.',
  /** Description of a Lighthouse audit that tells the user *why* they should have accessible names for HTML elements. This is displayed after a user expands the section to see more. No character length limits. 'Learn More' becomes link text to additional documentation. */
  description: 'When an element doesn\'t have an accessible name, screen readers announce it with a generic name, making it unusable for users who rely on screen readers. [Learn more](https://web.dev/aria-name/).',
};

const str_ = i18n.createMessageInstanceIdFn(__filename, UIStrings);

class AriaCommandName extends AxeAudit {
  /**
   * @return {LH.Audit.Meta}
   */
  static get meta() {
    return {
      id: 'aria-command-name',
      title: str_(UIStrings.title),
      failureTitle: str_(UIStrings.failureTitle),
      description: str_(UIStrings.description),
      requiredArtifacts: ['Accessibility'],
    };
  }
}

module.exports = AriaCommandName;
module.exports.UIStrings = UIStrings;

}).call(this)}).call(this,"/lighthouse-core/audits/accessibility/aria-command-name.js")
},{"../../lib/i18n/i18n.js":96,"./axe-audit.js":2}],"../audits/accessibility/aria-hidden-body":[function(require,module,exports){
(function (__filename){(function (){
/**
 * @license Copyright 2019 The Lighthouse Authors. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.
 */
'use strict';

/**
 * @fileoverview Ensures `aria-hidden='true'` is not present on the document body.
 * See base class in axe-audit.js for audit() implementation.
 */

const AxeAudit = require('./axe-audit.js');
const i18n = require('../../lib/i18n/i18n.js');

const UIStrings = {
  /** Title of an accesibility audit that checks if the html <body> element does not have an aria-hidden attribute set on it. This title is descriptive of the successful state and is shown to users when no user action is required. */
  title: '`[aria-hidden="true"]` is not present on the document `<body>`',
  /** Title of an accesibility audit that checks if the html <body> element does not have an aria-hidden attribute set on it. This title is descriptive of the failing state and is shown to users when there is a failure that needs to be addressed. */
  failureTitle: '`[aria-hidden="true"]` is present on the document `<body>`',
  /** Description of a Lighthouse audit that tells the user *why* they should try to pass. This is displayed after a user expands the section to see more. No character length limits. 'Learn More' becomes link text to additional documentation. */
  description: 'Assistive technologies, like screen readers, work inconsistently when `aria-hidden="true"` is set on the document `<body>`. [Learn more](https://web.dev/aria-hidden-body/).',
};

const str_ = i18n.createMessageInstanceIdFn(__filename, UIStrings);

class AriaHiddenBody extends AxeAudit {
  /**
   * @return {LH.Audit.Meta}
   */
  static get meta() {
    return {
      id: 'aria-hidden-body',
      title: str_(UIStrings.title),
      failureTitle: str_(UIStrings.failureTitle),
      description: str_(UIStrings.description),
      requiredArtifacts: ['Accessibility'],
    };
  }
}

module.exports = AriaHiddenBody;
module.exports.UIStrings = UIStrings;

}).call(this)}).call(this,"/lighthouse-core/audits/accessibility/aria-hidden-body.js")
},{"../../lib/i18n/i18n.js":96,"./axe-audit.js":2}],"../audits/accessibility/aria-hidden-focus":[function(require,module,exports){
(function (__filename){(function (){
/**
 * @license Copyright 2019 The Lighthouse Authors. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.
 */
'use strict';

/**
 * @fileoverview Ensures `aria-hidden` elements do not contain focusable elements.
 * See base class in axe-audit.js for audit() implementation.
 */

const AxeAudit = require('./axe-audit.js');
const i18n = require('../../lib/i18n/i18n.js');

const UIStrings = {
  /** Title of an accesibility audit that checks if all elements that have an aria-hidden attribute do not contain focusable descendent elements. This title is descriptive of the successful state and is shown to users when no user action is required. */
  title: '`[aria-hidden="true"]` elements do not contain focusable descendents',
  /** Title of an accesibility audit that checks if all elements that have an aria-hidden attribute do not contain focusable descendent elements. This title is descriptive of the failing state and is shown to users when there is a failure that needs to be addressed. */
  failureTitle: '`[aria-hidden="true"]` elements contain focusable descendents',
  /** Description of a Lighthouse audit that tells the user *why* they should try to pass. This is displayed after a user expands the section to see more. No character length limits. 'Learn More' becomes link text to additional documentation. */
  description: 'Focusable descendents within an `[aria-hidden="true"]` element prevent those interactive elements from being available to users of assistive technologies like screen readers. [Learn more](https://web.dev/aria-hidden-focus/).',
};

const str_ = i18n.createMessageInstanceIdFn(__filename, UIStrings);

class AriaHiddenFocus extends AxeAudit {
  /**
   * @return {LH.Audit.Meta}
   */
  static get meta() {
    return {
      id: 'aria-hidden-focus',
      title: str_(UIStrings.title),
      failureTitle: str_(UIStrings.failureTitle),
      description: str_(UIStrings.description),
      requiredArtifacts: ['Accessibility'],
    };
  }
}

module.exports = AriaHiddenFocus;
module.exports.UIStrings = UIStrings;

}).call(this)}).call(this,"/lighthouse-core/audits/accessibility/aria-hidden-focus.js")
},{"../../lib/i18n/i18n.js":96,"./axe-audit.js":2}],"../audits/accessibility/aria-input-field-name":[function(require,module,exports){
(function (__filename){(function (){
/**
 * @license Copyright 2019 The Lighthouse Authors. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.
 */
'use strict';

/**
 * @fileoverview Ensures all ARIA input fields have an accessible name.
 * See base class in axe-audit.js for audit() implementation.
 */

const AxeAudit = require('./axe-audit.js');
const i18n = require('../../lib/i18n/i18n.js');

const UIStrings = {
  /** Title of an accesibility audit that checks that all ARIA input fields have an accessible name. This title is descriptive of the successful state and is shown to users when no user action is required. */
  title: 'ARIA input fields have accessible names',
  /** Title of an accesibility audit that checks that all ARIA input fields have an accessible name. This title is descriptive of the failing state and is shown to users when there is a failure that needs to be addressed. */
  failureTitle: 'ARIA input fields do not have accessible names',
  /** Description of a Lighthouse audit that tells the user *why* they should try to pass. This is displayed after a user expands the section to see more. No character length limits. 'Learn More' becomes link text to additional documentation. */
  description: 'When an input field doesn\'t have an accessible name, screen readers announce it with a generic name, making it unusable for users who rely on screen readers. [Learn more](https://web.dev/aria-name/).',
};

const str_ = i18n.createMessageInstanceIdFn(__filename, UIStrings);

class AriaInputFieldName extends AxeAudit {
  /**
   * @return {LH.Audit.Meta}
   */
  static get meta() {
    return {
      id: 'aria-input-field-name',
      title: str_(UIStrings.title),
      failureTitle: str_(UIStrings.failureTitle),
      description: str_(UIStrings.description),
      requiredArtifacts: ['Accessibility'],
    };
  }
}

module.exports = AriaInputFieldName;
module.exports.UIStrings = UIStrings;

}).call(this)}).call(this,"/lighthouse-core/audits/accessibility/aria-input-field-name.js")
},{"../../lib/i18n/i18n.js":96,"./axe-audit.js":2}],"../audits/accessibility/aria-meter-name":[function(require,module,exports){
(function (__filename){(function (){
/**
 * @license Copyright 2020 The Lighthouse Authors. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.
 */
'use strict';

/**
 * @fileoverview Ensures every ARIA meter element has an accessible name
 * See base class in axe-audit.js for audit() implementation.
 */

const AxeAudit = require('./axe-audit.js');
const i18n = require('../../lib/i18n/i18n.js');

const UIStrings = {
  /** Title of an accessibility audit that evaluates if meter HTML elements have an accessible name. This title is descriptive of the successful state and is shown to users when no user action is required. */
  title: 'ARIA `meter` elements have accessible names',
  /** Title of an accessibility audit that evaluates if meter HTML elements do not have accessible names. This title is descriptive of the failing state and is shown to users when there is a failure that needs to be addressed. */
  failureTitle: 'ARIA `meter` elements do not have accessible names.',
  /** Description of a Lighthouse audit that tells the user *why* they should have accessible names for HTML elements. This is displayed after a user expands the section to see more. No character length limits. 'Learn More' becomes link text to additional documentation. */
  description: 'When an element doesn\'t have an accessible name, screen readers announce it with a generic name, making it unusable for users who rely on screen readers. [Learn more](https://web.dev/aria-name/).',
};

const str_ = i18n.createMessageInstanceIdFn(__filename, UIStrings);

class AriaMeterName extends AxeAudit {
  /**
   * @return {LH.Audit.Meta}
   */
  static get meta() {
    return {
      id: 'aria-meter-name',
      title: str_(UIStrings.title),
      failureTitle: str_(UIStrings.failureTitle),
      description: str_(UIStrings.description),
      requiredArtifacts: ['Accessibility'],
    };
  }
}

module.exports = AriaMeterName;
module.exports.UIStrings = UIStrings;

}).call(this)}).call(this,"/lighthouse-core/audits/accessibility/aria-meter-name.js")
},{"../../lib/i18n/i18n.js":96,"./axe-audit.js":2}],"../audits/accessibility/aria-progressbar-name":[function(require,module,exports){
(function (__filename){(function (){
/**
 * @license Copyright 2020 The Lighthouse Authors. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.
 */
'use strict';

/**
 * @fileoverview Ensures every ARIA progressbar element has an accessible name
 * See base class in axe-audit.js for audit() implementation.
 */

const AxeAudit = require('./axe-audit.js');
const i18n = require('../../lib/i18n/i18n.js');

const UIStrings = {
  /** Title of an accessibility audit that evaluates if progressbar HTML elements have an accessible name. This title is descriptive of the successful state and is shown to users when no user action is required. */
  title: 'ARIA `progressbar` elements have accessible names',
  /** Title of an accessibility audit that evaluates if progressbar HTML elements do not have accessible names. This title is descriptive of the failing state and is shown to users when there is a failure that needs to be addressed. */
  failureTitle: 'ARIA `progressbar` elements do not have accessible names.',
  /** Description of a Lighthouse audit that tells the user *why* they should try to pass. This is displayed after a user expands the section to see more. No character length limits. 'Learn More' becomes link text to additional documentation. */
  description: 'When a `progressbar` element doesn\'t have an accessible name, screen readers announce it with a generic name, making it unusable for users who rely on screen readers. [Learn more](https://web.dev/aria-name/).',
};

const str_ = i18n.createMessageInstanceIdFn(__filename, UIStrings);

class AriaProgressbarName extends AxeAudit {
  /**
   * @return {LH.Audit.Meta}
   */
  static get meta() {
    return {
      id: 'aria-progressbar-name',
      title: str_(UIStrings.title),
      failureTitle: str_(UIStrings.failureTitle),
      description: str_(UIStrings.description),
      requiredArtifacts: ['Accessibility'],
    };
  }
}

module.exports = AriaProgressbarName;
module.exports.UIStrings = UIStrings;

}).call(this)}).call(this,"/lighthouse-core/audits/accessibility/aria-progressbar-name.js")
},{"../../lib/i18n/i18n.js":96,"./axe-audit.js":2}],"../audits/accessibility/aria-required-attr":[function(require,module,exports){
(function (__filename){(function (){
/**
 * @license Copyright 2017 The Lighthouse Authors. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.
 */
'use strict';

/**
 * @fileoverview Ensures elements with ARIA roles have all required ARIA attributes.
 * See base class in axe-audit.js for audit() implementation.
 */

const AxeAudit = require('./axe-audit.js');
const i18n = require('../../lib/i18n/i18n.js');

const UIStrings = {
  /** Title of an accesibility audit that evaluates if all elements with the aria-role attribute have the other corresponding ARIA attributes set as well. This title is descriptive of the successful state and is shown to users when no user action is required. */
  title: '`[role]`s have all required `[aria-*]` attributes',
  /** Title of an accesibility audit that evaluates if all elements with the aria-role attribute have the other corresponding ARIA attributes set as well. This title is descriptive of the failing state and is shown to users when there is a failure that needs to be addressed. */
  failureTitle: '`[role]`s do not have all required `[aria-*]` attributes',
  /** Description of a Lighthouse audit that tells the user *why* they should try to pass. This is displayed after a user expands the section to see more. No character length limits. 'Learn More' becomes link text to additional documentation. */
  description: 'Some ARIA roles have required attributes that describe the state ' +
      'of the element to screen readers. [Learn more](https://web.dev/aria-required-attr/).',
};

const str_ = i18n.createMessageInstanceIdFn(__filename, UIStrings);

class ARIARequiredAttr extends AxeAudit {
  /**
   * @return {LH.Audit.Meta}
   */
  static get meta() {
    return {
      id: 'aria-required-attr',
      title: str_(UIStrings.title),
      failureTitle: str_(UIStrings.failureTitle),
      description: str_(UIStrings.description),
      requiredArtifacts: ['Accessibility'],
    };
  }
}

module.exports = ARIARequiredAttr;
module.exports.UIStrings = UIStrings;

}).call(this)}).call(this,"/lighthouse-core/audits/accessibility/aria-required-attr.js")
},{"../../lib/i18n/i18n.js":96,"./axe-audit.js":2}],"../audits/accessibility/aria-required-children":[function(require,module,exports){
(function (__filename){(function (){
/**
 * @license Copyright 2017 The Lighthouse Authors. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.
 */
'use strict';

/**
 * @fileoverview Ensures elements with an ARIA role contain any required children.
 * e.g. A parent node with role="list" should contain children with role="listitem".
 * See base class in axe-audit.js for audit() implementation.
 */

const AxeAudit = require('./axe-audit.js');
const i18n = require('../../lib/i18n/i18n.js');

const UIStrings = {
  /** Title of an accesibility audit that evaluates if the elements with an aria-role that require child elements have the required children. This title is descriptive of the successful state and is shown to users when no user action is required. */
  title: 'Elements with an ARIA `[role]` that require children to contain a specific ' +
  '`[role]` have all required children.',
  /** Title of an accesibility audit that evaluates if the elements with an aria-role that require child elements have the required children. This title is descriptive of the failing state and is shown to users when there is a failure that needs to be addressed. */
  failureTitle: 'Elements with an ARIA `[role]` that require children to contain a specific ' +
  '`[role]` are missing some or all of those required children.',
  /** Description of a Lighthouse audit that tells the user *why* they should try to pass. This is displayed after a user expands the section to see more. No character length limits. 'Learn More' becomes link text to additional documentation. */
  description: 'Some ARIA parent roles must contain specific child roles to perform ' +
      'their intended accessibility functions. ' +
      '[Learn more](https://web.dev/aria-required-children/).',
};

const str_ = i18n.createMessageInstanceIdFn(__filename, UIStrings);

class AriaRequiredChildren extends AxeAudit {
  /**
   * @return {LH.Audit.Meta}
   */
  static get meta() {
    return {
      id: 'aria-required-children',
      title: str_(UIStrings.title),
      failureTitle: str_(UIStrings.failureTitle),
      description: str_(UIStrings.description),
      requiredArtifacts: ['Accessibility'],
    };
  }
}

module.exports = AriaRequiredChildren;
module.exports.UIStrings = UIStrings;

}).call(this)}).call(this,"/lighthouse-core/audits/accessibility/aria-required-children.js")
},{"../../lib/i18n/i18n.js":96,"./axe-audit.js":2}],"../audits/accessibility/aria-required-parent":[function(require,module,exports){
(function (__filename){(function (){
/**
 * @license Copyright 2017 The Lighthouse Authors. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.
 */
'use strict';

/**
 * @fileoverview Ensures elements with an ARIA role are contained by their required parents.
 * e.g. A child node with role="listitem" should be contained by a parent with role="list".
 * See base class in axe-audit.js for audit() implementation.
 */

const AxeAudit = require('./axe-audit.js');
const i18n = require('../../lib/i18n/i18n.js');

const UIStrings = {
  /** Title of an accesibility audit that evaluates valid aria-role usage. Some ARIA roles require that elements must be a child of specific parent element. This audit checks that when those roles are used, the element with the role is in fact a child of the required parent. This title is descriptive of the successful state and is shown to users when no user action is required. */
  title: '`[role]`s are contained by their required parent element',
  /** Title of an accesibility audit that evaluates valid aria-role usage. Some ARIA roles require that elements must be a child of specific parent element. This audit checks that when those roles are used, the element with the role is in fact a child of the required parent. This title is descriptive of the failing state and is shown to users when there is a failure that needs to be addressed. */
  failureTitle: '`[role]`s are not contained by their required parent element',
  /** Description of a Lighthouse audit that tells the user *why* they should try to pass. This is displayed after a user expands the section to see more. No character length limits. 'Learn More' becomes link text to additional documentation. */
  description: 'Some ARIA child roles must be contained by specific parent roles to ' +
      'properly perform their intended accessibility functions. ' +
      '[Learn more](https://web.dev/aria-required-parent/).',
};

const str_ = i18n.createMessageInstanceIdFn(__filename, UIStrings);

class AriaRequiredParent extends AxeAudit {
  /**
   * @return {LH.Audit.Meta}
   */
  static get meta() {
    return {
      id: 'aria-required-parent',
      title: str_(UIStrings.title),
      failureTitle: str_(UIStrings.failureTitle),
      description: str_(UIStrings.description),
      requiredArtifacts: ['Accessibility'],
    };
  }
}

module.exports = AriaRequiredParent;
module.exports.UIStrings = UIStrings;

}).call(this)}).call(this,"/lighthouse-core/audits/accessibility/aria-required-parent.js")
},{"../../lib/i18n/i18n.js":96,"./axe-audit.js":2}],"../audits/accessibility/aria-roles":[function(require,module,exports){
(function (__filename){(function (){
/**
 * @license Copyright 2017 The Lighthouse Authors. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.
 */
'use strict';

/**
 * @fileoverview Ensures all elements with a role attribute use a valid value.
 * See base class in axe-audit.js for audit() implementation.
 */

const AxeAudit = require('./axe-audit.js');
const i18n = require('../../lib/i18n/i18n.js');

const UIStrings = {
  /** Title of an accesibility audit that evaluates if all elements have valid aria-role HTML attributes. This title is descriptive of the successful state and is shown to users when no user action is required. */
  title: '`[role]` values are valid',
  /** Title of an accesibility audit that evaluates if all elements have valid aria-role HTML attributes. This title is descriptive of the failing state and is shown to users when there is a failure that needs to be addressed. */
  failureTitle: '`[role]` values are not valid',
  /** Description of a Lighthouse audit that tells the user *why* they should try to pass. This is displayed after a user expands the section to see more. No character length limits. 'Learn More' becomes link text to additional documentation. */
  description: 'ARIA roles must have valid values in order to perform their ' +
      'intended accessibility functions. ' +
      '[Learn more](https://web.dev/aria-roles/).',
};

const str_ = i18n.createMessageInstanceIdFn(__filename, UIStrings);

class AriaRoles extends AxeAudit {
  /**
   * @return {LH.Audit.Meta}
   */
  static get meta() {
    return {
      id: 'aria-roles',
      title: str_(UIStrings.title),
      failureTitle: str_(UIStrings.failureTitle),
      description: str_(UIStrings.description),
      requiredArtifacts: ['Accessibility'],
    };
  }
}

module.exports = AriaRoles;
module.exports.UIStrings = UIStrings;

}).call(this)}).call(this,"/lighthouse-core/audits/accessibility/aria-roles.js")
},{"../../lib/i18n/i18n.js":96,"./axe-audit.js":2}],"../audits/accessibility/aria-toggle-field-name":[function(require,module,exports){
(function (__filename){(function (){
/**
 * @license Copyright 2019 The Lighthouse Authors. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.
 */
'use strict';

/**
 * @fileoverview Ensures all ARIA toggle fields have an accessible name.
 * See base class in axe-audit.js for audit() implementation.
 */

const AxeAudit = require('./axe-audit.js');
const i18n = require('../../lib/i18n/i18n.js');

const UIStrings = {
  /** Title of an accesibility audit that checks that all ARIA toggle fields have an accessible name. This title is descriptive of the successful state and is shown to users when no user action is required. */
  title: 'ARIA toggle fields have accessible names',
  /** Title of an accesibility audit that checks that all ARIA toggle fields have an accessible name. This title is descriptive of the failing state and is shown to users when there is a failure that needs to be addressed. */
  failureTitle: 'ARIA toggle fields do not have accessible names',
  /** Description of a Lighthouse audit that tells the user *why* they should try to pass. This is displayed after a user expands the section to see more. No character length limits. 'Learn More' becomes link text to additional documentation. */
  description: 'When a toggle field doesn\'t have an accessible name, screen readers announce it with a generic name, making it unusable for users who rely on screen readers. [Learn more](https://web.dev/aria-name/).',
};

const str_ = i18n.createMessageInstanceIdFn(__filename, UIStrings);

class AriaToggleFieldName extends AxeAudit {
  /**
   * @return {LH.Audit.Meta}
   */
  static get meta() {
    return {
      id: 'aria-toggle-field-name',
      title: str_(UIStrings.title),
      failureTitle: str_(UIStrings.failureTitle),
      description: str_(UIStrings.description),
      requiredArtifacts: ['Accessibility'],
    };
  }
}

module.exports = AriaToggleFieldName;
module.exports.UIStrings = UIStrings;

}).call(this)}).call(this,"/lighthouse-core/audits/accessibility/aria-toggle-field-name.js")
},{"../../lib/i18n/i18n.js":96,"./axe-audit.js":2}],"../audits/accessibility/aria-tooltip-name":[function(require,module,exports){
(function (__filename){(function (){
/**
 * @license Copyright 2020 The Lighthouse Authors. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.
 */
'use strict';

/**
 * @fileoverview Ensures every ARIA tooltip has an accessible name
 * See base class in axe-audit.js for audit() implementation.
 */

const AxeAudit = require('./axe-audit.js');
const i18n = require('../../lib/i18n/i18n.js');

const UIStrings = {
  /** Title of an accessibility audit that evaluates if tooltip HTML elements have an accessible name. This title is descriptive of the successful state and is shown to users when no user action is required. */
  title: 'ARIA `tooltip` elements have accessible names',
  /** Title of an accessibility audit that evaluates if tooltip HTML elements do not have accessible names. This title is descriptive of the failing state and is shown to users when there is a failure that needs to be addressed. */
  failureTitle: 'ARIA `tooltip` elements do not have accessible names.',
  /** Description of a Lighthouse audit that tells the user *why* they should have accessible names for HTML elements. This is displayed after a user expands the section to see more. No character length limits. 'Learn More' becomes link text to additional documentation. */
  description: 'When an element doesn\'t have an accessible name, screen readers announce it with a generic name, making it unusable for users who rely on screen readers. [Learn more](https://web.dev/aria-name/).',
};

const str_ = i18n.createMessageInstanceIdFn(__filename, UIStrings);

class AriaTooltipName extends AxeAudit {
  /**
   * @return {LH.Audit.Meta}
   */
  static get meta() {
    return {
      id: 'aria-tooltip-name',
      title: str_(UIStrings.title),
      failureTitle: str_(UIStrings.failureTitle),
      description: str_(UIStrings.description),
      requiredArtifacts: ['Accessibility'],
    };
  }
}

module.exports = AriaTooltipName;
module.exports.UIStrings = UIStrings;

}).call(this)}).call(this,"/lighthouse-core/audits/accessibility/aria-tooltip-name.js")
},{"../../lib/i18n/i18n.js":96,"./axe-audit.js":2}],"../audits/accessibility/aria-treeitem-name":[function(require,module,exports){
(function (__filename){(function (){
/**
 * @license Copyright 2020 The Lighthouse Authors. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.
 */
'use strict';

/**
 * @fileoverview Ensures every ARIA treeitem element has an accessible name.
 * See base class in axe-audit.js for audit() implementation.
 */

const AxeAudit = require('./axe-audit.js');
const i18n = require('../../lib/i18n/i18n.js');

const UIStrings = {
  /** Title of an accessibility audit that evaluates if treeitem HTML elements have an accessible name. This title is descriptive of the successful state and is shown to users when no user action is required. */
  title: 'ARIA `treeitem` elements have accessible names',
  /** Title of an accessibility audit that evaluates if treeitem HTML elements do not have accessible names. This title is descriptive of the failing state and is shown to users when there is a failure that needs to be addressed. */
  failureTitle: 'ARIA `treeitem` elements do not have accessible names.',
  /** Description of a Lighthouse audit that tells the user *why* they should have accessible names for HTML elements. This is displayed after a user expands the section to see more. No character length limits. 'Learn More' becomes link text to additional documentation. */
  description: 'When an element doesn\'t have an accessible name, screen readers announce it with a generic name, making it unusable for users who rely on screen readers. [Learn more](https://web.dev/aria-name/).',
};

const str_ = i18n.createMessageInstanceIdFn(__filename, UIStrings);

class AriaTreeitemName extends AxeAudit {
  /**
   * @return {LH.Audit.Meta}
   */
  static get meta() {
    return {
      id: 'aria-treeitem-name',
      title: str_(UIStrings.title),
      failureTitle: str_(UIStrings.failureTitle),
      description: str_(UIStrings.description),
      requiredArtifacts: ['Accessibility'],
    };
  }
}

module.exports = AriaTreeitemName;
module.exports.UIStrings = UIStrings;

}).call(this)}).call(this,"/lighthouse-core/audits/accessibility/aria-treeitem-name.js")
},{"../../lib/i18n/i18n.js":96,"./axe-audit.js":2}],"../audits/accessibility/aria-valid-attr-value":[function(require,module,exports){
(function (__filename){(function (){
/**
 * @license Copyright 2017 The Lighthouse Authors. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.
 */
'use strict';

/**
 * @fileoverview Ensures all ARIA attributes have valid values.
 * See base class in axe-audit.js for audit() implementation.
 */

const AxeAudit = require('./axe-audit.js');
const i18n = require('../../lib/i18n/i18n.js');

const UIStrings = {
  /** Title of an accesibility audit that evaluates if all elements that have an ARIA HTML attribute have a valid value for that attribute. This title is descriptive of the successful state and is shown to users when no user action is required. */
  title: '`[aria-*]` attributes have valid values',
  /** Title of an accesibility audit that evaluates if all elements that have an ARIA HTML attribute have a valid value for that attribute. This title is descriptive of the failing state and is shown to users when there is a failure that needs to be addressed. */
  failureTitle: '`[aria-*]` attributes do not have valid values',
  /** Description of a Lighthouse audit that tells the user *why* they should try to pass. This is displayed after a user expands the section to see more. No character length limits. 'Learn More' becomes link text to additional documentation. */
  description: 'Assistive technologies, like screen readers, can\'t interpret ARIA ' +
      'attributes with invalid values. [Learn ' +
      'more](https://web.dev/aria-valid-attr-value/).',
};

const str_ = i18n.createMessageInstanceIdFn(__filename, UIStrings);

class ARIAValidAttr extends AxeAudit {
  /**
   * @return {LH.Audit.Meta}
   */
  static get meta() {
    return {
      id: 'aria-valid-attr-value',
      title: str_(UIStrings.title),
      failureTitle: str_(UIStrings.failureTitle),
      description: str_(UIStrings.description),
      requiredArtifacts: ['Accessibility'],
    };
  }
}

module.exports = ARIAValidAttr;
module.exports.UIStrings = UIStrings;

}).call(this)}).call(this,"/lighthouse-core/audits/accessibility/aria-valid-attr-value.js")
},{"../../lib/i18n/i18n.js":96,"./axe-audit.js":2}],"../audits/accessibility/aria-valid-attr":[function(require,module,exports){
(function (__filename){(function (){
/**
 * @license Copyright 2017 The Lighthouse Authors. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.
 */
'use strict';

/**
 * @fileoverview Ensures aria-* attributes are valid and not misspelled or non-existent.
 * See base class in axe-audit.js for audit() implementation.
 */

const AxeAudit = require('./axe-audit.js');
const i18n = require('../../lib/i18n/i18n.js');

const UIStrings = {
  /** Title of an accesibility audit that evaluates if all elements with ARIA HTML attributes have spelled the name of attribute correctly. This title is descriptive of the successful state and is shown to users when no user action is required. */
  title: '`[aria-*]` attributes are valid and not misspelled',
  /** Title of an accesibility audit that evaluates if all elements with ARIA HTML attributes have spelled the name of attribute correctly. This title is descriptive of the failing state and is shown to users when there is a failure that needs to be addressed. */
  failureTitle: '`[aria-*]` attributes are not valid or misspelled',
  /** Description of a Lighthouse audit that tells the user *why* they should try to pass. This is displayed after a user expands the section to see more. No character length limits. 'Learn More' becomes link text to additional documentation. */
  description: 'Assistive technologies, like screen readers, can\'t interpret ARIA ' +
      'attributes with invalid names. [Learn ' +
      'more](https://web.dev/aria-valid-attr/).',
};

const str_ = i18n.createMessageInstanceIdFn(__filename, UIStrings);

class ARIAValidAttr extends AxeAudit {
  /**
   * @return {LH.Audit.Meta}
   */
  static get meta() {
    return {
      id: 'aria-valid-attr',
      title: str_(UIStrings.title),
      failureTitle: str_(UIStrings.failureTitle),
      description: str_(UIStrings.description),
      requiredArtifacts: ['Accessibility'],
    };
  }
}

module.exports = ARIAValidAttr;
module.exports.UIStrings = UIStrings;

}).call(this)}).call(this,"/lighthouse-core/audits/accessibility/aria-valid-attr.js")
},{"../../lib/i18n/i18n.js":96,"./axe-audit.js":2}],"../audits/accessibility/button-name":[function(require,module,exports){
(function (__filename){(function (){
/**
 * @license Copyright 2017 The Lighthouse Authors. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.
 */
'use strict';

/**
 * @fileoverview Ensures buttons have discernible text.
 * See base class in axe-audit.js for audit() implementation.
 */

const AxeAudit = require('./axe-audit.js');
const i18n = require('../../lib/i18n/i18n.js');

const UIStrings = {
  /** Title of an accesibility audit that evaluates if all button elements have names accessible to screen readers. This title is descriptive of the successful state and is shown to users when no user action is required. */
  title: 'Buttons have an accessible name',
  /** Title of an accesibility audit that evaluates if all button elements have names accessible to screen readers. This title is descriptive of the failing state and is shown to users when there is a failure that needs to be addressed. */
  failureTitle: 'Buttons do not have an accessible name',
  /** Description of a Lighthouse audit that tells the user *why* they should try to pass. This is displayed after a user expands the section to see more. No character length limits. 'Learn More' becomes link text to additional documentation. */
  description: 'When a button doesn\'t have an accessible name, screen readers announce it ' +
      'as "button", making it unusable for users who rely on screen readers. ' +
      '[Learn more](https://web.dev/button-name/).',
};

const str_ = i18n.createMessageInstanceIdFn(__filename, UIStrings);

class ButtonName extends AxeAudit {
  /**
   * @return {LH.Audit.Meta}
   */
  static get meta() {
    return {
      id: 'button-name',
      title: str_(UIStrings.title),
      failureTitle: str_(UIStrings.failureTitle),
      description: str_(UIStrings.description),
      requiredArtifacts: ['Accessibility'],
    };
  }
}

module.exports = ButtonName;
module.exports.UIStrings = UIStrings;

}).call(this)}).call(this,"/lighthouse-core/audits/accessibility/button-name.js")
},{"../../lib/i18n/i18n.js":96,"./axe-audit.js":2}],"../audits/accessibility/bypass":[function(require,module,exports){
(function (__filename){(function (){
/**
 * @license Copyright 2017 The Lighthouse Authors. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.
 */
'use strict';

/**
 * @fileoverview Ensures each page has at least one mechanism for a user to bypass navigation
 * and jump straight to the content.
 * See base class in axe-audit.js for audit() implementation.
 */

const AxeAudit = require('./axe-audit.js');
const i18n = require('../../lib/i18n/i18n.js');

const UIStrings = {
  /** Title of an accesibility audit that evaluates if the page has elements that let screen reader users skip over repetitive content. `heading`, `skip link`, and `landmark region` are technical terms for the elements that enable quick page navigation. This title is descriptive of the successful state and is shown to users when no user action is required. */
  title: 'The page contains a heading, skip link, or landmark region',
  /** Title of an accesibility audit that evaluates if the page has elements that let screen reader users skip over repetitive content. `heading`, `skip link`, and `landmark region` are technical terms for the elements that enable quick page navigation. This title is descriptive of the failing state and is shown to users when there is a failure that needs to be addressed. */
  failureTitle: 'The page does not contain a heading, skip link, or landmark region',
  /** Description of a Lighthouse audit that tells the user *why* they should try to pass. This is displayed after a user expands the section to see more. No character length limits. 'Learn More' becomes link text to additional documentation. */
  description: 'Adding ways to bypass repetitive content lets keyboard users navigate the ' +
      'page more efficiently. ' +
      '[Learn more](https://web.dev/bypass/).',
};

const str_ = i18n.createMessageInstanceIdFn(__filename, UIStrings);

class Bypass extends AxeAudit {
  /**
   * @return {LH.Audit.Meta}
   */
  static get meta() {
    return {
      id: 'bypass',
      title: str_(UIStrings.title),
      failureTitle: str_(UIStrings.failureTitle),
      description: str_(UIStrings.description),
      requiredArtifacts: ['Accessibility'],
    };
  }
}

module.exports = Bypass;
module.exports.UIStrings = UIStrings;

}).call(this)}).call(this,"/lighthouse-core/audits/accessibility/bypass.js")
},{"../../lib/i18n/i18n.js":96,"./axe-audit.js":2}],"../audits/accessibility/color-contrast":[function(require,module,exports){
(function (__filename){(function (){
/**
 * @license Copyright 2017 The Lighthouse Authors. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.
 */
'use strict';

/**
 * @fileoverview Ensures the contrast between foreground and background colors meets
 * WCAG 2 AA contrast ratio thresholds.
 * See base class in axe-audit.js for audit() implementation.
 */

const AxeAudit = require('./axe-audit.js');
const i18n = require('../../lib/i18n/i18n.js');

const UIStrings = {
  /** Title of an accesibility audit that evaluates if all foreground colors are distinct enough from their background colors to be legible for users. This title is descriptive of the successful state and is shown to users when no user action is required. */
  title: 'Background and foreground colors have a sufficient contrast ratio',
  /** Title of an accesibility audit that evaluates if all foreground colors are distinct enough from their background colors to be legible for users. This title is descriptive of the failing state and is shown to users when there is a failure that needs to be addressed. */
  failureTitle: 'Background and foreground colors do not have a ' +
      'sufficient contrast ratio.',
  /** Description of a Lighthouse audit that tells the user *why* they should try to pass. This is displayed after a user expands the section to see more. No character length limits. 'Learn More' becomes link text to additional documentation. */
  description: 'Low-contrast text is difficult or impossible for many users to read. ' +
      '[Learn more](https://web.dev/color-contrast/).',
};

const str_ = i18n.createMessageInstanceIdFn(__filename, UIStrings);

class ColorContrast extends AxeAudit {
  /**
   * @return {LH.Audit.Meta}
   */
  static get meta() {
    return {
      id: 'color-contrast',
      title: str_(UIStrings.title),
      failureTitle: str_(UIStrings.failureTitle),
      description: str_(UIStrings.description),
      requiredArtifacts: ['Accessibility'],
    };
  }
}

module.exports = ColorContrast;
module.exports.UIStrings = UIStrings;

}).call(this)}).call(this,"/lighthouse-core/audits/accessibility/color-contrast.js")
},{"../../lib/i18n/i18n.js":96,"./axe-audit.js":2}],"../audits/accessibility/definition-list":[function(require,module,exports){
(function (__filename){(function (){
/**
 * @license Copyright 2017 The Lighthouse Authors. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.
 */
'use strict';

/**
 * @fileoverview Ensures `<dl>` elements are structured correctly.
 * See base class in axe-audit.js for audit() implementation.
 */

const AxeAudit = require('./axe-audit.js');
const i18n = require('../../lib/i18n/i18n.js');

const UIStrings = {
  /** Title of an accesibility audit that evaluates if all the definition list elements have valid markup for screen readers. This title is descriptive of the successful state and is shown to users when no user action is required. */
  title: '`<dl>`\'s contain only properly-ordered `<dt>` and `<dd>` groups, `<script>`, ' +
      '`<template>` or `<div>` elements.',
  /** Title of an accesibility audit that evaluates if all the definition list elements have valid markup for screen readers. This title is descriptive of the failing state and is shown to users when there is a failure that needs to be addressed. */
  failureTitle: '`<dl>`\'s do not contain only properly-ordered `<dt>` and `<dd>` ' +
      'groups, `<script>`, `<template>` or `<div>` elements.',
  /** Description of a Lighthouse audit that tells the user *why* they should try to pass. This is displayed after a user expands the section to see more. No character length limits. 'Learn More' becomes link text to additional documentation. */
  description: 'When definition lists are not properly marked up, screen readers may produce ' +
      'confusing or inaccurate output. ' +
      '[Learn more](https://web.dev/definition-list/).',
};

const str_ = i18n.createMessageInstanceIdFn(__filename, UIStrings);

class DefinitionList extends AxeAudit {
  /**
   * @return {LH.Audit.Meta}
   */
  static get meta() {
    return {
      id: 'definition-list',
      title: str_(UIStrings.title),
      failureTitle: str_(UIStrings.failureTitle),
      description: str_(UIStrings.description),
      requiredArtifacts: ['Accessibility'],
    };
  }
}

module.exports = DefinitionList;
module.exports.UIStrings = UIStrings;

}).call(this)}).call(this,"/lighthouse-core/audits/accessibility/definition-list.js")
},{"../../lib/i18n/i18n.js":96,"./axe-audit.js":2}],"../audits/accessibility/dlitem":[function(require,module,exports){
(function (__filename){(function (){
/**
 * @license Copyright 2017 The Lighthouse Authors. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.
 */
'use strict';

/**
 * @fileoverview Ensures that all child <dd> and <dt> elements have a <dl> as a parent.
 * See base class in axe-audit.js for audit() implementation.
 */

const AxeAudit = require('./axe-audit.js');
const i18n = require('../../lib/i18n/i18n.js');

const UIStrings = {
  /** Title of an accesibility audit that evaluates if all definition list item elements (`<dt>`/`<dd>`) have a definition list parent element (`<dl>`). This title is descriptive of the successful state and is shown to users when no user action is required. */
  title: 'Definition list items are wrapped in `<dl>` elements',
  /** Title of an accesibility audit that evaluates if all definition list item elements (`<dt>`/`<dd>`) have a definition list parent element (`<dl>`). This title is descriptive of the failing state and is shown to users when there is a failure that needs to be addressed. */
  failureTitle: 'Definition list items are not wrapped in `<dl>` elements',
  /** Description of a Lighthouse audit that tells the user *why* they should try to pass. This is displayed after a user expands the section to see more. No character length limits. 'Learn More' becomes link text to additional documentation. */
  description: 'Definition list items (`<dt>` and `<dd>`) must be wrapped in a ' +
      'parent `<dl>` element to ensure that screen readers can properly announce them. ' +
      '[Learn more](https://web.dev/dlitem/).',
};

const str_ = i18n.createMessageInstanceIdFn(__filename, UIStrings);

class DLItem extends AxeAudit {
  /**
   * @return {LH.Audit.Meta}
   */
  static get meta() {
    return {
      id: 'dlitem',
      title: str_(UIStrings.title),
      failureTitle: str_(UIStrings.failureTitle),
      description: str_(UIStrings.description),
      requiredArtifacts: ['Accessibility'],
    };
  }
}

module.exports = DLItem;
module.exports.UIStrings = UIStrings;

}).call(this)}).call(this,"/lighthouse-core/audits/accessibility/dlitem.js")
},{"../../lib/i18n/i18n.js":96,"./axe-audit.js":2}],"../audits/accessibility/document-title":[function(require,module,exports){
(function (__filename){(function (){
/**
 * @license Copyright 2017 The Lighthouse Authors. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.
 */
'use strict';

/**
 * @fileoverview Ensures that each HTML document contains a `<title>`.
 * See base class in axe-audit.js for audit() implementation.
 */

const AxeAudit = require('./axe-audit.js');
const i18n = require('../../lib/i18n/i18n.js');

const UIStrings = {
  /** Title of an accesibility audit that evaluates if the page has a <title> element that describes the page. This title is descriptive of the successful state and is shown to users when no user action is required. */
  title: 'Document has a `<title>` element',
  /** Title of an accesibility audit that evaluates if the page has a <title> element that describes the page. This title is descriptive of the failing state and is shown to users when there is a failure that needs to be addressed. */
  failureTitle: 'Document doesn\'t have a `<title>` element',
  /** Description of a Lighthouse audit that tells the user *why* they should try to pass. This is displayed after a user expands the section to see more. No character length limits. 'Learn More' becomes link text to additional documentation. */
  description: 'The title gives screen reader users an overview of the page, and search ' +
      'engine users rely on it heavily to determine if a page is relevant to their search. ' +
      '[Learn more](https://web.dev/document-title/).',
};

const str_ = i18n.createMessageInstanceIdFn(__filename, UIStrings);

class DocumentTitle extends AxeAudit {
  /**
   * @return {LH.Audit.Meta}
   */
  static get meta() {
    return {
      id: 'document-title',
      title: str_(UIStrings.title),
      failureTitle: str_(UIStrings.failureTitle),
      description: str_(UIStrings.description),
      requiredArtifacts: ['Accessibility'],
    };
  }
}

module.exports = DocumentTitle;
module.exports.UIStrings = UIStrings;

}).call(this)}).call(this,"/lighthouse-core/audits/accessibility/document-title.js")
},{"../../lib/i18n/i18n.js":96,"./axe-audit.js":2}],"../audits/accessibility/duplicate-id-active":[function(require,module,exports){
(function (__filename){(function (){
/**
 * @license Copyright 2019 The Lighthouse Authors. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.
 */
'use strict';

/**
 * @fileoverview Ensures every `id` attribute value of active, focusable elements is unique.
 * See base class in axe-audit.js for audit() implementation.
 */

const AxeAudit = require('./axe-audit.js');
const i18n = require('../../lib/i18n/i18n.js');

const UIStrings = {
  /** Title of an accesibility audit that checks if there are any duplicate id HTML attributes on active, focusable elements. This title is descriptive of the successful state and is shown to users when no user action is required. */
  title: '`[id]` attributes on active, focusable elements are unique',
  /** Title of an accesibility audit that checks if there are any duplicate id HTML attributes on active, focusable elements. This title is descriptive of the failing state and is shown to users when there is a failure that needs to be addressed. */
  failureTitle: '`[id]` attributes on active, focusable elements are not unique',
  /** Description of a Lighthouse audit that tells the user *why* they should try to pass. This is displayed after a user expands the section to see more. No character length limits. 'Learn More' becomes link text to additional documentation. */
  description: 'All focusable elements must have a unique `id` to ensure that they\'re visible to assistive technologies. [Learn more](https://web.dev/duplicate-id-active/).',
};

const str_ = i18n.createMessageInstanceIdFn(__filename, UIStrings);

class DuplicateIdActive extends AxeAudit {
  /**
   * @return {LH.Audit.Meta}
   */
  static get meta() {
    return {
      id: 'duplicate-id-active',
      title: str_(UIStrings.title),
      failureTitle: str_(UIStrings.failureTitle),
      description: str_(UIStrings.description),
      requiredArtifacts: ['Accessibility'],
    };
  }
}

module.exports = DuplicateIdActive;
module.exports.UIStrings = UIStrings;

}).call(this)}).call(this,"/lighthouse-core/audits/accessibility/duplicate-id-active.js")
},{"../../lib/i18n/i18n.js":96,"./axe-audit.js":2}],"../audits/accessibility/duplicate-id-aria":[function(require,module,exports){
(function (__filename){(function (){
/**
 * @license Copyright 2019 The Lighthouse Authors. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.
 */
'use strict';

/**
 * @fileoverview Ensures every `id` attribute value used in ARIA and in labels is unique.
 * See base class in axe-audit.js for audit() implementation.
 */

const AxeAudit = require('./axe-audit.js');
const i18n = require('../../lib/i18n/i18n.js');

const UIStrings = {
  /** Title of an accesibility audit that checks if there are any duplicate ARIA IDs on the page. This title is descriptive of the successful state and is shown to users when no user action is required. */
  title: 'ARIA IDs are unique',
  /** Title of an accesibility audit that checks if there are any duplicate ARIA IDs on the page. This title is descriptive of the failing state and is shown to users when there is a failure that needs to be addressed. */
  failureTitle: 'ARIA IDs are not unique',
  /** Description of a Lighthouse audit that tells the user *why* they should try to pass. This is displayed after a user expands the section to see more. No character length limits. 'Learn More' becomes link text to additional documentation. */
  description: 'The value of an ARIA ID must be unique to prevent other instances from being overlooked by assistive technologies. [Learn more](https://web.dev/duplicate-id-aria/).',
};

const str_ = i18n.createMessageInstanceIdFn(__filename, UIStrings);

class DuplicateIdAria extends AxeAudit {
  /**
   * @return {LH.Audit.Meta}
   */
  static get meta() {
    return {
      id: 'duplicate-id-aria',
      title: str_(UIStrings.title),
      failureTitle: str_(UIStrings.failureTitle),
      description: str_(UIStrings.description),
      requiredArtifacts: ['Accessibility'],
    };
  }
}

module.exports = DuplicateIdAria;
module.exports.UIStrings = UIStrings;

}).call(this)}).call(this,"/lighthouse-core/audits/accessibility/duplicate-id-aria.js")
},{"../../lib/i18n/i18n.js":96,"./axe-audit.js":2}],"../audits/accessibility/form-field-multiple-labels":[function(require,module,exports){
(function (__filename){(function (){
/**
 * @license Copyright 2019 The Lighthouse Authors. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.
 */
'use strict';

/**
 * @fileoverview Ensures no form field has multiple label elements.
 * See base class in axe-audit.js for audit() implementation.
 */

const AxeAudit = require('./axe-audit.js');
const i18n = require('../../lib/i18n/i18n.js');

const UIStrings = {
  /** Title of an accesibility audit that checks if any form fields have multiple label elements. This title is descriptive of the successful state and is shown to users when no user action is required. */
  title: 'No form fields have multiple labels',
  /** Title of an accesibility audit that checks if any form fields have multiple label elements. This title is descriptive of the failing state and is shown to users when there is a failure that needs to be addressed. */
  failureTitle: 'Form fields have multiple labels',
  /** Description of a Lighthouse audit that tells the user *why* they should try to pass. This is displayed after a user expands the section to see more. No character length limits. 'Learn More' becomes link text to additional documentation. */
  description: 'Form fields with multiple labels can be confusingly announced by assistive technologies like screen readers which use either the first, the last, or all of the labels. [Learn more](https://web.dev/form-field-multiple-labels/).',
};

const str_ = i18n.createMessageInstanceIdFn(__filename, UIStrings);

class FormFieldMultipleLabels extends AxeAudit {
  /**
   * @return {LH.Audit.Meta}
   */
  static get meta() {
    return {
      id: 'form-field-multiple-labels',
      title: str_(UIStrings.title),
      failureTitle: str_(UIStrings.failureTitle),
      description: str_(UIStrings.description),
      scoreDisplayMode: AxeAudit.SCORING_MODES.INFORMATIVE,
      requiredArtifacts: ['Accessibility'],
    };
  }
}

module.exports = FormFieldMultipleLabels;
module.exports.UIStrings = UIStrings;

}).call(this)}).call(this,"/lighthouse-core/audits/accessibility/form-field-multiple-labels.js")
},{"../../lib/i18n/i18n.js":96,"./axe-audit.js":2}],"../audits/accessibility/frame-title":[function(require,module,exports){
(function (__filename){(function (){
/**
 * @license Copyright 2017 The Lighthouse Authors. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.
 */
'use strict';

/**
 * @fileoverview Ensures `<iframe>` and `<frame>` elements contain a non-empty title attribute.
 * See base class in axe-audit.js for audit() implementation.
 */

const AxeAudit = require('./axe-audit.js');
const i18n = require('../../lib/i18n/i18n.js');

const UIStrings = {
  /** Title of an accesibility audit that evaluates if all `<frame>` and `<iframe>` elements on the page have a title HTML attribute to describe their contents. This title is descriptive of the successful state and is shown to users when no user action is required. */
  title: '`<frame>` or `<iframe>` elements have a title',
  /** Title of an accesibility audit that evaluates if all `<frame>` and `<iframe>` elements on the page have a title HTML attribute to describe their contents. This title is descriptive of the failing state and is shown to users when there is a failure that needs to be addressed. */
  failureTitle: '`<frame>` or `<iframe>` elements do not have a title',
  /** Description of a Lighthouse audit that tells the user *why* they should try to pass. This is displayed after a user expands the section to see more. No character length limits. 'Learn More' becomes link text to additional documentation. */
  description: 'Screen reader users rely on frame titles to describe the contents of frames. ' +
      '[Learn more](https://web.dev/frame-title/).',
};

const str_ = i18n.createMessageInstanceIdFn(__filename, UIStrings);

class FrameTitle extends AxeAudit {
  /**
   * @return {LH.Audit.Meta}
   */
  static get meta() {
    return {
      id: 'frame-title',
      title: str_(UIStrings.title),
      failureTitle: str_(UIStrings.failureTitle),
      description: str_(UIStrings.description),
      requiredArtifacts: ['Accessibility'],
    };
  }
}

module.exports = FrameTitle;
module.exports.UIStrings = UIStrings;

}).call(this)}).call(this,"/lighthouse-core/audits/accessibility/frame-title.js")
},{"../../lib/i18n/i18n.js":96,"./axe-audit.js":2}],"../audits/accessibility/heading-order":[function(require,module,exports){
(function (__filename){(function (){
/**
 * @license Copyright 2019 The Lighthouse Authors. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.
 */
'use strict';

/**
 * @fileoverview Ensures heading levels should only ever increase by one.
 * See base class in axe-audit.js for audit() implementation.
 */

const AxeAudit = require('./axe-audit.js');
const i18n = require('../../lib/i18n/i18n.js');

const UIStrings = {
  /** Title of an accesibility audit that checks if heading elements (<h1>, <h2>, etc) appear in numeric order and only ever increase in steps of 1. This title is descriptive of the successful state and is shown to users when no user action is required. */
  title: 'Heading elements appear in a sequentially-descending order',
  /** Title of an accesibility audit that checks if heading elements (<h1>, <h2>, etc) appear in numeric order and only ever increase in steps of 1. This title is descriptive of the failing state and is shown to users when there is a failure that needs to be addressed. */
  failureTitle: 'Heading elements are not in a sequentially-descending order',
  /** Description of a Lighthouse audit that tells the user *why* they should try to pass. This is displayed after a user expands the section to see more. No character length limits. 'Learn More' becomes link text to additional documentation. */
  description: 'Properly ordered headings that do not skip levels convey the semantic structure of the page, making it easier to navigate and understand when using assistive technologies. [Learn more](https://web.dev/heading-order/).',
};

const str_ = i18n.createMessageInstanceIdFn(__filename, UIStrings);

class HeadingOrder extends AxeAudit {
  /**
   * @return {LH.Audit.Meta}
   */
  static get meta() {
    return {
      id: 'heading-order',
      title: str_(UIStrings.title),
      failureTitle: str_(UIStrings.failureTitle),
      description: str_(UIStrings.description),
      requiredArtifacts: ['Accessibility'],
    };
  }
}

module.exports = HeadingOrder;
module.exports.UIStrings = UIStrings;

}).call(this)}).call(this,"/lighthouse-core/audits/accessibility/heading-order.js")
},{"../../lib/i18n/i18n.js":96,"./axe-audit.js":2}],"../audits/accessibility/html-has-lang":[function(require,module,exports){
(function (__filename){(function (){
/**
 * @license Copyright 2017 The Lighthouse Authors. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.
 */
'use strict';

/**
 * @fileoverview Ensures every HTML document has a `lang` attribute.
 * See base class in axe-audit.js for audit() implementation.
 */

const AxeAudit = require('./axe-audit.js');
const i18n = require('../../lib/i18n/i18n.js');

const UIStrings = {
  /** Title of an accesibility audit that evaluates if the root HTML tag has a lang attribute identifying the page's language. This title is descriptive of the successful state and is shown to users when no user action is required. */
  title: '`<html>` element has a `[lang]` attribute',
  /** Title of an accesibility audit that evaluates if the root HTML tag has a lang attribute identifying the page's language. This title is descriptive of the failing state and is shown to users when there is a failure that needs to be addressed. */
  failureTitle: '`<html>` element does not have a `[lang]` attribute',
  /** Description of a Lighthouse audit that tells the user *why* they should try to pass. This is displayed after a user expands the section to see more. No character length limits. 'Learn More' becomes link text to additional documentation. */
  description: 'If a page doesn\'t specify a lang attribute, a screen reader assumes ' +
      'that the page is in the default language that the user chose when setting up the ' +
      'screen reader. If the page isn\'t actually in the default language, then the screen ' +
      'reader might not announce the page\'s text correctly. ' +
      '[Learn more](https://web.dev/html-has-lang/).',
};

const str_ = i18n.createMessageInstanceIdFn(__filename, UIStrings);

class HTMLHasLang extends AxeAudit {
  /**
   * @return {LH.Audit.Meta}
   */
  static get meta() {
    return {
      id: 'html-has-lang',
      title: str_(UIStrings.title),
      failureTitle: str_(UIStrings.failureTitle),
      description: str_(UIStrings.description),
      requiredArtifacts: ['Accessibility'],
    };
  }
}

module.exports = HTMLHasLang;
module.exports.UIStrings = UIStrings;

}).call(this)}).call(this,"/lighthouse-core/audits/accessibility/html-has-lang.js")
},{"../../lib/i18n/i18n.js":96,"./axe-audit.js":2}],"../audits/accessibility/html-lang-valid":[function(require,module,exports){
(function (__filename){(function (){
/**
 * @license Copyright 2017 The Lighthouse Authors. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.
 */
'use strict';

/**
 * @fileoverview Ensures the lang attribute of the <html> element has a valid value.
 * See base class in axe-audit.js for audit() implementation.
 */

const AxeAudit = require('./axe-audit.js');
const i18n = require('../../lib/i18n/i18n.js');

const UIStrings = {
  /** Title of an accesibility audit that evaluates if the value for root HTML tag's lang attribute is a valid BCP 47 language. This title is descriptive of the successful state and is shown to users when no user action is required. */
  title: '`<html>` element has a valid value for its `[lang]` attribute',
  /** Title of an accesibility audit that evaluates if the value for root HTML tag's lang attribute is a valid BCP 47 language. This title is descriptive of the failing state and is shown to users when there is a failure that needs to be addressed. */
  failureTitle: '`<html>` element does not have a valid value for ' +
      'its `[lang]` attribute.',
  /** Description of a Lighthouse audit that tells the user *why* they should try to pass. This is displayed after a user expands the section to see more. No character length limits. 'Learn More' becomes link text to additional documentation. */
  description: 'Specifying a valid [BCP 47 language](https://www.w3.org/International/questions/qa-choosing-language-tags#question) ' +
      'helps screen readers announce text properly. ' +
      '[Learn more](https://web.dev/html-lang-valid/).',
};

const str_ = i18n.createMessageInstanceIdFn(__filename, UIStrings);

class HTMLLangValid extends AxeAudit {
  /**
   * @return {LH.Audit.Meta}
   */
  static get meta() {
    return {
      id: 'html-lang-valid',
      title: str_(UIStrings.title),
      failureTitle: str_(UIStrings.failureTitle),
      description: str_(UIStrings.description),
      requiredArtifacts: ['Accessibility'],
    };
  }
}

module.exports = HTMLLangValid;
module.exports.UIStrings = UIStrings;

}).call(this)}).call(this,"/lighthouse-core/audits/accessibility/html-lang-valid.js")
},{"../../lib/i18n/i18n.js":96,"./axe-audit.js":2}],"../audits/accessibility/image-alt":[function(require,module,exports){
(function (__filename){(function (){
/**
 * @license Copyright 2017 The Lighthouse Authors. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.
 */
'use strict';

/**
 * @fileoverview Ensures <img> elements have alternate text or a role of none or presentation.
 * See base class in axe-audit.js for audit() implementation.
 */

const AxeAudit = require('./axe-audit.js');
const i18n = require('../../lib/i18n/i18n.js');

const UIStrings = {
  /** Title of an accesibility audit that evaluates if all image elements have the alt HTML attribute to describe their contents. This title is descriptive of the successful state and is shown to users when no user action is required. */
  title: 'Image elements have `[alt]` attributes',
  /** Title of an accesibility audit that evaluates if all image elements have the alt HTML attribute to describe their contents. This title is descriptive of the failing state and is shown to users when there is a failure that needs to be addressed. */
  failureTitle: 'Image elements do not have `[alt]` attributes',
  /** Description of a Lighthouse audit that tells the user *why* they should try to pass. This is displayed after a user expands the section to see more. No character length limits. 'Learn More' becomes link text to additional documentation. */
  description: 'Informative elements should aim for short, descriptive alternate text. ' +
      'Decorative elements can be ignored with an empty alt attribute. ' +
      '[Learn more](https://web.dev/image-alt/).',
};

const str_ = i18n.createMessageInstanceIdFn(__filename, UIStrings);

class ImageAlt extends AxeAudit {
  /**
   * @return {LH.Audit.Meta}
   */
  static get meta() {
    return {
      id: 'image-alt',
      title: str_(UIStrings.title),
      failureTitle: str_(UIStrings.failureTitle),
      description: str_(UIStrings.description),
      requiredArtifacts: ['Accessibility'],
    };
  }
}

module.exports = ImageAlt;
module.exports.UIStrings = UIStrings;

}).call(this)}).call(this,"/lighthouse-core/audits/accessibility/image-alt.js")
},{"../../lib/i18n/i18n.js":96,"./axe-audit.js":2}],"../audits/accessibility/input-image-alt":[function(require,module,exports){
(function (__filename){(function (){
/**
 * @license Copyright 2017 The Lighthouse Authors. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.
 */
'use strict';

/**
 * @fileoverview Ensures `<input type="image">` elements have alternate text.
 * See base class in axe-audit.js for audit() implementation.
 */

const AxeAudit = require('./axe-audit.js');
const i18n = require('../../lib/i18n/i18n.js');

const UIStrings = {
  /** Title of an accesibility audit that evaluates if all input elements of type image have an alt HTML attribute to describe their contents. This title is descriptive of the successful state and is shown to users when no user action is required. */
  title: '`<input type="image">` elements have `[alt]` text',
  /** Title of an accesibility audit that evaluates if all input elements of type image have an alt HTML attribute to describe their contents. This title is descriptive of the failing state and is shown to users when there is a failure that needs to be addressed. */
  failureTitle: '`<input type="image">` elements do not have `[alt]` text',
  /** Description of a Lighthouse audit that tells the user *why* they should try to pass. This is displayed after a user expands the section to see more. No character length limits. 'Learn More' becomes link text to additional documentation. */
  description: 'When an image is being used as an `<input>` button, providing alternative ' +
      'text can help screen reader users understand the purpose of the button. ' +
      '[Learn more](https://web.dev/input-image-alt/).',
};

const str_ = i18n.createMessageInstanceIdFn(__filename, UIStrings);

class InputImageAlt extends AxeAudit {
  /**
   * @return {LH.Audit.Meta}
   */
  static get meta() {
    return {
      id: 'input-image-alt',
      title: str_(UIStrings.title),
      failureTitle: str_(UIStrings.failureTitle),
      description: str_(UIStrings.description),
      requiredArtifacts: ['Accessibility'],
    };
  }
}

module.exports = InputImageAlt;
module.exports.UIStrings = UIStrings;

}).call(this)}).call(this,"/lighthouse-core/audits/accessibility/input-image-alt.js")
},{"../../lib/i18n/i18n.js":96,"./axe-audit.js":2}],"../audits/accessibility/label":[function(require,module,exports){
(function (__filename){(function (){
/**
 * @license Copyright 2017 The Lighthouse Authors. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.
 */
'use strict';

/**
 * @fileoverview Ensures every form element has a label.
 * See base class in axe-audit.js for audit() implementation.
 */

const AxeAudit = require('./axe-audit.js');
const i18n = require('../../lib/i18n/i18n.js');

const UIStrings = {
  /** Title of an accesibility audit that evaluates if all form elements have corresponding label elements. This title is descriptive of the successful state and is shown to users when no user action is required. */
  title: 'Form elements have associated labels',
  /** Title of an accesibility audit that evaluates if all form elements have corresponding label elements. This title is descriptive of the failing state and is shown to users when there is a failure that needs to be addressed. */
  failureTitle: 'Form elements do not have associated labels',
  /** Description of a Lighthouse audit that tells the user *why* they should try to pass. This is displayed after a user expands the section to see more. No character length limits. 'Learn More' becomes link text to additional documentation. */
  description: 'Labels ensure that form controls are announced properly by assistive ' +
      'technologies, like screen readers. [Learn ' +
      'more](https://web.dev/label/).',
};

const str_ = i18n.createMessageInstanceIdFn(__filename, UIStrings);

class Label extends AxeAudit {
  /**
   * @return {LH.Audit.Meta}
   */
  static get meta() {
    return {
      id: 'label',
      title: str_(UIStrings.title),
      failureTitle: str_(UIStrings.failureTitle),
      description: str_(UIStrings.description),
      requiredArtifacts: ['Accessibility'],
    };
  }
}

module.exports = Label;
module.exports.UIStrings = UIStrings;

}).call(this)}).call(this,"/lighthouse-core/audits/accessibility/label.js")
},{"../../lib/i18n/i18n.js":96,"./axe-audit.js":2}],"../audits/accessibility/link-name":[function(require,module,exports){
(function (__filename){(function (){
/**
 * @license Copyright 2017 The Lighthouse Authors. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.
 */
'use strict';

/**
 * @fileoverview Ensures links have discernible text.
 * See base class in axe-audit.js for audit() implementation.
 */

const AxeAudit = require('./axe-audit.js');
const i18n = require('../../lib/i18n/i18n.js');

const UIStrings = {
  /** Title of an accesibility audit that evaluates if all link elements have a non-generic name to screen readers. This title is descriptive of the successful state and is shown to users when no user action is required. */
  title: 'Links have a discernible name',
  /** Title of an accesibility audit that evaluates if all link elements have a non-generic name to screen readers. This title is descriptive of the failing state and is shown to users when there is a failure that needs to be addressed. */
  failureTitle: 'Links do not have a discernible name',
  /** Description of a Lighthouse audit that tells the user *why* they should try to pass. This is displayed after a user expands the section to see more. No character length limits. 'Learn More' becomes link text to additional documentation. */
  description: 'Link text (and alternate text for images, when used as links) that is ' +
      'discernible, unique, and focusable improves the navigation experience for ' +
      'screen reader users. ' +
      '[Learn more](https://web.dev/link-name/).',
};

const str_ = i18n.createMessageInstanceIdFn(__filename, UIStrings);

class LinkName extends AxeAudit {
  /**
   * @return {LH.Audit.Meta}
   */
  static get meta() {
    return {
      id: 'link-name',
      title: str_(UIStrings.title),
      failureTitle: str_(UIStrings.failureTitle),
      description: str_(UIStrings.description),
      requiredArtifacts: ['Accessibility'],
    };
  }
}

module.exports = LinkName;
module.exports.UIStrings = UIStrings;

}).call(this)}).call(this,"/lighthouse-core/audits/accessibility/link-name.js")
},{"../../lib/i18n/i18n.js":96,"./axe-audit.js":2}],"../audits/accessibility/listitem":[function(require,module,exports){
(function (__filename){(function (){
/**
 * @license Copyright 2017 The Lighthouse Authors. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.
 */
'use strict';

/**
 * @fileoverview Ensures every list item is contained within a parent list
 * See base class in axe-audit.js for audit() implementation.
 */

const AxeAudit = require('./axe-audit.js');
const i18n = require('../../lib/i18n/i18n.js');

const UIStrings = {
  /** Title of an accesibility audit that evaluates if any list item elements do not have list parent elements. This title is descriptive of the successful state and is shown to users when no user action is required. */
  title: 'List items (`<li>`) are contained within `<ul>` or `<ol>` parent elements',
  /** Title of an accesibility audit that evaluates if any list item elements do not have list parent elements. This title is descriptive of the failing state and is shown to users when there is a failure that needs to be addressed. */
  failureTitle: 'List items (`<li>`) are not contained within `<ul>` ' +
      'or `<ol>` parent elements.',
  /** Description of a Lighthouse audit that tells the user *why* they should try to pass. This is displayed after a user expands the section to see more. No character length limits. 'Learn More' becomes link text to additional documentation. */
  description: 'Screen readers require list items (`<li>`) to be contained within a ' +
      'parent `<ul>` or `<ol>` to be announced properly. ' +
      '[Learn more](https://web.dev/listitem/).',
};

const str_ = i18n.createMessageInstanceIdFn(__filename, UIStrings);

class ListItem extends AxeAudit {
  /**
   * @return {LH.Audit.Meta}
   */
  static get meta() {
    return {
      id: 'listitem',
      title: str_(UIStrings.title),
      failureTitle: str_(UIStrings.failureTitle),
      description: str_(UIStrings.description),
      requiredArtifacts: ['Accessibility'],
    };
  }
}

module.exports = ListItem;
module.exports.UIStrings = UIStrings;

}).call(this)}).call(this,"/lighthouse-core/audits/accessibility/listitem.js")
},{"../../lib/i18n/i18n.js":96,"./axe-audit.js":2}],"../audits/accessibility/list":[function(require,module,exports){
(function (__filename){(function (){
/**
 * @license Copyright 2017 The Lighthouse Authors. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.
 */
'use strict';

/**
 * @fileoverview Ensures that lists are structured correctly.
 * See base class in axe-audit.js for audit() implementation.
 */

const AxeAudit = require('./axe-audit.js');
const i18n = require('../../lib/i18n/i18n.js');

const UIStrings = {
  /** Title of an accesibility audit that evaluates if all list elements have a valid structure containing only list items. This title is descriptive of the successful state and is shown to users when no user action is required. */
  title: 'Lists contain only `<li>` elements and script supporting elements ' +
      '(`<script>` and `<template>`).',
  /** Title of an accesibility audit that evaluates if all list elements have a valid structure containing only list items. This title is descriptive of the failing state and is shown to users when there is a failure that needs to be addressed. */
  failureTitle: 'Lists do not contain only `<li>` elements and script ' +
      'supporting elements (`<script>` and `<template>`).',
  /** Description of a Lighthouse audit that tells the user *why* they should try to pass. This is displayed after a user expands the section to see more. No character length limits. 'Learn More' becomes link text to additional documentation. */
  description: 'Screen readers have a specific way of announcing lists. Ensuring proper list ' +
      'structure aids screen reader output. ' +
      '[Learn more](https://web.dev/list/).',
};

const str_ = i18n.createMessageInstanceIdFn(__filename, UIStrings);

class List extends AxeAudit {
  /**
   * @return {LH.Audit.Meta}
   */
  static get meta() {
    return {
      id: 'list',
      title: str_(UIStrings.title),
      failureTitle: str_(UIStrings.failureTitle),
      description: str_(UIStrings.description),
      requiredArtifacts: ['Accessibility'],
    };
  }
}

module.exports = List;
module.exports.UIStrings = UIStrings;

}).call(this)}).call(this,"/lighthouse-core/audits/accessibility/list.js")
},{"../../lib/i18n/i18n.js":96,"./axe-audit.js":2}],"../audits/accessibility/manual/custom-controls-labels":[function(require,module,exports){

/**
 * @license Copyright 2017 The Lighthouse Authors. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.
 */
'use strict';

const ManualAudit = require('../../manual/manual-audit.js');

/**
 * @fileoverview Manual A11y audit to assert custom controls have associated labels.
 */

class CustomControlsLabels extends ManualAudit {
  /**
   * @return {LH.Audit.Meta}
   */
  static get meta() {
    return Object.assign({
      id: 'custom-controls-labels',
      description: 'Custom interactive controls have associated labels, provided by aria-label or aria-labelledby. [Learn more](https://web.dev/custom-controls-labels/).',
      title: 'Custom controls have associated labels',
    }, super.partialMeta);
  }
}

module.exports = CustomControlsLabels;

},{"../../manual/manual-audit.js":6}],"../audits/accessibility/manual/custom-controls-roles":[function(require,module,exports){

/**
 * @license Copyright 2017 The Lighthouse Authors. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.
 */
'use strict';

const ManualAudit = require('../../manual/manual-audit.js');

/**
 * @fileoverview Manual A11y audit to assert custom controls have associated roles.
 */

class CustomControlsRoles extends ManualAudit {
  /**
   * @return {LH.Audit.Meta}
   */
  static get meta() {
    return Object.assign({
      id: 'custom-controls-roles',
      description: 'Custom interactive controls have appropriate ARIA roles. [Learn more](https://web.dev/custom-control-roles/).',
      title: 'Custom controls have ARIA roles',
    }, super.partialMeta);
  }
}

module.exports = CustomControlsRoles;

},{"../../manual/manual-audit.js":6}],"../audits/accessibility/manual/focus-traps":[function(require,module,exports){

/**
 * @license Copyright 2017 The Lighthouse Authors. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.
 */
'use strict';

const ManualAudit = require('../../manual/manual-audit.js');

/**
 * @fileoverview Manual A11y audit to avoid trapping keyboard focus in a region.
 */

class FocusTraps extends ManualAudit {
  /**
   * @return {LH.Audit.Meta}
   */
  static get meta() {
    return Object.assign({
      id: 'focus-traps',
      description: 'A user can tab into and out of any control or region without accidentally trapping their focus. [Learn more](https://web.dev/focus-traps/).',
      title: 'User focus is not accidentally trapped in a region',
    }, super.partialMeta);
  }
}

module.exports = FocusTraps;

},{"../../manual/manual-audit.js":6}],"../audits/accessibility/manual/focusable-controls":[function(require,module,exports){

/**
 * @license Copyright 2017 The Lighthouse Authors. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.
 */
'use strict';

const ManualAudit = require('../../manual/manual-audit.js');

/**
 * @fileoverview Manual A11y audit for focusable controls.
 */

class FocusableControls extends ManualAudit {
  /**
   * @return {LH.Audit.Meta}
   */
  static get meta() {
    return Object.assign({
      id: 'focusable-controls',
      description: 'Custom interactive controls are keyboard focusable and display a focus indicator. [Learn more](https://web.dev/focusable-controls/).',
      title: 'Interactive controls are keyboard focusable',
    }, super.partialMeta);
  }
}

module.exports = FocusableControls;

},{"../../manual/manual-audit.js":6}],"../audits/accessibility/manual/interactive-element-affordance":[function(require,module,exports){

/**
 * @license Copyright 2018 The Lighthouse Authors. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.
 */
'use strict';

const ManualAudit = require('../../manual/manual-audit.js');

/**
 * @fileoverview Manual A11y audit for interactive element affordance.
 */

class InteractiveElementAffordance extends ManualAudit {
  /**
   * @return {LH.Audit.Meta}
   */
  static get meta() {
    return Object.assign({
      id: 'interactive-element-affordance',
      description: 'Interactive elements, such as links and buttons, should indicate their state and be distinguishable from non-interactive elements. [Learn more](https://web.dev/interactive-element-affordance/).',
      title: 'Interactive elements indicate their purpose and state',
    }, super.partialMeta);
  }
}

module.exports = InteractiveElementAffordance;

},{"../../manual/manual-audit.js":6}],"../audits/accessibility/manual/logical-tab-order":[function(require,module,exports){

/**
 * @license Copyright 2017 The Lighthouse Authors. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.
 */
'use strict';

const ManualAudit = require('../../manual/manual-audit.js');

/**
 * @fileoverview Manual A11y audit for tab order that follows DOM order.
 */

class LogicalTabOrder extends ManualAudit {
  /**
   * @return {LH.Audit.Meta}
   */
  static get meta() {
    return Object.assign({
      id: 'logical-tab-order',
      description: 'Tabbing through the page follows the visual layout. Users cannot focus elements that are offscreen. [Learn more](https://web.dev/logical-tab-order/).',
      title: 'The page has a logical tab order',
    }, super.partialMeta);
  }
}

module.exports = LogicalTabOrder;

},{"../../manual/manual-audit.js":6}],"../audits/accessibility/manual/managed-focus":[function(require,module,exports){

/**
 * @license Copyright 2017 The Lighthouse Authors. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.
 */
'use strict';

const ManualAudit = require('../../manual/manual-audit.js');

/**
 * @fileoverview Manual A11y audit for focusing new content that's added to the page.
 */

class ManagedFocus extends ManualAudit {
  /**
   * @return {LH.Audit.Meta}
   */
  static get meta() {
    return Object.assign({
      id: 'managed-focus',
      description: 'If new content, such as a dialog, is added to the page, the user\'s focus is directed to it. [Learn more](https://web.dev/managed-focus/).',
      title: 'The user\'s focus is directed to new content added to the page',
    }, super.partialMeta);
  }
}

module.exports = ManagedFocus;

},{"../../manual/manual-audit.js":6}],"../audits/accessibility/manual/offscreen-content-hidden":[function(require,module,exports){

/**
 * @license Copyright 2017 The Lighthouse Authors. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.
 */
'use strict';

const ManualAudit = require('../../manual/manual-audit.js');

/**
 * @fileoverview Manual A11y audit to check that offscreen content is hidden from
 * assistive technology.
 */

class OffscreenContentHidden extends ManualAudit {
  /**
   * @return {LH.Audit.Meta}
   */
  static get meta() {
    return Object.assign({
      id: 'offscreen-content-hidden',
      description: 'Offscreen content is hidden with display: none or aria-hidden=true. [Learn more](https://web.dev/offscreen-content-hidden/).',
      title: 'Offscreen content is hidden from assistive technology',
    }, super.partialMeta);
  }
}

module.exports = OffscreenContentHidden;

},{"../../manual/manual-audit.js":6}],"../audits/accessibility/manual/use-landmarks":[function(require,module,exports){

/**
 * @license Copyright 2017 The Lighthouse Authors. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.
 */
'use strict';

const ManualAudit = require('../../manual/manual-audit.js');

/**
 * @fileoverview Manual A11y audit to check that landmark elements are used whenever possible.
 */

class UseLandmarks extends ManualAudit {
  /**
   * @return {LH.Audit.Meta}
   */
  static get meta() {
    return Object.assign({
      id: 'use-landmarks',
      description: 'Landmark elements (<main>, <nav>, etc.) are used to improve the keyboard navigation of the page for assistive technology. [Learn more](https://web.dev/use-landmarks/).',
      title: 'HTML5 landmark elements are used to improve navigation',
    }, super.partialMeta);
  }
}

module.exports = UseLandmarks;

},{"../../manual/manual-audit.js":6}],"../audits/accessibility/manual/visual-order-follows-dom":[function(require,module,exports){

/**
 * @license Copyright 2017 The Lighthouse Authors. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.
 */
'use strict';

const ManualAudit = require('../../manual/manual-audit.js');

/**
 * @fileoverview Manual A11y audit to check that the visual layout of the page matches the DOM.
 */

class VisualOrderFollowsDOM extends ManualAudit {
  /**
   * @return {LH.Audit.Meta}
   */
  static get meta() {
    return Object.assign({
      id: 'visual-order-follows-dom',
      description: 'DOM order matches the visual order, improving navigation for assistive technology. [Learn more](https://web.dev/visual-order-follows-dom/).',
      title: 'Visual order on the page follows DOM order',
    }, super.partialMeta);
  }
}

module.exports = VisualOrderFollowsDOM;

},{"../../manual/manual-audit.js":6}],"../audits/accessibility/meta-refresh":[function(require,module,exports){
(function (__filename){(function (){
/**
 * @license Copyright 2017 The Lighthouse Authors. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.
 */
'use strict';

/**
 * @fileoverview Ensures `<meta http-equiv="refresh">` is not used.
 * See base class in axe-audit.js for audit() implementation.
 */

const AxeAudit = require('./axe-audit.js');
const i18n = require('../../lib/i18n/i18n.js');

const UIStrings = {
  /** Title of an accesibility audit that evaluates if the page uses a meta tag that refreshes the page automatically. This title is descriptive of the successful state and is shown to users when no user action is required. */
  title: 'The document does not use `<meta http-equiv="refresh">`',
  /** Title of an accesibility audit that evaluates if the page uses a meta tag that refreshes the page automatically. This title is descriptive of the failing state and is shown to users when there is a failure that needs to be addressed. */
  failureTitle: 'The document uses `<meta http-equiv="refresh">`',
  /** Description of a Lighthouse audit that tells the user *why* they should try to pass. This is displayed after a user expands the section to see more. No character length limits. 'Learn More' becomes link text to additional documentation. */
  description: 'Users do not expect a page to refresh automatically, and doing so will move ' +
      'focus back to the top of the page. This may create a frustrating or ' +
      'confusing experience. ' +
      '[Learn more](https://web.dev/meta-refresh/).',
};

const str_ = i18n.createMessageInstanceIdFn(__filename, UIStrings);

class MetaRefresh extends AxeAudit {
  /**
   * @return {LH.Audit.Meta}
   */
  static get meta() {
    return {
      id: 'meta-refresh',
      title: str_(UIStrings.title),
      failureTitle: str_(UIStrings.failureTitle),
      description: str_(UIStrings.description),
      requiredArtifacts: ['Accessibility'],
    };
  }
}

module.exports = MetaRefresh;
module.exports.UIStrings = UIStrings;

}).call(this)}).call(this,"/lighthouse-core/audits/accessibility/meta-refresh.js")
},{"../../lib/i18n/i18n.js":96,"./axe-audit.js":2}],"../audits/accessibility/meta-viewport":[function(require,module,exports){
(function (__filename){(function (){
/**
 * @license Copyright 2017 The Lighthouse Authors. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.
 */
'use strict';

/**
 * @fileoverview Ensures `<meta name="viewport">` does not disable text scaling and zooming.
 * See base class in axe-audit.js for audit() implementation.
 */

const AxeAudit = require('./axe-audit.js');
const i18n = require('../../lib/i18n/i18n.js');

const UIStrings = {
  /** Title of an accesibility audit that evaluates if the page has limited the scaling properties of the page in a way that harms users with low vision. This title is descriptive of the successful state and is shown to users when no user action is required. */
  title: '`[user-scalable="no"]` is not used in the `<meta name="viewport">` ' +
      'element and the `[maximum-scale]` attribute is not less than 5.',
  /** Title of an accesibility audit that evaluates if the page has limited the scaling properties of the page in a way that harms users with low vision. This title is descriptive of the failing state and is shown to users when there is a failure that needs to be addressed. */
  failureTitle: '`[user-scalable="no"]` is used in the `<meta name="viewport">` ' +
      'element or the `[maximum-scale]` attribute is less than 5.',
  /** Description of a Lighthouse audit that tells the user *why* they should try to pass. This is displayed after a user expands the section to see more. No character length limits. 'Learn More' becomes link text to additional documentation. */
  description: 'Disabling zooming is problematic for users with low vision who rely on ' +
      'screen magnification to properly see the contents of a web page. ' +
      '[Learn more](https://web.dev/meta-viewport/).',
};

const str_ = i18n.createMessageInstanceIdFn(__filename, UIStrings);

class MetaViewport extends AxeAudit {
  /**
   * @return {LH.Audit.Meta}
   */
  static get meta() {
    return {
      id: 'meta-viewport',
      title: str_(UIStrings.title),
      failureTitle: str_(UIStrings.failureTitle),
      description: str_(UIStrings.description),
      requiredArtifacts: ['Accessibility'],
    };
  }
}

module.exports = MetaViewport;
module.exports.UIStrings = UIStrings;

}).call(this)}).call(this,"/lighthouse-core/audits/accessibility/meta-viewport.js")
},{"../../lib/i18n/i18n.js":96,"./axe-audit.js":2}],"../audits/accessibility/object-alt":[function(require,module,exports){
(function (__filename){(function (){
/**
 * @license Copyright 2017 The Lighthouse Authors. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.
 */
'use strict';

/**
 * @fileoverview Ensures <object> elements have alternate text.
 * See base class in axe-audit.js for audit() implementation.
 */

const AxeAudit = require('./axe-audit.js');
const i18n = require('../../lib/i18n/i18n.js');

const UIStrings = {
  /** Title of an accesibility audit that evaluates if all object elements have an alt HTML attribute that describes their contents. This title is descriptive of the successful state and is shown to users when no user action is required. */
  title: '`<object>` elements have `[alt]` text',
  /** Title of an accesibility audit that evaluates if all object elements have an alt HTML attribute that describes their contents. This title is descriptive of the failing state and is shown to users when there is a failure that needs to be addressed. */
  failureTitle: '`<object>` elements do not have `[alt]` text',
  /** Description of a Lighthouse audit that tells the user *why* they should try to pass. This is displayed after a user expands the section to see more. No character length limits. 'Learn More' becomes link text to additional documentation. */
  description: 'Screen readers cannot translate non-text content. Adding alt text to ' +
      '`<object>` elements helps screen readers convey meaning to users. ' +
      '[Learn more](https://web.dev/object-alt/).',
};

const str_ = i18n.createMessageInstanceIdFn(__filename, UIStrings);

class ObjectAlt extends AxeAudit {
  /**
   * @return {LH.Audit.Meta}
   */
  static get meta() {
    return {
      id: 'object-alt',
      title: str_(UIStrings.title),
      failureTitle: str_(UIStrings.failureTitle),
      description: str_(UIStrings.description),
      requiredArtifacts: ['Accessibility'],
    };
  }
}

module.exports = ObjectAlt;
module.exports.UIStrings = UIStrings;

}).call(this)}).call(this,"/lighthouse-core/audits/accessibility/object-alt.js")
},{"../../lib/i18n/i18n.js":96,"./axe-audit.js":2}],"../audits/accessibility/tabindex":[function(require,module,exports){
(function (__filename){(function (){
/**
 * @license Copyright 2017 The Lighthouse Authors. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.
 */
'use strict';

/**
 * @fileoverview Ensures tabindex attribute values are not greater than 0.
 * See base class in axe-audit.js for audit() implementation.
 */

const AxeAudit = require('./axe-audit.js');
const i18n = require('../../lib/i18n/i18n.js');

const UIStrings = {
  /** Title of an accesibility audit that evaluates if any elements have custom tabindex HTML attributes that might frustrate users of assitive technology. This title is descriptive of the successful state and is shown to users when no user action is required. */
  title: 'No element has a `[tabindex]` value greater than 0',
  /** Title of an accesibility audit that evaluates if any elements have custom tabindex HTML attributes that might frustrate users of assitive technology. This title is descriptive of the failing state and is shown to users when there is a failure that needs to be addressed. */
  failureTitle: 'Some elements have a `[tabindex]` value greater than 0',
  /** Description of a Lighthouse audit that tells the user *why* they should try to pass. This is displayed after a user expands the section to see more. No character length limits. 'Learn More' becomes link text to additional documentation. */
  description: 'A value greater than 0 implies an explicit navigation ordering. ' +
      'Although technically valid, this often creates frustrating experiences ' +
      'for users who rely on assistive technologies. [Learn more](https://web.dev/tabindex/).',
};

const str_ = i18n.createMessageInstanceIdFn(__filename, UIStrings);

class TabIndex extends AxeAudit {
  /**
   * @return {LH.Audit.Meta}
   */
  static get meta() {
    return {
      id: 'tabindex',
      title: str_(UIStrings.title),
      failureTitle: str_(UIStrings.failureTitle),
      description: str_(UIStrings.description),
      requiredArtifacts: ['Accessibility'],
    };
  }
}

module.exports = TabIndex;
module.exports.UIStrings = UIStrings;

}).call(this)}).call(this,"/lighthouse-core/audits/accessibility/tabindex.js")
},{"../../lib/i18n/i18n.js":96,"./axe-audit.js":2}],"../audits/accessibility/td-headers-attr":[function(require,module,exports){
(function (__filename){(function (){
/**
 * @license Copyright 2017 The Lighthouse Authors. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.
 */
'use strict';

/**
 * @fileoverview Ensure that each cell in a table using the headers refers to another cell in
 * that table
 * See base class in axe-audit.js for audit() implementation.
 */

const AxeAudit = require('./axe-audit.js');
const i18n = require('../../lib/i18n/i18n.js');

const UIStrings = {
  /** Title of an accesibility audit that evaluates if all table cell elements in a table that use the headers HTML attribute use it correctly to refer to header cells within the same table. This title is descriptive of the successful state and is shown to users when no user action is required. */
  title: 'Cells in a `<table>` element that use the `[headers]` attribute refer ' +
      'to table cells within the same table.',
  /** Title of an accesibility audit that evaluates if all table cell elements in a table that use the headers HTML attribute use it correctly to refer to header cells within the same table. This title is descriptive of the failing state and is shown to users when there is a failure that needs to be addressed. */
  failureTitle: 'Cells in a `<table>` element that use the `[headers]` attribute refer ' +
      'to an element `id` not found within the same table.',
  /** Description of a Lighthouse audit that tells the user *why* they should try to pass. This is displayed after a user expands the section to see more. No character length limits. 'Learn More' becomes link text to additional documentation. */
  description: 'Screen readers have features to make navigating tables easier. Ensuring ' +
      '`<td>` cells using the `[headers]` attribute only refer to other cells in the same ' +
      'table may improve the experience for screen reader users. ' +
      '[Learn more](https://web.dev/td-headers-attr/).',
};

const str_ = i18n.createMessageInstanceIdFn(__filename, UIStrings);

class TDHeadersAttr extends AxeAudit {
  /**
   * @return {LH.Audit.Meta}
   */
  static get meta() {
    return {
      id: 'td-headers-attr',
      title: str_(UIStrings.title),
      failureTitle: str_(UIStrings.failureTitle),
      description: str_(UIStrings.description),
      requiredArtifacts: ['Accessibility'],
    };
  }
}

module.exports = TDHeadersAttr;
module.exports.UIStrings = UIStrings;

}).call(this)}).call(this,"/lighthouse-core/audits/accessibility/td-headers-attr.js")
},{"../../lib/i18n/i18n.js":96,"./axe-audit.js":2}],"../audits/accessibility/th-has-data-cells":[function(require,module,exports){
(function (__filename){(function (){
/**
 * @license Copyright 2017 The Lighthouse Authors. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.
 */
'use strict';

/**
 * @fileoverview Ensure that each table header in a data table refers to data cells.
 * See base class in axe-audit.js for audit() implementation.
 */

const AxeAudit = require('./axe-audit.js');
const i18n = require('../../lib/i18n/i18n.js');

const UIStrings = {
  /** Title of an accesibility audit that evaluates if all table header elements have children. This title is descriptive of the successful state and is shown to users when no user action is required. */
  title: '`<th>` elements and elements with `[role="columnheader"/"rowheader"]` have ' +
      'data cells they describe.',
  /** Title of an accesibility audit that evaluates if all table header elements have children. This title is descriptive of the failing state and is shown to users when there is a failure that needs to be addressed. */
  failureTitle: '`<th>` elements and elements with ' +
      '`[role="columnheader"/"rowheader"]` do not have data cells they describe.',
  /** Description of a Lighthouse audit that tells the user *why* they should try to pass. This is displayed after a user expands the section to see more. No character length limits. 'Learn More' becomes link text to additional documentation. */
  description: 'Screen readers have features to make navigating tables easier. Ensuring ' +
      'table headers always refer to some set of cells may improve the experience for screen ' +
      'reader users. ' +
      '[Learn more](https://web.dev/th-has-data-cells/).',
};

const str_ = i18n.createMessageInstanceIdFn(__filename, UIStrings);

class THHasDataCells extends AxeAudit {
  /**
   * @return {LH.Audit.Meta}
   */
  static get meta() {
    return {
      id: 'th-has-data-cells',
      title: str_(UIStrings.title),
      failureTitle: str_(UIStrings.failureTitle),
      description: str_(UIStrings.description),
      requiredArtifacts: ['Accessibility'],
    };
  }
}

module.exports = THHasDataCells;
module.exports.UIStrings = UIStrings;

}).call(this)}).call(this,"/lighthouse-core/audits/accessibility/th-has-data-cells.js")
},{"../../lib/i18n/i18n.js":96,"./axe-audit.js":2}],"../audits/accessibility/valid-lang":[function(require,module,exports){
(function (__filename){(function (){
/**
 * @license Copyright 2017 The Lighthouse Authors. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.
 */
'use strict';

/**
 * @fileoverview Ensures lang attributes have valid values.
 * See base class in axe-audit.js for audit() implementation.
 */

const AxeAudit = require('./axe-audit.js');
const i18n = require('../../lib/i18n/i18n.js');

const UIStrings = {
  /** Title of an accesibility audit that evaluates if all lang HTML attributes are valid BCP 47 languages. This title is descriptive of the successful state and is shown to users when no user action is required. */
  title: '`[lang]` attributes have a valid value',
  /** Title of an accesibility audit that evaluates if all lang HTML attributes are valid BCP 47 languages. This title is descriptive of the failing state and is shown to users when there is a failure that needs to be addressed. */
  failureTitle: '`[lang]` attributes do not have a valid value',
  /** Description of a Lighthouse audit that tells the user *why* they should try to pass. This is displayed after a user expands the section to see more. No character length limits. 'Learn More' becomes link text to additional documentation. */
  description: 'Specifying a valid [BCP 47 language](https://www.w3.org/International/questions/qa-choosing-language-tags#question) ' +
      'on elements helps ensure that text is pronounced correctly by a screen reader. ' +
      '[Learn more](https://web.dev/valid-lang/).',
};

const str_ = i18n.createMessageInstanceIdFn(__filename, UIStrings);

class ValidLang extends AxeAudit {
  /**
   * @return {LH.Audit.Meta}
   */
  static get meta() {
    return {
      id: 'valid-lang',
      title: str_(UIStrings.title),
      failureTitle: str_(UIStrings.failureTitle),
      description: str_(UIStrings.description),
      requiredArtifacts: ['Accessibility'],
    };
  }
}

module.exports = ValidLang;
module.exports.UIStrings = UIStrings;

}).call(this)}).call(this,"/lighthouse-core/audits/accessibility/valid-lang.js")
},{"../../lib/i18n/i18n.js":96,"./axe-audit.js":2}],"../audits/accessibility/video-caption":[function(require,module,exports){
(function (__filename){(function (){
/**
 * @license Copyright 2017 The Lighthouse Authors. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.
 */
'use strict';

/**
 * @fileoverview Ensures `<video>` elements have closed captions.
 * See base class in axe-audit.js for audit() implementation.
 */

const AxeAudit = require('./axe-audit.js');
const i18n = require('../../lib/i18n/i18n.js');

const UIStrings = {
  /** Title of an accesibility audit that evaluates if all video elements contain a child track element that has captions describing their audio. This title is descriptive of the successful state and is shown to users when no user action is required. */
  title: '`<video>` elements contain a `<track>` element with `[kind="captions"]`',
  /** Title of an accesibility audit that evaluates if all video elements contain a child track element that has captions describing their audio. This title is descriptive of the failing state and is shown to users when there is a failure that needs to be addressed. */
  failureTitle: '`<video>` elements do not contain a `<track>` element ' +
      'with `[kind="captions"]`.',
  /** Description of a Lighthouse audit that tells the user *why* they should try to pass. This is displayed after a user expands the section to see more. No character length limits. 'Learn More' becomes link text to additional documentation. */
  description: 'When a video provides a caption it is easier for deaf and hearing impaired ' +
      'users to access its information. ' +
      '[Learn more](https://web.dev/video-caption/).',
};

const str_ = i18n.createMessageInstanceIdFn(__filename, UIStrings);

class VideoCaption extends AxeAudit {
  /**
   * @return {LH.Audit.Meta}
   */
  static get meta() {
    return {
      id: 'video-caption',
      title: str_(UIStrings.title),
      failureTitle: str_(UIStrings.failureTitle),
      description: str_(UIStrings.description),
      requiredArtifacts: ['Accessibility'],
    };
  }
}

module.exports = VideoCaption;
module.exports.UIStrings = UIStrings;

}).call(this)}).call(this,"/lighthouse-core/audits/accessibility/video-caption.js")
},{"../../lib/i18n/i18n.js":96,"./axe-audit.js":2}],"../audits/apple-touch-icon":[function(require,module,exports){
(function (__filename){(function (){
/**
 * @license Copyright 2019 The Lighthouse Authors. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.
 */
'use strict';

const Audit = require('./audit.js');
const i18n = require('../lib/i18n/i18n.js');

/**
 * @fileoverview Audits if a page has an `apple-touch-icon` link element with a valid href.
 */

const UIStrings = {
  /** Title of a Lighthouse audit that tells the user that their site contains a vaild touch icon. This descriptive title is shown when the page contains a valid iOS touch icon. "apple-touch-icon" is an HTML attribute value and should not be translated. */
  title: 'Provides a valid `apple-touch-icon`',
  /** Title of a Lighthouse audit that tells the user that their site contains a vaild touch icon. This descriptive title is shown when the page does not contain a valid iOS touch icon. "apple-touch-icon" is an HTML attribute value and should not be translated. */
  failureTitle: 'Does not provide a valid `apple-touch-icon`',
  /** Description of a Lighthouse audit that tells the user that having an apple-touch-icon allows websites to include an app icon to their installed progressive web apps, similar to a native app. This is displayed after a user expands the section to see more. No character length limits. 'Learn More' becomes link text to additional documentation. "apple-touch-icon" is an HTML attribute value and should not be translated. */
  description: 'For ideal appearance on iOS when users add a progressive web app to the home ' +
    'screen, define an `apple-touch-icon`. It must point to a non-transparent 192px (or 180px) ' +
    'square PNG. [Learn More](https://web.dev/apple-touch-icon/).',
  /** Warning that HTML attribute `apple-touch-icon-precomposed` should not be used in favor of `apple-touch-icon`.  "apple-touch-icon-precomposed" and "apple-touch-icon" are HTML attribute values and should not be translated. */
  precomposedWarning: '`apple-touch-icon-precomposed` is out of date; ' +
    '`apple-touch-icon` is preferred.',
};

const str_ = i18n.createMessageInstanceIdFn(__filename, UIStrings);

class AppleTouchIcon extends Audit {
  /**
   * @return {LH.Audit.Meta}
   */
  static get meta() {
    return {
      id: 'apple-touch-icon',
      title: str_(UIStrings.title),
      failureTitle: str_(UIStrings.failureTitle),
      description: str_(UIStrings.description),
      supportedModes: ['navigation'],
      requiredArtifacts: ['LinkElements'],
    };
  }

  /**
   * @param {LH.Artifacts} artifacts
   * @return {LH.Audit.Product}
   */
  static audit(artifacts) {
    const appleTouchIcons = artifacts.LinkElements
      .filter(el => el.rel === 'apple-touch-icon' || el.rel === 'apple-touch-icon-precomposed')
      .filter(el => !!el.href);

    // Audit passes if an `apple-touch-icon` exists.
    const passed = appleTouchIcons.length !== 0;

    const warnings = [];
    if (appleTouchIcons.filter(el => el.rel === 'apple-touch-icon-precomposed').length !== 0
      && appleTouchIcons.filter(el => el.rel === 'apple-touch-icon').length === 0) {
      warnings.push(str_(UIStrings.precomposedWarning));
    }

    return {
      score: passed ? 1 : 0,
      warnings,
    };
  }
}

module.exports = AppleTouchIcon;
module.exports.UIStrings = UIStrings;

}).call(this)}).call(this,"/lighthouse-core/audits/apple-touch-icon.js")
},{"../lib/i18n/i18n.js":96,"./audit.js":3}],"../audits/autocomplete":[function(require,module,exports){
(function (__filename){(function (){
/**
 * @license Copyright 2020 The Lighthouse Authors. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.
 */

/**
 * @fileoverview Audits a page to make sure all input elements
 *  have an autocomplete attribute set.
 * See https://docs.google.com/document/d/1yiulNnV8uEy1jPaAEmWeHxHcQOzxpqvAV4hOFpXLJ1M/edit?usp=sharing
 */

'use strict';

const Audit = require('./audit.js');
const i18n = require('../lib/i18n/i18n.js');
const log = require('lighthouse-logger');

const UIStrings = {
  /** Title of a Lighthouse audit that lets the user know if there are any missing or invalid autocomplete attributes on page inputs. This descriptive title is shown to users when all input attributes have a valid autocomplete attribute. */
  title: '`<input>` elements correctly use `autocomplete`',
  /** Title of a Lighthouse audit that lets the user know if there are any missing or invalid autocomplete attributes on page inputs. This descriptive title is shown to users when one or more inputs do not have autocomplete set or has an invalid autocomplete set. */
  failureTitle: '`<input>` elements do not have correct `autocomplete` attributes',
  /** Description of a Lighthouse audit that lets the user know if there are any missing or invalid autocomplete attributes on page inputs. This is displayed after a user expands the section to see more. No character length limits. 'Learn More' becomes link text to additional documentation. */
  description: '`autocomplete` helps users submit forms quicker. To reduce user ' +
   'effort, consider enabling by setting the `autocomplete` ' +
   'attribute to a valid value.' +
  ' [Learn more](https://developers.google.com/web/fundamentals/design-and-ux/input/forms#use_metadata_to_enable_auto-complete)',
  /** Label for a column in a data table; entries will be the autocomplete token suggestions based on heuristics. */
  columnSuggestions: 'Suggested Token',
  /** Label for a column in a data table; entries will be the incorrect optional autocomplete tokens or prompting user to review them. */
  columnCurrent: 'Current Value',
  /**
   * @description Warning that autocomplete token is invalid.
   * @example {invalid-token name} token
   * @example {<autocomplete="invalid-token name">} snippet
   */
  warningInvalid: '`autocomplete` token(s): "{token}" is invalid in {snippet}',
  /**
   * @description Warning that autocomplete token order is invalid.
   * @example {mobile section-red cc-name} tokens
   * @example {<autocomplete="mobile section-red cc-name">} snippet
   */
  warningOrder: 'Review order of tokens: "{tokens}" in {snippet}',
  /** Entry for under the Autocomplete Suggested Token Column that tells users to review the ordering of their tokens if they are valid. */
  reviewOrder: 'Review order of tokens',
  /** Entry for under the Autocomplete Suggested Token Column that appears when we have no autocomplete suggestion. */
  manualReview: 'Requires manual review',
};

const str_ = i18n.createMessageInstanceIdFn(__filename, UIStrings);

/** @type {string[]} This array contains all acceptable autocomplete attributes from the WHATWG standard. More found at https://html.spec.whatwg.org/multipage/form-control-infrastructure.html#autofill */
const validAutocompleteTokens = ['name', 'honorific-prefix', 'given-name',
  'additional-name', 'family-name', 'honorific-suffix', 'nickname', 'username', 'new-password',
  'current-password', 'one-time-code', 'organization-title', 'organization', 'street-address',
  'address-line1', 'address-line2', 'address-line3', 'address-level4', 'address-level3',
  'address-level2', 'address-level1', 'country', 'country-name', 'postal-code', 'cc-name',
  'cc-given-name', 'cc-additional-name', 'cc-family-name', 'cc-number', 'cc-exp',
  'cc-exp-month', 'cc-exp-year', 'cc-csc', 'cc-type', 'transaction-currency',
  'transaction-amount', 'language', 'bday', 'bday-day', 'bday-month', 'bday-year',
  'sex', 'url', 'photo', 'tel', 'tel-country-code', 'tel-national', 'tel-area-code', 'on',
  'tel-local', 'tel-local-prefix', 'tel-local-suffix', 'tel-extension', 'email', 'impp', 'off',
  'additional-name-initial', 'home', 'work', 'mobile', 'fax', 'pager', 'shipping', 'billing'];

/** @type {string[]} This array contains all autofull suggestions that have no prediction tied to it. Autofill predictions found at https://source.chromium.org/chromium/chromium/src/+/main:components/autofill/core/browser/field_types.h;l=26 */
const noPrediction = ['NO_SERVER_DATA', 'UNKNOWN_TYPE', 'EMPTY_TYPE', 'HTML_TYPE_UNSPECIFIED',
  'HTML_TYPE_UNRECOGNIZED'];

/** This mapping contains all autofill predictions to corresponding autocomplete attributes. Autofill predictions are found at https://source.chromium.org/chromium/chromium/src/+/main:components/autofill/core/browser/field_types.h;l=34*/
const predictionTypesToTokens = {
  'NO_SERVER_DATA': str_(UIStrings.manualReview),
  'UNKNOWN_TYPE': str_(UIStrings.manualReview),
  'EMPTY_TYPE': str_(UIStrings.manualReview),
  'NAME_FIRST': 'given-name',
  'NAME_MIDDLE': 'additional-name',
  'NAME_LAST': 'family-name',
  'NAME_FULL': 'name',
  'NAME_MIDDLE_INITIAL': 'additional-name-initial',
  'NAME_SUFFIX': 'honorific-suffix',
  'NAME_BILLING_FIRST': 'billing given-name',
  'NAME_BILLING_MIDDLE': 'billing additional-name',
  'NAME_BILLING_LAST': 'billing family-name',
  'NAME_BILLING_MIDDLE_INITIAL': 'billing additional-name-initial',
  'NAME_BILLING_FULL': 'billing name',
  'NAME_BILLING_SUFFIX': 'billing honorific-suffix',
  'EMAIL_ADDRESS': 'email',
  'MERCHANT_EMAIL_SIGNUP': 'email',
  'PHONE_HOME_NUMBER': 'tel-local',
  'PHONE_HOME_CITY_CODE': 'tel-area-code',
  'PHONE_HOME_COUNTRY_CODE': 'tel-country-code',
  'PHONE_HOME_CITY_AND_NUMBER': 'tel-national',
  'PHONE_HOME_WHOLE_NUMBER': 'tel',
  'PHONE_HOME_EXTENSION': 'tel-extension',
  'PHONE_BILLING_NUMBER': 'billing tel-local',
  'PHONE_BILLING_CITY_CODE': 'billing tel-area-code',
  'PHONE_BILLING_COUNTRY_CODE': 'tel-country-code',
  'PHONE_BILLING_CITY_AND_NUMBER': 'tel-national',
  'PHONE_BILLING_WHOLE_NUMBER': 'tel',
  'ADDRESS_HOME_STREET_ADDRESS': 'street-address',
  'ADDRESS_HOME_LINE1': 'address-line1',
  'ADDRESS_HOME_LINE2': 'address-line2',
  'ADDRESS_HOME_LINE3': 'address-line3',
  'ADDRESS_HOME_STATE': 'address-level1',
  'ADDRESS_HOME_CITY': 'address-level2',
  'ADDRESS_HOME_DEPENDENT_LOCALITY': 'address-level3',
  'ADDRESS_HOME_ZIP': 'postal-code',
  'ADDRESS_HOME_COUNTRY': 'country-name',
  'ADDRESS_BILLING_DEPENDENT_LOCALITY': 'billing address-level3',
  'ADDRESS_BILLING_STREET_ADDRESS': 'billing street-address',
  'ADDRESS_BILLING_LINE1': 'billing address-line1',
  'ADDRESS_BILLING_LINE2': 'billing address-line2',
  'ADDRESS_BILLING_LINE3': 'billing address-line3',
  'ADDRESS_BILLING_APT_NUM': 'billing address-level3',
  'ADDRESS_BILLING_CITY': 'billing address-level2',
  'ADDRESS_BILLING_STATE': 'billing address-level1',
  'ADDRESS_BILLING_ZIP': 'billing postal-code',
  'ADDRESS_BILLING_COUNTRY': 'billing country-name',
  'CREDIT_CARD_NAME_FULL': 'cc-name',
  'CREDIT_CARD_NAME_FIRST': 'cc-given-name',
  'CREDIT_CARD_NAME_LAST': 'cc-family-name',
  'CREDIT_CARD_NUMBER': 'cc-number',
  'CREDIT_CARD_EXP_MONTH': 'cc-exp-month',
  'CREDIT_CARD_EXP_2_DIGIT_YEAR': 'cc-exp-year',
  'CREDIT_CARD_EXP_4_DIGIT_YEAR': 'cc-exp-year',
  'CREDIT_CARD_EXP_DATE_2_DIGIT_YEAR': 'cc-exp',
  'CREDIT_CARD_EXP_DATE_4_DIGIT_YEAR': 'cc-exp',
  'CREDIT_CARD_TYPE': 'cc-type',
  'CREDIT_CARD_VERIFICATION_CODE': 'cc-csc',
  'COMPANY_NAME': 'organization',
  'PASSWORD': 'current-password',
  'ACCOUNT_CREATION_PASSWORD': 'new-password',
  'HTML_TYPE_UNSPECIFIED': str_(UIStrings.manualReview),
  'HTML_TYPE_NAME': 'name',
  'HTML_TYPE_HONORIFIC_PREFIX': 'honorific-prefix',
  'HTML_TYPE_GIVEN_NAME': 'given-name',
  'HTML_TYPE_ADDITIONAL_NAME': 'additional-name',
  'HTML_TYPE_FAMILY_NAME': 'family-name',
  'HTML_TYPE_ORGANIZATION': 'organization',
  'HTML_TYPE_STREET_ADDRESS': 'street-address',
  'HTML_TYPE_ADDRESS_LINE1': 'address-line1',
  'HTML_TYPE_ADDRESS_LINE2': 'address-line2',
  'HTML_TYPE_ADDRESS_LINE3': 'address-line3',
  'HTML_TYPE_ADDRESS_LEVEL1': 'address-level1',
  'HTML_TYPE_ADDRESS_LEVEL2': 'address-level2',
  'HTML_TYPE_ADDRESS_LEVEL3': 'address-level3',
  'HTML_TYPE_COUNTRY_CODE': 'tel-country-code',
  'HTML_TYPE_COUNTRY_NAME': 'country-name',
  'HTML_TYPE_POSTAL_CODE': 'postal-code',
  'HTML_TYPE_FULL_ADDRESS': 'street-address',
  'HTML_TYPE_CREDIT_CARD_NAME_FULL': 'cc-name',
  'HTML_TYPE_CREDIT_CARD_NAME_FIRST': 'cc-given-name',
  'HTML_TYPE_CREDIT_CARD_NAME_LAST': 'cc-family-name',
  'HTML_TYPE_CREDIT_CARD_NUMBER': 'cc-number',
  'HTML_TYPE_CREDIT_CARD_EXP': 'cc-exp',
  'HTML_TYPE_CREDIT_CARD_EXP_MONTH': 'cc-exp-month',
  'HTML_TYPE_CREDIT_CARD_EXP_YEAR': 'cc-exp-year',
  'HTML_TYPE_CREDIT_CARD_VERIFICATION_CODE': 'cc-csc',
  'HTML_TYPE_CREDIT_CARD_TYPE': 'cc-csc',
  'HTML_TYPE_TEL': 'tel',
  'HTML_TYPE_TEL_COUNTRY_CODE': 'tel-country-code',
  'HTML_TYPE_TEL_NATIONAL': 'tel-national',
  'HTML_TYPE_TEL_AREA_CODE': 'tel-area-code',
  'HTML_TYPE_TEL_LOCAL': 'tel-local',
  'HTML_TYPE_TEL_LOCAL_PREFIX': 'tel-local-prefix',
  'HTML_TYPE_TEL_LOCAL_SUFFIX': 'tel-local-suffix',
  'HTML_TYPE_TEL_EXTENSION': 'tel-extension',
  'HTML_TYPE_EMAIL': 'email',
  'HTML_TYPE_ADDITIONAL_NAME_INITIAL': 'additional-name-initial',
  'HTML_TYPE_CREDIT_CARD_EXP_DATE_2_DIGIT_YEAR': 'cc-exp-year',
  'HTML_TYPE_CREDIT_CARD_EXP_DATE_4_DIGIT_YEAR': 'cc-exp-year',
  'HTML_TYPE_CREDIT_CARD_EXP_2_DIGIT_YEAR': 'cc-exp-year',
  'HTML_TYPE_CREDIT_CARD_EXP_4_DIGIT_YEAR': 'cc-exp-year',
  'HTML_TYPE_UPI_VPA': str_(UIStrings.manualReview),
  'HTML_TYPE_ONE_TIME_CODE': 'one-time-code',
  'HTML_TYPE_UNRECOGNIZED': str_(UIStrings.manualReview),
  'HTML_TYPE_TRANSACTION_AMOUNT': 'transaction-amount',
  'HTML_TYPE_TRANSACTION_CURRENCY': 'transaction-currency',
};

/**
 * The autocomplete attribute can have multiple tokens in it. All tokens should be valid and in the correct order.
 * For example, cc-namez is an invalid token. tel mobile shipping section-foo are valid tokens, but out of order. The spec defines correct ordering, but in short, correct order is:
 *
 * [section-*] [shipping|billing] [home|work|mobile|fax|pager] <autofill field name>
 *
 * If either of these invalid situations, the autocomplete property will be an empty string. */
class AutocompleteAudit extends Audit {
  /**
   * @return {LH.Audit.Meta}
   */
  static get meta() {
    return {
      id: 'autocomplete',
      title: str_(UIStrings.title),
      failureTitle: str_(UIStrings.failureTitle),
      description: str_(UIStrings.description),
      requiredArtifacts: ['FormElements'],
    };
  }

  /**
   * @param {LH.Artifacts.FormInput} input
   * @return {{hasValidTokens: boolean, isValidOrder?: boolean}}
   */
  static checkAttributeValidity(input) {
    if (!input.autocomplete.attribute) return {hasValidTokens: false};
    const tokenArray = input.autocomplete.attribute.split(' ');
    for (const token of tokenArray) {
      // A `section-` prefix indicates a unique autofill scope.
      // https://html.spec.whatwg.org/multipage/form-control-infrastructure.html#:~:text=section-
      if (token.slice(0, 8) === 'section-') continue;
      if (validAutocompleteTokens.includes(token)) continue;
      return {hasValidTokens: false};
    }
    // If all autocomplete tokens are valid but there is still no property attribute, then that means the tokens are out of order.
    // https://cloudfour.com/thinks/autofill-what-web-devs-should-know-but-dont/#all-the-tokens
    if (!input.autocomplete.property) return {hasValidTokens: true, isValidOrder: false};
    return {hasValidTokens: true, isValidOrder: true};
  }

  /**
   * @param {LH.Artifacts} artifacts
   * @return {LH.Audit.Product}
   */
  static audit(artifacts) {
    const forms = artifacts.FormElements;
    const failingFormsData = [];
    const warnings = [];
    let foundPrediction = false;
    for (const form of forms) {
      for (const input of form.inputs) {
        const validity = this.checkAttributeValidity(input);
        if (validity.hasValidTokens && validity.isValidOrder) continue;
        if (!input.autocomplete.prediction) continue;
        if (noPrediction.includes(input.autocomplete.prediction) &&
          !input.autocomplete.attribute) continue;

        foundPrediction = true;

        // @ts-ignore
        let suggestion = predictionTypesToTokens[input.autocomplete.prediction];
        // This is here to satisfy typescript because the possible null value of autocomplete.attribute is not compatible with Audit details.
        if (!input.autocomplete.attribute) input.autocomplete.attribute = '';
        // Warning is created because while there is an autocomplete attribute, the autocomplete property does not exsist, thus the attribute's value is invalid.
        if (input.autocomplete.attribute) {
          warnings.push(str_(UIStrings.warningInvalid, {token: input.autocomplete.attribute,
            snippet: input.node.snippet}));
        }
        if (validity.isValidOrder === false) {
          warnings.push(str_(UIStrings.warningOrder, {tokens: input.autocomplete.attribute,
            snippet: input.node.snippet}));
          suggestion = UIStrings.reviewOrder;
        }
        // If the autofill prediction is not in our autofill suggestion mapping, then we warn
        if (!(input.autocomplete.prediction in predictionTypesToTokens) &&
            validity.isValidOrder) {
          log.warn(`Autocomplete prediction (${input.autocomplete.prediction})
             not found in our mapping`);
          continue;
        }
        failingFormsData.push({
          node: Audit.makeNodeItem(input.node),
          suggestion: suggestion,
          current: input.autocomplete.attribute,
        });
      }
    }

    /** @type {LH.Audit.Details.Table['headings']} */
    const headings = [
      {key: 'node', itemType: 'node', text: str_(i18n.UIStrings.columnFailingElem)},
      {key: 'current', itemType: 'text', text: str_(UIStrings.columnCurrent)},
      {key: 'suggestion', itemType: 'text', text: str_(UIStrings.columnSuggestions)},
    ];
    const details = Audit.makeTableDetails(headings, failingFormsData);
    let displayValue;
    if (failingFormsData.length > 0) {
      displayValue = str_(i18n.UIStrings.displayValueElementsFound,
        {nodeCount: failingFormsData.length});
    }
    return {
      score: (failingFormsData.length > 0) ? 0 : 1,
      notApplicable: !foundPrediction,
      displayValue,
      details,
      warnings,
    };
  }
}

module.exports = AutocompleteAudit;
module.exports.UIStrings = UIStrings;

}).call(this)}).call(this,"/lighthouse-core/audits/autocomplete.js")
},{"../lib/i18n/i18n.js":96,"./audit.js":3,"lighthouse-logger":188}],"../audits/bootup-time":[function(require,module,exports){
(function (__filename){(function (){
/**
 * @license Copyright 2017 The Lighthouse Authors. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.
 */
'use strict';

const Audit = require('./audit.js');
const NetworkRequest = require('../lib/network-request.js');
const {taskGroups} = require('../lib/tracehouse/task-groups.js');
const i18n = require('../lib/i18n/i18n.js');
const NetworkRecords = require('../computed/network-records.js');
const MainThreadTasks = require('../computed/main-thread-tasks.js');

const UIStrings = {
  /** Title of a diagnostic audit that provides detail on the time spent executing javascript files during the load. This descriptive title is shown to users when the amount is acceptable and no user action is required. */
  title: 'JavaScript execution time',
  /** Title of a diagnostic audit that provides detail on the time spent executing javascript files during the load. This imperative title is shown to users when there is a significant amount of execution time that could be reduced. */
  failureTitle: 'Reduce JavaScript execution time',
  /** Description of a Lighthouse audit that tells the user that they should reduce the amount of time spent executing javascript and one method of doing so. This is displayed after a user expands the section to see more. No character length limits. 'Learn More' becomes link text to additional documentation. */
  description: 'Consider reducing the time spent parsing, compiling, and executing JS. ' +
    'You may find delivering smaller JS payloads helps with this. [Learn ' +
    'more](https://web.dev/bootup-time/).',
  /** Label for the total time column in a data table; entries will be the number of milliseconds spent executing per resource loaded by the page. */
  columnTotal: 'Total CPU Time',
  /** Label for a time column in a data table; entries will be the number of milliseconds spent evaluating script for every script loaded by the page. */
  columnScriptEval: 'Script Evaluation',
  /** Label for a time column in a data table; entries will be the number of milliseconds spent parsing script files for every script loaded by the page. */
  columnScriptParse: 'Script Parse',
  /** A message displayed in a Lighthouse audit result warning that Chrome extensions on the user's system substantially affected Lighthouse's measurements and instructs the user on how to run again without those extensions. */
  chromeExtensionsWarning: 'Chrome extensions negatively affected this page\'s load performance. ' +
    'Try auditing the page in incognito mode or from a Chrome profile without extensions.',
};

const str_ = i18n.createMessageInstanceIdFn(__filename, UIStrings);

// These trace events, when not triggered by a script inside a particular task, are just general Chrome overhead.
const BROWSER_TASK_NAMES_SET = new Set([
  'CpuProfiler::StartProfiling',
]);

// These trace events, when not triggered by a script inside a particular task, are GC Chrome overhead.
const BROWSER_GC_TASK_NAMES_SET = new Set([
  'V8.GCCompactor',
  'MajorGC',
  'MinorGC',
]);

class BootupTime extends Audit {
  /**
   * @return {LH.Audit.Meta}
   */
  static get meta() {
    return {
      id: 'bootup-time',
      title: str_(UIStrings.title),
      failureTitle: str_(UIStrings.failureTitle),
      description: str_(UIStrings.description),
      scoreDisplayMode: Audit.SCORING_MODES.NUMERIC,
      requiredArtifacts: ['traces', 'devtoolsLogs'],
    };
  }

  /**
   * @return {LH.Audit.ScoreOptions & {thresholdInMs: number}}
   */
  static get defaultOptions() {
    return {
      // see https://www.desmos.com/calculator/ynl8fzh1wd
      // <500ms ~= 100, >1.3s is yellow, >3.5s is red
      p10: 1282,
      median: 3500,
      thresholdInMs: 50,
    };
  }

  /**
   * @param {LH.Artifacts.NetworkRequest[]} records
   */
  static getJavaScriptURLs(records) {
    /** @type {Set<string>} */
    const urls = new Set();
    for (const record of records) {
      if (record.resourceType === NetworkRequest.TYPES.Script) {
        urls.add(record.url);
      }
    }

    return urls;
  }

  /**
   * @param {LH.Artifacts.TaskNode} task
   * @param {Set<string>} jsURLs
   * @return {string}
   */
  static getAttributableURLForTask(task, jsURLs) {
    const jsURL = task.attributableURLs.find(url => jsURLs.has(url));
    const fallbackURL = task.attributableURLs[0];
    let attributableURL = jsURL || fallbackURL;
    // If we can't find what URL was responsible for this execution, attribute it to the root page
    // or Chrome depending on the type of work.
    if (!attributableURL || attributableURL === 'about:blank') {
      if (BROWSER_TASK_NAMES_SET.has(task.event.name)) attributableURL = 'Browser';
      else if (BROWSER_GC_TASK_NAMES_SET.has(task.event.name)) attributableURL = 'Browser GC';
      else attributableURL = 'Unattributable';
    }

    return attributableURL;
  }

  /**
   * @param {LH.Artifacts.TaskNode[]} tasks
   * @param {Set<string>} jsURLs
   * @return {Map<string, Object<string, number>>}
   */
  static getExecutionTimingsByURL(tasks, jsURLs) {
    /** @type {Map<string, Object<string, number>>} */
    const result = new Map();

    for (const task of tasks) {
      const attributableURL = BootupTime.getAttributableURLForTask(task, jsURLs);
      const timingByGroupId = result.get(attributableURL) || {};
      const originalTime = timingByGroupId[task.group.id] || 0;
      timingByGroupId[task.group.id] = originalTime + task.selfTime;
      result.set(attributableURL, timingByGroupId);
    }

    return result;
  }

  /**
   * @param {LH.Artifacts} artifacts
   * @param {LH.Audit.Context} context
   * @return {Promise<LH.Audit.Product>}
   */
  static async audit(artifacts, context) {
    const settings = context.settings || {};
    const trace = artifacts.traces[BootupTime.DEFAULT_PASS];
    const devtoolsLog = artifacts.devtoolsLogs[BootupTime.DEFAULT_PASS];
    const networkRecords = await NetworkRecords.request(devtoolsLog, context);
    const tasks = await MainThreadTasks.request(trace, context);
    const multiplier = settings.throttlingMethod === 'simulate' ?
      settings.throttling.cpuSlowdownMultiplier : 1;

    const jsURLs = BootupTime.getJavaScriptURLs(networkRecords);
    const executionTimings = BootupTime.getExecutionTimingsByURL(tasks, jsURLs);

    let hadExcessiveChromeExtension = false;
    let totalBootupTime = 0;
    const results = Array.from(executionTimings)
      .map(([url, timingByGroupId]) => {
        // Add up the totalExecutionTime for all the taskGroups
        let totalExecutionTimeForURL = 0;
        for (const [groupId, timespanMs] of Object.entries(timingByGroupId)) {
          timingByGroupId[groupId] = timespanMs * multiplier;
          totalExecutionTimeForURL += timespanMs * multiplier;
        }

        const scriptingTotal = timingByGroupId[taskGroups.scriptEvaluation.id] || 0;
        const parseCompileTotal = timingByGroupId[taskGroups.scriptParseCompile.id] || 0;

        // Add up all the JavaScript time of shown URLs
        if (totalExecutionTimeForURL >= context.options.thresholdInMs) {
          totalBootupTime += scriptingTotal + parseCompileTotal;
        }

        hadExcessiveChromeExtension = hadExcessiveChromeExtension ||
          (url.startsWith('chrome-extension:') && scriptingTotal > 100);

        return {
          url: url,
          total: totalExecutionTimeForURL,
          // Highlight the JavaScript task costs
          scripting: scriptingTotal,
          scriptParseCompile: parseCompileTotal,
        };
      })
      .filter(result => result.total >= context.options.thresholdInMs)
      .sort((a, b) => b.total - a.total);


    // TODO: consider moving this to core gathering so you don't need to run the audit for warning
    let runWarnings;
    if (hadExcessiveChromeExtension) {
      runWarnings = [str_(UIStrings.chromeExtensionsWarning)];
    }

    const summary = {wastedMs: totalBootupTime};

    /** @type {LH.Audit.Details.Table['headings']} */
    const headings = [
      {key: 'url', itemType: 'url', text: str_(i18n.UIStrings.columnURL)},
      {key: 'total', granularity: 1, itemType: 'ms', text: str_(UIStrings.columnTotal)},
      {key: 'scripting', granularity: 1, itemType: 'ms', text: str_(UIStrings.columnScriptEval)},
      {key: 'scriptParseCompile', granularity: 1, itemType: 'ms',
        text: str_(UIStrings.columnScriptParse)},
    ];

    const details = BootupTime.makeTableDetails(headings, results, summary);

    const score = Audit.computeLogNormalScore(
      {p10: context.options.p10, median: context.options.median},
      totalBootupTime
    );

    return {
      score,
      numericValue: totalBootupTime,
      numericUnit: 'millisecond',
      displayValue: totalBootupTime > 0 ?
        str_(i18n.UIStrings.seconds, {timeInMs: totalBootupTime}) : '',
      details,
      runWarnings,
    };
  }
}

module.exports = BootupTime;
module.exports.UIStrings = UIStrings;

}).call(this)}).call(this,"/lighthouse-core/audits/bootup-time.js")
},{"../computed/main-thread-tasks.js":15,"../computed/network-records.js":40,"../lib/i18n/i18n.js":96,"../lib/network-request.js":109,"../lib/tracehouse/task-groups.js":118,"./audit.js":3}],"../audits/byte-efficiency/duplicated-javascript":[function(require,module,exports){
(function (__filename){(function (){
/**
 * @license Copyright 2020 The Lighthouse Authors. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.
 */
'use strict';

/** @typedef {import('./byte-efficiency-audit.js').ByteEfficiencyProduct} ByteEfficiencyProduct */
/** @typedef {LH.Audit.ByteEfficiencyItem & {source: string, subItems: {type: 'subitems', items: SubItem[]}}} Item */
/** @typedef {{url: string, sourceTransferBytes?: number}} SubItem */

const ByteEfficiencyAudit = require('./byte-efficiency-audit.js');
const ModuleDuplication = require('../../computed/module-duplication.js');
const NetworkAnalyzer = require('../../lib/dependency-graph/simulator/network-analyzer.js');
const i18n = require('../../lib/i18n/i18n.js');

const UIStrings = {
  /** Imperative title of a Lighthouse audit that tells the user to remove duplicate JavaScript from their code. This is displayed in a list of audit titles that Lighthouse generates. */
  title: 'Remove duplicate modules in JavaScript bundles',
  /** Description of a Lighthouse audit that tells the user *why* they should remove duplicate JavaScript from their scripts. This is displayed after a user expands the section to see more. No word length limits. 'Learn More' becomes link text to additional documentation. */
  description: 'Remove large, duplicate JavaScript modules from bundles ' +
    'to reduce unnecessary bytes consumed by network activity. ', // +
  // TODO: we need docs.
  // '[Learn more](https://web.dev/duplicated-javascript/).',
};

const str_ = i18n.createMessageInstanceIdFn(__filename, UIStrings);

const IGNORE_THRESHOLD_IN_BYTES = 1024;

/**
 * @param {string} haystack
 * @param {string} needle
 * @param {number} startPosition
 */
function indexOfOrEnd(haystack, needle, startPosition = 0) {
  const index = haystack.indexOf(needle, startPosition);
  return index === -1 ? haystack.length : index;
}

class DuplicatedJavascript extends ByteEfficiencyAudit {
  /**
   * @return {LH.Audit.Meta}
   */
  static get meta() {
    return {
      id: 'duplicated-javascript',
      title: str_(UIStrings.title),
      description: str_(UIStrings.description),
      scoreDisplayMode: ByteEfficiencyAudit.SCORING_MODES.NUMERIC,
      requiredArtifacts: ['devtoolsLogs', 'traces', 'SourceMaps', 'ScriptElements',
        'GatherContext', 'URL'],
    };
  }

  /**
   * @param {string} source
   */
  static _getNodeModuleName(source) {
    const sourceSplit = source.split('node_modules/');
    source = sourceSplit[sourceSplit.length - 1];

    const indexFirstSlash = indexOfOrEnd(source, '/');
    if (source[0] === '@') {
      return source.slice(0, indexOfOrEnd(source, '/', indexFirstSlash + 1));
    }

    return source.slice(0, indexFirstSlash);
  }

  /**
   * @param {LH.Artifacts} artifacts
   * @param {LH.Audit.Context} context
   */
  static async _getDuplicationGroupedByNodeModules(artifacts, context) {
    const duplication = await ModuleDuplication.request(artifacts, context);

    /** @type {typeof duplication} */
    const groupedDuplication = new Map();
    for (const [source, sourceDatas] of duplication.entries()) {
      if (!source.includes('node_modules')) {
        groupedDuplication.set(source, sourceDatas);
        continue;
      }

      const normalizedSource = 'node_modules/' + DuplicatedJavascript._getNodeModuleName(source);
      const aggregatedSourceDatas = groupedDuplication.get(normalizedSource) || [];
      for (const {scriptUrl, resourceSize} of sourceDatas) {
        let sourceData = aggregatedSourceDatas.find(d => d.scriptUrl === scriptUrl);
        if (!sourceData) {
          sourceData = {scriptUrl, resourceSize: 0};
          aggregatedSourceDatas.push(sourceData);
        }
        sourceData.resourceSize += resourceSize;
      }
      groupedDuplication.set(normalizedSource, aggregatedSourceDatas);
    }

    for (const sourceDatas of duplication.values()) {
      sourceDatas.sort((a, b) => b.resourceSize - a.resourceSize);
    }

    return groupedDuplication;
  }

  /**
   *
   * @param {LH.Artifacts.NetworkRequest|undefined} networkRecord
   * @param {number} contentLength
   */
  static _estimateTransferRatio(networkRecord, contentLength) {
    const transferSize =
      ByteEfficiencyAudit.estimateTransferSize(networkRecord, contentLength, 'Script');
    return transferSize / contentLength;
  }

  /**
   * This audit highlights JavaScript modules that appear to be duplicated across all resources,
   * either within the same bundle or between different bundles. Each details item returned is
   * a module with subItems for each resource that includes it. The wastedBytes for the details
   * item is the number of bytes occupied by the sum of all but the largest copy of the module.
   * wastedBytesByUrl attributes the cost of the bytes to a specific resource, for use by lantern.
   * @param {LH.Artifacts} artifacts
   * @param {Array<LH.Artifacts.NetworkRequest>} networkRecords
   * @param {LH.Audit.Context} context
   * @return {Promise<ByteEfficiencyAudit.ByteEfficiencyProduct>}
   */
  static async audit_(artifacts, networkRecords, context) {
    const ignoreThresholdInBytes =
      context.options && context.options.ignoreThresholdInBytes || IGNORE_THRESHOLD_IN_BYTES;
    const duplication =
      await DuplicatedJavascript._getDuplicationGroupedByNodeModules(artifacts, context);
    const mainDocumentRecord = NetworkAnalyzer.findOptionalMainDocument(networkRecords);

    /** @type {Map<string, number>} */
    const transferRatioByUrl = new Map();

    /** @type {Item[]} */
    const items = [];

    let overflowWastedBytes = 0;
    const overflowUrls = new Set();

    /** @type {Map<string, number>} */
    const wastedBytesByUrl = new Map();
    for (const [source, sourceDatas] of duplication.entries()) {
      // One copy of this module is treated as the canonical version - the rest will have
      // non-zero `wastedBytes`. In the case of all copies being the same version, all sizes are
      // equal and the selection doesn't matter. When the copies are different versions, it does
      // matter. Ideally the newest version would be the canonical copy, but version information
      // is not present. Instead, size is used as a heuristic for latest version. This makes the
      // audit conserative in its estimation.

      /** @type {SubItem[]} */
      const subItems = [];

      let wastedBytesTotal = 0;
      for (let i = 0; i < sourceDatas.length; i++) {
        const sourceData = sourceDatas[i];
        const url = sourceData.scriptUrl;

        /** @type {number|undefined} */
        let transferRatio = transferRatioByUrl.get(url);
        if (transferRatio === undefined) {
          const networkRecord = url === artifacts.URL.finalUrl ?
            mainDocumentRecord :
            networkRecords.find(n => n.url === url);

          const script = artifacts.ScriptElements.find(script => script.src === url);
          if (!script || script.content === null) {
            // This should never happen because we found the wasted bytes from bundles, which required contents in a ScriptElement.
            continue;
          }

          const contentLength = script.content.length;
          transferRatio = DuplicatedJavascript._estimateTransferRatio(networkRecord, contentLength);
          transferRatioByUrl.set(url, transferRatio);
        }

        if (transferRatio === undefined) {
          // Shouldn't happen for above reasons.
          continue;
        }

        const transferSize = Math.round(sourceData.resourceSize * transferRatio);

        subItems.push({
          url,
          sourceTransferBytes: transferSize,
        });

        if (i === 0) continue;
        wastedBytesTotal += transferSize;
        wastedBytesByUrl.set(url, (wastedBytesByUrl.get(url) || 0) + transferSize);
      }

      if (wastedBytesTotal <= ignoreThresholdInBytes) {
        overflowWastedBytes += wastedBytesTotal;
        for (const subItem of subItems) {
          overflowUrls.add(subItem.url);
        }
        continue;
      }

      items.push({
        source,
        wastedBytes: wastedBytesTotal,
        // Not needed, but keeps typescript happy.
        url: '',
        // Not needed, but keeps typescript happy.
        totalBytes: 0,
        subItems: {
          type: 'subitems',
          items: subItems,
        },
      });
    }

    if (overflowWastedBytes > ignoreThresholdInBytes) {
      items.push({
        source: 'Other',
        wastedBytes: overflowWastedBytes,
        url: '',
        totalBytes: 0,
        subItems: {
          type: 'subitems',
          items: Array.from(overflowUrls).map(url => ({url})),
        },
      });
    }

    /** @type {LH.Audit.Details.OpportunityColumnHeading[]} */
    const headings = [
      /* eslint-disable max-len */
      {key: 'source', valueType: 'code', subItemsHeading: {key: 'url', valueType: 'url'}, label: str_(i18n.UIStrings.columnSource)},
      {key: null, valueType: 'bytes', subItemsHeading: {key: 'sourceTransferBytes'}, granularity: 0.05, label: str_(i18n.UIStrings.columnTransferSize)},
      {key: 'wastedBytes', valueType: 'bytes', granularity: 0.05, label: str_(i18n.UIStrings.columnWastedBytes)},
      /* eslint-enable max-len */
    ];

    // TODO: show warning somewhere if no source maps.
    return {
      items,
      headings,
      wastedBytesByUrl,
    };
  }
}

module.exports = DuplicatedJavascript;
module.exports.UIStrings = UIStrings;

}).call(this)}).call(this,"/lighthouse-core/audits/byte-efficiency/duplicated-javascript.js")
},{"../../computed/module-duplication.js":38,"../../lib/dependency-graph/simulator/network-analyzer.js":91,"../../lib/i18n/i18n.js":96,"./byte-efficiency-audit.js":4}],"../audits/byte-efficiency/efficient-animated-content":[function(require,module,exports){
(function (__filename){(function (){
/**
 * @license Copyright 2018 The Lighthouse Authors. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.
 */
/*
 * @fileoverview Audit a page to ensure that videos are used instead of animated gifs
 */
'use strict';

const NetworkRequest = require('../../lib/network-request.js');
const ByteEfficiencyAudit = require('./byte-efficiency-audit.js');
const i18n = require('../../lib/i18n/i18n.js');

const UIStrings = {
  /** Imperative title of a Lighthouse audit that tells the user to use video formats rather than animated GIFs, which are wasteful. This is displayed in a list of audit titles that Lighthouse generates. */
  title: 'Use video formats for animated content',
  /** Description of a Lighthouse audit that tells the user *why* they should use video instead of GIF format for delivering animated content. This is displayed after a user expands the section to see more. No character length limits. 'Learn More' becomes link text to additional documentation. */
  description: 'Large GIFs are inefficient for delivering animated content. Consider using ' +
    'MPEG4/WebM videos for animations and PNG/WebP for static images instead of GIF to save ' +
    'network bytes. [Learn more](https://web.dev/efficient-animated-content/)',
};

const str_ = i18n.createMessageInstanceIdFn(__filename, UIStrings);

// If GIFs are above this size, we'll flag them
// See https://github.com/GoogleChrome/lighthouse/pull/4885#discussion_r178406623 and https://github.com/GoogleChrome/lighthouse/issues/4696#issuecomment-370979920
const GIF_BYTE_THRESHOLD = 100 * 1024;

class EfficientAnimatedContent extends ByteEfficiencyAudit {
  /**
   * @return {LH.Audit.Meta}
   */
  static get meta() {
    return {
      id: 'efficient-animated-content',
      title: str_(UIStrings.title),
      description: str_(UIStrings.description),
      scoreDisplayMode: ByteEfficiencyAudit.SCORING_MODES.NUMERIC,
      requiredArtifacts: ['devtoolsLogs', 'traces', 'GatherContext'],
    };
  }

  /**
   * Calculate rough savings percentage based on 1000 real gifs transcoded to video
   * @param {number} bytes
   * @return {number} rough savings percentage
   * @see https://github.com/GoogleChrome/lighthouse/issues/4696#issuecomment-380296510 bytes
   */
  static getPercentSavings(bytes) {
    return Math.round((29.1 * Math.log10(bytes) - 100.7)) / 100;
  }

  /**
   * @param {LH.Artifacts} artifacts
   * @param {Array<LH.Artifacts.NetworkRequest>} networkRecords
   * @return {ByteEfficiencyAudit.ByteEfficiencyProduct}
   */
  static audit_(artifacts, networkRecords) {
    const unoptimizedContent = networkRecords.filter(
      record => record.mimeType === 'image/gif' &&
        record.resourceType === NetworkRequest.TYPES.Image &&
        (record.resourceSize || 0) > GIF_BYTE_THRESHOLD
    );

    /** @type {Array<{url: string, totalBytes: number, wastedBytes: number}>}*/
    const items = unoptimizedContent.map(record => {
      const resourceSize = record.resourceSize || 0;
      return {
        url: record.url,
        totalBytes: resourceSize,
        wastedBytes: Math.round(resourceSize *
          EfficientAnimatedContent.getPercentSavings(resourceSize)),
      };
    });

    /** @type {LH.Audit.Details.Opportunity['headings']} */
    const headings = [
      {key: 'url', valueType: 'url', label: str_(i18n.UIStrings.columnURL)},
      {key: 'totalBytes', valueType: 'bytes', label: str_(i18n.UIStrings.columnResourceSize)},
      {key: 'wastedBytes', valueType: 'bytes', label: str_(i18n.UIStrings.columnWastedBytes)},
    ];

    return {
      items,
      headings,
    };
  }
}

module.exports = EfficientAnimatedContent;
module.exports.UIStrings = UIStrings;

}).call(this)}).call(this,"/lighthouse-core/audits/byte-efficiency/efficient-animated-content.js")
},{"../../lib/i18n/i18n.js":96,"../../lib/network-request.js":109,"./byte-efficiency-audit.js":4}],"../audits/byte-efficiency/legacy-javascript":[function(require,module,exports){
(function (__filename){(function (){
/**
 * @license Copyright 2020 The Lighthouse Authors. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.
 */
'use strict';

/**
 * @fileoverview Identifies polyfills and transforms that should not be present if using module/nomodule pattern.
 * @see https://docs.google.com/document/d/1ItjJwAd6e0Ts6yMbvh8TN3BBh_sAd58rYE1whnpuxaA/edit Design document
 * @see https://docs.google.com/spreadsheets/d/1z28Au8wo8-c2UsM2lDVEOJcI3jOkb2c951xEBqzBKCc/edit?usp=sharing Legacy babel transforms / polyfills
 * ./lighthouse-core/scripts/legacy-javascript - verification tool.
 */

/** @typedef {{name: string, expression: string, estimateBytes?: (result: PatternMatchResult) => number}} Pattern */
/** @typedef {{name: string, line: number, column: number, count: number}} PatternMatchResult */
/** @typedef {import('./byte-efficiency-audit.js').ByteEfficiencyProduct} ByteEfficiencyProduct */
/** @typedef {LH.Audit.ByteEfficiencyItem & {subItems: {type: 'subitems', items: SubItem[]}}} Item */
/** @typedef {{signal: string, location: LH.Audit.Details.SourceLocationValue}} SubItem */

const ByteEfficiencyAudit = require('./byte-efficiency-audit.js');
const JsBundles = require('../../computed/js-bundles.js');
const i18n = require('../../lib/i18n/i18n.js');
const thirdPartyWeb = require('../../lib/third-party-web.js');
const NetworkAnalyzer = require('../../lib/dependency-graph/simulator/network-analyzer.js');

const UIStrings = {
  /** Title of a Lighthouse audit that tells the user about legacy polyfills and transforms used on the page. This is displayed in a list of audit titles that Lighthouse generates. */
  title: 'Avoid serving legacy JavaScript to modern browsers',
  // eslint-disable-next-line max-len
  // TODO: web.dev article. this codelab is good starting place: https://web.dev/codelab-serve-modern-code/
  /** Description of a Lighthouse audit that tells the user about old JavaScript that is no longer needed. This is displayed after a user expands the section to see more. No character length limits. 'Learn More' becomes link text to additional documentation. */
  description: 'Polyfills and transforms enable legacy browsers to use new JavaScript features. However, many aren\'t necessary for modern browsers. For your bundled JavaScript, adopt a modern script deployment strategy using module/nomodule feature detection to reduce the amount of code shipped to modern browsers, while retaining support for legacy browsers. [Learn More](https://philipwalton.com/articles/deploying-es2015-code-in-production-today/)',
};

const str_ = i18n.createMessageInstanceIdFn(__filename, UIStrings);

/**
 * Takes a list of patterns (consisting of a name identifier and a RegExp expression string)
 * and returns match results with line / column information for a given code input.
 */
class CodePatternMatcher {
  /**
   * @param {Pattern[]} patterns
   */
  constructor(patterns) {
    const patternsExpression = patterns.map(pattern => `(${pattern.expression})`).join('|');
    this.re = new RegExp(`(^\r\n|\r|\n)|${patternsExpression}`, 'g');
    this.patterns = patterns;
  }

  /**
   * @param {string} code
   * @return {PatternMatchResult[]}
   */
  match(code) {
    // Reset RegExp state.
    this.re.lastIndex = 0;

    const seen = new Set();
    /** @type {PatternMatchResult[]} */
    const matches = [];
    /** @type {RegExpExecArray | null} */
    let result;
    let line = 0;
    let lineBeginsAtIndex = 0;
    // Each pattern maps to one subgroup in the generated regex. For each iteration of RegExp.exec,
    // only one subgroup will be defined. Exec until no more matches.
    while ((result = this.re.exec(code)) !== null) {
      // Discard first value in `result` - it's just the entire match.
      const captureGroups = result.slice(1);
      // isNewline - truthy if matching a newline, used to track the line number.
      // `patternExpressionMatches` maps to each possible pattern in `this.patterns`.
      // Only one of [isNewline, ...patternExpressionMatches] is ever truthy.
      const [isNewline, ...patternExpressionMatches] = captureGroups;
      if (isNewline) {
        line++;
        lineBeginsAtIndex = result.index + 1;
        continue;
      }
      const pattern = this.patterns[patternExpressionMatches.findIndex(Boolean)];

      if (seen.has(pattern)) {
        const existingMatch = matches.find(m => m.name === pattern.name);
        if (existingMatch) existingMatch.count += 1;
        continue;
      }
      seen.add(pattern);

      matches.push({
        name: pattern.name,
        line,
        column: result.index - lineBeginsAtIndex,
        count: 1,
      });
    }

    return matches;
  }
}

class LegacyJavascript extends ByteEfficiencyAudit {
  /**
   * @return {LH.Audit.Meta}
   */
  static get meta() {
    return {
      id: 'legacy-javascript',
      scoreDisplayMode: ByteEfficiencyAudit.SCORING_MODES.NUMERIC,
      description: str_(UIStrings.description),
      title: str_(UIStrings.title),
      requiredArtifacts: ['devtoolsLogs', 'traces', 'ScriptElements', 'SourceMaps',
        'GatherContext', 'URL'],
    };
  }

  /**
   * @param {string?} object
   * @param {string} property
   */
  static buildPolyfillExpression(object, property) {
    const qt = (/** @type {string} */ token) =>
      `['"]${token}['"]`; // don't worry about matching string delims

    let expression = '';

    if (object) {
      // String.prototype.startsWith =
      expression += `${object}\\.${property}\\s?=[^=]`;
    } else {
      // Promise =
      // window.Promise =// Promise =Z
      // but not: SomePromise =
      expression += `(?:window\\.|[\\s;]+)${property}\\s?=[^=]`;
    }

    // String.prototype['startsWith'] =
    if (object) {
      expression += `|${object}\\[${qt(property)}\\]\\s?=[^=]`;
    }

    // Object.defineProperty(String.prototype, 'startsWith'
    expression += `|defineProperty\\(${object || 'window'},\\s?${qt(property)}`;

    // core-js
    if (object) {
      const objectWithoutPrototype = object.replace('.prototype', '');
      // e(e.S,"Object",{values
      // Minified + mangled pattern found in CDN babel-polyfill.
      // see https://cdnjs.cloudflare.com/ajax/libs/babel-polyfill/7.2.5/polyfill.min.js
      // TODO: perhaps this is the wrong place to check for a CDN polyfill. Remove?
      // expression += `|;e\\([^,]+,${qt(objectWithoutPrototype)},{${property}:`;

      // core-js@2 minified pattern.
      // $export($export.S,"Date",{now:function
      expression += `|\\$export\\([^,]+,${qt(objectWithoutPrototype)},{${property}:`;

      // core-js@3 minified pattern.
      // {target:"Array",proto:true},{fill:fill
      // {target:"Array",proto:true,forced:!HAS_SPECIES_SUPPORT||!USES_TO_LENGTH},{filter:
      expression += `|{target:${qt(objectWithoutPrototype)}\\S*},{${property}:`;
    } else {
      // WeakSet, etc.
      expression += `|function ${property}\\(`;
    }

    return expression;
  }

  static getPolyfillData() {
    return [
      ['Array.prototype.fill', 'es6.array.fill'],
      ['Array.prototype.filter', 'es6.array.filter'],
      ['Array.prototype.find', 'es6.array.find'],
      ['Array.prototype.findIndex', 'es6.array.find-index'],
      ['Array.prototype.forEach', 'es6.array.for-each'],
      ['Array.from', 'es6.array.from'],
      ['Array.isArray', 'es6.array.is-array'],
      ['Array.prototype.map', 'es6.array.map'],
      ['Array.of', 'es6.array.of'],
      ['Array.prototype.reduce', 'es6.array.reduce'],
      ['Array.prototype.reduceRight', 'es6.array.reduce-right'],
      ['Array.prototype.some', 'es6.array.some'],
      ['Date.now', 'es6.date.now'],
      ['Date.prototype.toISOString', 'es6.date.to-iso-string'],
      ['Date.prototype.toJSON', 'es6.date.to-json'],
      ['Date.prototype.toString', 'es6.date.to-string'],
      ['Function.prototype.name', 'es6.function.name'],
      ['Number.isInteger', 'es6.number.is-integer'],
      ['Number.isSafeInteger', 'es6.number.is-safe-integer'],
      ['Number.parseInt', 'es6.number.parse-int'],
      ['Object.defineProperties', 'es6.object.define-properties'],
      ['Object.defineProperty', 'es6.object.define-property'],
      ['Object.freeze', 'es6.object.freeze'],
      ['Object.getOwnPropertyNames', 'es6.object.get-own-property-names'],
      ['Object.getPrototypeOf', 'es6.object.get-prototype-of'],
      ['Object.isExtensible', 'es6.object.is-extensible'],
      ['Object.isFrozen', 'es6.object.is-frozen'],
      ['Object.isSealed', 'es6.object.is-sealed'],
      ['Object.keys', 'es6.object.keys'],
      ['Object.preventExtensions', 'es6.object.prevent-extensions'],
      ['Object.seal', 'es6.object.seal'],
      ['Object.setPrototypeOf', 'es6.object.set-prototype-of'],
      ['Reflect.apply', 'es6.reflect.apply'],
      ['Reflect.construct', 'es6.reflect.construct'],
      ['Reflect.defineProperty', 'es6.reflect.define-property'],
      ['Reflect.deleteProperty', 'es6.reflect.delete-property'],
      ['Reflect.get', 'es6.reflect.get'],
      ['Reflect.getOwnPropertyDescriptor', 'es6.reflect.get-own-property-descriptor'],
      ['Reflect.getPrototypeOf', 'es6.reflect.get-prototype-of'],
      ['Reflect.has', 'es6.reflect.has'],
      ['Reflect.isExtensible', 'es6.reflect.is-extensible'],
      ['Reflect.ownKeys', 'es6.reflect.own-keys'],
      ['Reflect.preventExtensions', 'es6.reflect.prevent-extensions'],
      ['Reflect.setPrototypeOf', 'es6.reflect.set-prototype-of'],
      ['String.prototype.codePointAt', 'es6.string.code-point-at'],
      ['String.fromCodePoint', 'es6.string.from-code-point'],
      ['String.raw', 'es6.string.raw'],
      ['String.prototype.repeat', 'es6.string.repeat'],
      ['Array.prototype.includes', 'es7.array.includes'],
      ['Object.entries', 'es7.object.entries'],
      ['Object.getOwnPropertyDescriptors', 'es7.object.get-own-property-descriptors'],
      ['Object.values', 'es7.object.values'],
    ].map(data => {
      const [name, coreJs2Module] = data;
      return {
        name,
        coreJs2Module,
        coreJs3Module: coreJs2Module
          .replace('es6.', 'es.')
          .replace('es7.', 'es.')
          .replace('typed.', 'typed-array.'),
      };
    });
  }

  /**
   * @return {Pattern[]}
   */
  static getPolyfillPatterns() {
    return this.getPolyfillData().map(({name}) => {
      const parts = name.split('.');
      const object = parts.length > 1 ? parts.slice(0, parts.length - 1).join('.') : null;
      const property = parts[parts.length - 1];
      return {
        name,
        expression: this.buildPolyfillExpression(object, property),
      };
    });
  }

  /**
   * @return {Pattern[]}
   */
  static getTransformPatterns() {
    return [
      {
        name: '@babel/plugin-transform-classes',
        expression: 'Cannot call a class as a function',
        estimateBytes: result => 150 + result.count * '_classCallCheck()'.length,
      },
      {
        name: '@babel/plugin-transform-regenerator',
        expression: /regeneratorRuntime\.a?wrap/.source,
        // Example of this transform: https://gist.github.com/connorjclark/af8bccfff377ac44efc104a79bc75da2
        // `regeneratorRuntime.awrap` is generated for every usage of `await`, and adds ~80 bytes each.
        estimateBytes: result => result.count * 80,
      },
      {
        name: '@babel/plugin-transform-spread',
        expression: /\.apply\(void 0,\s?_toConsumableArray/.source,
        estimateBytes: result => 1169 + result.count * '_toConsumableArray()'.length,
      },
    ];
  }

  /**
   * Returns a collection of match results grouped by script url.
   *
   * @param {CodePatternMatcher} matcher
   * @param {LH.GathererArtifacts['ScriptElements']} scripts
   * @param {LH.Artifacts.NetworkRequest[]} networkRecords
   * @param {LH.Artifacts.Bundle[]} bundles
   * @return {Map<string, PatternMatchResult[]>}
   */
  static detectAcrossScripts(matcher, scripts, networkRecords, bundles) {
    /** @type {Map<string, PatternMatchResult[]>} */
    const urlToMatchResults = new Map();
    const polyfillData = this.getPolyfillData();

    for (const {requestId, content} of Object.values(scripts)) {
      if (!content) continue;
      const networkRecord = networkRecords.find(record => record.requestId === requestId);
      if (!networkRecord) continue;

      // Start with pattern matching against the downloaded script.
      const matches = matcher.match(content);

      // If it's a bundle with source maps, add in the polyfill modules by name too.
      const bundle = bundles.find(b => b.script.src === networkRecord.url);
      if (bundle) {
        for (const {coreJs2Module, coreJs3Module, name} of polyfillData) {
          // Skip if the pattern matching found a match for this polyfill.
          if (matches.some(m => m.name === name)) continue;

          const source = bundle.rawMap.sources.find(source =>
            source.endsWith(`${coreJs2Module}.js`) || source.endsWith(`${coreJs3Module}.js`));
          if (!source) continue;

          const mapping = bundle.map.mappings().find(m => m.sourceURL === source);
          if (mapping) {
            matches.push({name, line: mapping.lineNumber, column: mapping.columnNumber, count: 1});
          } else {
            matches.push({name, line: 0, column: 0, count: 1});
          }
        }
      }

      if (!matches.length) continue;
      urlToMatchResults.set(networkRecord.url, matches);
    }

    return urlToMatchResults;
  }

  /**
   * @param {PatternMatchResult[]} matches
   * @return {number}
   */
  static estimateWastedBytes(matches) {
    // Split up results based on polyfill / transform. Only transforms start with @.
    const polyfillResults = matches.filter(m => !m.name.startsWith('@'));
    const transformResults = matches.filter(m => m.name.startsWith('@'));

    let estimatedWastedBytesFromPolyfills = 0;
    /** @type {import('../../scripts/legacy-javascript/create-polyfill-size-estimation.js').PolyfillSizeEstimator} */
    const graph = require('./polyfill-graph-data.json');
    const modulesSeen = new Set();
    for (const result of polyfillResults) {
      const modules = graph.dependencies[result.name];
      if (!modules) continue; // Shouldn't happen.
      for (const module of modules) {
        modulesSeen.add(module);
      }
    }

    if (polyfillResults.length > 0) estimatedWastedBytesFromPolyfills += graph.baseSize;
    estimatedWastedBytesFromPolyfills += [...modulesSeen].reduce((acc, moduleIndex) => {
      return acc + graph.moduleSizes[moduleIndex];
    }, 0);
    estimatedWastedBytesFromPolyfills = Math.min(estimatedWastedBytesFromPolyfills, graph.maxSize);

    let estimatedWastedBytesFromTransforms = 0;

    for (const result of transformResults) {
      const pattern = this.getTransformPatterns().find(p => p.name === result.name);
      if (!pattern || !pattern.estimateBytes) continue;
      estimatedWastedBytesFromTransforms += pattern.estimateBytes(result);
    }

    const estimatedWastedBytes =
      estimatedWastedBytesFromPolyfills + estimatedWastedBytesFromTransforms;
    return estimatedWastedBytes;
  }

  /**
   * Utility function to estimate transfer size and cache calculation.
   *
   * Note: duplicated-javascript does this exact thing. In the future, consider
   * making a generic estimator on ByteEfficienyAudit.
   * @param {Map<string, number>} transferRatioByUrl
   * @param {string} url
   * @param {LH.Artifacts} artifacts
   * @param {Array<LH.Artifacts.NetworkRequest>} networkRecords
   */
  static async estimateTransferRatioForScript(transferRatioByUrl, url, artifacts, networkRecords) {
    let transferRatio = transferRatioByUrl.get(url);
    if (transferRatio !== undefined) return transferRatio;

    const mainDocumentRecord = NetworkAnalyzer.findOptionalMainDocument(networkRecords);
    const networkRecord = url === artifacts.URL.finalUrl ?
      mainDocumentRecord :
      networkRecords.find(n => n.url === url);
    const script = artifacts.ScriptElements.find(script => script.src === url);

    if (!script || script.content === null) {
      // Can't find content, so just use 1.
      transferRatio = 1;
    } else {
      const contentLength = script.content.length;
      const transferSize =
        ByteEfficiencyAudit.estimateTransferSize(networkRecord, contentLength, 'Script');
      transferRatio = transferSize / contentLength;
    }

    transferRatioByUrl.set(url, transferRatio);
    return transferRatio;
  }

  /**
   * @param {LH.Artifacts.Bundle} bundle
   * @param {number} generatedLine
   * @param {number} generatedColumn
   * @return {LH.Audit.Details.SourceLocationValue['original']}
   */
  static _findOriginalLocation(bundle, generatedLine, generatedColumn) {
    const entry = bundle && bundle.map.findEntry(generatedLine, generatedColumn);
    if (!entry) return;

    return {
      file: entry.sourceURL || '',
      line: entry.sourceLineNumber || 0,
      column: entry.sourceColumnNumber || 0,
    };
  }

  /**
   * @param {LH.Artifacts} artifacts
   * @param {Array<LH.Artifacts.NetworkRequest>} networkRecords
   * @param {LH.Audit.Context} context
   * @return {Promise<ByteEfficiencyProduct>}
   */
  static async audit_(artifacts, networkRecords, context) {
    const mainDocumentEntity = thirdPartyWeb.getEntity(artifacts.URL.finalUrl);
    const bundles = await JsBundles.request(artifacts, context);

    /** @type {Item[]} */
    const items = [];

    const matcher = new CodePatternMatcher([
      ...this.getPolyfillPatterns(),
      ...this.getTransformPatterns(),
    ]);

    /** @type {Map<string, number>} */
    const transferRatioByUrl = new Map();

    const urlToMatchResults =
      this.detectAcrossScripts(matcher, artifacts.ScriptElements, networkRecords, bundles);
    for (const [url, matches] of urlToMatchResults.entries()) {
      const transferRatio = await this.estimateTransferRatioForScript(
        transferRatioByUrl, url, artifacts, networkRecords);
      const wastedBytes = Math.round(this.estimateWastedBytes(matches) * transferRatio);
      /** @type {typeof items[number]} */
      const item = {
        url,
        wastedBytes,
        subItems: {
          type: 'subitems',
          items: [],
        },
        // Not needed, but keeps typescript happy.
        totalBytes: 0,
      };

      const bundle = bundles.find(bundle => bundle.script.src === url);
      for (const match of matches) {
        const {name, line, column} = match;

        /** @type {SubItem} */
        const subItem = {
          signal: name,
          location: {
            type: 'source-location',
            url,
            line,
            column,
            original: bundle && this._findOriginalLocation(bundle, line, column),
            urlProvider: 'network',
          },
        };
        item.subItems.items.push(subItem);
      }
      items.push(item);
    }

    /** @type {Map<string, number>} */
    const wastedBytesByUrl = new Map();
    for (const item of items) {
      // Only estimate savings if first party code has legacy code.
      if (thirdPartyWeb.isFirstParty(item.url, mainDocumentEntity)) {
        wastedBytesByUrl.set(item.url, item.wastedBytes);
      }
    }

    /** @type {LH.Audit.Details.OpportunityColumnHeading[]} */
    const headings = [
      /* eslint-disable max-len */
      {key: 'url', valueType: 'url', subItemsHeading: {key: 'location', valueType: 'source-location'}, label: str_(i18n.UIStrings.columnURL)},
      {key: null, valueType: 'code', subItemsHeading: {key: 'signal'}, label: ''},
      {key: 'wastedBytes', valueType: 'bytes', label: str_(i18n.UIStrings.columnWastedBytes)},
      /* eslint-enable max-len */
    ];

    return {
      items,
      headings,
      wastedBytesByUrl,
    };
  }
}

module.exports = LegacyJavascript;
module.exports.UIStrings = UIStrings;

}).call(this)}).call(this,"/lighthouse-core/audits/byte-efficiency/legacy-javascript.js")
},{"../../computed/js-bundles.js":12,"../../lib/dependency-graph/simulator/network-analyzer.js":91,"../../lib/i18n/i18n.js":96,"../../lib/third-party-web.js":116,"./byte-efficiency-audit.js":4,"./polyfill-graph-data.json":5}],"../audits/byte-efficiency/modern-image-formats":[function(require,module,exports){
(function (__filename){(function (){
/**
 * @license Copyright 2017 The Lighthouse Authors. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.
 */
/*
 * @fileoverview This audit determines if the images could be smaller when compressed with WebP.
 */
'use strict';

const ByteEfficiencyAudit = require('./byte-efficiency-audit.js');
const URL = require('../../lib/url-shim.js');
const i18n = require('../../lib/i18n/i18n.js');

const UIStrings = {
  /** Imperative title of a Lighthouse audit that tells the user to serve images in newer and more efficient image formats in order to enhance the performance of a page. A non-modern image format was designed 20+ years ago. This is displayed in a list of audit titles that Lighthouse generates. */
  title: 'Serve images in next-gen formats',
  /** Description of a Lighthouse audit that tells the user *why* they should use newer and more efficient image formats. This is displayed after a user expands the section to see more. No character length limits. 'Learn More' becomes link text to additional documentation. */
  description: 'Image formats like WebP and AVIF often provide better ' +
    'compression than PNG or JPEG, which means faster downloads and less data consumption. ' +
    '[Learn more](https://web.dev/uses-webp-images/).',
};

const str_ = i18n.createMessageInstanceIdFn(__filename, UIStrings);

const IGNORE_THRESHOLD_IN_BYTES = 8192;

class ModernImageFormats extends ByteEfficiencyAudit {
  /**
   * @return {LH.Audit.Meta}
   */
  static get meta() {
    return {
      id: 'modern-image-formats',
      title: str_(UIStrings.title),
      description: str_(UIStrings.description),
      scoreDisplayMode: ByteEfficiencyAudit.SCORING_MODES.NUMERIC,
      requiredArtifacts: ['OptimizedImages', 'devtoolsLogs', 'traces', 'URL', 'GatherContext',
        'ImageElements'],
    };
  }

  /**
   * @param {{naturalWidth: number, naturalHeight: number}} imageElement
   * @return {number}
   */
  static estimateWebPSizeFromDimensions(imageElement) {
    const totalPixels = imageElement.naturalWidth * imageElement.naturalHeight;
    // See uses-optimized-images for the rationale behind our 2 byte-per-pixel baseline and
    // JPEG compression ratio of 8:1.
    // WebP usually gives ~20% additional savings on top of that, so we will use 10:1.
    // This is quite pessimistic as their study shows a photographic compression ratio of ~29:1.
    // https://developers.google.com/speed/webp/docs/webp_lossless_alpha_study#results
    const expectedBytesPerPixel = 2 * 1 / 10;
    return Math.round(totalPixels * expectedBytesPerPixel);
  }

  /**
   * @param {{naturalWidth: number, naturalHeight: number}} imageElement
   * @return {number}
   */
  static estimateAvifSizeFromDimensions(imageElement) {
    const totalPixels = imageElement.naturalWidth * imageElement.naturalHeight;
    // See above for the rationale behind our 2 byte-per-pixel baseline and WebP ratio of 10:1.
    // AVIF usually gives ~20% additional savings on top of that, so we will use 12:1.
    // This is quite pessimistic as Netflix study shows a photographic compression ratio of ~40:1
    // (0.4 *bits* per pixel at SSIM 0.97).
    // https://netflixtechblog.com/avif-for-next-generation-image-coding-b1d75675fe4
    const expectedBytesPerPixel = 2 * 1 / 12;
    return Math.round(totalPixels * expectedBytesPerPixel);
  }

  /**
   * @param {{jpegSize: number | undefined, webpSize: number | undefined}} otherFormatSizes
   * @return {number|undefined}
   */
  static estimateAvifSizeFromWebPAndJpegEstimates(otherFormatSizes) {
    if (!otherFormatSizes.jpegSize || !otherFormatSizes.webpSize) return undefined;

    // AVIF saves at least ~50% on JPEG, ~20% on WebP at low quality.
    // http://downloads.aomedia.org/assets/pdf/symposium-2019/slides/CyrilConcolato_Netflix-AVIF-AOM-Research-Symposium-2019.pdf
    // https://jakearchibald.com/2020/avif-has-landed/
    // https://www.finally.agency/blog/what-is-avif-image-format
    // See https://github.com/GoogleChrome/lighthouse/issues/12295#issue-840261460 for more.
    const estimateFromJpeg = otherFormatSizes.jpegSize * 5 / 10;
    const estimateFromWebp = otherFormatSizes.webpSize * 8 / 10;
    return estimateFromJpeg / 2 + estimateFromWebp / 2;
  }

  /**
   * @param {LH.Artifacts} artifacts
   * @return {ByteEfficiencyAudit.ByteEfficiencyProduct}
   */
  static audit_(artifacts) {
    const pageURL = artifacts.URL.finalUrl;
    const images = artifacts.OptimizedImages;
    const imageElements = artifacts.ImageElements;
    /** @type {Map<string, LH.Artifacts.ImageElement>} */
    const imageElementsByURL = new Map();
    imageElements.forEach(img => imageElementsByURL.set(img.src, img));

    /** @type {Array<LH.Audit.ByteEfficiencyItem>} */
    const items = [];
    const warnings = [];
    for (const image of images) {
      if (image.failed) {
        warnings.push(`Unable to decode ${URL.getURLDisplayName(image.url)}`);
        continue;
      }

      // Skip if the image was already using a modern format.
      if (image.mimeType === 'image/webp' || image.mimeType === 'image/avif') continue;

      const jpegSize = image.jpegSize;
      let webpSize = image.webpSize;
      let avifSize = ModernImageFormats.estimateAvifSizeFromWebPAndJpegEstimates({
        jpegSize,
        webpSize,
      });
      let fromProtocol = true;

      if (typeof webpSize === 'undefined') {
        const imageElement = imageElementsByURL.get(image.url);
        if (!imageElement) {
          warnings.push(`Unable to locate resource ${URL.getURLDisplayName(image.url)}`);
          continue;
        }

        // Skip if we couldn't collect natural image size information.
        if (!imageElement.naturalDimensions) continue;
        const naturalHeight = imageElement.naturalDimensions.height;
        const naturalWidth = imageElement.naturalDimensions.width;
        // If naturalHeight or naturalWidth are falsy, information is not valid, skip.
        if (!naturalWidth || !naturalHeight) continue;

        webpSize = ModernImageFormats.estimateWebPSizeFromDimensions({
          naturalHeight,
          naturalWidth,
        });
        avifSize = ModernImageFormats.estimateAvifSizeFromDimensions({
          naturalHeight,
          naturalWidth,
        });
        fromProtocol = false;
      }

      if (webpSize === undefined || avifSize === undefined) continue;

      // Visible wasted bytes uses AVIF, but we still include the WebP savings in the LHR.
      const wastedWebpBytes = image.originalSize - webpSize;
      const wastedBytes = image.originalSize - avifSize;
      if (wastedBytes < IGNORE_THRESHOLD_IN_BYTES) continue;

      const url = URL.elideDataURI(image.url);
      const isCrossOrigin = !URL.originsMatch(pageURL, image.url);

      items.push({
        url,
        fromProtocol,
        isCrossOrigin,
        totalBytes: image.originalSize,
        wastedBytes,
        wastedWebpBytes,
      });
    }

    /** @type {LH.Audit.Details.Opportunity['headings']} */
    const headings = [
      {key: 'url', valueType: 'thumbnail', label: ''},
      {key: 'url', valueType: 'url', label: str_(i18n.UIStrings.columnURL)},
      {key: 'totalBytes', valueType: 'bytes', label: str_(i18n.UIStrings.columnResourceSize)},
      {key: 'wastedBytes', valueType: 'bytes', label: str_(i18n.UIStrings.columnWastedBytes)},
    ];

    return {
      warnings,
      items,
      headings,
    };
  }
}

module.exports = ModernImageFormats;
module.exports.UIStrings = UIStrings;

}).call(this)}).call(this,"/lighthouse-core/audits/byte-efficiency/modern-image-formats.js")
},{"../../lib/i18n/i18n.js":96,"../../lib/url-shim.js":"url","./byte-efficiency-audit.js":4}],"../audits/byte-efficiency/offscreen-images":[function(require,module,exports){
(function (__filename){(function (){
/**
 * @license Copyright 2017 The Lighthouse Authors. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.
 */
/**
 * @fileoverview Checks to see if images are displayed only outside of the viewport.
 *     Images requested after TTI are not flagged as violations.
 */
'use strict';

const ByteEfficiencyAudit = require('./byte-efficiency-audit.js');
const Sentry = require('../../lib/sentry.js');
const URL = require('../../lib/url-shim.js');
const i18n = require('../../lib/i18n/i18n.js');
const Interactive = require('../../computed/metrics/interactive.js');
const ProcessedTrace = require('../../computed/processed-trace.js');

const UIStrings = {
  /** Imperative title of a Lighthouse audit that tells the user to defer loading offscreen images. Offscreen images are images located outside of the visible browser viewport. As they are unseen by the user and slow down page load, they should be loaded later, closer to when the user is going to see them. This is displayed in a list of audit titles that Lighthouse generates. */
  title: 'Defer offscreen images',
  /** Description of a Lighthouse audit that tells the user *why* they should defer loading offscreen images. Offscreen images are images located outside of the visible browser viewport. As they are unseen by the user and slow down page load, they should be loaded later, closer to when the user is going to see them. This is displayed after a user expands the section to see more. No character length limits. 'Learn More' becomes link text to additional documentation. */
  description:
    'Consider lazy-loading offscreen and hidden images after all critical resources have ' +
    'finished loading to lower time to interactive. ' +
    '[Learn more](https://web.dev/offscreen-images/).',
};

const str_ = i18n.createMessageInstanceIdFn(__filename, UIStrings);

// See https://github.com/GoogleChrome/lighthouse/issues/10471 for discussion about the thresholds here.
const ALLOWABLE_OFFSCREEN_IN_PX = 100;
const ALLOWABLE_OFFSCREEN_BOTTOM_IN_VIEWPORTS = 3;

const IGNORE_THRESHOLD_IN_BYTES = 2048;
const IGNORE_THRESHOLD_IN_PERCENT = 75;
const IGNORE_THRESHOLD_IN_MS = 50;

/** @typedef {{url: string, requestStartTime: number, totalBytes: number, wastedBytes: number, wastedPercent: number}} WasteResult */

class OffscreenImages extends ByteEfficiencyAudit {
  /**
   * @return {LH.Audit.Meta}
   */
  static get meta() {
    return {
      id: 'offscreen-images',
      title: str_(UIStrings.title),
      description: str_(UIStrings.description),
      scoreDisplayMode: ByteEfficiencyAudit.SCORING_MODES.NUMERIC,
      supportedModes: ['navigation'],
      requiredArtifacts: ['ImageElements', 'ViewportDimensions', 'GatherContext', 'devtoolsLogs',
        'traces'],
    };
  }

  /**
   * @param {{top: number, bottom: number, left: number, right: number}} imageRect
   * @param {{innerWidth: number, innerHeight: number}} viewportDimensions
   * @return {number}
   */
  static computeVisiblePixels(imageRect, viewportDimensions) {
    const innerWidth = viewportDimensions.innerWidth;
    const innerHeight = viewportDimensions.innerHeight;
    const allowableOffscreenBottomInPx = ALLOWABLE_OFFSCREEN_BOTTOM_IN_VIEWPORTS *
      viewportDimensions.innerHeight;

    const top = Math.max(imageRect.top, -1 * ALLOWABLE_OFFSCREEN_IN_PX);
    const right = Math.min(imageRect.right, innerWidth + ALLOWABLE_OFFSCREEN_IN_PX);
    const bottom = Math.min(imageRect.bottom, innerHeight + allowableOffscreenBottomInPx);
    const left = Math.max(imageRect.left, -1 * ALLOWABLE_OFFSCREEN_IN_PX);

    return Math.max(right - left, 0) * Math.max(bottom - top, 0);
  }

  /**
   * @param {LH.Artifacts.ImageElement} image
   * @param {{innerWidth: number, innerHeight: number}} viewportDimensions
   * @param {Array<LH.Artifacts.NetworkRequest>} networkRecords
   * @return {null|Error|WasteResult}
   */
  static computeWaste(image, viewportDimensions, networkRecords) {
    const networkRecord = networkRecords.find(record => record.url === image.src);
    // If we don't know how big it was, we can't really report savings, treat it as passed.
    if (!networkRecord) return null;
    // If the image had its loading behavior explicitly controlled already, treat it as passed.
    if (image.loading === 'lazy' || image.loading === 'eager') return null;

    const url = URL.elideDataURI(image.src);
    const totalPixels = image.displayedWidth * image.displayedHeight;
    const visiblePixels = this.computeVisiblePixels(image.clientRect, viewportDimensions);
    // Treat images with 0 area as if they're offscreen. See https://github.com/GoogleChrome/lighthouse/issues/1914
    const wastedRatio = totalPixels === 0 ? 1 : 1 - visiblePixels / totalPixels;
    // Resource size is almost always the right one to be using because of the below:
    //     transferSize = resourceSize + headers.length
    // HOWEVER, there are some cases where an image is compressed again over the network and transfer size
    // is smaller (see https://github.com/GoogleChrome/lighthouse/pull/4968).
    // Use the min of the two numbers to be safe.
    const {resourceSize = 0, transferSize = 0} = networkRecord;
    const totalBytes = Math.min(resourceSize, transferSize);
    const wastedBytes = Math.round(totalBytes * wastedRatio);

    if (!Number.isFinite(wastedRatio)) {
      return new Error(`Invalid image sizing information ${url}`);
    }

    return {
      url,
      requestStartTime: networkRecord.startTime,
      totalBytes,
      wastedBytes,
      wastedPercent: 100 * wastedRatio,
    };
  }

  /**
   * Filters out image requests that were requested after the last long task based on lantern timings.
   *
   * @param {WasteResult[]} images
   * @param {LH.Artifacts.LanternMetric} lanternMetricData
   */
  static filterLanternResults(images, lanternMetricData) {
    const nodeTimings = lanternMetricData.pessimisticEstimate.nodeTimings;

    // Find the last long task start time
    let lastLongTaskStartTime = 0;
    // Find the start time of all requests
    /** @type {Map<string, number>} */
    const startTimesByURL = new Map();
    for (const [node, timing] of nodeTimings) {
      if (node.type === 'cpu' && timing.duration >= 50) {
        lastLongTaskStartTime = Math.max(lastLongTaskStartTime, timing.startTime);
      } else if (node.type === 'network') {
        startTimesByURL.set(node.record.url, timing.startTime);
      }
    }

    return images.filter(image => {
      // Filter out images that had little waste
      if (image.wastedBytes < IGNORE_THRESHOLD_IN_BYTES) return false;
      if (image.wastedPercent < IGNORE_THRESHOLD_IN_PERCENT) return false;
      // Filter out images that started after the last long task
      const imageRequestStartTime = startTimesByURL.get(image.url) || 0;
      return imageRequestStartTime < lastLongTaskStartTime - IGNORE_THRESHOLD_IN_MS;
    });
  }

  /**
   * Filters out image requests that were requested after TTI.
   *
   * @param {WasteResult[]} images
   * @param {number} interactiveTimestamp
   */
  static filterObservedResults(images, interactiveTimestamp) {
    return images.filter(image => {
      if (image.wastedBytes < IGNORE_THRESHOLD_IN_BYTES) return false;
      if (image.wastedPercent < IGNORE_THRESHOLD_IN_PERCENT) return false;
      return image.requestStartTime < interactiveTimestamp / 1e6 - IGNORE_THRESHOLD_IN_MS / 1000;
    });
  }

  /**
   * The default byte efficiency audit will report max(TTI, load), since lazy-loading offscreen
   * images won't reduce the overall time and the wasted bytes are really only "wasted" for TTI,
   * override the function to just look at TTI savings.
   *
   * @param {Array<LH.Audit.ByteEfficiencyItem>} results
   * @param {LH.Gatherer.Simulation.GraphNode} graph
   * @param {LH.Gatherer.Simulation.Simulator} simulator
   * @return {number}
   */
  static computeWasteWithTTIGraph(results, graph, simulator) {
    return super.computeWasteWithTTIGraph(results, graph, simulator,
      {includeLoad: false});
  }

  /**
   * @param {LH.Artifacts} artifacts
   * @param {Array<LH.Artifacts.NetworkRequest>} networkRecords
   * @param {LH.Audit.Context} context
   * @return {Promise<ByteEfficiencyAudit.ByteEfficiencyProduct>}
   */
  static async audit_(artifacts, networkRecords, context) {
    const images = artifacts.ImageElements;
    const viewportDimensions = artifacts.ViewportDimensions;
    const gatherContext = artifacts.GatherContext;
    const trace = artifacts.traces[ByteEfficiencyAudit.DEFAULT_PASS];
    const devtoolsLog = artifacts.devtoolsLogs[ByteEfficiencyAudit.DEFAULT_PASS];

    /** @type {string[]} */
    const warnings = [];
    const resultsMap = images.reduce((results, image) => {
      const processed = OffscreenImages.computeWaste(image, viewportDimensions, networkRecords);
      if (processed === null) {
        return results;
      }

      if (processed instanceof Error) {
        warnings.push(processed.message);
        Sentry.captureException(processed, {tags: {audit: this.meta.id}, level: 'warning'});
        return results;
      }

      // If an image was used more than once, warn only about its least wasteful usage
      const existing = results.get(processed.url);
      if (!existing || existing.wastedBytes > processed.wastedBytes) {
        results.set(processed.url, processed);
      }

      return results;
    }, /** @type {Map<string, WasteResult>} */ (new Map()));

    const settings = context.settings;

    let items;
    const unfilteredResults = Array.from(resultsMap.values());
    // get the interactive time or fallback to getting the end of trace time
    try {
      const metricComputationData = {trace, devtoolsLog, gatherContext, settings};
      const interactive = await Interactive.request(metricComputationData, context);

      // use interactive to generate items
      const lanternInteractive = /** @type {LH.Artifacts.LanternMetric} */ (interactive);
      // Filter out images that were loaded after all CPU activity
      items = context.settings.throttlingMethod === 'simulate' ?
        OffscreenImages.filterLanternResults(unfilteredResults, lanternInteractive) :
        // @ts-expect-error - .timestamp will exist if throttlingMethod isn't lantern
        OffscreenImages.filterObservedResults(unfilteredResults, interactive.timestamp);
    } catch (err) {
      // if the error is during a Lantern run, end of trace may also be inaccurate, so rethrow
      if (context.settings.throttlingMethod === 'simulate') {
        throw err;
      }
      // use end of trace as a substitute for finding interactive time
      items = OffscreenImages.filterObservedResults(unfilteredResults,
        await ProcessedTrace.request(trace, context).then(tot => tot.timestamps.traceEnd));
    }

    /** @type {LH.Audit.Details.Opportunity['headings']} */
    const headings = [
      {key: 'url', valueType: 'thumbnail', label: ''},
      {key: 'url', valueType: 'url', label: str_(i18n.UIStrings.columnURL)},
      {key: 'totalBytes', valueType: 'bytes', label: str_(i18n.UIStrings.columnResourceSize)},
      {key: 'wastedBytes', valueType: 'bytes', label: str_(i18n.UIStrings.columnWastedBytes)},
    ];

    return {
      warnings,
      items,
      headings,
    };
  }
}

module.exports = OffscreenImages;
module.exports.UIStrings = UIStrings;

}).call(this)}).call(this,"/lighthouse-core/audits/byte-efficiency/offscreen-images.js")
},{"../../computed/metrics/interactive.js":21,"../../computed/processed-trace.js":43,"../../lib/i18n/i18n.js":96,"../../lib/sentry.js":112,"../../lib/url-shim.js":"url","./byte-efficiency-audit.js":4}],"../audits/byte-efficiency/render-blocking-resources":[function(require,module,exports){
(function (__filename){(function (){
/**
 * @license Copyright 2018 The Lighthouse Authors. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.
 */

/**
 * @fileoverview Audit a page to see if it does have resources that are blocking first paint
 */
'use strict';

const Audit = require('../audit.js');
const i18n = require('../../lib/i18n/i18n.js');
const BaseNode = require('../../lib/dependency-graph/base-node.js');
const ByteEfficiencyAudit = require('./byte-efficiency-audit.js');
const UnusedCSS = require('../../computed/unused-css.js');
const NetworkRequest = require('../../lib/network-request.js');
const ProcessedTrace = require('../../computed/processed-trace.js');
const ProcessedNavigation = require('../../computed/processed-navigation.js');
const LoadSimulator = require('../../computed/load-simulator.js');
const FirstContentfulPaint = require('../../computed/metrics/first-contentful-paint.js');

/** @typedef {import('../../lib/dependency-graph/simulator/simulator')} Simulator */
/** @typedef {import('../../lib/dependency-graph/base-node.js').Node} Node */
/** @typedef {import('../../lib/dependency-graph/network-node.js')} NetworkNode */

// Because of the way we detect blocking stylesheets, asynchronously loaded
// CSS with link[rel=preload] and an onload handler (see https://github.com/filamentgroup/loadCSS)
// can be falsely flagged as blocking. Therefore, ignore stylesheets that loaded fast enough
// to possibly be non-blocking (and they have minimal impact anyway).
const MINIMUM_WASTED_MS = 50;

const UIStrings = {
  /** Imperative title of a Lighthouse audit that tells the user to reduce or remove network resources that block the initial render of the page. This is displayed in a list of audit titles that Lighthouse generates. */
  title: 'Eliminate render-blocking resources',
  /** Description of a Lighthouse audit that tells the user *why* they should reduce or remove network resources that block the initial render of the page. This is displayed after a user expands the section to see more. No character length limits. 'Learn More' becomes link text to additional documentation. */
  description: 'Resources are blocking the first paint of your page. Consider ' +
    'delivering critical JS/CSS inline and deferring all non-critical ' +
    'JS/styles. [Learn more](https://web.dev/render-blocking-resources/).',
};

const str_ = i18n.createMessageInstanceIdFn(__filename, UIStrings);

/**
 * Given a simulation's nodeTimings, return an object with the nodes/timing keyed by network URL
 * @param {LH.Gatherer.Simulation.Result['nodeTimings']} nodeTimings
 * @return {Object<string, {node: Node, nodeTiming: LH.Gatherer.Simulation.NodeTiming}>}
 */
function getNodesAndTimingByUrl(nodeTimings) {
  /** @type {Object<string, {node: Node, nodeTiming: LH.Gatherer.Simulation.NodeTiming}>} */
  const urlMap = {};
  const nodes = Array.from(nodeTimings.keys());
  nodes.forEach(node => {
    if (node.type !== 'network') return;
    const nodeTiming = nodeTimings.get(node);
    if (!nodeTiming) return;

    urlMap[node.record.url] = {node, nodeTiming};
  });

  return urlMap;
}

/**
 * Adjust the timing of a node and its dependencies to account for stack specific overrides.
 * @param {Map<Node, LH.Gatherer.Simulation.NodeTiming>} adjustedNodeTimings
 * @param {Node} node
 * @param {LH.Artifacts.DetectedStack[]} Stacks
 */
function adjustNodeTimings(adjustedNodeTimings, node, Stacks) {
  const nodeTiming = adjustedNodeTimings.get(node);
  if (!nodeTiming) return;
  const stackSpecificTiming = computeStackSpecificTiming(node, nodeTiming, Stacks);
  const difference = nodeTiming.duration - stackSpecificTiming.duration;
  if (!difference) return;

  // AMP's method of removal of stylesheets effectively removes all dependent nodes from the FCP graph
  node.traverse(childNode => {
    adjustedNodeTimings.delete(childNode);
  });
  adjustedNodeTimings.set(node, stackSpecificTiming);
}

/**
 * Any stack specific timing overrides should go in this function.
 * @see https://github.com/GoogleChrome/lighthouse/issues/2832#issuecomment-591066081
 *
 * @param {Node} node
 * @param {LH.Gatherer.Simulation.NodeTiming} nodeTiming
 * @param {LH.Artifacts.DetectedStack[]} Stacks
 */
function computeStackSpecificTiming(node, nodeTiming, Stacks) {
  const stackSpecificTiming = {...nodeTiming};
  if (Stacks.some(stack => stack.id === 'amp')) {
    // AMP will load a linked stylesheet asynchronously if it has not been loaded after 2.1 seconds:
    // https://github.com/ampproject/amphtml/blob/8e03ac2f315774070651584a7e046ff24212c9b1/src/font-stylesheet-timeout.js#L54-L59
    // Any potential savings must only include time spent on AMP stylesheet nodes before 2.1 seconds.
    if (node.type === BaseNode.TYPES.NETWORK &&
        node.record.resourceType === NetworkRequest.TYPES.Stylesheet &&
        nodeTiming.endTime > 2100) {
      stackSpecificTiming.endTime = Math.max(nodeTiming.startTime, 2100);
      stackSpecificTiming.duration = stackSpecificTiming.endTime - stackSpecificTiming.startTime;
    }
  }
  return stackSpecificTiming;
}

class RenderBlockingResources extends Audit {
  /**
   * @return {LH.Audit.Meta}
   */
  static get meta() {
    return {
      id: 'render-blocking-resources',
      title: str_(UIStrings.title),
      supportedModes: ['navigation'],
      scoreDisplayMode: Audit.SCORING_MODES.NUMERIC,
      description: str_(UIStrings.description),
      // TODO: look into adding an `optionalArtifacts` property that captures the non-required nature
      // of CSSUsage
      requiredArtifacts: ['URL', 'TagsBlockingFirstPaint', 'traces', 'devtoolsLogs', 'CSSUsage',
        'GatherContext', 'Stacks'],
    };
  }

  /**
   * @param {LH.Artifacts} artifacts
   * @param {LH.Audit.Context} context
   * @return {Promise<{wastedMs: number, results: Array<{url: string, totalBytes: number, wastedMs: number}>}>}
   */
  static async computeResults(artifacts, context) {
    const gatherContext = artifacts.GatherContext;
    const trace = artifacts.traces[Audit.DEFAULT_PASS];
    const devtoolsLog = artifacts.devtoolsLogs[Audit.DEFAULT_PASS];
    const simulatorData = {devtoolsLog, settings: context.settings};
    const processedTrace = await ProcessedTrace.request(trace, context);
    const processedNavigation = await ProcessedNavigation.request(processedTrace, context);
    const simulator = await LoadSimulator.request(simulatorData, context);
    const wastedCssBytes = await RenderBlockingResources.computeWastedCSSBytes(artifacts, context);

    /** @type {Immutable<LH.Config.Settings>} */
    const metricSettings = {
      ...context.settings,
      throttlingMethod: 'simulate',
    };

    const metricComputationData = {trace, devtoolsLog, gatherContext, simulator,
      settings: metricSettings};

    // Cast to just `LanternMetric` since we explicitly set `throttlingMethod: 'simulate'`.
    const fcpSimulation = /** @type {LH.Artifacts.LanternMetric} */
      (await FirstContentfulPaint.request(metricComputationData, context));
    const fcpTsInMs = processedNavigation.timestamps.firstContentfulPaint / 1000;

    const nodesByUrl = getNodesAndTimingByUrl(fcpSimulation.optimisticEstimate.nodeTimings);

    const results = [];
    const deferredNodeIds = new Set();
    for (const resource of artifacts.TagsBlockingFirstPaint) {
      // Ignore any resources that finished after observed FCP (they're clearly not render-blocking)
      if (resource.endTime * 1000 > fcpTsInMs) continue;
      // TODO: beacon to Sentry, https://github.com/GoogleChrome/lighthouse/issues/7041
      if (!nodesByUrl[resource.tag.url]) continue;

      const {node, nodeTiming} = nodesByUrl[resource.tag.url];

      const stackSpecificTiming = computeStackSpecificTiming(node, nodeTiming, artifacts.Stacks);

      // Mark this node and all its dependents as deferrable
      node.traverse(node => deferredNodeIds.add(node.id));

      // "wastedMs" is the download time of the network request, responseReceived - requestSent
      const wastedMs = Math.round(stackSpecificTiming.duration);
      if (wastedMs < MINIMUM_WASTED_MS) continue;

      results.push({
        url: resource.tag.url,
        totalBytes: resource.transferSize,
        wastedMs,
      });
    }

    if (!results.length) {
      return {results, wastedMs: 0};
    }

    const wastedMs = RenderBlockingResources.estimateSavingsWithGraphs(
      simulator,
      fcpSimulation.optimisticGraph,
      deferredNodeIds,
      wastedCssBytes,
      artifacts.Stacks
    );

    return {results, wastedMs};
  }

  /**
   * Estimates how much faster this page would reach FCP if we inlined all the used CSS from the
   * render blocking stylesheets and deferred all the scripts. This is more conservative than
   * removing all the assets and more aggressive than inlining everything.
   *
   * *Most* of the time, scripts in the head are there accidentally/due to lack of awareness
   * rather than necessity, so we're comfortable with this balance. In the worst case, we're telling
   * devs that they should be able to get to a reasonable first paint without JS, which is not a bad
   * thing.
   *
   * @param {Simulator} simulator
   * @param {Node} fcpGraph
   * @param {Set<string>} deferredIds
   * @param {Map<string, number>} wastedCssBytesByUrl
   * @param {LH.Artifacts.DetectedStack[]} Stacks
   * @return {number}
   */
  static estimateSavingsWithGraphs(simulator, fcpGraph, deferredIds, wastedCssBytesByUrl, Stacks) {
    const {nodeTimings} = simulator.simulate(fcpGraph);
    const adjustedNodeTimings = new Map(nodeTimings);

    let totalChildNetworkBytes = 0;
    const minimalFCPGraph = fcpGraph.cloneWithRelationships(node => {
      adjustNodeTimings(adjustedNodeTimings, node, Stacks);

      // If a node can be deferred, exclude it from the new FCP graph
      const canDeferRequest = deferredIds.has(node.id);
      if (node.type !== BaseNode.TYPES.NETWORK) return !canDeferRequest;

      const isStylesheet =
        node.record.resourceType === NetworkRequest.TYPES.Stylesheet;
      if (canDeferRequest && isStylesheet) {
        // We'll inline the used bytes of the stylesheet and assume the rest can be deferred
        const wastedBytes = wastedCssBytesByUrl.get(node.record.url) || 0;
        totalChildNetworkBytes += (node.record.transferSize || 0) - wastedBytes;
      }
      return !canDeferRequest;
    });

    if (minimalFCPGraph.type !== 'network') {
      throw new Error('minimalFCPGraph not a NetworkNode');
    }

    // Recalculate the "before" time based on our adjusted node timings.
    const estimateBeforeInline = Math.max(...Array.from(
      Array.from(adjustedNodeTimings).map(timing => timing[1].endTime)
    ));

    // Add the inlined bytes to the HTML response
    const originalTransferSize = minimalFCPGraph.record.transferSize;
    const safeTransferSize = originalTransferSize || 0;
    minimalFCPGraph.record.transferSize = safeTransferSize + totalChildNetworkBytes;
    const estimateAfterInline = simulator.simulate(minimalFCPGraph).timeInMs;
    minimalFCPGraph.record.transferSize = originalTransferSize;
    return Math.round(Math.max(estimateBeforeInline - estimateAfterInline, 0));
  }

  /**
   * @param {LH.Artifacts} artifacts
   * @param {LH.Audit.Context} context
   * @return {Promise<Map<string, number>>}
   */
  static async computeWastedCSSBytes(artifacts, context) {
    const wastedBytesByUrl = new Map();
    try {
      const unusedCssItems = await UnusedCSS.request({
        CSSUsage: artifacts.CSSUsage,
        URL: artifacts.URL,
        devtoolsLog: artifacts.devtoolsLogs[Audit.DEFAULT_PASS],
      }, context);
      for (const item of unusedCssItems) {
        wastedBytesByUrl.set(item.url, item.wastedBytes);
      }
    } catch (_) {}

    return wastedBytesByUrl;
  }

  /**
   * @param {LH.Artifacts} artifacts
   * @param {LH.Audit.Context} context
   * @return {Promise<LH.Audit.Product>}
   */
  static async audit(artifacts, context) {
    const {results, wastedMs} = await RenderBlockingResources.computeResults(artifacts, context);

    let displayValue;
    if (results.length > 0) {
      displayValue = str_(i18n.UIStrings.displayValueMsSavings, {wastedMs});
    }

    /** @type {LH.Audit.Details.Opportunity['headings']} */
    const headings = [
      {key: 'url', valueType: 'url', label: str_(i18n.UIStrings.columnURL)},
      {key: 'totalBytes', valueType: 'bytes', label: str_(i18n.UIStrings.columnTransferSize)},
      {key: 'wastedMs', valueType: 'timespanMs', label: str_(i18n.UIStrings.columnWastedMs)},
    ];

    const details = Audit.makeOpportunityDetails(headings, results, wastedMs);

    return {
      displayValue,
      score: ByteEfficiencyAudit.scoreForWastedMs(wastedMs),
      numericValue: wastedMs,
      numericUnit: 'millisecond',
      details,
    };
  }
}

module.exports = RenderBlockingResources;
module.exports.UIStrings = UIStrings;

}).call(this)}).call(this,"/lighthouse-core/audits/byte-efficiency/render-blocking-resources.js")
},{"../../computed/load-simulator.js":13,"../../computed/metrics/first-contentful-paint.js":19,"../../computed/processed-navigation.js":42,"../../computed/processed-trace.js":43,"../../computed/unused-css.js":48,"../../lib/dependency-graph/base-node.js":86,"../../lib/i18n/i18n.js":96,"../../lib/network-request.js":109,"../audit.js":3,"./byte-efficiency-audit.js":4}],"../audits/byte-efficiency/total-byte-weight":[function(require,module,exports){
(function (__filename){(function (){
/**
 * @license Copyright 2017 The Lighthouse Authors. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.
 */
'use strict';

const Audit = require('../audit.js');
const i18n = require('../../lib/i18n/i18n.js');
const NetworkRequest = require('../../lib/network-request.js');
const NetworkRecords = require('../../computed/network-records.js');

const UIStrings = {
  /** Title of a diagnostic audit that provides detail on large network resources required during page load. 'Payloads' is roughly equivalent to 'resources'. This descriptive title is shown to users when the amount is acceptable and no user action is required. */
  title: 'Avoids enormous network payloads',
  /** Title of a diagnostic audit that provides detail on large network resources required during page load. 'Payloads' is roughly equivalent to 'resources'. This imperative title is shown to users when there is a significant amount of execution time that could be reduced. */
  failureTitle: 'Avoid enormous network payloads',
  /** Description of a Lighthouse audit that tells the user *why* they should reduce the size of the network resources required by the page. This is displayed after a user expands the section to see more. No character length limits. 'Learn More' becomes link text to additional documentation. */
  description:
  'Large network payloads cost users real money and are highly correlated with ' +
  'long load times. [Learn ' +
  'more](https://web.dev/total-byte-weight/).',
  /** Used to summarize the total byte size of the page and all its network requests. The `{totalBytes}` placeholder will be replaced with the total byte sizes, shown in kibibytes (e.g. 142 KiB) */
  displayValue: 'Total size was {totalBytes, number, bytes}\xa0KiB',
};

const str_ = i18n.createMessageInstanceIdFn(__filename, UIStrings);

class TotalByteWeight extends Audit {
  /**
   * @return {LH.Audit.Meta}
   */
  static get meta() {
    return {
      id: 'total-byte-weight',
      title: str_(UIStrings.title),
      failureTitle: str_(UIStrings.failureTitle),
      description: str_(UIStrings.description),
      scoreDisplayMode: Audit.SCORING_MODES.NUMERIC,
      requiredArtifacts: ['devtoolsLogs'],
    };
  }

  /**
   * @return {LH.Audit.ScoreOptions}
   */
  static get defaultOptions() {
    return {
      // see https://www.desmos.com/calculator/h7kfv68jre
      // ~25th and ~10th percentiles, with resulting p10 computed.
      // http://httparchive.org/interesting.php?a=All&l=Feb%201%202017&s=All#bytesTotal
      p10: 2667 * 1024,
      median: 4000 * 1024,
    };
  }

  /**
   * @param {LH.Artifacts} artifacts
   * @param {LH.Audit.Context} context
   * @return {Promise<LH.Audit.Product>}
   */
  static async audit(artifacts, context) {
    const devtoolsLog = artifacts.devtoolsLogs[Audit.DEFAULT_PASS];
    const records = await NetworkRecords.request(devtoolsLog, context);

    let totalBytes = 0;
    /** @type {Array<{url: string, totalBytes: number}>} */
    let results = [];
    records.forEach(record => {
      // Exclude non-network URIs since their size is reflected in other resources.
      // Exclude records without transfer size information (or 0 bytes which won't matter anyway).
      if (NetworkRequest.isNonNetworkRequest(record) || !record.transferSize) return;

      const result = {
        url: record.url,
        totalBytes: record.transferSize,
      };

      totalBytes += result.totalBytes;
      results.push(result);
    });
    results = results.sort((itemA, itemB) => {
      return itemB.totalBytes - itemA.totalBytes ||
        itemA.url.localeCompare(itemB.url);
    }).slice(0, 10);

    const score = Audit.computeLogNormalScore(
      {p10: context.options.p10, median: context.options.median},
      totalBytes
    );

    /** @type {LH.Audit.Details.Table['headings']} */
    const headings = [
      {key: 'url', itemType: 'url', text: str_(i18n.UIStrings.columnURL)},
      {key: 'totalBytes', itemType: 'bytes', text: str_(i18n.UIStrings.columnTransferSize)},
    ];

    const tableDetails = Audit.makeTableDetails(headings, results);

    return {
      score,
      numericValue: totalBytes,
      numericUnit: 'byte',
      displayValue: str_(UIStrings.displayValue, {totalBytes}),
      details: tableDetails,
    };
  }
}

module.exports = TotalByteWeight;
module.exports.UIStrings = UIStrings;

}).call(this)}).call(this,"/lighthouse-core/audits/byte-efficiency/total-byte-weight.js")
},{"../../computed/network-records.js":40,"../../lib/i18n/i18n.js":96,"../../lib/network-request.js":109,"../audit.js":3}],"../audits/byte-efficiency/unminified-css":[function(require,module,exports){
(function (__filename){(function (){
/**
 * @license Copyright 2017 The Lighthouse Authors. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.
 */
'use strict';

const ByteEfficiencyAudit = require('./byte-efficiency-audit.js');
const UnusedCSS = require('../../computed/unused-css.js');
const i18n = require('../../lib/i18n/i18n.js');
const computeTokenLength = require('../../lib/minification-estimator.js').computeCSSTokenLength;

const UIStrings = {
  /** Imperative title of a Lighthouse audit that tells the user to minify (remove whitespace) the page's CSS code. This is displayed in a list of audit titles that Lighthouse generates. */
  title: 'Minify CSS',
  /** Description of a Lighthouse audit that tells the user *why* they should minify (remove whitespace) the page's CSS code. This is displayed after a user expands the section to see more. No character length limits. 'Learn More' becomes link text to additional documentation. */
  description: 'Minifying CSS files can reduce network payload sizes. ' +
    '[Learn more](https://web.dev/unminified-css/).',
};

const str_ = i18n.createMessageInstanceIdFn(__filename, UIStrings);

const IGNORE_THRESHOLD_IN_PERCENT = 5;
const IGNORE_THRESHOLD_IN_BYTES = 2048;

/**
 * @fileOverview
 */
class UnminifiedCSS extends ByteEfficiencyAudit {
  /**
   * @return {LH.Audit.Meta}
   */
  static get meta() {
    return {
      id: 'unminified-css',
      title: str_(UIStrings.title),
      description: str_(UIStrings.description),
      scoreDisplayMode: ByteEfficiencyAudit.SCORING_MODES.NUMERIC,
      requiredArtifacts: ['CSSUsage', 'devtoolsLogs', 'traces', 'URL', 'GatherContext'],
    };
  }

  /**
   * Computes the total length of the meaningful tokens (CSS excluding comments and whitespace).
   *
   * @param {string} content
   * @return {number}
   */
  static computeTokenLength(content) {
    return computeTokenLength(content);
  }

  /**
   * @param {LH.Artifacts.CSSStyleSheetInfo} stylesheet
   * @param {LH.Artifacts.NetworkRequest|undefined} networkRecord
   * @param {string} pageUrl
   * @return {{url: string, totalBytes: number, wastedBytes: number, wastedPercent: number}}
   */
  static computeWaste(stylesheet, networkRecord, pageUrl) {
    const content = stylesheet.content;
    const totalTokenLength = UnminifiedCSS.computeTokenLength(content);

    let url = stylesheet.header.sourceURL;
    if (!url || url === pageUrl) {
      const contentPreview = UnusedCSS.determineContentPreview(stylesheet.content);
      url = contentPreview;
    }

    const totalBytes = ByteEfficiencyAudit.estimateTransferSize(networkRecord, content.length,
      'Stylesheet');
    const wastedRatio = 1 - totalTokenLength / content.length;
    const wastedBytes = Math.round(totalBytes * wastedRatio);

    return {
      url,
      totalBytes,
      wastedBytes,
      wastedPercent: 100 * wastedRatio,
    };
  }

  /**
   * @param {LH.Artifacts} artifacts
   * @param {Array<LH.Artifacts.NetworkRequest>} networkRecords
   * @return {ByteEfficiencyAudit.ByteEfficiencyProduct}
   */
  static audit_(artifacts, networkRecords) {
    const pageUrl = artifacts.URL.finalUrl;
    const items = [];
    for (const stylesheet of artifacts.CSSUsage.stylesheets) {
      const networkRecord = networkRecords
        .find(record => record.url === stylesheet.header.sourceURL);
      if (!stylesheet.content) continue;

      const result = UnminifiedCSS.computeWaste(stylesheet, networkRecord, pageUrl);

      // If the ratio is minimal, the file is likely already minified, so ignore it.
      // If the total number of bytes to be saved is quite small, it's also safe to ignore.
      if (result.wastedPercent < IGNORE_THRESHOLD_IN_PERCENT ||
          result.wastedBytes < IGNORE_THRESHOLD_IN_BYTES ||
          !Number.isFinite(result.wastedBytes)) continue;
      items.push(result);
    }

    /** @type {LH.Audit.Details.Opportunity['headings']} */
    const headings = [
      {key: 'url', valueType: 'url', label: str_(i18n.UIStrings.columnURL)},
      {key: 'totalBytes', valueType: 'bytes', label: str_(i18n.UIStrings.columnTransferSize)},
      {key: 'wastedBytes', valueType: 'bytes', label: str_(i18n.UIStrings.columnWastedBytes)},
    ];

    return {items, headings};
  }
}

module.exports = UnminifiedCSS;
module.exports.UIStrings = UIStrings;

}).call(this)}).call(this,"/lighthouse-core/audits/byte-efficiency/unminified-css.js")
},{"../../computed/unused-css.js":48,"../../lib/i18n/i18n.js":96,"../../lib/minification-estimator.js":106,"./byte-efficiency-audit.js":4}],"../audits/byte-efficiency/unminified-javascript":[function(require,module,exports){
(function (__filename){(function (){
/**
 * @license Copyright 2017 The Lighthouse Authors. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.
 */
'use strict';

const ByteEfficiencyAudit = require('./byte-efficiency-audit.js');
const i18n = require('../../lib/i18n/i18n.js');
const computeTokenLength = require('../../lib/minification-estimator.js').computeJSTokenLength;

const UIStrings = {
  /** Imperative title of a Lighthouse audit that tells the user to minify the page’s JS code to reduce file size. This is displayed in a list of audit titles that Lighthouse generates. */
  title: 'Minify JavaScript',
  /** Description of a Lighthouse audit that tells the user *why* they should minify the page’s JS code to reduce file size. This is displayed after a user expands the section to see more. No character length limits. 'Learn More' becomes link text to additional documentation. */
  description: 'Minifying JavaScript files can reduce payload sizes and script parse time. ' +
    '[Learn more](https://web.dev/unminified-javascript/).',
};

const str_ = i18n.createMessageInstanceIdFn(__filename, UIStrings);

const IGNORE_THRESHOLD_IN_PERCENT = 10;
const IGNORE_THRESHOLD_IN_BYTES = 2048;

/**
 * @fileOverview Estimates minification savings by determining the ratio of parseable JS tokens to the
 * length of the entire string. Though simple, this method is quite accurate at identifying whether
 * a script was already minified and offers a relatively conservative minification estimate (our two
 * primary goals).
 *
 * This audit only examines scripts that were independent network requests and not inlined or eval'd.
 *
 * See https://github.com/GoogleChrome/lighthouse/pull/3950#issue-277887798 for stats on accuracy.
 */
class UnminifiedJavaScript extends ByteEfficiencyAudit {
  /**
   * @return {LH.Audit.Meta}
   */
  static get meta() {
    return {
      id: 'unminified-javascript',
      title: str_(UIStrings.title),
      description: str_(UIStrings.description),
      scoreDisplayMode: ByteEfficiencyAudit.SCORING_MODES.NUMERIC,
      requiredArtifacts: ['ScriptElements', 'devtoolsLogs', 'traces', 'GatherContext'],
    };
  }

  /**
   * @param {string} scriptContent
   * @param {string} displayUrl
   * @param {LH.Artifacts.NetworkRequest|undefined} networkRecord
   * @return {{url: string, totalBytes: number, wastedBytes: number, wastedPercent: number}}
   */
  static computeWaste(scriptContent, displayUrl, networkRecord) {
    const contentLength = scriptContent.length;
    const totalTokenLength = computeTokenLength(scriptContent);

    const totalBytes = ByteEfficiencyAudit.estimateTransferSize(networkRecord, contentLength,
      'Script');
    const wastedRatio = 1 - totalTokenLength / contentLength;
    const wastedBytes = Math.round(totalBytes * wastedRatio);

    return {
      url: displayUrl,
      totalBytes,
      wastedBytes,
      wastedPercent: 100 * wastedRatio,
    };
  }

  /**
   * @param {LH.Artifacts} artifacts
   * @param {Array<LH.Artifacts.NetworkRequest>} networkRecords
   * @return {ByteEfficiencyAudit.ByteEfficiencyProduct}
   */
  static audit_(artifacts, networkRecords) {
    /** @type {Array<LH.Audit.ByteEfficiencyItem>} */
    const items = [];
    const warnings = [];
    for (const {requestId, src, content} of artifacts.ScriptElements) {
      if (!content) continue;

      const networkRecord = networkRecords.find(record => record.requestId === requestId);
      const displayUrl = !src || !networkRecord ?
        `inline: ${content.substr(0, 40)}...` :
        networkRecord.url;
      try {
        const result = UnminifiedJavaScript.computeWaste(content, displayUrl, networkRecord);
        // If the ratio is minimal, the file is likely already minified, so ignore it.
        // If the total number of bytes to be saved is quite small, it's also safe to ignore.
        if (result.wastedPercent < IGNORE_THRESHOLD_IN_PERCENT ||
          result.wastedBytes < IGNORE_THRESHOLD_IN_BYTES ||
          !Number.isFinite(result.wastedBytes)) continue;
        items.push(result);
      } catch (err) {
        const url = networkRecord ? networkRecord.url : '?';
        warnings.push(`Unable to process script ${url}: ${err.message}`);
      }
    }

    /** @type {LH.Audit.Details.Opportunity['headings']} */
    const headings = [
      {key: 'url', valueType: 'url', label: str_(i18n.UIStrings.columnURL)},
      {key: 'totalBytes', valueType: 'bytes', label: str_(i18n.UIStrings.columnTransferSize)},
      {key: 'wastedBytes', valueType: 'bytes', label: str_(i18n.UIStrings.columnWastedBytes)},
    ];

    return {
      items,
      warnings,
      headings,
    };
  }
}

module.exports = UnminifiedJavaScript;
module.exports.UIStrings = UIStrings;

}).call(this)}).call(this,"/lighthouse-core/audits/byte-efficiency/unminified-javascript.js")
},{"../../lib/i18n/i18n.js":96,"../../lib/minification-estimator.js":106,"./byte-efficiency-audit.js":4}],"../audits/byte-efficiency/unused-css-rules":[function(require,module,exports){
(function (__filename){(function (){
/**
 * @license Copyright 2017 The Lighthouse Authors. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.
 */
'use strict';

const ByteEfficiencyAudit = require('./byte-efficiency-audit.js');
const UnusedCSS = require('../../computed/unused-css.js');
const i18n = require('../../lib/i18n/i18n.js');

const UIStrings = {
  /** Imperative title of a Lighthouse audit that tells the user to reduce content from their CSS that isn’t needed immediately and instead load that content at a later time. This is displayed in a list of audit titles that Lighthouse generates. */
  title: 'Reduce unused CSS',
  /** Description of a Lighthouse audit that tells the user *why* they should defer loading any content in CSS that isn’t needed at page load. This is displayed after a user expands the section to see more. No word length limits. 'Learn More' becomes link text to additional documentation. */
  description: 'Reduce unused rules from stylesheets and defer CSS not used for ' +
    'above-the-fold content to decrease bytes consumed by network activity. ' +
    '[Learn more](https://web.dev/unused-css-rules/).',
};

const str_ = i18n.createMessageInstanceIdFn(__filename, UIStrings);

// Allow 10KiB of unused CSS to permit `:hover` and other styles not used on a non-interactive load.
// @see https://github.com/GoogleChrome/lighthouse/issues/9353 for more discussion.
const IGNORE_THRESHOLD_IN_BYTES = 10 * 1024;

class UnusedCSSRules extends ByteEfficiencyAudit {
  /**
   * @return {LH.Audit.Meta}
   */
  static get meta() {
    return {
      id: 'unused-css-rules',
      title: str_(UIStrings.title),
      description: str_(UIStrings.description),
      scoreDisplayMode: ByteEfficiencyAudit.SCORING_MODES.NUMERIC,
      requiredArtifacts: ['CSSUsage', 'URL', 'devtoolsLogs', 'traces', 'GatherContext'],
    };
  }

  /**
   * @param {LH.Artifacts} artifacts
   * @param {LH.Artifacts.NetworkRequest[]} _
   * @param {LH.Audit.Context} context
   * @return {Promise<ByteEfficiencyAudit.ByteEfficiencyProduct>}
   */
  static async audit_(artifacts, _, context) {
    const unusedCssItems = await UnusedCSS.request({
      CSSUsage: artifacts.CSSUsage,
      URL: artifacts.URL,
      devtoolsLog: artifacts.devtoolsLogs[ByteEfficiencyAudit.DEFAULT_PASS],
    }, context);
    const items = unusedCssItems
      .filter(sheet => sheet && sheet.wastedBytes > IGNORE_THRESHOLD_IN_BYTES);

    /** @type {LH.Audit.Details.Opportunity['headings']} */
    const headings = [
      {key: 'url', valueType: 'url', label: str_(i18n.UIStrings.columnURL)},
      {key: 'totalBytes', valueType: 'bytes', label: str_(i18n.UIStrings.columnTransferSize)},
      {key: 'wastedBytes', valueType: 'bytes', label: str_(i18n.UIStrings.columnWastedBytes)},
    ];

    return {
      items,
      headings,
    };
  }
}

module.exports = UnusedCSSRules;
module.exports.UIStrings = UIStrings;

}).call(this)}).call(this,"/lighthouse-core/audits/byte-efficiency/unused-css-rules.js")
},{"../../computed/unused-css.js":48,"../../lib/i18n/i18n.js":96,"./byte-efficiency-audit.js":4}],"../audits/byte-efficiency/unused-javascript":[function(require,module,exports){
(function (__filename){(function (){
/**
 * @license Copyright 2017 The Lighthouse Authors. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.
 */
'use strict';

const ByteEfficiencyAudit = require('./byte-efficiency-audit.js');
const UnusedJavaScriptSummary = require('../../computed/unused-javascript-summary.js');
const JsBundles = require('../../computed/js-bundles.js');
const i18n = require('../../lib/i18n/i18n.js');

const UIStrings = {
  /** Imperative title of a Lighthouse audit that tells the user to reduce JavaScript that is never evaluated during page load. This is displayed in a list of audit titles that Lighthouse generates. */
  title: 'Reduce unused JavaScript',
  /** Description of a Lighthouse audit that tells the user *why* they should reduce JavaScript that is never needed/evaluated by the browser. This is displayed after a user expands the section to see more. No character length limits. 'Learn More' becomes link text to additional documentation. */
  description: 'Reduce unused JavaScript and defer loading scripts until they are required to ' +
    'decrease bytes consumed by network activity. [Learn more](https://web.dev/unused-javascript/).',
};

const str_ = i18n.createMessageInstanceIdFn(__filename, UIStrings);

const UNUSED_BYTES_IGNORE_THRESHOLD = 20 * 1024;
const UNUSED_BYTES_IGNORE_BUNDLE_SOURCE_THRESHOLD = 512;

/**
 * @param {string[]} strings
 */
function commonPrefix(strings) {
  if (!strings.length) {
    return '';
  }

  const maxWord = strings.reduce((a, b) => a > b ? a : b);
  let prefix = strings.reduce((a, b) => a > b ? b : a);
  while (!maxWord.startsWith(prefix)) {
    prefix = prefix.slice(0, -1);
  }

  return prefix;
}

/**
 * @param {string} string
 * @param {string} commonPrefix
 * @return {string}
 */
function trimCommonPrefix(string, commonPrefix) {
  if (!commonPrefix) return string;
  return string.startsWith(commonPrefix) ? '…' + string.slice(commonPrefix.length) : string;
}

/**
 * @typedef WasteData
 * @property {Uint8Array} unusedByIndex
 * @property {number} unusedLength
 * @property {number} contentLength
 */

class UnusedJavaScript extends ByteEfficiencyAudit {
  /**
   * @return {LH.Audit.Meta}
   */
  static get meta() {
    return {
      id: 'unused-javascript',
      title: str_(UIStrings.title),
      description: str_(UIStrings.description),
      scoreDisplayMode: ByteEfficiencyAudit.SCORING_MODES.NUMERIC,
      requiredArtifacts: ['JsUsage', 'ScriptElements', 'SourceMaps', 'GatherContext',
        'devtoolsLogs', 'traces'],
    };
  }

  /**
   * @param {LH.Artifacts} artifacts
   * @param {Array<LH.Artifacts.NetworkRequest>} networkRecords
   * @param {LH.Audit.Context} context
   * @return {Promise<ByteEfficiencyAudit.ByteEfficiencyProduct>}
   */
  static async audit_(artifacts, networkRecords, context) {
    const bundles = await JsBundles.request(artifacts, context);
    const {
      unusedThreshold = UNUSED_BYTES_IGNORE_THRESHOLD,
      bundleSourceUnusedThreshold = UNUSED_BYTES_IGNORE_BUNDLE_SOURCE_THRESHOLD,
    } = context.options || {};

    const items = [];
    for (const [url, scriptCoverages] of Object.entries(artifacts.JsUsage)) {
      const networkRecord = networkRecords.find(record => record.url === url);
      if (!networkRecord) continue;
      const bundle = bundles.find(b => b.script.src === url);
      const unusedJsSummary =
        await UnusedJavaScriptSummary.request({url, scriptCoverages, bundle}, context);
      if (unusedJsSummary.wastedBytes === 0 || unusedJsSummary.totalBytes === 0) continue;

      const transfer = ByteEfficiencyAudit
        .estimateTransferSize(networkRecord, unusedJsSummary.totalBytes, 'Script');
      const transferRatio = transfer / unusedJsSummary.totalBytes;
      /** @type {LH.Audit.ByteEfficiencyItem} */
      const item = {
        url: unusedJsSummary.url,
        totalBytes: Math.round(transferRatio * unusedJsSummary.totalBytes),
        wastedBytes: Math.round(transferRatio * unusedJsSummary.wastedBytes),
        wastedPercent: unusedJsSummary.wastedPercent,
      };

      if (item.wastedBytes <= unusedThreshold) continue;
      items.push(item);

      // If there was an error calculating the bundle sizes, we can't
      // create any sub-items.
      if (!bundle || 'errorMessage' in bundle.sizes) continue;
      const sizes = bundle.sizes;

      // Augment with bundle data.
      if (unusedJsSummary.sourcesWastedBytes) {
        const topUnusedSourceSizes = Object.entries(unusedJsSummary.sourcesWastedBytes)
          .sort((a, b) => b[1] - a[1])
          .slice(0, 5)
          .map(([source, unused]) => {
            const total = source === '(unmapped)' ? sizes.unmappedBytes : sizes.files[source];
            return {
              source,
              unused: Math.round(unused * transferRatio),
              total: Math.round(total * transferRatio),
            };
          })
          .filter(d => d.unused >= bundleSourceUnusedThreshold);

        const commonSourcePrefix = commonPrefix([...bundle.map._sourceInfos.keys()]);
        item.subItems = {
          type: 'subitems',
          items: topUnusedSourceSizes.map(({source, unused, total}) => {
            return {
              source: trimCommonPrefix(source, commonSourcePrefix),
              sourceBytes: total,
              sourceWastedBytes: unused,
            };
          }),
        };
      }
    }

    return {
      items,
      headings: [
        /* eslint-disable max-len */
        {key: 'url', valueType: 'url', subItemsHeading: {key: 'source', valueType: 'code'}, label: str_(i18n.UIStrings.columnURL)},
        {key: 'totalBytes', valueType: 'bytes', subItemsHeading: {key: 'sourceBytes'}, label: str_(i18n.UIStrings.columnTransferSize)},
        {key: 'wastedBytes', valueType: 'bytes', subItemsHeading: {key: 'sourceWastedBytes'}, label: str_(i18n.UIStrings.columnWastedBytes)},
        /* eslint-enable max-len */
      ],
    };
  }
}

module.exports = UnusedJavaScript;
module.exports.UIStrings = UIStrings;

}).call(this)}).call(this,"/lighthouse-core/audits/byte-efficiency/unused-javascript.js")
},{"../../computed/js-bundles.js":12,"../../computed/unused-javascript-summary.js":49,"../../lib/i18n/i18n.js":96,"./byte-efficiency-audit.js":4}],"../audits/byte-efficiency/uses-long-cache-ttl":[function(require,module,exports){
(function (__filename){(function (){
/**
 * @license Copyright 2017 The Lighthouse Authors. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.
 */
'use strict';

const parseCacheControl = require('parse-cache-control');
const Audit = require('../audit.js');
const NetworkRequest = require('../../lib/network-request.js');
const URL = require('../../lib/url-shim.js');
const linearInterpolation = require('../../lib/statistics.js').linearInterpolation;
const i18n = require('../../lib/i18n/i18n.js');
const NetworkRecords = require('../../computed/network-records.js');

const UIStrings = {
  /** Title of a diagnostic audit that provides detail on the cache policy applies to the page's static assets. Cache refers to browser disk cache, which keeps old versions of network resources around for future use. This is displayed in a list of audit titles that Lighthouse generates. */
  title: 'Uses efficient cache policy on static assets',
  /** Title of a diagnostic audit that provides details on the any page resources that could have been served with more efficient cache policies. Cache refers to browser disk cache, which keeps old versions of network resources around for future use. This imperative title is shown to users when there is a significant amount of assets served with poor cache policies. */
  failureTitle: 'Serve static assets with an efficient cache policy',
  /** Description of a Lighthouse audit that tells the user *why* they need to adopt a long cache lifetime policy. This is displayed after a user expands the section to see more. No character length limits. 'Learn More' becomes link text to additional documentation. */
  description:
    'A long cache lifetime can speed up repeat visits to your page. ' +
    '[Learn more](https://web.dev/uses-long-cache-ttl/).',
  /** [ICU Syntax] Label for the audit identifying network resources with inefficient cache values. Clicking this will expand the audit to show the resources. */
  displayValue: `{itemCount, plural,
    =1 {1 resource found}
    other {# resources found}
    }`,
};

const str_ = i18n.createMessageInstanceIdFn(__filename, UIStrings);

// Ignore assets that have very high likelihood of cache hit
const IGNORE_THRESHOLD_IN_PERCENT = 0.925;

class CacheHeaders extends Audit {
  /**
   * @return {LH.Audit.Meta}
   */
  static get meta() {
    return {
      id: 'uses-long-cache-ttl',
      title: str_(UIStrings.title),
      failureTitle: str_(UIStrings.failureTitle),
      description: str_(UIStrings.description),
      scoreDisplayMode: Audit.SCORING_MODES.NUMERIC,
      requiredArtifacts: ['devtoolsLogs'],
    };
  }

  /**
   * @return {LH.Audit.ScoreOptions}
   */
  static get defaultOptions() {
    return {
      // 50th and 25th percentiles HTTPArchive -> 50 and 75, with p10 derived from them.
      // https://bigquery.cloud.google.com/table/httparchive:lighthouse.2018_04_01_mobile?pli=1
      // see https://www.desmos.com/calculator/uzsyl2hbcb
      p10: 28 * 1024,
      median: 128 * 1024,
    };
  }

  /**
   * Computes the percent likelihood that a return visit will be within the cache lifetime, based on
   * Chrome UMA stats see the note below.
   * @param {number} maxAgeInSeconds
   * @return {number}
   */
  static getCacheHitProbability(maxAgeInSeconds) {
    // This array contains the hand wavy distribution of the age of a resource in hours at the time of
    // cache hit at 0th, 10th, 20th, 30th, etc percentiles. This is used to compute `wastedMs` since there
    // are clearly diminishing returns to cache duration i.e. 6 months is not 2x better than 3 months.
    // Based on UMA stats for HttpCache.StaleEntry.Validated.Age, see https://www.desmos.com/calculator/7v0qh1nzvh
    // Example: a max-age of 12 hours already covers ~50% of cases, doubling to 24 hours covers ~10% more.
    const RESOURCE_AGE_IN_HOURS_DECILES = [0, 0.2, 1, 3, 8, 12, 24, 48, 72, 168, 8760, Infinity];
    if (RESOURCE_AGE_IN_HOURS_DECILES.length !== 12) {
      throw new Error('deciles 0-10 and 1 for overflow');
    }

    const maxAgeInHours = maxAgeInSeconds / 3600;
    const upperDecileIndex = RESOURCE_AGE_IN_HOURS_DECILES.findIndex(
      decile => decile >= maxAgeInHours
    );

    // Clip the likelihood between 0 and 1
    if (upperDecileIndex === RESOURCE_AGE_IN_HOURS_DECILES.length - 1) return 1;
    if (upperDecileIndex === 0) return 0;

    // Use the two closest decile points as control points
    const upperDecileValue = RESOURCE_AGE_IN_HOURS_DECILES[upperDecileIndex];
    const lowerDecileValue = RESOURCE_AGE_IN_HOURS_DECILES[upperDecileIndex - 1];
    const upperDecile = upperDecileIndex / 10;
    const lowerDecile = (upperDecileIndex - 1) / 10;

    // Approximate the real likelihood with linear interpolation
    return linearInterpolation(
      lowerDecileValue,
      lowerDecile,
      upperDecileValue,
      upperDecile,
      maxAgeInHours
    );
  }

  /**
   * Return max-age if defined, otherwise expires header if defined, and null if not.
   * @param {Map<string, string>} headers
   * @param {ReturnType<typeof parseCacheControl>} cacheControl
   * @return {?number}
   */
  static computeCacheLifetimeInSeconds(headers, cacheControl) {
    if (cacheControl && cacheControl['max-age'] !== undefined) {
      return cacheControl['max-age'];
    }

    const expiresHeaders = headers.get('expires');
    if (expiresHeaders) {
      const expires = new Date(expiresHeaders).getTime();
      // Invalid expires values MUST be treated as already expired
      if (!expires) return 0;
      return Math.ceil((expires - Date.now()) / 1000);
    }

    return null;
  }

  /**
   * Given a network record, returns whether we believe the asset is cacheable, i.e. it was a network
   * request that satisifed the conditions:
   *
   *  1. Has a cacheable status code
   *  2. Has a resource type that corresponds to static assets (image, script, stylesheet, etc).
   *
   * Allowing assets with a query string is debatable, PSI considered them non-cacheable with a similar
   * caveat.
   *
   * TODO: Investigate impact in HTTPArchive, experiment with this policy to see what changes.
   *
   * @param {LH.Artifacts.NetworkRequest} record
   * @return {boolean}
   */
  static isCacheableAsset(record) {
    const CACHEABLE_STATUS_CODES = new Set([200, 203, 206]);

    /** @type {Set<LH.Crdp.Network.ResourceType>} */
    const STATIC_RESOURCE_TYPES = new Set([
      NetworkRequest.TYPES.Font,
      NetworkRequest.TYPES.Image,
      NetworkRequest.TYPES.Media,
      NetworkRequest.TYPES.Script,
      NetworkRequest.TYPES.Stylesheet,
    ]);

    // It's not a request loaded over the network, caching makes no sense
    if (NetworkRequest.isNonNetworkRequest(record)) return false;


    return (
      CACHEABLE_STATUS_CODES.has(record.statusCode) &&
      STATIC_RESOURCE_TYPES.has(record.resourceType || 'Other')
    );
  }

  /**
   * Returns true if headers suggest a record should not be cached for a long time.
   * @param {Map<string, string>} headers
   * @param {ReturnType<typeof parseCacheControl>} cacheControl
   * @return {boolean}
   */
  static shouldSkipRecord(headers, cacheControl) {
    // The HTTP/1.0 Pragma header can disable caching if cache-control is not set, see https://tools.ietf.org/html/rfc7234#section-5.4
    if (!cacheControl && (headers.get('pragma') || '').includes('no-cache')) {
      return true;
    }

    // Ignore assets where policy implies they should not be cached long periods
    if (cacheControl &&
      (
        cacheControl['must-revalidate'] ||
        cacheControl['no-cache'] ||
        cacheControl['no-store'] ||
        cacheControl['private'])) {
      return true;
    }

    return false;
  }

  /**
   * @param {LH.Artifacts} artifacts
   * @param {LH.Audit.Context} context
   * @return {Promise<LH.Audit.Product>}
   */
  static audit(artifacts, context) {
    const devtoolsLogs = artifacts.devtoolsLogs[Audit.DEFAULT_PASS];
    return NetworkRecords.request(devtoolsLogs, context).then(records => {
      const results = [];
      let totalWastedBytes = 0;

      for (const record of records) {
        if (!CacheHeaders.isCacheableAsset(record)) continue;

        /** @type {Map<string, string>} */
        const headers = new Map();
        for (const header of record.responseHeaders || []) {
          if (headers.has(header.name.toLowerCase())) {
            const previousHeaderValue = headers.get(header.name.toLowerCase());
            headers.set(header.name.toLowerCase(),
              `${previousHeaderValue}, ${header.value}`);
          } else {
            headers.set(header.name.toLowerCase(), header.value);
          }
        }

        const cacheControl = parseCacheControl(headers.get('cache-control'));
        if (this.shouldSkipRecord(headers, cacheControl)) {
          continue;
        }

        // Ignore if cacheLifetimeInSeconds is a nonpositive number.
        let cacheLifetimeInSeconds = CacheHeaders.computeCacheLifetimeInSeconds(
          headers, cacheControl);
        if (cacheLifetimeInSeconds !== null &&
          (!Number.isFinite(cacheLifetimeInSeconds) || cacheLifetimeInSeconds <= 0)) {
          continue;
        }
        cacheLifetimeInSeconds = cacheLifetimeInSeconds || 0;

        // Ignore assets whose cache lifetime is already high enough
        const cacheHitProbability = CacheHeaders.getCacheHitProbability(cacheLifetimeInSeconds);
        if (cacheHitProbability > IGNORE_THRESHOLD_IN_PERCENT) continue;

        const url = URL.elideDataURI(record.url);
        const totalBytes = record.transferSize || 0;
        const wastedBytes = (1 - cacheHitProbability) * totalBytes;

        totalWastedBytes += wastedBytes;

        // Include cacheControl info (if it exists) per url as a diagnostic.
        /** @type {LH.Audit.Details.DebugData|undefined} */
        let debugData;
        if (cacheControl) {
          debugData = {
            type: 'debugdata',
            ...cacheControl,
          };
        }

        results.push({
          url,
          debugData,
          cacheLifetimeMs: cacheLifetimeInSeconds * 1000,
          cacheHitProbability,
          totalBytes,
          wastedBytes,
        });
      }

      results.sort((a, b) => {
        return a.cacheLifetimeMs - b.cacheLifetimeMs ||
          b.totalBytes - a.totalBytes ||
          a.url.localeCompare(b.url);
      });

      const score = Audit.computeLogNormalScore(
        {p10: context.options.p10, median: context.options.median},
        totalWastedBytes
      );

      /** @type {LH.Audit.Details.Table['headings']} */
      const headings = [
        {key: 'url', itemType: 'url', text: str_(i18n.UIStrings.columnURL)},
        // TODO(i18n): pre-compute localized duration
        {key: 'cacheLifetimeMs', itemType: 'ms', text: str_(i18n.UIStrings.columnCacheTTL),
          displayUnit: 'duration'},
        {key: 'totalBytes', itemType: 'bytes', text: str_(i18n.UIStrings.columnTransferSize),
          displayUnit: 'kb', granularity: 1},
      ];

      const summary = {wastedBytes: totalWastedBytes};
      const details = Audit.makeTableDetails(headings, results, summary);

      return {
        score,
        numericValue: totalWastedBytes,
        numericUnit: 'byte',
        displayValue: str_(UIStrings.displayValue, {itemCount: results.length}),
        details,
      };
    });
  }
}

module.exports = CacheHeaders;
module.exports.UIStrings = UIStrings;

}).call(this)}).call(this,"/lighthouse-core/audits/byte-efficiency/uses-long-cache-ttl.js")
},{"../../computed/network-records.js":40,"../../lib/i18n/i18n.js":96,"../../lib/network-request.js":109,"../../lib/statistics.js":114,"../../lib/url-shim.js":"url","../audit.js":3,"parse-cache-control":221}],"../audits/byte-efficiency/uses-optimized-images":[function(require,module,exports){
(function (__filename){(function (){
/**
 * @license Copyright 2017 The Lighthouse Authors. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.
 */
/*
 * @fileoverview This audit determines if the images used are sufficiently larger
 * than JPEG compressed images without metadata at quality 85.
 */
'use strict';

const ByteEfficiencyAudit = require('./byte-efficiency-audit.js');
const URL = require('../../lib/url-shim.js');
const i18n = require('../../lib/i18n/i18n.js');

const UIStrings = {
  /** Imperative title of a Lighthouse audit that tells the user to encode images with optimization (better compression). This is displayed in a list of audit titles that Lighthouse generates. */
  title: 'Efficiently encode images',
  /** Description of a Lighthouse audit that tells the user *why* they need to efficiently encode images. This is displayed after a user expands the section to see more. No character length limits. 'Learn More' becomes link text to additional documentation. */
  description: 'Optimized images load faster and consume less cellular data. ' +
  '[Learn more](https://web.dev/uses-optimized-images/).',
};

const str_ = i18n.createMessageInstanceIdFn(__filename, UIStrings);

const IGNORE_THRESHOLD_IN_BYTES = 4096;

class UsesOptimizedImages extends ByteEfficiencyAudit {
  /**
   * @return {LH.Audit.Meta}
   */
  static get meta() {
    return {
      id: 'uses-optimized-images',
      title: str_(UIStrings.title),
      description: str_(UIStrings.description),
      scoreDisplayMode: ByteEfficiencyAudit.SCORING_MODES.NUMERIC,
      requiredArtifacts: ['OptimizedImages', 'ImageElements', 'GatherContext', 'devtoolsLogs',
        'traces', 'URL'],
    };
  }

  /**
   * @param {{originalSize: number, jpegSize: number}} image
   * @return {{bytes: number, percent: number}}
   */
  static computeSavings(image) {
    const bytes = image.originalSize - image.jpegSize;
    const percent = 100 * bytes / image.originalSize;
    return {bytes, percent};
  }

  /**
   * @param {{naturalWidth: number, naturalHeight: number}} imageElement
   * @return {number}
   */
  static estimateJPEGSizeFromDimensions(imageElement) {
    const totalPixels = imageElement.naturalWidth * imageElement.naturalHeight;
    // Even JPEGs with lots of detail can usually be compressed down to <1 byte per pixel
    // Using 4:2:2 subsampling already gets an uncompressed bitmap to 2 bytes per pixel.
    // The compression ratio for JPEG is usually somewhere around 10:1 depending on content, so
    // 8:1 is a reasonable expectation for web content which is 1.5MB for a 6MP image.
    const expectedBytesPerPixel = 2 * 1 / 8;
    return Math.round(totalPixels * expectedBytesPerPixel);
  }

  /**
   * @param {LH.Artifacts} artifacts
   * @return {ByteEfficiencyAudit.ByteEfficiencyProduct}
   */
  static audit_(artifacts) {
    const pageURL = artifacts.URL.finalUrl;
    const images = artifacts.OptimizedImages;
    const imageElements = artifacts.ImageElements;
    /** @type {Map<string, LH.Artifacts.ImageElement>} */
    const imageElementsByURL = new Map();
    imageElements.forEach(img => imageElementsByURL.set(img.src, img));

    /** @type {Array<{url: string, fromProtocol: boolean, isCrossOrigin: boolean, totalBytes: number, wastedBytes: number}>} */
    const items = [];
    const warnings = [];
    for (const image of images) {
      if (image.failed) {
        warnings.push(`Unable to decode ${URL.getURLDisplayName(image.url)}`);
        continue;
      } else if (/(jpeg|bmp)/.test(image.mimeType) === false) {
        continue;
      }

      let jpegSize = image.jpegSize;
      let fromProtocol = true;

      if (typeof jpegSize === 'undefined') {
        const imageElement = imageElementsByURL.get(image.url);
        if (!imageElement) {
          warnings.push(`Unable to locate resource ${URL.getURLDisplayName(image.url)}`);
          continue;
        }

        // Skip if we couldn't collect natural image size information.
        if (!imageElement.naturalDimensions) continue;
        const naturalHeight = imageElement.naturalDimensions.height;
        const naturalWidth = imageElement.naturalDimensions.width;
        // If naturalHeight or naturalWidth are falsy, information is not valid, skip.
        if (!naturalHeight || !naturalWidth) continue;
        jpegSize =
          UsesOptimizedImages.estimateJPEGSizeFromDimensions({naturalHeight, naturalWidth});
        fromProtocol = false;
      }

      if (image.originalSize < jpegSize + IGNORE_THRESHOLD_IN_BYTES) continue;

      const url = URL.elideDataURI(image.url);
      const isCrossOrigin = !URL.originsMatch(pageURL, image.url);
      const jpegSavings = UsesOptimizedImages.computeSavings({...image, jpegSize});

      items.push({
        url,
        fromProtocol,
        isCrossOrigin,
        totalBytes: image.originalSize,
        wastedBytes: jpegSavings.bytes,
      });
    }

    /** @type {LH.Audit.Details.Opportunity['headings']} */
    const headings = [
      {key: 'url', valueType: 'thumbnail', label: ''},
      {key: 'url', valueType: 'url', label: str_(i18n.UIStrings.columnURL)},
      {key: 'totalBytes', valueType: 'bytes', label: str_(i18n.UIStrings.columnResourceSize)},
      {key: 'wastedBytes', valueType: 'bytes', label: str_(i18n.UIStrings.columnWastedBytes)},
    ];

    return {
      warnings,
      items,
      headings,
    };
  }
}

module.exports = UsesOptimizedImages;
module.exports.UIStrings = UIStrings;

}).call(this)}).call(this,"/lighthouse-core/audits/byte-efficiency/uses-optimized-images.js")
},{"../../lib/i18n/i18n.js":96,"../../lib/url-shim.js":"url","./byte-efficiency-audit.js":4}],"../audits/byte-efficiency/uses-responsive-images-snapshot":[function(require,module,exports){
(function (__filename){(function (){
/**
 * @license Copyright 2021 The Lighthouse Authors. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.
 */
/**
 * @fileoverview Checks to see if the images used on the page are larger than
 *   their display sizes. The audit will list all images that are larger than
 *   their display size with DPR (a 1000px wide image displayed as a
 *   500px high-res image on a Retina display is 100% used);
 */
'use strict';

const Audit = require('../audit.js');
const UsesResponsiveImages = require('./uses-responsive-images.js');
const URL = require('../../lib/url-shim.js');
const i18n = require('../../lib/i18n/i18n.js');

const UIStrings = {
  /** Label for a column in a data table; entries will be the dimensions of an image as it appears on the page. */
  columnDisplayedDimensions: 'Displayed dimensions',
  /** Label for a column in a data table; entries will be the dimensions of an image from it's source file. */
  columnActualDimensions: 'Actual dimensions',
};

const str_ = i18n.createMessageInstanceIdFn(__filename, UIStrings);

// Based on byte threshold of 4096, with 3 bytes per pixel.
const IGNORE_THRESHOLD_IN_PIXELS = 1365;

class UsesResponsiveImagesSnapshot extends Audit {
  /**
   * @return {LH.Audit.Meta}
   */
  static get meta() {
    return {
      id: 'uses-responsive-images-snapshot',
      title: UsesResponsiveImages.str_(UsesResponsiveImages.UIStrings.title),
      description: UsesResponsiveImages.str_(UsesResponsiveImages.UIStrings.description),
      supportedModes: ['snapshot'],
      requiredArtifacts: ['ImageElements', 'ViewportDimensions'],
    };
  }

  /**
   * @param {LH.Artifacts} artifacts
   * @return {Promise<LH.Audit.Product>}
   */
  static async audit(artifacts) {
    let score = 1;
    /** @type {LH.Audit.Details.TableItem[]} */
    const items = [];
    for (const image of artifacts.ImageElements) {
      if (!image.naturalDimensions) continue;
      const actual = image.naturalDimensions;
      const displayed = UsesResponsiveImages.getDisplayedDimensions(
        {...image, naturalWidth: actual.width, naturalHeight: actual.height},
        artifacts.ViewportDimensions
      );

      const actualPixels = actual.width * actual.height;
      const usedPixels = displayed.width * displayed.height;

      if (actualPixels <= usedPixels) continue;
      if (actualPixels - usedPixels > IGNORE_THRESHOLD_IN_PIXELS) score = 0;

      items.push({
        url: URL.elideDataURI(image.src),
        displayedDimensions: `${displayed.width}x${displayed.height}`,
        actualDimensions: `${actual.width}x${actual.height}`,
      });
    }

    /** @type {LH.Audit.Details.Table['headings']} */
    const headings = [
      /* eslint-disable max-len */
      {key: 'url', itemType: 'thumbnail', text: ''},
      {key: 'url', itemType: 'url', text: str_(i18n.UIStrings.columnURL)},
      {key: 'displayedDimensions', itemType: 'text', text: str_(UIStrings.columnDisplayedDimensions)},
      {key: 'actualDimensions', itemType: 'text', text: str_(UIStrings.columnActualDimensions)},
      /* eslint-enable max-len */
    ];

    const details = Audit.makeTableDetails(headings, items);

    return {
      score,
      details,
    };
  }
}

module.exports = UsesResponsiveImagesSnapshot;
module.exports.UIStrings = UIStrings;

}).call(this)}).call(this,"/lighthouse-core/audits/byte-efficiency/uses-responsive-images-snapshot.js")
},{"../../lib/i18n/i18n.js":96,"../../lib/url-shim.js":"url","../audit.js":3,"./uses-responsive-images.js":"../audits/byte-efficiency/uses-responsive-images"}],"../audits/byte-efficiency/uses-responsive-images":[function(require,module,exports){
(function (__filename){(function (){
/**
 * @license Copyright 2017 The Lighthouse Authors. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.
 */
/**
 * @fileoverview Checks to see if the images used on the page are larger than
 *   their display sizes. The audit will list all images that are larger than
 *   their display size with DPR (a 1000px wide image displayed as a
 *   500px high-res image on a Retina display is 100% used);
 *   However, the audit will only fail pages that use images that have waste
 *   beyond a particular byte threshold.
 */
'use strict';

const ByteEfficiencyAudit = require('./byte-efficiency-audit.js');
const ImageRecords = require('../../computed/image-records.js');
const URL = require('../../lib/url-shim.js');
const i18n = require('../../lib/i18n/i18n.js');

const UIStrings = {
  /** Imperative title of a Lighthouse audit that tells the user to resize images to match the display dimensions. This is displayed in a list of audit titles that Lighthouse generates. */
  title: 'Properly size images',
  /** Description of a Lighthouse audit that tells the user *why* they need to serve appropriately sized images. This is displayed after a user expands the section to see more. No character length limits. 'Learn More' becomes link text to additional documentation. */
  description:
  'Serve images that are appropriately-sized to save cellular data ' +
  'and improve load time. ' +
  '[Learn more](https://web.dev/uses-responsive-images/).',
};

const str_ = i18n.createMessageInstanceIdFn(__filename, UIStrings);

const IGNORE_THRESHOLD_IN_BYTES = 4096;

class UsesResponsiveImages extends ByteEfficiencyAudit {
  /**
   * @return {LH.Audit.Meta}
   */
  static get meta() {
    return {
      id: 'uses-responsive-images',
      title: str_(UIStrings.title),
      description: str_(UIStrings.description),
      scoreDisplayMode: ByteEfficiencyAudit.SCORING_MODES.NUMERIC,
      requiredArtifacts: ['ImageElements', 'ViewportDimensions', 'GatherContext',
        'devtoolsLogs', 'traces'],
    };
  }

  /**
   * @param {LH.Artifacts.ImageElement & {naturalWidth: number, naturalHeight: number}} image
   * @param {LH.Artifacts.ViewportDimensions} ViewportDimensions
   * @return {{width: number, height: number}};
   */
  static getDisplayedDimensions(image, ViewportDimensions) {
    if (image.displayedWidth && image.displayedHeight) {
      return {
        width: image.displayedWidth * ViewportDimensions.devicePixelRatio,
        height: image.displayedHeight * ViewportDimensions.devicePixelRatio,
      };
    }

    // If the image has 0 dimensions, it's probably hidden/offscreen, so we'll be as forgiving as possible
    // and assume it's the size of two viewports. See https://github.com/GoogleChrome/lighthouse/issues/7236
    const viewportWidth = ViewportDimensions.innerWidth;
    const viewportHeight = ViewportDimensions.innerHeight * 2;
    const imageAspectRatio = image.naturalWidth / image.naturalHeight;
    const viewportAspectRatio = viewportWidth / viewportHeight;
    let usedViewportWidth = viewportWidth;
    let usedViewportHeight = viewportHeight;
    if (imageAspectRatio > viewportAspectRatio) {
      usedViewportHeight = viewportWidth / imageAspectRatio;
    } else {
      usedViewportWidth = viewportHeight * imageAspectRatio;
    }

    return {
      width: usedViewportWidth * ViewportDimensions.devicePixelRatio,
      height: usedViewportHeight * ViewportDimensions.devicePixelRatio,
    };
  }

  /**
   * @param {LH.Artifacts.ImageElement & {naturalWidth: number, naturalHeight: number}} image
   * @param {LH.Artifacts.ViewportDimensions} ViewportDimensions
   * @param {Array<LH.Artifacts.NetworkRequest>} networkRecords
   * @return {null|LH.Audit.ByteEfficiencyItem};
   */
  static computeWaste(image, ViewportDimensions, networkRecords) {
    const networkRecord = networkRecords.find(record => record.url === image.src);
    // Nothing can be done without network info, ignore images without resource size information.
    if (!networkRecord) {
      return null;
    }

    const displayed = this.getDisplayedDimensions(image, ViewportDimensions);
    const usedPixels = displayed.width * displayed.height;

    const url = URL.elideDataURI(image.src);
    const actualPixels = image.naturalWidth * image.naturalHeight;
    const wastedRatio = 1 - (usedPixels / actualPixels);
    // Resource size is almost always the right one to be using because of the below:
    //     transferSize = resourceSize + headers.length
    // HOWEVER, there are some cases where an image is compressed again over the network and transfer size
    // is smaller (see https://github.com/GoogleChrome/lighthouse/pull/4968).
    // Use the min of the two numbers to be safe.
    const {resourceSize = 0, transferSize = 0} = networkRecord;
    const totalBytes = Math.min(resourceSize, transferSize);
    const wastedBytes = Math.round(totalBytes * wastedRatio);

    return {
      url,
      totalBytes,
      wastedBytes,
      wastedPercent: 100 * wastedRatio,
    };
  }

  /**
   * @param {LH.Artifacts} artifacts
   * @param {Array<LH.Artifacts.NetworkRequest>} networkRecords
   * @param {LH.Audit.Context} context
   * @return {Promise<ByteEfficiencyAudit.ByteEfficiencyProduct>}
   */
  static async audit_(artifacts, networkRecords, context) {
    const images = await ImageRecords.request({
      ImageElements: artifacts.ImageElements,
      networkRecords,
    }, context);
    const ViewportDimensions = artifacts.ViewportDimensions;
    /** @type {Map<string, LH.Audit.ByteEfficiencyItem>} */
    const resultsMap = new Map();
    for (const image of images) {
      // Give SVG a free pass because creating a "responsive" SVG is of questionable value.
      // Ignore CSS images because it's difficult to determine what is a spritesheet,
      // and the reward-to-effort ratio for responsive CSS images is quite low https://css-tricks.com/responsive-images-css/.
      if (image.mimeType === 'image/svg+xml' || image.isCss) {
        continue;
      }

      // Skip if we couldn't collect natural image size information.
      if (!image.naturalDimensions) continue;
      const naturalHeight = image.naturalDimensions.height;
      const naturalWidth = image.naturalDimensions.width;
      // If naturalHeight or naturalWidth are falsy, information is not valid, skip.
      if (!naturalWidth || !naturalHeight) continue;
      const processed =
        UsesResponsiveImages.computeWaste(
          {...image, naturalHeight, naturalWidth},
          ViewportDimensions, networkRecords
        );
      if (!processed) continue;

      // Don't warn about an image that was later used appropriately
      const existing = resultsMap.get(processed.url);
      if (!existing || existing.wastedBytes > processed.wastedBytes) {
        resultsMap.set(processed.url, processed);
      }
    }

    const items = Array.from(resultsMap.values())
        .filter(item => item.wastedBytes > IGNORE_THRESHOLD_IN_BYTES);

    /** @type {LH.Audit.Details.Opportunity['headings']} */
    const headings = [
      {key: 'url', valueType: 'thumbnail', label: ''},
      {key: 'url', valueType: 'url', label: str_(i18n.UIStrings.columnURL)},
      {key: 'totalBytes', valueType: 'bytes', label: str_(i18n.UIStrings.columnResourceSize)},
      {key: 'wastedBytes', valueType: 'bytes', label: str_(i18n.UIStrings.columnWastedBytes)},
    ];

    return {
      items,
      headings,
    };
  }
}

module.exports = UsesResponsiveImages;
module.exports.UIStrings = UIStrings;
module.exports.str_ = str_;

}).call(this)}).call(this,"/lighthouse-core/audits/byte-efficiency/uses-responsive-images.js")
},{"../../computed/image-records.js":11,"../../lib/i18n/i18n.js":96,"../../lib/url-shim.js":"url","./byte-efficiency-audit.js":4}],"../audits/byte-efficiency/uses-text-compression":[function(require,module,exports){
(function (__filename){(function (){
/**
 * @license Copyright 2017 The Lighthouse Authors. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.
 */
/*
 * @fileoverview Audit a page to ensure that resources loaded with
 * gzip/br/deflate compression.
 */
'use strict';

const ByteEfficiencyAudit = require('./byte-efficiency-audit.js');
const URL = require('../../lib/url-shim.js');
const i18n = require('../../lib/i18n/i18n.js');

const UIStrings = {
  /** Imperative title of a Lighthouse audit that tells the user to enable text compression (like gzip) in order to enhance the performance of a page. This is displayed in a list of audit titles that Lighthouse generates. */
  title: 'Enable text compression',
  /** Description of a Lighthouse audit that tells the user *why* their text-based resources should be served with compression (like gzip). This is displayed after a user expands the section to see more. No character length limits. 'Learn More' becomes link text to additional documentation. */
  description: 'Text-based resources should be served with compression (gzip, deflate or' +
    ' brotli) to minimize total network bytes.' +
    ' [Learn more](https://web.dev/uses-text-compression/).',
};

const str_ = i18n.createMessageInstanceIdFn(__filename, UIStrings);

const IGNORE_THRESHOLD_IN_BYTES = 1400;
const IGNORE_THRESHOLD_IN_PERCENT = 0.1;

class ResponsesAreCompressed extends ByteEfficiencyAudit {
  /**
   * @return {LH.Audit.Meta}
   */
  static get meta() {
    return {
      id: 'uses-text-compression',
      title: str_(UIStrings.title),
      description: str_(UIStrings.description),
      scoreDisplayMode: ByteEfficiencyAudit.SCORING_MODES.NUMERIC,
      requiredArtifacts: ['ResponseCompression', 'GatherContext', 'devtoolsLogs', 'traces'],
    };
  }

  /**
   * @param {LH.Artifacts} artifacts
   * @return {ByteEfficiencyAudit.ByteEfficiencyProduct}
   */
  static audit_(artifacts) {
    const uncompressedResponses = artifacts.ResponseCompression;

    /** @type {Array<LH.Audit.ByteEfficiencyItem>} */
    const items = [];
    uncompressedResponses.forEach(record => {
      // Ignore invalid GZIP size values (undefined, NaN, 0, -n, etc)
      if (!record.gzipSize || record.gzipSize < 0) return;

      const originalSize = record.resourceSize;
      const gzipSize = record.gzipSize;
      const gzipSavings = originalSize - gzipSize;

      // we require at least 10% savings off the original size AND at least 1400 bytes
      // if the savings is smaller than either, we don't care
      if (1 - gzipSize / originalSize < IGNORE_THRESHOLD_IN_PERCENT ||
          gzipSavings < IGNORE_THRESHOLD_IN_BYTES ||
          record.transferSize < gzipSize
      ) {
        return;
      }

      // remove duplicates
      const url = URL.elideDataURI(record.url);
      const isDuplicate = items.find(item => item.url === url &&
        item.totalBytes === record.resourceSize);
      if (isDuplicate) {
        return;
      }

      items.push({
        url,
        totalBytes: originalSize,
        wastedBytes: gzipSavings,
      });
    });

    /** @type {LH.Audit.Details.Opportunity['headings']} */
    const headings = [
      {key: 'url', valueType: 'url', label: str_(i18n.UIStrings.columnURL)},
      {key: 'totalBytes', valueType: 'bytes', label: str_(i18n.UIStrings.columnTransferSize)},
      {key: 'wastedBytes', valueType: 'bytes', label: str_(i18n.UIStrings.columnWastedBytes)},
    ];

    return {
      items,
      headings,
    };
  }
}

module.exports = ResponsesAreCompressed;
module.exports.UIStrings = UIStrings;

}).call(this)}).call(this,"/lighthouse-core/audits/byte-efficiency/uses-text-compression.js")
},{"../../lib/i18n/i18n.js":96,"../../lib/url-shim.js":"url","./byte-efficiency-audit.js":4}],"../audits/content-width":[function(require,module,exports){
(function (__filename){(function (){
/**
 * @license Copyright 2016 The Lighthouse Authors. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.
 */
'use strict';

const Audit = require('./audit.js');
const i18n = require('../lib/i18n/i18n.js');

const UIStrings = {
  /** Title of a Lighthouse audit that provides detail on the content size of a web site compared to the viewport, which is the size of the screen the site is displayed on. This descriptive title is shown to users when the site's content is sized appropriately. */
  title: 'Content is sized correctly for the viewport',
  /** Title of a Lighthouse audit that provides detail on the content size of a web site compared to the viewport, which is the size of the screen the site is displayed on. This descriptive title is shown to users when the site's content is not sized appropriately. */
  failureTitle: 'Content is not sized correctly for the viewport',
  /** Description of a Lighthouse audit that tells the user why they should care that a site's content size should match its viewport size, which is the size of the screen the site is displayed on. This is displayed after a user expands the section to see more. No character length limits. 'Learn More' becomes link text to additional documentation. */
  description: 'If the width of your app\'s content doesn\'t match the width ' +
    'of the viewport, your app might not be optimized for mobile screens. ' +
    '[Learn more](https://web.dev/content-width/).',
  /**
   * @description Explanatory message stating that the viewport size and window size differ.
   * @example {100} innerWidth
   * @example {101} outerWidth
   * */
  explanation: 'The viewport size of {innerWidth}px does not match the window ' +
    'size of {outerWidth}px.',
};

const str_ = i18n.createMessageInstanceIdFn(__filename, UIStrings);

class ContentWidth extends Audit {
  /**
   * @return {LH.Audit.Meta}
   */
  static get meta() {
    return {
      id: 'content-width',
      title: str_(UIStrings.title),
      failureTitle: str_(UIStrings.failureTitle),
      description: str_(UIStrings.description),
      requiredArtifacts: ['ViewportDimensions'],
    };
  }

  /**
   * @param {LH.Artifacts} artifacts
   * @param {LH.Audit.Context} context
   * @return {LH.Audit.Product}
   */
  static audit(artifacts, context) {
    const viewportWidth = artifacts.ViewportDimensions.innerWidth;
    const windowWidth = artifacts.ViewportDimensions.outerWidth;
    const widthsMatch = viewportWidth === windowWidth;

    if (context.settings.formFactor === 'desktop') {
      return {
        score: 1,
        notApplicable: true,
      };
    }

    let explanation;
    if (!widthsMatch) {
      explanation = str_(UIStrings.explanation,
        {innerWidth: artifacts.ViewportDimensions.innerWidth,
          outerWidth: artifacts.ViewportDimensions.outerWidth});
    }

    return {
      score: Number(widthsMatch),
      explanation,
    };
  }
}

module.exports = ContentWidth;
module.exports.UIStrings = UIStrings;

}).call(this)}).call(this,"/lighthouse-core/audits/content-width.js")
},{"../lib/i18n/i18n.js":96,"./audit.js":3}],"../audits/critical-request-chains":[function(require,module,exports){
(function (__filename){(function (){
/**
 * @license Copyright 2016 The Lighthouse Authors. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.
 */
'use strict';

const Audit = require('./audit.js');
const i18n = require('../lib/i18n/i18n.js');
const ComputedChains = require('../computed/critical-request-chains.js');

const UIStrings = {
  /** Imperative title of a Lighthouse audit that tells the user to reduce the depth of critical network requests to enhance initial load of a page. Critical request chains are series of dependent network requests that are important for page rendering. For example, here's a 4-request-deep chain: The biglogo.jpg image is required, but is requested via the styles.css style code, which is requested by the initialize.js javascript, which is requested by the page's HTML. This is displayed in a list of audit titles that Lighthouse generates. */
  title: 'Avoid chaining critical requests',
  /** Description of a Lighthouse audit that tells the user *why* they should reduce the depth of critical network requests to enhance initial load of a page . This is displayed after a user expands the section to see more. No character length limits. 'Learn More' becomes link text to additional documentation. */
  description: 'The Critical Request Chains below show you what resources are ' +
      'loaded with a high priority. Consider reducing ' +
      'the length of chains, reducing the download size of resources, or ' +
      'deferring the download of unnecessary resources to improve page load. ' +
      '[Learn more](https://web.dev/critical-request-chains/).',
  /** [ICU Syntax] Label for an audit identifying the number of sequences of dependent network requests used to load the page. */
  displayValue: `{itemCount, plural,
    =1 {1 chain found}
    other {# chains found}
    }`,
};

const str_ = i18n.createMessageInstanceIdFn(__filename, UIStrings);

class CriticalRequestChains extends Audit {
  /**
   * @return {LH.Audit.Meta}
   */
  static get meta() {
    return {
      id: 'critical-request-chains',
      title: str_(UIStrings.title),
      description: str_(UIStrings.description),
      scoreDisplayMode: Audit.SCORING_MODES.INFORMATIVE,
      supportedModes: ['navigation'],
      requiredArtifacts: ['traces', 'devtoolsLogs', 'URL'],
    };
  }

  /** @typedef {{depth: number, id: string, chainDuration: number, chainTransferSize: number, node: LH.Audit.SimpleCriticalRequestNode[string]}} CrcNodeInfo */

  /**
   * @param {LH.Audit.SimpleCriticalRequestNode} tree
   * @param {function(CrcNodeInfo): void} cb
   */
  static _traverse(tree, cb) {
    /**
     * @param {LH.Audit.SimpleCriticalRequestNode} node
     * @param {number} depth
     * @param {number=} startTime
     * @param {number=} transferSize
     */
    function walk(node, depth, startTime, transferSize = 0) {
      const children = Object.keys(node);
      if (children.length === 0) {
        return;
      }
      children.forEach(id => {
        const child = node[id];
        if (!startTime) {
          startTime = child.request.startTime;
        }

        // Call the callback with the info for this child.
        cb({
          depth,
          id,
          node: child,
          chainDuration: (child.request.endTime - startTime) * 1000,
          chainTransferSize: (transferSize + child.request.transferSize),
        });

        // Carry on walking.
        if (child.children) {
          walk(child.children, depth + 1, startTime);
        }
      }, '');
    }

    walk(tree, 0);
  }

  /**
   * Get stats about the longest initiator chain (as determined by time duration)
   * @param {LH.Audit.SimpleCriticalRequestNode} tree
   * @return {{duration: number, length: number, transferSize: number}}
   */
  static _getLongestChain(tree) {
    const longest = {
      duration: 0,
      length: 0,
      transferSize: 0,
    };
    CriticalRequestChains._traverse(tree, opts => {
      const duration = opts.chainDuration;
      if (duration > longest.duration) {
        longest.duration = duration;
        longest.transferSize = opts.chainTransferSize;
        longest.length = opts.depth;
      }
    });
    // Always return the longest chain + 1 because the depth is zero indexed.
    longest.length++;
    return longest;
  }

  /**
   * @param {LH.Artifacts.CriticalRequestNode} tree
   * @return {LH.Audit.SimpleCriticalRequestNode}
   */
  static flattenRequests(tree) {
    /** @type {LH.Audit.SimpleCriticalRequestNode} */
    const flattendChains = {};
    /** @type {Map<string, LH.Audit.SimpleCriticalRequestNode[string]>} */
    const chainMap = new Map();

    /** @param {CrcNodeInfo} opts */
    function flatten(opts) {
      const request = opts.node.request;
      const simpleRequest = {
        url: request.url,
        startTime: request.startTime,
        endTime: request.endTime,
        responseReceivedTime: request.responseReceivedTime,
        transferSize: request.transferSize,
      };

      let chain = chainMap.get(opts.id);
      if (chain) {
        chain.request = simpleRequest;
      } else {
        chain = {
          request: simpleRequest,
        };
        flattendChains[opts.id] = chain;
      }

      if (opts.node.children) {
        for (const chainId of Object.keys(opts.node.children)) {
          // Note: cast should be Partial<>, but filled in when child node is traversed.
          const childChain = /** @type {LH.Audit.SimpleCriticalRequestNode[string]} */ ({
            request: {},
          });
          chainMap.set(chainId, childChain);
          if (!chain.children) {
            chain.children = {};
          }
          chain.children[chainId] = childChain;
        }
      }
      chainMap.set(opts.id, chain);
    }

    CriticalRequestChains._traverse(tree, flatten);

    return flattendChains;
  }

  /**
   * Audits the page to give a score for First Meaningful Paint.
   * @param {LH.Artifacts} artifacts The artifacts from the gather phase.
   * @param {LH.Audit.Context} context
   * @return {Promise<LH.Audit.Product>}
   */
  static audit(artifacts, context) {
    const trace = artifacts.traces[Audit.DEFAULT_PASS];
    const devtoolsLog = artifacts.devtoolsLogs[Audit.DEFAULT_PASS];
    const URL = artifacts.URL;
    return ComputedChains.request({devtoolsLog, trace, URL}, context).then(chains => {
      let chainCount = 0;
      /**
       * @param {LH.Audit.SimpleCriticalRequestNode} node
       * @param {number} depth
       */
      function walk(node, depth) {
        const childIds = Object.keys(node);

        childIds.forEach(id => {
          const child = node[id];
          if (child.children) {
            walk(child.children, depth + 1);
          } else {
            // if the node doesn't have a children field, then it is a leaf, so +1
            chainCount++;
          }
        }, '');
      }
      // Convert
      const flattenedChains = CriticalRequestChains.flattenRequests(chains);

      // Account for initial navigation
      const initialNavKey = Object.keys(flattenedChains)[0];
      const initialNavChildren = initialNavKey && flattenedChains[initialNavKey].children;
      if (initialNavChildren && Object.keys(initialNavChildren).length > 0) {
        walk(initialNavChildren, 0);
      }

      const longestChain = CriticalRequestChains._getLongestChain(flattenedChains);

      return {
        score: Number(chainCount === 0),
        notApplicable: chainCount === 0,
        displayValue: chainCount ? str_(UIStrings.displayValue, {itemCount: chainCount}) : '',
        details: {
          type: 'criticalrequestchain',
          chains: flattenedChains,
          longestChain,
        },
      };
    });
  }
}

module.exports = CriticalRequestChains;
module.exports.UIStrings = UIStrings;

}).call(this)}).call(this,"/lighthouse-core/audits/critical-request-chains.js")
},{"../computed/critical-request-chains.js":10,"../lib/i18n/i18n.js":96,"./audit.js":3}],"../audits/csp-xss":[function(require,module,exports){
(function (__filename){(function (){
/**
 * @license Copyright 2021 The Lighthouse Authors. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.
 */
'use strict';

const Audit = require('./audit.js');
const MainResource = require('../computed/main-resource.js');
const i18n = require('../lib/i18n/i18n.js');
const {
  evaluateRawCspsForXss,
  getTranslatedDescription,
} = require('../lib/csp-evaluator.js');

/** @typedef {import('../lib/csp-evaluator.js').Finding} Finding */

const UIStrings = {
  /** Title of a Lighthouse audit that evaluates the security of a page's CSP. "CSP" stands for "Content Security Policy". "XSS" stands for "Cross Site Scripting". "CSP" and "XSS" do not need to be translated. */
  title: 'Ensure CSP is effective against XSS attacks',
  /** Description of a Lighthouse audit that evaluates the security of a page's CSP. This is displayed after a user expands the section to see more. No character length limits. 'Learn More' becomes link text to additional documentation. "CSP" stands for "Content Security Policy". "XSS" stands for "Cross Site Scripting". "CSP" and "XSS" do not need to be translated. */
  description: 'A strong Content Security Policy (CSP) significantly ' +
    'reduces the risk of cross-site scripting (XSS) attacks. ' +
    '[Learn more](https://web.dev/csp-xss/)',
  /** Summary text for the results of a Lighthouse audit that evaluates the security of a page's CSP. This is displayed if no CSP is being enforced. "CSP" stands for "Content Security Policy". "CSP" does not need to be translated. */
  noCsp: 'No CSP found in enforcement mode',
  /** Message shown when one or more CSPs are defined in a <meta> tag. Shown in a table with a list of other CSP bypasses and warnings. "CSP" stands for "Content Security Policy". "CSP" and "HTTP" do not need to be translated. */
  metaTagMessage: 'The page contains a CSP defined in a <meta> tag. ' +
    'Consider defining the CSP in an HTTP header if you can.',
  /** Label for a column in a data table; entries will be a directive of a CSP. "CSP" stands for "Content Security Policy". */
  columnDirective: 'Directive',
  /** Label for a column in a data table; entries will be the severity of an issue with the CSP. "CSP" stands for "Content Security Policy". */
  columnSeverity: 'Severity',
  /** Table item value calling out the presence of a syntax error. */
  itemSeveritySyntax: 'Syntax',
};

const str_ = i18n.createMessageInstanceIdFn(__filename, UIStrings);

class CspXss extends Audit {
  /**
   * @return {LH.Audit.Meta}
   */
  static get meta() {
    return {
      id: 'csp-xss',
      scoreDisplayMode: Audit.SCORING_MODES.INFORMATIVE,
      title: str_(UIStrings.title),
      description: str_(UIStrings.description),
      requiredArtifacts: ['devtoolsLogs', 'MetaElements', 'URL'],
    };
  }

  /**
   * @param {LH.Artifacts} artifacts
   * @param {LH.Audit.Context} context
   * @return {Promise<{cspHeaders: string[], cspMetaTags: string[]}>}
   */
  static async getRawCsps(artifacts, context) {
    const devtoolsLog = artifacts.devtoolsLogs[Audit.DEFAULT_PASS];
    const mainResource = await MainResource.request({devtoolsLog, URL: artifacts.URL}, context);

    const cspMetaTags = artifacts.MetaElements
      .filter(m => {
        return m.httpEquiv && m.httpEquiv.toLowerCase() === 'content-security-policy';
      })
      .flatMap(m => (m.content || '').split(','))
      .filter(rawCsp => rawCsp.replace(/\s/g, ''));
    const cspHeaders = mainResource.responseHeaders
      .filter(h => {
        return h.name.toLowerCase() === 'content-security-policy';
      })
      .flatMap(h => h.value.split(','))
      .filter(rawCsp => rawCsp.replace(/\s/g, ''));

    return {cspHeaders, cspMetaTags};
  }

  /**
   * @param {Finding} finding
   * @param {LH.IcuMessage=} severity
   * @return {LH.Audit.Details.TableItem}
   */
  static findingToTableItem(finding, severity) {
    return {
      directive: finding.directive,
      description: getTranslatedDescription(finding),
      severity,
    };
  }

  /**
   * @param {Finding[][]} syntaxFindings
   * @param {string[]} rawCsps
   * @return {LH.Audit.Details.TableItem[]}
   */
  static constructSyntaxResults(syntaxFindings, rawCsps) {
    /** @type {LH.Audit.Details.TableItem[]} */
    const results = [];

    for (let i = 0; i < syntaxFindings.length; ++i) {
      const items = syntaxFindings[i].map(f => this.findingToTableItem(f));
      if (!items.length) continue;
      results.push({
        severity: str_(UIStrings.itemSeveritySyntax),
        description: {
          type: 'code',
          value: rawCsps[i],
        },
        subItems: {
          type: 'subitems',
          items,
        },
      });
    }

    return results;
  }

  /**
   * @param {string[]} cspHeaders
   * @param {string[]} cspMetaTags
   * @return {{score: number, results: LH.Audit.Details.TableItem[]}}
   */
  static constructResults(cspHeaders, cspMetaTags) {
    const rawCsps = [...cspHeaders, ...cspMetaTags];
    if (!rawCsps.length) {
      return {
        score: 0,
        results: [{
          severity: str_(i18n.UIStrings.itemSeverityHigh),
          description: str_(UIStrings.noCsp),
          directive: undefined,
        }],
      };
    }

    const {bypasses, warnings, syntax} = evaluateRawCspsForXss(rawCsps);

    const results = [
      ...this.constructSyntaxResults(syntax, rawCsps),
      ...bypasses.map(f => this.findingToTableItem(f, str_(i18n.UIStrings.itemSeverityHigh))),
      ...warnings.map(f => this.findingToTableItem(f, str_(i18n.UIStrings.itemSeverityMedium))),
    ];

    // Add extra warning for a CSP defined in a meta tag.
    if (cspMetaTags.length) {
      results.push({
        severity: str_(i18n.UIStrings.itemSeverityMedium),
        description: str_(UIStrings.metaTagMessage),
        directive: undefined,
      });
    }

    return {score: bypasses.length ? 0 : 1, results};
  }

  /**
   * @param {LH.Artifacts} artifacts
   * @param {LH.Audit.Context} context
   * @return {Promise<LH.Audit.Product>}
   */
  static async audit(artifacts, context) {
    const {cspHeaders, cspMetaTags} = await this.getRawCsps(artifacts, context);
    const {score, results} = this.constructResults(cspHeaders, cspMetaTags);

    /** @type {LH.Audit.Details.Table['headings']} */
    const headings = [
      /* eslint-disable max-len */
      {key: 'description', itemType: 'text', subItemsHeading: {key: 'description'}, text: str_(i18n.UIStrings.columnDescription)},
      {key: 'directive', itemType: 'code', subItemsHeading: {key: 'directive'}, text: str_(UIStrings.columnDirective)},
      {key: 'severity', itemType: 'text', subItemsHeading: {key: 'severity'}, text: str_(UIStrings.columnSeverity)},
      /* eslint-enable max-len */
    ];
    const details = Audit.makeTableDetails(headings, results);

    return {
      score,
      notApplicable: false,
      details,
    };
  }
}

module.exports = CspXss;
module.exports.UIStrings = UIStrings;

}).call(this)}).call(this,"/lighthouse-core/audits/csp-xss.js")
},{"../computed/main-resource.js":14,"../lib/csp-evaluator.js":85,"../lib/i18n/i18n.js":96,"./audit.js":3}],"../audits/deprecations":[function(require,module,exports){
(function (__filename){(function (){
/**
 * @license Copyright 2017 The Lighthouse Authors. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.
 */
'use strict';

/**
 * @fileoverview Audits a page to determine if it is calling deprecated APIs.
 * This is done by collecting console log messages and filtering them by ones
 * that contain deprecated API warnings sent by Chrome.
 */

const Audit = require('./audit.js');
const i18n = require('../lib/i18n/i18n.js');

const UIStrings = {
  /** Title of a Lighthouse audit that provides detail on the use of deprecated APIs. This descriptive title is shown to users when the page does not use deprecated APIs. */
  title: 'Avoids deprecated APIs',
  /** Title of a Lighthouse audit that provides detail on the use of deprecated APIs. This descriptive title is shown to users when the page uses deprecated APIs. */
  failureTitle: 'Uses deprecated APIs',
  /** Description of a Lighthouse audit that tells the user why they should not use deprecated APIs on their page. This is displayed after a user expands the section to see more. No character length limits. 'Learn More' becomes link text to additional documentation. */
  description: 'Deprecated APIs will eventually be removed from the browser. ' +
      '[Learn more](https://web.dev/deprecations/).',
  /** [ICU Syntax] Label for the audit identifying the number of warnings generated by using deprecated APIs. */
  displayValue: `{itemCount, plural,
    =1 {1 warning found}
    other {# warnings found}
    }`,
  /** Header of the table column which displays the warning message describing use of a deprecated API by code running in the web page. */
  columnDeprecate: 'Deprecation / Warning',
  /** Table column header for line of code (eg. 432) that is using a deprecated API. */
  columnLine: 'Line',
};

const str_ = i18n.createMessageInstanceIdFn(__filename, UIStrings);

class Deprecations extends Audit {
  /**
   * @return {LH.Audit.Meta}
   */
  static get meta() {
    return {
      id: 'deprecations',
      title: str_(UIStrings.title),
      failureTitle: str_(UIStrings.failureTitle),
      description: str_(UIStrings.description),
      requiredArtifacts: ['ConsoleMessages'],
    };
  }

  /**
   * @param {LH.Artifacts} artifacts
   * @return {LH.Audit.Product}
   */
  static audit(artifacts) {
    const entries = artifacts.ConsoleMessages;

    const deprecations = entries.filter(log => log.source === 'deprecation')
    // TODO(M91): Temporary ignore until Chrome M91 became stable version.
    // M91 doesn't throw deprecation on ::-webkit-details-marker.
    .filter(log => !log.text.includes('::-webkit-details-marker'))
    .map(log => {
      return {
        value: log.text,
        source: Audit.makeSourceLocationFromConsoleMessage(log),
      };
    });

    /** @type {LH.Audit.Details.Table['headings']} */
    const headings = [
      {key: 'value', itemType: 'text', text: str_(UIStrings.columnDeprecate)},
      {key: 'source', itemType: 'source-location', text: str_(i18n.UIStrings.columnSource)},
    ];
    const details = Audit.makeTableDetails(headings, deprecations);

    let displayValue;
    if (deprecations.length > 0) {
      displayValue = str_(UIStrings.displayValue, {itemCount: deprecations.length});
    }

    return {
      score: Number(deprecations.length === 0),
      displayValue,
      details,
    };
  }
}

module.exports = Deprecations;
module.exports.UIStrings = UIStrings;

}).call(this)}).call(this,"/lighthouse-core/audits/deprecations.js")
},{"../lib/i18n/i18n.js":96,"./audit.js":3}],"../audits/diagnostics":[function(require,module,exports){
/**
 * @license Copyright 2019 The Lighthouse Authors. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.
 */
'use strict';

const Audit = require('./audit.js');
const MainThreadTasksComputed = require('../computed/main-thread-tasks.js');
const NetworkRecordsComputed = require('../computed/network-records.js');
const NetworkAnalysisComputed = require('../computed/network-analysis.js');
const NetworkAnalyzer = require('../lib/dependency-graph/simulator/network-analyzer.js');

class Diagnostics extends Audit {
  /**
   * @return {LH.Audit.Meta}
   */
  static get meta() {
    return {
      id: 'diagnostics',
      scoreDisplayMode: Audit.SCORING_MODES.INFORMATIVE,
      title: 'Diagnostics',
      description: 'Collection of useful page vitals.',
      supportedModes: ['navigation'],
      requiredArtifacts: ['traces', 'devtoolsLogs'],
    };
  }

  /**
   * @param {LH.Artifacts} artifacts
   * @param {LH.Audit.Context} context
   * @return {Promise<LH.Audit.Product>}
   */
  static async audit(artifacts, context) {
    const trace = artifacts.traces[Audit.DEFAULT_PASS];
    const devtoolsLog = artifacts.devtoolsLogs[Audit.DEFAULT_PASS];
    const tasks = await MainThreadTasksComputed.request(trace, context);
    const records = await NetworkRecordsComputed.request(devtoolsLog, context);
    const analysis = await NetworkAnalysisComputed.request(devtoolsLog, context);

    const toplevelTasks = tasks.filter(t => !t.parent);
    const mainDocumentTransferSize = NetworkAnalyzer.findMainDocument(records).transferSize;
    const totalByteWeight = records.reduce((sum, r) => sum + (r.transferSize || 0), 0);
    const totalTaskTime = toplevelTasks.reduce((sum, t) => sum + (t.duration || 0), 0);
    const maxRtt = Math.max(...analysis.additionalRttByOrigin.values()) + analysis.rtt;
    const maxServerLatency = Math.max(...analysis.serverResponseTimeByOrigin.values());

    const diagnostics = {
      numRequests: records.length,
      numScripts: records.filter(r => r.resourceType === 'Script').length,
      numStylesheets: records.filter(r => r.resourceType === 'Stylesheet').length,
      numFonts: records.filter(r => r.resourceType === 'Font').length,
      numTasks: toplevelTasks.length,
      numTasksOver10ms: toplevelTasks.filter(t => t.duration > 10).length,
      numTasksOver25ms: toplevelTasks.filter(t => t.duration > 25).length,
      numTasksOver50ms: toplevelTasks.filter(t => t.duration > 50).length,
      numTasksOver100ms: toplevelTasks.filter(t => t.duration > 100).length,
      numTasksOver500ms: toplevelTasks.filter(t => t.duration > 500).length,
      rtt: analysis.rtt,
      throughput: analysis.throughput,
      maxRtt,
      maxServerLatency,
      totalByteWeight,
      totalTaskTime,
      mainDocumentTransferSize,
    };

    return {
      score: 1,
      details: {
        type: 'debugdata',
        // TODO: Consider not nesting diagnostics under `items`.
        items: [diagnostics],
      },
    };
  }
}

module.exports = Diagnostics;

},{"../computed/main-thread-tasks.js":15,"../computed/network-analysis.js":39,"../computed/network-records.js":40,"../lib/dependency-graph/simulator/network-analyzer.js":91,"./audit.js":3}],"../audits/dobetterweb/appcache-manifest":[function(require,module,exports){
(function (__filename){(function (){
/**
 * @license Copyright 2016 The Lighthouse Authors. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.
 */

/**
 * @fileoverview Audit a page to ensure it is not using the Application Cache API.
 */

'use strict';

const Audit = require('../audit.js');
const i18n = require('../../lib/i18n/i18n.js');

const UIStrings = {
  /** Title of a Lighthouse audit that provides detail on the use of the Application Cache API. This descriptive title is shown to users when they do not use the Application Cache API. */
  title: 'Avoids Application Cache',
  /** Title of a Lighthouse audit that provides detail on the use of the Application Cache API. This descriptive title is shown to users when they do use the Application Cache API, which is considered bad practice. */
  failureTitle: 'Uses Application Cache',
  /** Description of a Lighthouse audit that tells the user why they should not use the Application Cache API. This is displayed after a user expands the section to see more. No character length limits. 'Learn More' becomes link text to additional documentation. */
  description: 'Application Cache is deprecated. ' +
    '[Learn more](https://web.dev/appcache-manifest/).',
  /**
   * @description Label for the audit identifying uses of the Application Cache.
   * @example {clock.appcache} AppCacheManifest
   */
  displayValue: 'Found "{AppCacheManifest}"',
};

const str_ = i18n.createMessageInstanceIdFn(__filename, UIStrings);

class AppCacheManifestAttr extends Audit {
  /**
   * @return {LH.Audit.Meta}
   */
  static get meta() {
    return {
      id: 'appcache-manifest',
      title: str_(UIStrings.title),
      failureTitle: str_(UIStrings.failureTitle),
      description: str_(UIStrings.description),
      requiredArtifacts: ['AppCacheManifest'],
    };
  }

  /**
   * @param {LH.Artifacts} artifacts
   * @return {LH.Audit.Product}
   */
  static audit(artifacts) {
    // Fails if an AppCacheManifest was found.
    if (artifacts.AppCacheManifest !== null) {
      return {
        score: 0,
        displayValue: str_(UIStrings.displayValue, {AppCacheManifest: artifacts.AppCacheManifest}),
      };
    }

    return {
      score: 1,
    };
  }
}

module.exports = AppCacheManifestAttr;
module.exports.UIStrings = UIStrings;

}).call(this)}).call(this,"/lighthouse-core/audits/dobetterweb/appcache-manifest.js")
},{"../../lib/i18n/i18n.js":96,"../audit.js":3}],"../audits/dobetterweb/charset":[function(require,module,exports){
(function (__filename){(function (){
/**
 * @license Copyright 2020 The Lighthouse Authors. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.
 */

/**
 * @fileoverview Audits a page to ensure charset it configured properly.
 * It must be defined within the first 1024 bytes of the HTML document, defined in the HTTP header, or the document source must start with a BOM.
 *
 * @see https://github.com/GoogleChrome/lighthouse/issues/10023
 */
'use strict';

const Audit = require('../audit.js');
const i18n = require('../../lib/i18n/i18n.js');
const MainResource = require('../../computed/main-resource.js');

const UIStrings = {
  /** Title of a Lighthouse audit that provides detail on if the charset is set properly for a page. This title is shown when the charset is defined correctly. Charset defines the character encoding (eg UTF-8) of the page content. */
  title: 'Properly defines charset',
  /** Title of a Lighthouse audit that provides detail on if the charset is set properly for a page. This title is shown when the charset meta tag is missing or defined too late in the page. */
  failureTitle: 'Charset declaration is missing or occurs too late in the HTML',
  /** Description of a Lighthouse audit that tells the user why the charset needs to be defined early on. */
  description: 'A character encoding declaration is required. It can be done with a `<meta>` tag ' +
    'in the first 1024 bytes of the HTML or in the Content-Type HTTP response header. ' +
    '[Learn more](https://web.dev/charset/).',
};

const str_ = i18n.createMessageInstanceIdFn(__filename, UIStrings);

const CONTENT_TYPE_HEADER = 'content-type';
// /^[a-zA-Z0-9-_:.()]{2,}$/ matches all known IANA charset names (https://www.iana.org/assignments/character-sets/character-sets.xhtml)
const IANA_REGEX = /^[a-zA-Z0-9-_:.()]{2,}$/;
const CHARSET_HTML_REGEX = /<meta[^>]+charset[^<]+>/i;
const CHARSET_HTTP_REGEX = /charset\s*=\s*[a-zA-Z0-9-_:.()]{2,}/i;

class CharsetDefined extends Audit {
  /**
   * @return {LH.Audit.Meta}
   */
  static get meta() {
    return {
      id: 'charset',
      title: str_(UIStrings.title),
      failureTitle: str_(UIStrings.failureTitle),
      description: str_(UIStrings.description),
      requiredArtifacts: ['MainDocumentContent', 'URL', 'devtoolsLogs', 'MetaElements'],
    };
  }

  /**
   * @param {LH.Artifacts} artifacts
   * @param {LH.Audit.Context} context
   * @return {Promise<LH.Audit.Product>}
   */
  static async audit(artifacts, context) {
    const devtoolsLog = artifacts.devtoolsLogs[Audit.DEFAULT_PASS];
    const mainResource = await MainResource.request({devtoolsLog, URL: artifacts.URL}, context);
    let isCharsetSet = false;
    // Check the http header 'content-type' to see if charset is defined there
    if (mainResource.responseHeaders) {
      const contentTypeHeader = mainResource.responseHeaders
        .find(header => header.name.toLowerCase() === CONTENT_TYPE_HEADER);

      if (contentTypeHeader) {
        isCharsetSet = CHARSET_HTTP_REGEX.test(contentTypeHeader.value);
      }
    }

    // Check if there is a BOM byte marker
    const BOM_FIRSTCHAR = 0xFEFF;
    isCharsetSet = isCharsetSet || artifacts.MainDocumentContent.charCodeAt(0) === BOM_FIRSTCHAR;

    // Check if charset-ish meta tag is defined within the first 1024 characters(~1024 bytes) of the HTML document
    if (CHARSET_HTML_REGEX.test(artifacts.MainDocumentContent.slice(0, 1024))) {
      // If so, double-check the DOM attributes, considering both legacy http-equiv and html5 charset styles.
      isCharsetSet = isCharsetSet || artifacts.MetaElements.some(meta => {
        return (meta.charset && IANA_REGEX.test(meta.charset)) ||
          (meta.httpEquiv === 'content-type' &&
          meta.content &&
          CHARSET_HTTP_REGEX.test(meta.content));
      });
    }

    return {
      score: Number(isCharsetSet),
    };
  }
}

module.exports = CharsetDefined;
module.exports.UIStrings = UIStrings;
module.exports.CHARSET_HTML_REGEX = CHARSET_HTML_REGEX;
module.exports.CHARSET_HTTP_REGEX = CHARSET_HTTP_REGEX;
module.exports.IANA_REGEX = IANA_REGEX;

}).call(this)}).call(this,"/lighthouse-core/audits/dobetterweb/charset.js")
},{"../../computed/main-resource.js":14,"../../lib/i18n/i18n.js":96,"../audit.js":3}],"../audits/dobetterweb/doctype":[function(require,module,exports){
(function (__filename){(function (){
/**
 * @license Copyright 2018 The Lighthouse Authors. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.
 */
'use strict';

const Audit = require('../audit.js');
const i18n = require('../../lib/i18n/i18n.js');

const UIStrings = {
  /** Title of a Lighthouse audit that provides detail on the doctype of a page. This descriptive title is shown to users when the pages's doctype is set to HTML. */
  title: 'Page has the HTML doctype',
  /** Title of a Lighthouse audit that provides detail on the doctype of a page. This descriptive title is shown to users when the page's doctype is not set to HTML. */
  failureTitle: 'Page lacks the HTML doctype, thus triggering quirks-mode',
  /** Description of a Lighthouse audit that tells the user why they should define an HTML doctype. This is displayed after a user expands the section to see more. No character length limits. 'Learn More' becomes link text to additional documentation. */
  description: 'Specifying a doctype prevents the browser ' +
    'from switching to quirks-mode. ' +
    '[Learn more](https://web.dev/doctype/).',
  /** Explanatory message stating that the document has no doctype. */
  explanationNoDoctype: 'Document must contain a doctype',
  /** Explanatory message stating that the publicId field is not empty. */
  explanationPublicId: 'Expected publicId to be an empty string',
  /** Explanatory message stating that the systemId field is not empty. */
  explanationSystemId: 'Expected systemId to be an empty string',
  /** Explanatory message stating that the doctype is set, but is not "html" and is therefore invalid. */
  explanationBadDoctype: 'Doctype name must be the lowercase string `html`',
};

const str_ = i18n.createMessageInstanceIdFn(__filename, UIStrings);

class Doctype extends Audit {
  /**
   * @return {LH.Audit.Meta}
   */
  static get meta() {
    return {
      id: 'doctype',
      title: str_(UIStrings.title),
      failureTitle: str_(UIStrings.failureTitle),
      description: str_(UIStrings.description),
      requiredArtifacts: ['Doctype'],
    };
  }

  /**
   * @param {LH.Artifacts} artifacts
   * @return {LH.Audit.Product}
   */
  static audit(artifacts) {
    if (!artifacts.Doctype) {
      return {
        score: 0,
        explanation: str_(UIStrings.explanationNoDoctype),
      };
    }

    // only set constants once we know there is a doctype
    const doctypeName = artifacts.Doctype.name.trim();
    const doctypePublicId = artifacts.Doctype.publicId;
    const doctypeSystemId = artifacts.Doctype.systemId;

    if (doctypePublicId !== '') {
      return {
        score: 0,
        explanation: str_(UIStrings.explanationPublicId),
      };
    }

    if (doctypeSystemId !== '') {
      return {
        score: 0,
        explanation: str_(UIStrings.explanationSystemId),
      };
    }

    /* Note that the value for name is case sensitive,
       and must be the string `html`. For details see:
       https://html.spec.whatwg.org/multipage/parsing.html#the-initial-insertion-mode */
    if (doctypeName === 'html') {
      return {
        score: 1,
      };
    } else {
      return {
        score: 0,
        explanation: str_(UIStrings.explanationBadDoctype),
      };
    }
  }
}

module.exports = Doctype;
module.exports.UIStrings = UIStrings;

}).call(this)}).call(this,"/lighthouse-core/audits/dobetterweb/doctype.js")
},{"../../lib/i18n/i18n.js":96,"../audit.js":3}],"../audits/dobetterweb/dom-size":[function(require,module,exports){
(function (__filename){(function (){
/**
 * @license Copyright 2017 The Lighthouse Authors. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.
 */

/**
 * @fileoverview Audits a page to see how the size of DOM it creates. Stats like
 * tree depth, # children, and total elements are returned. The score is calculated
 * based solely on the total number of elements found on the page.
 */

'use strict';

const Audit = require('../audit.js');
const i18n = require('../../lib/i18n/i18n.js');

const UIStrings = {
  /** Title of a diagnostic audit that provides detail on the size of the web page's DOM. The size of a DOM is characterized by the total number of DOM elements and greatest DOM depth. This descriptive title is shown to users when the amount is acceptable and no user action is required. */
  title: 'Avoids an excessive DOM size',
  /** Title of a diagnostic audit that provides detail on the size of the web page's DOM. The size of a DOM is characterized by the total number of DOM elements and greatest DOM depth. This imperative title is shown to users when there is a significant amount of execution time that could be reduced. */
  failureTitle: 'Avoid an excessive DOM size',
  /** Description of a Lighthouse audit that tells the user *why* they should reduce the size of the web page's DOM. The size of a DOM is characterized by the total number of DOM elements and greatest DOM depth. This is displayed after a user expands the section to see more. No character length limits. 'Learn More' becomes link text to additional documentation. */
  description: 'A large DOM will increase memory usage, cause longer ' +
    '[style calculations](https://developers.google.com/web/fundamentals/performance/rendering/reduce-the-scope-and-complexity-of-style-calculations), ' +
    'and produce costly [layout reflows](https://developers.google.com/speed/articles/reflow). [Learn more](https://web.dev/dom-size/).',
  /** Table column header for the type of statistic. These statistics describe how big the DOM is (count of DOM elements, children, depth). */
  columnStatistic: 'Statistic',
  /** Table column header for the observed value of the DOM statistic. */
  columnValue: 'Value',
  /** [ICU Syntax] Label for an audit identifying the number of DOM elements found in the page. */
  displayValue: `{itemCount, plural,
    =1 {1 element}
    other {# elements}
    }`,
  /** Label for the total number of DOM elements found in the page. */
  statisticDOMElements: 'Total DOM Elements',
  /** Label for the numeric value of the maximum depth in the page's DOM tree. */
  statisticDOMDepth: 'Maximum DOM Depth',
  /** Label for the numeric value of the maximum number of children any DOM element in the page has. The element described will have the most children in the page. */
  statisticDOMWidth: 'Maximum Child Elements',
};

const str_ = i18n.createMessageInstanceIdFn(__filename, UIStrings);

class DOMSize extends Audit {
  /**
   * @return {LH.Audit.Meta}
   */
  static get meta() {
    return {
      id: 'dom-size',
      title: str_(UIStrings.title),
      failureTitle: str_(UIStrings.failureTitle),
      description: str_(UIStrings.description),
      scoreDisplayMode: Audit.SCORING_MODES.NUMERIC,
      requiredArtifacts: ['DOMStats'],
    };
  }

  /**
   * @return {LH.Audit.ScoreOptions}
   */
  static get defaultOptions() {
    return {
      // https://bigquery.cloud.google.com/table/httparchive:lighthouse.2018_04_01_mobile?pli=1
      // see https://www.desmos.com/calculator/tsunbwqt3f
      p10: 818,
      median: 1400,
    };
  }


  /**
   * @param {LH.Artifacts} artifacts
   * @param {LH.Audit.Context} context
   * @return {LH.Audit.Product}
   */
  static audit(artifacts, context) {
    const stats = artifacts.DOMStats;

    const score = Audit.computeLogNormalScore(
      {p10: context.options.p10, median: context.options.median},
      stats.totalBodyElements
    );

    /** @type {LH.Audit.Details.Table['headings']} */
    const headings = [
      {key: 'statistic', itemType: 'text', text: str_(UIStrings.columnStatistic)},
      {key: 'node', itemType: 'node', text: str_(i18n.UIStrings.columnElement)},
      {key: 'value', itemType: 'numeric', text: str_(UIStrings.columnValue)},
    ];

    /** @type {LH.Audit.Details.Table['items']} */
    const items = [
      {
        statistic: str_(UIStrings.statisticDOMElements),
        value: stats.totalBodyElements,
      },
      {
        node: Audit.makeNodeItem(stats.depth),
        statistic: str_(UIStrings.statisticDOMDepth),
        value: stats.depth.max,
      },
      {
        node: Audit.makeNodeItem(stats.width),
        statistic: str_(UIStrings.statisticDOMWidth),
        value: stats.width.max,
      },
    ];

    return {
      score,
      numericValue: stats.totalBodyElements,
      numericUnit: 'element',
      displayValue: str_(UIStrings.displayValue, {itemCount: stats.totalBodyElements}),
      details: Audit.makeTableDetails(headings, items),
    };
  }
}

module.exports = DOMSize;
module.exports.UIStrings = UIStrings;

}).call(this)}).call(this,"/lighthouse-core/audits/dobetterweb/dom-size.js")
},{"../../lib/i18n/i18n.js":96,"../audit.js":3}],"../audits/dobetterweb/external-anchors-use-rel-noopener":[function(require,module,exports){
(function (__filename){(function (){
/**
 * @license Copyright 2016 The Lighthouse Authors. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.
 */
'use strict';

const URL = require('../../lib/url-shim.js');
const Audit = require('../audit.js');
const i18n = require('../../lib/i18n/i18n.js');

const UIStrings = {
  /** Title of a Lighthouse audit that provides detail on the cross-origin links that the web page contains, and whether the links can be considered safe. This descriptive title is shown to users when all links are safe. */
  title: 'Links to cross-origin destinations are safe',
  /** Title of a Lighthouse audit that provides detail on the cross-origin links that the web page contains, and whether the links can be considered safe. This descriptive title is shown to users when not all links can be considered safe. */
  failureTitle: 'Links to cross-origin destinations are unsafe',
  /** Description of a Lighthouse audit that tells the user why and how they should secure cross-origin links. This is displayed after a user expands the section to see more. No character length limits. 'Learn More' becomes link text to additional documentation. */
  description: 'Add `rel="noopener"` or `rel="noreferrer"` to any external links to improve ' +
    'performance and prevent security vulnerabilities. ' +
    '[Learn more](https://web.dev/external-anchors-use-rel-noopener/).',
  /**
   * @description Warning that some links' destinations cannot be determined and therefore the audit cannot evaluate the link's safety.
   * @example {<a target="_blank">} anchorHTML
   */
  warning: 'Unable to determine the destination for anchor ({anchorHTML}). ' +
    'If not used as a hyperlink, consider removing target=_blank.',
  /** Label for a column in a data table; entries will be the HTML elements that failed the audit. Anchors are DOM elements that are links. */
  columnFailingAnchors: 'Failing Anchors',
};

const str_ = i18n.createMessageInstanceIdFn(__filename, UIStrings);

class ExternalAnchorsUseRelNoopenerAudit extends Audit {
  /**
   * @return {LH.Audit.Meta}
   */
  static get meta() {
    return {
      id: 'external-anchors-use-rel-noopener',
      title: str_(UIStrings.title),
      failureTitle: str_(UIStrings.failureTitle),
      description: str_(UIStrings.description),
      requiredArtifacts: ['URL', 'AnchorElements'],
    };
  }

  /**
   * @param {LH.Artifacts} artifacts
   * @return {LH.Audit.Product}
   */
  static audit(artifacts) {
    /** @type {LH.IcuMessage[]} */
    const warnings = [];
    const pageHost = new URL(artifacts.URL.finalUrl).host;
    const failingAnchors = artifacts.AnchorElements
      .filter(anchor => anchor.target === '_blank' && !anchor.rel.includes('noopener') &&
        !anchor.rel.includes('noreferrer'))
    // Filter usages to exclude anchors that are same origin
      .filter(anchor => {
        try {
          return new URL(anchor.href).host !== pageHost;
        } catch (err) {
          warnings.push(str_(UIStrings.warning, {anchorHTML: anchor.node.snippet}));
          return true;
        }
      })
      .filter(anchor => {
        return !anchor.href || anchor.href.toLowerCase().startsWith('http');
      })
      .map(anchor => {
        return {
          node: Audit.makeNodeItem(anchor.node),
          href: anchor.href || 'Unknown',
          target: anchor.target || '',
          rel: anchor.rel || '',
          outerHTML: anchor.node.snippet || '',
        };
      });

    /** @type {LH.Audit.Details.Table['headings']} */
    const headings = [
      {key: 'node', itemType: 'node', text: str_(UIStrings.columnFailingAnchors)},
    ];

    const details = Audit.makeTableDetails(headings, failingAnchors);

    return {
      score: Number(failingAnchors.length === 0),
      details,
      warnings,
    };
  }
}

module.exports = ExternalAnchorsUseRelNoopenerAudit;
module.exports.UIStrings = UIStrings;

}).call(this)}).call(this,"/lighthouse-core/audits/dobetterweb/external-anchors-use-rel-noopener.js")
},{"../../lib/i18n/i18n.js":96,"../../lib/url-shim.js":"url","../audit.js":3}],"../audits/dobetterweb/geolocation-on-start":[function(require,module,exports){
(function (__filename){(function (){
/**
 * @license Copyright 2016 The Lighthouse Authors. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.
 */

/**
 * @fileoverview Audits a page to see if it is requesting the geolocation API on
 * page load. This is often a sign of poor user experience because it lacks context.
 */

'use strict';

const ViolationAudit = require('../violation-audit.js');
const i18n = require('../../lib/i18n/i18n.js');

const UIStrings = {
  /** Title of a Lighthouse audit that provides detail on geolocation permission requests while the page is loading. This descriptive title is shown to users when the page does not ask for geolocation permissions on load. */
  title: 'Avoids requesting the geolocation permission on page load',
  /** Title of a Lighthouse audit that provides detail on geolocation permissions requests. This descriptive title is shown to users when the page does ask for geolocation permissions on load. */
  failureTitle: 'Requests the geolocation permission on page load',
  /** Description of a Lighthouse audit that tells the user why they should not ask for geolocation permissions on load. This is displayed after a user expands the section to see more. No character length limits. 'Learn More' becomes link text to additional documentation. */
  description: 'Users are mistrustful of or confused by sites that request their ' +
    'location without context. Consider tying the request to a user action instead. ' +
    '[Learn more](https://web.dev/geolocation-on-start/).',
};

const str_ = i18n.createMessageInstanceIdFn(__filename, UIStrings);

class GeolocationOnStart extends ViolationAudit {
  /**
   * @return {LH.Audit.Meta}
   */
  static get meta() {
    return {
      id: 'geolocation-on-start',
      title: str_(UIStrings.title),
      failureTitle: str_(UIStrings.failureTitle),
      description: str_(UIStrings.description),
      supportedModes: ['navigation'],
      requiredArtifacts: ['ConsoleMessages'],
    };
  }

  /**
   * @param {LH.Artifacts} artifacts
   * @return {LH.Audit.Product}
   */
  static audit(artifacts) {
    // 'Only request geolocation information in response to a user gesture.'
    const results = ViolationAudit.getViolationResults(artifacts, /geolocation/);

    /** @type {LH.Audit.Details.Table['headings']} */
    const headings = [
      {key: 'source', itemType: 'source-location', text: str_(i18n.UIStrings.columnSource)},
    ];
    // TODO(bckenny): there should actually be a ts error here. results[0].stackTrace
    // should violate the results type. Shouldn't be removed from details items regardless.
    const details = ViolationAudit.makeTableDetails(headings, results);

    return {
      score: Number(results.length === 0),
      details,
    };
  }
}

module.exports = GeolocationOnStart;
module.exports.UIStrings = UIStrings;

}).call(this)}).call(this,"/lighthouse-core/audits/dobetterweb/geolocation-on-start.js")
},{"../../lib/i18n/i18n.js":96,"../violation-audit.js":8}],"../audits/dobetterweb/inspector-issues":[function(require,module,exports){
(function (__filename){(function (){
/**
 * @license Copyright 2020 The Lighthouse Authors. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.
 */

/**
 * @fileoverview Audits a page to determine whether it generates issues in the Issues panel of Chrome Devtools.
 * The audit is meant to maintain parity with the Chrome Devtools Issues panel front end.
 * https://source.chromium.org/chromium/chromium/src/+/main:third_party/devtools-frontend/src/front_end/sdk/
 */

'use strict';

/** @typedef {{url: string}} IssueSubItem */
/** @typedef {{issueType: string|LH.IcuMessage, subItems: Array<IssueSubItem>}} IssueItem */

const Audit = require('../audit.js');
const i18n = require('../../lib/i18n/i18n.js');

const UIStrings = {
  /** Title of a Lighthouse audit that provides detail on various types of problems with a website, like security or network errors. This descriptive title is shown to users when no issues were logged into the Chrome DevTools Issues panel. */
  title: 'No issues in the `Issues` panel in Chrome Devtools',
  /** Title of a Lighthouse audit that provides detail on various types of problems with a website, like security or network errors. This descriptive title is shown to users when issues are detected and logged into the Chrome DevTools Issues panel. */
  failureTitle: 'Issues were logged in the `Issues` panel in Chrome Devtools',
  /* eslint-disable max-len */
  /** Description of a Lighthouse audit that tells the user why issues being logged to the Chrome DevTools Issues panel are a cause for concern and so should be fixed. This is displayed after a user expands the section to see more. No character length limits. */
  description: 'Issues logged to the `Issues` panel in Chrome Devtools indicate unresolved problems. They can come from network request failures, insufficient security controls, and other browser concerns. Open up the Issues panel in Chrome DevTools for more details on each issue.',
  /* eslint-enable max-len */
  /** Table column header for the types of problems observed in a website, like security or network errors. */
  columnIssueType: 'Issue type',
  /** The type of an Issue in Chrome DevTools when a resource is blocked due to the website's cross-origin policy. */
  issueTypeBlockedByResponse: 'Blocked by cross-origin policy',
  /** The type of an Issue in Chrome DevTools when a site has large ads that use up a lot of the browser's resources. */
  issueTypeHeavyAds: 'Heavy resource usage by ads',
};

const str_ = i18n.createMessageInstanceIdFn(__filename, UIStrings);

class IssuesPanelEntries extends Audit {
  /**
   * @return {LH.Audit.Meta}
   */
  static get meta() {
    return {
      id: 'inspector-issues',
      title: str_(UIStrings.title),
      failureTitle: str_(UIStrings.failureTitle),
      description: str_(UIStrings.description),
      requiredArtifacts: ['InspectorIssues'],
    };
  }

  /**
   * @param {Array<LH.Crdp.Audits.MixedContentIssueDetails>} mixedContentIssues
   * @return {LH.Audit.Details.TableItem}
   */
  static getMixedContentRow(mixedContentIssues) {
    const requestUrls = new Set();
    for (const issue of mixedContentIssues) {
      const requestUrl = (issue.request && issue.request.url) || issue.mainResourceURL;
      requestUrls.add(requestUrl);
    }
    return {
      issueType: 'Mixed content',
      subItems: {
        type: 'subitems',
        items: Array.from(requestUrls).map(url => ({url})),
      },
    };
  }

  /**
   * @param {Array<LH.Crdp.Audits.SameSiteCookieIssueDetails>} sameSiteCookieIssues
   * @return {LH.Audit.Details.TableItem}
   */
  static getSameSiteCookieRow(sameSiteCookieIssues) {
    const requestUrls = new Set();
    for (const issue of sameSiteCookieIssues) {
      const requestUrl = (issue.request && issue.request.url) || issue.cookieUrl;
      if (requestUrl) {
        requestUrls.add(requestUrl);
      }
    }
    return {
      issueType: 'SameSite cookie',
      subItems: {
        type: 'subitems',
        items: Array.from(requestUrls).map(url => {
          return {
            url,
          };
        }),
      },
    };
  }

  /**
   * @param {Array<LH.Crdp.Audits.BlockedByResponseIssueDetails>} blockedByResponseIssues
   * @return {LH.Audit.Details.TableItem}
   */
  static getBlockedByResponseRow(blockedByResponseIssues) {
    const requestUrls = new Set();
    for (const issue of blockedByResponseIssues) {
      const requestUrl = issue.request && issue.request.url;
      if (requestUrl) {
        requestUrls.add(requestUrl);
      }
    }
    return {
      issueType: str_(UIStrings.issueTypeBlockedByResponse),
      subItems: {
        type: 'subitems',
        items: Array.from(requestUrls).map(url => {
          return {
            url,
          };
        }),
      },
    };
  }

  /**
   * @param {Array<LH.Crdp.Audits.ContentSecurityPolicyIssueDetails>} cspIssues
   * @return {LH.Audit.Details.TableItem}
   */
  static getContentSecurityPolicyRow(cspIssues) {
    const requestUrls = new Set();
    for (const issue of cspIssues) {
      const requestUrl = issue.blockedURL;
      if (requestUrl) {
        requestUrls.add(requestUrl);
      }
    }
    return {
      issueType: 'Content security policy',
      subItems: {
        type: 'subitems',
        items: Array.from(requestUrls).map(url => {
          return {
            url,
          };
        }),
      },
    };
  }

  /**
   * @param {LH.Artifacts} artifacts
   * @return {LH.Audit.Product}
   */
  static audit(artifacts) {
    /** @type {LH.Audit.Details.Table['headings']} */
    const headings = [
      /* eslint-disable max-len */
      {key: 'issueType', itemType: 'text', subItemsHeading: {key: 'url', itemType: 'url'}, text: str_(UIStrings.columnIssueType)},
      /* eslint-enable max-len */
    ];

    const issues = artifacts.InspectorIssues;
    /** @type LH.Audit.Details.TableItem[] */
    const items = [];

    if (issues.mixedContent.length) {
      items.push(this.getMixedContentRow(issues.mixedContent));
    }
    if (issues.sameSiteCookies.length) {
      items.push(this.getSameSiteCookieRow(issues.sameSiteCookies));
    }
    if (issues.blockedByResponse.length) {
      items.push(this.getBlockedByResponseRow(issues.blockedByResponse));
    }
    if (issues.heavyAds.length) {
      items.push({issueType: str_(UIStrings.issueTypeHeavyAds)});
    }
    const cspIssues = issues.contentSecurityPolicy.filter(issue => {
      // kTrustedTypesSinkViolation and kTrustedTypesPolicyViolation aren't currently supported by the Issues panel
      return issue.contentSecurityPolicyViolationType !== 'kTrustedTypesSinkViolation' &&
        issue.contentSecurityPolicyViolationType !== 'kTrustedTypesPolicyViolation';
    });
    if (cspIssues.length) {
      items.push(this.getContentSecurityPolicyRow(cspIssues));
    }
    return {
      score: items.length > 0 ? 0 : 1,
      details: Audit.makeTableDetails(headings, items),
    };
  }
}

module.exports = IssuesPanelEntries;
module.exports.UIStrings = UIStrings;

}).call(this)}).call(this,"/lighthouse-core/audits/dobetterweb/inspector-issues.js")
},{"../../lib/i18n/i18n.js":96,"../audit.js":3}],"../audits/dobetterweb/js-libraries":[function(require,module,exports){
(function (__filename){(function (){
/**
 * @license Copyright 2017 The Lighthouse Authors. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.
 */

/**
 * @fileoverview Diagnostic audit that lists all JavaScript libraries detected on the page
 */

'use strict';

const Audit = require('../audit.js');
const i18n = require('../../lib/i18n/i18n.js');

const UIStrings = {
  /** Title of a Lighthouse audit that provides detail on the Javascript libraries that are used on the page. */
  title: 'Detected JavaScript libraries',
  /** Description of a Lighthouse audit that tells the user what this audit is detecting. This is displayed after a user expands the section to see more. No character length limits. */
  description: 'All front-end JavaScript libraries detected on the page. [Learn more](https://web.dev/js-libraries/).',
  /** Label for a column in a data table; entries will be the version numbers of the detected Javascript libraries.  */
  columnVersion: 'Version',
};

const str_ = i18n.createMessageInstanceIdFn(__filename, UIStrings);

class JsLibrariesAudit extends Audit {
  /**
   * @return {LH.Audit.Meta}
   */
  static get meta() {
    return {
      id: 'js-libraries',
      title: str_(UIStrings.title),
      description: str_(UIStrings.description),
      requiredArtifacts: ['Stacks'],
    };
  }

  /**
   * @param {LH.Artifacts} artifacts
   * @return {LH.Audit.Product}
   */
  static audit(artifacts) {
    const libDetails = artifacts.Stacks
      .filter(stack => stack.detector === 'js')
      // Don't show the fast paths in the table.
      .filter(stack => !stack.id.endsWith('-fast'))
      .map(stack => ({
        name: stack.name,
        version: stack.version,
        npm: stack.npm,
      }));

    /** @type {LH.Audit.Details.Table['headings']} */
    const headings = [
      {key: 'name', itemType: 'text', text: str_(i18n.UIStrings.columnName)},
      {key: 'version', itemType: 'text', text: str_(UIStrings.columnVersion)},
    ];
    const details = Audit.makeTableDetails(headings, libDetails, {});

    const debugData = {
      type: /** @type {'debugdata'} */ ('debugdata'),
      stacks: artifacts.Stacks.map(stack => {
        return {
          id: stack.id,
          version: stack.version,
        };
      }),
    };

    return {
      score: 1, // Always pass for now.
      details: {
        ...details,
        debugData,
      },
    };
  }
}

module.exports = JsLibrariesAudit;
module.exports.UIStrings = UIStrings;

}).call(this)}).call(this,"/lighthouse-core/audits/dobetterweb/js-libraries.js")
},{"../../lib/i18n/i18n.js":96,"../audit.js":3}],"../audits/dobetterweb/no-document-write":[function(require,module,exports){
(function (__filename){(function (){
/**
 * @license Copyright 2016 The Lighthouse Authors. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.
 */

/**
 * @fileoverview Audit a page to see if it's using document.write(). document.write() has terrible performance characteristics.
 *
 * *Intervention*
 * There is a Chrome intervention for the API: https://developers.google.com/web/updates/2016/08/removing-document-write
 * The intervention appears to only be enabled when the user is on a slow connnection. https://chromestatus.com/features#document.write
 * When it's enabled, _some_ calls to document.write() will just not do anything. They're just no-ops.
 *  - "some" == mostly third-party situations. src: https://cs.chromium.org/chromium/src/third_party/blink/renderer/core/script/document_write_intervention.cc?l=109&rcl=61a806621861e9abc07b3a57a6f2edae188d1742
 * If this happens, there will be an error message in the console. src: https://cs.chromium.org/chromium/src/third_party/blink/renderer/core/script/document_write_intervention.cc?l=51-61&rcl=61a806621861e9abc07b3a57a6f2edae188d1742
 *  - Lighthouse doesn't report here on that situation, though it'll show up in `errors-in-console`
 * The intervention may also not block the .write() (because the connection wasn't slow),
 * but it will emit a console warning.
 *  - Lighthouse will also report that here, as the .write() call succeeded.
 * Demo URL: https://output.jsbin.com/qopijux/quiet
 *
 * *This Audit*
 * This audit reports on document.write() calls which the intervention didn't stop.
 * (They worked as intended). If that happens, the browser emits a verbose-level violation
 * console message (hidden by default) that says:
 *     "Parser was blocked due to document.write(<script>)". src: https://cs.chromium.org/chromium/src/third_party/blink/renderer/core/frame/performance_monitor.cc?l=294-300&rcl=40b90cafad9f219e0845879ed8648bdcc96116dc
 */

'use strict';

const ViolationAudit = require('../violation-audit.js');
const i18n = require('../../lib/i18n/i18n.js');

const UIStrings = {
  /** Title of a Lighthouse audit that provides detail on the page's use of the `document.write` API. This descriptive title is shown to users when the page does not use `document.write`. */
  title: 'Avoids `document.write()`',
  /** Title of a Lighthouse audit that provides detail on the page's use of the `document.write` API. This imperative title is shown to users when the page does use `document.write`. */
  failureTitle: 'Avoid `document.write()`',
  /** Description of a Lighthouse audit that tells the user why they should avoid `document.write`. This is displayed after a user expands the section to see more. No character length limits. 'Learn More' becomes link text to additional documentation. */
  description: 'For users on slow connections, external scripts dynamically injected via ' +
      '`document.write()` can delay page load by tens of seconds. ' +
      '[Learn more](https://web.dev/no-document-write/).',
};

const str_ = i18n.createMessageInstanceIdFn(__filename, UIStrings);

class NoDocWriteAudit extends ViolationAudit {
  /**
   * @return {LH.Audit.Meta}
   */
  static get meta() {
    return {
      id: 'no-document-write',
      title: str_(UIStrings.title),
      failureTitle: str_(UIStrings.failureTitle),
      description: str_(UIStrings.description),
      requiredArtifacts: ['ConsoleMessages'],
    };
  }

  /**
   * @param {LH.Artifacts} artifacts
   * @return {LH.Audit.Product}
   */
  static audit(artifacts) {
    const results = ViolationAudit.getViolationResults(artifacts, /document\.write/);

    /** @type {LH.Audit.Details.Table['headings']} */
    const headings = [
      {key: 'source', itemType: 'source-location', text: str_(i18n.UIStrings.columnSource)},
    ];
    // TODO(bckenny): see TODO in geolocation-on-start
    const details = ViolationAudit.makeTableDetails(headings, results);

    return {
      score: Number(results.length === 0),
      details,
    };
  }
}

module.exports = NoDocWriteAudit;
module.exports.UIStrings = UIStrings;

}).call(this)}).call(this,"/lighthouse-core/audits/dobetterweb/no-document-write.js")
},{"../../lib/i18n/i18n.js":96,"../violation-audit.js":8}],"../audits/dobetterweb/no-vulnerable-libraries":[function(require,module,exports){
(function (__filename){(function (){
/**
 * @license Copyright 2017 The Lighthouse Authors. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.
 */

/**
 * @fileoverview Audits a page to make sure there are no JS libraries with
 * known vulnerabilities being used. Checks against a vulnerability db
 * provided by Snyk.io and checked in locally as third-party/snyk/snapshot.json
 */

'use strict';

const Audit = require('../audit.js');
const Sentry = require('../../lib/sentry.js');
const semver = require('semver');
const snykDatabase = require('../../../third-party/snyk/snapshot.json');
const i18n = require('../../lib/i18n/i18n.js');

const UIStrings = {
  /** Title of a Lighthouse audit that provides detail on Javascript libraries the page uses. This descriptive title is shown to users when all Javascript libraries are free of known security vulnerabilities. */
  title: 'Avoids front-end JavaScript libraries' +
    ' with known security vulnerabilities',
  /** Title of a Lighthouse audit that provides detail on Javascript libraries the page uses. This descriptive title is shown to users when some detected Javascript libraries have known security vulnerabilities. */
  failureTitle: 'Includes front-end JavaScript libraries' +
    ' with known security vulnerabilities',
  /** Description of a Lighthouse audit that tells the user why they should be concerned about the third party Javascript libraries that they use. This is displayed after a user expands the section to see more. No character length limits. 'Learn More' becomes link text to additional documentation. */
  description: 'Some third-party scripts may contain known security vulnerabilities ' +
    'that are easily identified and exploited by attackers. ' +
    '[Learn more](https://web.dev/no-vulnerable-libraries/).',
  /** [ICU Syntax] Label for the audit identifying the number of vulnerable Javascript libraries found. */
  displayValue: `{itemCount, plural,
    =1 {1 vulnerability detected}
    other {# vulnerabilities detected}
    }`,
  /** Label for a column in a data table; entries will be the version numbers of the Javascript libraries found.  */
  columnVersion: 'Library Version',
  /** Label for a column in a data table; entries will be the counts of JavaScript-library vulnerabilities found.  */
  columnVuln: 'Vulnerability Count',
  /** Label for a column in a data table; entries will be the severity of the vulnerabilities found within a Javascript library. */
  columnSeverity: 'Highest Severity',
};

const str_ = i18n.createMessageInstanceIdFn(__filename, UIStrings);

const SEMVER_REGEX = /^(\d+\.\d+\.\d+)[^-0-9]+/;

/** @type {Record<string, LH.IcuMessage>} */
const severityStringsMap = {
  'low': str_(i18n.UIStrings.itemSeverityLow),
  'medium': str_(i18n.UIStrings.itemSeverityMedium),
  'high': str_(i18n.UIStrings.itemSeverityHigh),
};

/** @typedef {{npm: Object<string, Array<{id: string, severity: string, semver: {vulnerable: Array<string>}}>>}} SnykDB */
/** @typedef {{severity: LH.IcuMessage, numericSeverity: number, library: string, url: string}} Vulnerability */

class NoVulnerableLibrariesAudit extends Audit {
  /**
   * @return {LH.Audit.Meta}
   */
  static get meta() {
    return {
      id: 'no-vulnerable-libraries',
      title: str_(UIStrings.title),
      failureTitle: str_(UIStrings.failureTitle),
      description: str_(UIStrings.description),
      requiredArtifacts: ['Stacks'],
    };
  }

  /**
   * @return {SnykDB}
   */
  static get snykDB() {
    return snykDatabase;
  }

  /**
   * @return {Object<string, number>}
   */
  static get severityMap() {
    return {
      high: 3,
      medium: 2,
      low: 1,
    };
  }

  /**
   * Attempts to normalize the version.
   * @param {string|undefined} version
   * @return {string|undefined}
   */
  static normalizeVersion(version) {
    if (!version) return version;
    if (semver.valid(version)) return version;

    // converts 1.5 -> 1.5.0
    if (/^\d+\.\d+$/.test(version)) return `${version}.0`;
    // converts 1.0.0a-bunch-of-crap -> 1.0.0
    const versionMatch = version.match(SEMVER_REGEX);
    if (versionMatch) return versionMatch[1];
    // leave everything else untouched
    return version;
  }

  /**
   * @param {string} normalizedVersion
   * @param {LH.Artifacts.DetectedStack} lib
   * @param {SnykDB} snykDB
   * @return {Array<Vulnerability>}
   */
  static getVulnerabilities(normalizedVersion, lib, snykDB) {
    if (!lib.npm || !snykDB.npm[lib.npm]) {
      return [];
    }

    // Verify the version is well-formed first
    try {
      semver.satisfies(normalizedVersion, '*');
    } catch (err) {
      err.pkgName = lib.npm;
      // Report the failure and skip this library if the version was ill-specified
      Sentry.captureException(err, {level: 'warning'});
      return [];
    }

    // Match the vulnerability candidates from snyk against the version we see in the page
    const vulnCandidatesForLib = snykDB.npm[lib.npm];
    const matchingVulns = vulnCandidatesForLib.filter(vulnCandidate => {
      // Each snyk vulnerability comes with an array of semver ranges
      // The page is vulnerable if any of the ranges match.
      const hasMatchingVersion = vulnCandidate.semver.vulnerable.some(vulnSemverRange =>
        semver.satisfies(normalizedVersion, vulnSemverRange)
      );
      return hasMatchingVersion;
    });

    const vulns = matchingVulns.map(vuln => {
      return {
        severity: severityStringsMap[vuln.severity],
        numericSeverity: this.severityMap[vuln.severity],
        library: `${lib.name}@${normalizedVersion}`,
        url: 'https://snyk.io/vuln/' + vuln.id,
      };
    });

    return vulns;
  }

  /**
   * @param {Array<Vulnerability>} vulnerabilities
   * @return {LH.IcuMessage}
   */
  static highestSeverity(vulnerabilities) {
    const sortedVulns = vulnerabilities
      .sort((a, b) => b.numericSeverity - a.numericSeverity);
    return sortedVulns[0].severity;
  }

  /**
   * @param {LH.Artifacts} artifacts
   * @return {LH.Audit.Product}
   */
  static audit(artifacts) {
    const foundLibraries = artifacts.Stacks.filter(stack => stack.detector === 'js');
    const snykDB = NoVulnerableLibrariesAudit.snykDB;

    if (!foundLibraries.length) {
      return {
        score: 1,
      };
    }

    let totalVulns = 0;
    /** @type {Array<{highestSeverity: LH.IcuMessage, vulnCount: number, detectedLib: LH.Audit.Details.LinkValue}>} */
    const vulnerabilityResults = [];

    for (const lib of foundLibraries) {
      const version = this.normalizeVersion(lib.version) || '';
      const vulns = this.getVulnerabilities(version, lib, snykDB);
      const vulnCount = vulns.length;
      totalVulns += vulnCount;

      let highestSeverity;
      if (vulns.length > 0) {
        highestSeverity = this.highestSeverity(vulns);

        vulnerabilityResults.push({
          highestSeverity,
          vulnCount,
          detectedLib: {
            text: lib.name + '@' + version,
            url: `https://snyk.io/vuln/npm:${lib.npm}?lh=${version}&utm_source=lighthouse&utm_medium=ref&utm_campaign=audit`,
            type: 'link',
          },
        });
      }
    }

    let displayValue;
    if (totalVulns > 0) {
      displayValue = str_(UIStrings.displayValue, {itemCount: totalVulns});
    }

    /** @type {LH.Audit.Details.Table['headings']} */
    const headings = [
      {key: 'detectedLib', itemType: 'link', text: str_(UIStrings.columnVersion)},
      {key: 'vulnCount', itemType: 'text', text: str_(UIStrings.columnVuln)},
      {key: 'highestSeverity', itemType: 'text', text: str_(UIStrings.columnSeverity)},
    ];
    const details = Audit.makeTableDetails(headings, vulnerabilityResults, {});

    return {
      score: Number(totalVulns === 0),
      displayValue,
      details,
    };
  }
}

module.exports = NoVulnerableLibrariesAudit;
module.exports.UIStrings = UIStrings;

}).call(this)}).call(this,"/lighthouse-core/audits/dobetterweb/no-vulnerable-libraries.js")
},{"../../../third-party/snyk/snapshot.json":262,"../../lib/i18n/i18n.js":96,"../../lib/sentry.js":112,"../audit.js":3,"semver":230}],"../audits/dobetterweb/notification-on-start":[function(require,module,exports){
(function (__filename){(function (){
/**
 * @license Copyright 2016 The Lighthouse Authors. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.
 */

/**
 * @fileoverview Audits a page to see if it is requesting usage of the notification API on
 * page load. This is often a sign of poor user experience because it lacks context.
 */

'use strict';

const ViolationAudit = require('../violation-audit.js');
const i18n = require('../../lib/i18n/i18n.js');

const UIStrings = {
  /** Title of a Lighthouse audit that provides detail on the page's notification permission requests. This descriptive title is shown to users when the page does not ask for notification permission on load. */
  title: 'Avoids requesting the notification permission on page load',
  /** Title of a Lighthouse audit that provides detail on the page's notification permission requests. This descriptive title is shown to users when the page does ask for notification permission on load. */
  failureTitle: 'Requests the notification permission on page load',
  /** Description of a Lighthouse audit that tells the user why they should not ask for notification permission on load. This is displayed after a user expands the section to see more. No character length limits. 'Learn More' becomes link text to additional documentation. */
  description: 'Users are mistrustful of or confused by sites that request to send ' +
      'notifications without context. Consider tying the request to user gestures ' +
      'instead. [Learn more](https://web.dev/notification-on-start/).',
};

const str_ = i18n.createMessageInstanceIdFn(__filename, UIStrings);

class NotificationOnStart extends ViolationAudit {
  /**
   * @return {LH.Audit.Meta}
   */
  static get meta() {
    return {
      id: 'notification-on-start',
      title: str_(UIStrings.title),
      failureTitle: str_(UIStrings.failureTitle),
      description: str_(UIStrings.description),
      supportedModes: ['navigation'],
      requiredArtifacts: ['ConsoleMessages'],
    };
  }

  /**
   * @param {LH.Artifacts} artifacts
   * @return {LH.Audit.Product}
   */
  static audit(artifacts) {
    const results = ViolationAudit.getViolationResults(artifacts, /notification permission/);

    /** @type {LH.Audit.Details.Table['headings']} */
    const headings = [
      {key: 'source', itemType: 'source-location', text: str_(i18n.UIStrings.columnSource)},
    ];
    // TODO(bckenny): see TODO in geolocation-on-start
    const details = ViolationAudit.makeTableDetails(headings, results);

    return {
      score: Number(results.length === 0),
      details,
    };
  }
}

module.exports = NotificationOnStart;
module.exports.UIStrings = UIStrings;

}).call(this)}).call(this,"/lighthouse-core/audits/dobetterweb/notification-on-start.js")
},{"../../lib/i18n/i18n.js":96,"../violation-audit.js":8}],"../audits/dobetterweb/password-inputs-can-be-pasted-into":[function(require,module,exports){
(function (__filename){(function (){
/**
 * @license Copyright 2016 The Lighthouse Authors. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.
 */
'use strict';

const Audit = require('../audit.js');
const i18n = require('../../lib/i18n/i18n.js');

const UIStrings = {
  /** Title of a Lighthouse audit that provides detail on the ability to paste into password fields. This descriptive title is shown to users when the page allows pasting of content into password fields. */
  title: 'Allows users to paste into password fields',
  /** Title of a Lighthouse audit that provides detail on the ability to paste into password fields. This descriptive title is shown to users when the page does not allow pasting of content into password fields. */
  failureTitle: 'Prevents users to paste into password fields',
  /** Description of a Lighthouse audit that tells the user why they should allow pasting of content into password fields. This is displayed after a user expands the section to see more. No character length limits. 'Learn More' becomes link text to additional documentation. */
  description: 'Preventing password pasting undermines good security policy. ' +
      '[Learn more](https://web.dev/password-inputs-can-be-pasted-into/).',
};

const str_ = i18n.createMessageInstanceIdFn(__filename, UIStrings);

class PasswordInputsCanBePastedIntoAudit extends Audit {
  /**
   * @return {LH.Audit.Meta}
   */
  static get meta() {
    return {
      id: 'password-inputs-can-be-pasted-into',
      title: str_(UIStrings.title),
      failureTitle: str_(UIStrings.failureTitle),
      description: str_(UIStrings.description),
      requiredArtifacts: ['PasswordInputsWithPreventedPaste'],
    };
  }

  /**
   * @param {LH.Artifacts} artifacts
   * @return {LH.Audit.Product}
   */
  static audit(artifacts) {
    const passwordInputsWithPreventedPaste = artifacts.PasswordInputsWithPreventedPaste;

    /** @type {LH.Audit.Details.Table['items']} */
    const items = [];

    passwordInputsWithPreventedPaste.forEach(input => {
      items.push({
        node: Audit.makeNodeItem(input.node),
      });
    });

    /** @type {LH.Audit.Details.Table['headings']} */
    const headings = [
      {key: 'node', itemType: 'node', text: str_(i18n.UIStrings.columnFailingElem)},
    ];

    return {
      score: Number(passwordInputsWithPreventedPaste.length === 0),
      details: Audit.makeTableDetails(headings, items),
    };
  }
}

module.exports = PasswordInputsCanBePastedIntoAudit;
module.exports.UIStrings = UIStrings;

}).call(this)}).call(this,"/lighthouse-core/audits/dobetterweb/password-inputs-can-be-pasted-into.js")
},{"../../lib/i18n/i18n.js":96,"../audit.js":3}],"../audits/dobetterweb/uses-http2":[function(require,module,exports){
(function (__filename){(function (){
/**
 * @license Copyright 2016 The Lighthouse Authors. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.
 */
'use strict';

/**
 * @fileoverview Audit a page to ensure that resource loaded over its own
 * origin are over the http/2 protocol.
 */

/** @typedef {import('../../lib/dependency-graph/simulator/simulator')} Simulator */
/** @typedef {import('../../lib/dependency-graph/base-node.js').Node} Node */

const Audit = require('../audit.js');
const ThirdParty = require('../../lib/third-party-web.js');
const URL = require('../../lib/url-shim.js');
const ByteEfficiencyAudit = require('../byte-efficiency/byte-efficiency-audit.js');
const Interactive = require('../../computed/metrics/lantern-interactive.js');
const NetworkRequest = require('../../lib/network-request.js');
const NetworkRecords = require('../../computed/network-records.js');
const LoadSimulator = require('../../computed/load-simulator.js');
const PageDependencyGraph = require('../../computed/page-dependency-graph.js');
const i18n = require('../../lib/i18n/i18n.js');

const UIStrings = {
  /** Imperative title of a Lighthouse audit that tells the user to enable HTTP/2. This is displayed in a list of audit titles that Lighthouse generates. */
  title: 'Use HTTP/2',
  /** Description of a Lighthouse audit that tells the user why they should use HTTP/2. This is displayed after a user expands the section to see more. No character length limits. 'Learn More' becomes link text to additional documentation. */
  description: 'HTTP/2 offers many benefits over HTTP/1.1, including binary headers and ' +
      'multiplexing. [Learn more](https://web.dev/uses-http2/).',
  /** [ICU Syntax] Label identifying the number of network requests that were not served with HTTP/2. */
  displayValue: `{itemCount, plural,
    =1 {1 request not served via HTTP/2}
    other {# requests not served via HTTP/2}
    }`,
  /**  Label for a column in a data table; entries in the column will be the HTTP Protocol used to make a network request. */
  columnProtocol: 'Protocol',
};

const str_ = i18n.createMessageInstanceIdFn(__filename, UIStrings);

/** @type {Set<LH.Artifacts.NetworkRequest['resourceType']>} */
const STATIC_RESOURCE_TYPES = new Set([
  NetworkRequest.TYPES.Document,
  NetworkRequest.TYPES.Font,
  NetworkRequest.TYPES.Image,
  NetworkRequest.TYPES.Stylesheet,
  NetworkRequest.TYPES.Script,
  NetworkRequest.TYPES.Media,
]);

class UsesHTTP2Audit extends Audit {
  /**
   * @return {LH.Audit.Meta}
   */
  static get meta() {
    return {
      id: 'uses-http2',
      title: str_(UIStrings.title),
      description: str_(UIStrings.description),
      supportedModes: ['navigation'],
      requiredArtifacts: ['URL', 'devtoolsLogs', 'traces'],
    };
  }

  /**
   * Computes the estimated effect all results being converted to use http/2, the max of:
   *
   * - end time of the last long task in the provided graph
   * - end time of the last node in the graph
   *
   * @param {Array<{url: string}>} results
   * @param {Node} graph
   * @param {Simulator} simulator
   * @return {number}
   */
  static computeWasteWithTTIGraph(results, graph, simulator) {
    const beforeLabel = `uses-http2-before`;
    const afterLabel = `uses-http2-after`;
    const flexibleOrdering = true;

    const urlsToChange = new Set(results.map(result => result.url));
    const simulationBefore = simulator.simulate(graph, {label: beforeLabel, flexibleOrdering});

    // Update all the protocols to reflect implementing our recommendations
    /** @type {Map<string, string>} */
    const originalProtocols = new Map();
    graph.traverse(node => {
      if (node.type !== 'network') return;
      if (!urlsToChange.has(node.record.url)) return;

      originalProtocols.set(node.record.requestId, node.record.protocol);
      node.record.protocol = 'h2';
    });

    const simulationAfter = simulator.simulate(graph, {label: afterLabel, flexibleOrdering});

    // Restore the original protocol after we've done our simulation
    graph.traverse(node => {
      if (node.type !== 'network') return;
      const originalProtocol = originalProtocols.get(node.record.requestId);
      if (originalProtocol === undefined) return;
      node.record.protocol = originalProtocol;
    });

    const savingsOnOverallLoad = simulationBefore.timeInMs - simulationAfter.timeInMs;
    const savingsOnTTI = Interactive.getLastLongTaskEndTime(simulationBefore.nodeTimings) -
      Interactive.getLastLongTaskEndTime(simulationAfter.nodeTimings);
    const savings = Math.max(savingsOnTTI, savingsOnOverallLoad);

    // Round waste to nearest 10ms
    return Math.round(Math.max(savings, 0) / 10) * 10;
  }

  /**
   * Determines whether a network request is a "static resource" that would benefit from H2 multiplexing.
   * XHRs, tracking pixels, etc generally don't benefit as much because they aren't requested en-masse
   * for the same origin at the exact same time.
   *
   * @param {LH.Artifacts.NetworkRequest} networkRequest
   * @return {boolean}
   */
  static isStaticAsset(networkRequest) {
    if (!STATIC_RESOURCE_TYPES.has(networkRequest.resourceType)) return false;

    // Resources from third-parties that are less than 100 bytes are usually tracking pixels, not actual resources.
    // They can masquerade as static types though (gifs, documents, etc)
    if (networkRequest.resourceSize < 100) {
      const entity = ThirdParty.getEntity(networkRequest.url);
      if (entity) return false;
    }

    return true;
  }

  /**
   * Determine the set of resources that aren't HTTP/2 but should be.
   * We're a little conservative about what we surface for a few reasons:
   *
   *    - The simulator approximation of HTTP/2 is a little more generous than reality.
   *    - There's a bit of debate surrounding HTTP/2 due to its worse performance in environments with high packet loss.**
   *    - It's something that you'd have absolutely zero control over with a third-party (can't defer to fix it for example).
   *
   * Therefore, we only surface requests that were...
   *
   *    - Served over HTTP/1.1 or earlier
   *    - Served over an origin that serves at least 6 static asset requests
   *      (if there aren't more requests than browser's max/host, multiplexing isn't as big a deal)
   *    - Not served on localhost (h2 is a pain to deal with locally & and CI)
   *
   * ** = https://news.ycombinator.com/item?id=19086639
   *      https://www.twilio.com/blog/2017/10/http2-issues.html
   *      https://www.cachefly.com/http-2-is-not-a-magic-bullet/
   *
   * @param {Array<LH.Artifacts.NetworkRequest>} networkRecords
   * @return {Array<{url: string, protocol: string}>}
   */
  static determineNonHttp2Resources(networkRecords) {
    /** @type {Array<{url: string, protocol: string}>} */
    const nonHttp2Resources = [];

    /** @type {Set<string>} */
    const seenURLs = new Set();
    /** @type {Map<string, Array<LH.Artifacts.NetworkRequest>>} */
    const groupedByOrigin = new Map();
    for (const record of networkRecords) {
      if (!UsesHTTP2Audit.isStaticAsset(record)) continue;
      if (URL.isLikeLocalhost(record.parsedURL.host)) continue;
      const existing = groupedByOrigin.get(record.parsedURL.securityOrigin) || [];
      existing.push(record);
      groupedByOrigin.set(record.parsedURL.securityOrigin, existing);
    }

    for (const record of networkRecords) {
      // Skip duplicates.
      if (seenURLs.has(record.url)) continue;
      // Check if record is not served through the service worker, servicer worker uses http/1.1 as a protocol.
      // These can generate false positives (bug: https://github.com/GoogleChrome/lighthouse/issues/7158).
      if (record.fetchedViaServiceWorker) continue;
      // Test the protocol to see if it was http/1.1.
      const isOldHttp = /HTTP\/[01][.\d]?/i.test(record.protocol);
      if (!isOldHttp) continue;
      // Check if the origin has enough requests to bother flagging.
      const group = groupedByOrigin.get(record.parsedURL.securityOrigin) || [];
      if (group.length < 6) continue;

      seenURLs.add(record.url);
      nonHttp2Resources.push({protocol: record.protocol, url: record.url});
    }

    return nonHttp2Resources;
  }

  /**
   * @param {LH.Artifacts} artifacts
   * @param {LH.Audit.Context} context
   * @return {Promise<LH.Audit.Product>}
   */
  static async audit(artifacts, context) {
    const trace = artifacts.traces[Audit.DEFAULT_PASS];
    const devtoolsLog = artifacts.devtoolsLogs[Audit.DEFAULT_PASS];
    const settings = context && context.settings || {};
    const simulatorOptions = {
      devtoolsLog,
      settings,
    };

    const networkRecords = await NetworkRecords.request(devtoolsLog, context);
    const graph = await PageDependencyGraph.request({trace, devtoolsLog}, context);
    const simulator = await LoadSimulator.request(simulatorOptions, context);

    const resources = UsesHTTP2Audit.determineNonHttp2Resources(networkRecords);
    const wastedMs = UsesHTTP2Audit.computeWasteWithTTIGraph(resources, graph, simulator);

    let displayValue;
    if (resources.length > 0) {
      displayValue = str_(UIStrings.displayValue, {itemCount: resources.length});
    }

    /** @type {LH.Audit.Details.Opportunity['headings']} */
    const headings = [
      {key: 'url', valueType: 'url', label: str_(i18n.UIStrings.columnURL)},
      {key: 'protocol', valueType: 'text', label: str_(UIStrings.columnProtocol)},
    ];

    const details = Audit.makeOpportunityDetails(headings, resources, wastedMs);

    return {
      displayValue,
      numericValue: wastedMs,
      numericUnit: 'millisecond',
      score: ByteEfficiencyAudit.scoreForWastedMs(wastedMs),
      details,
    };
  }
}

module.exports = UsesHTTP2Audit;
module.exports.UIStrings = UIStrings;

}).call(this)}).call(this,"/lighthouse-core/audits/dobetterweb/uses-http2.js")
},{"../../computed/load-simulator.js":13,"../../computed/metrics/lantern-interactive.js":24,"../../computed/network-records.js":40,"../../computed/page-dependency-graph.js":41,"../../lib/i18n/i18n.js":96,"../../lib/network-request.js":109,"../../lib/third-party-web.js":116,"../../lib/url-shim.js":"url","../audit.js":3,"../byte-efficiency/byte-efficiency-audit.js":4}],"../audits/dobetterweb/uses-passive-event-listeners":[function(require,module,exports){
(function (__filename){(function (){
/**
 * @license Copyright 2016 The Lighthouse Authors. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.
 */

/**
 * @fileoverview Audit a page to see if it is using passive event listeners on
 * scroll-blocking touch and wheel event listeners.
 */

'use strict';

const ViolationAudit = require('../violation-audit.js');
const i18n = require('../../lib/i18n/i18n.js');

const UIStrings = {
  /** Title of a Lighthouse audit that provides detail on the page's use of passive event listeners used to improve the scrolling performance of the page. This descriptive title is shown to users when the page does use passive listeners. */
  title: 'Uses passive listeners to improve scrolling performance',
  /** Title of a Lighthouse audit that provides detail on the page's use of passive event listeners used to improve the scrolling performance of the page. This descriptive title is shown to users when the page does not use passive listeners. */
  failureTitle: 'Does not use passive listeners to improve scrolling performance',
  /** Description of a Lighthouse audit that tells the user why they should use passive event listeners on the page. This is displayed after a user expands the section to see more. No character length limits. 'Learn More' becomes link text to additional documentation. */
  description: 'Consider marking your touch and wheel event listeners as `passive` ' +
      'to improve your page\'s scroll performance. ' +
      '[Learn more](https://web.dev/uses-passive-event-listeners/).',
};

const str_ = i18n.createMessageInstanceIdFn(__filename, UIStrings);

class PassiveEventsAudit extends ViolationAudit {
  /**
   * @return {LH.Audit.Meta}
   */
  static get meta() {
    return {
      id: 'uses-passive-event-listeners',
      title: str_(UIStrings.title),
      failureTitle: str_(UIStrings.failureTitle),
      description: str_(UIStrings.description),
      requiredArtifacts: ['ConsoleMessages'],
    };
  }

  /**
   * @param {LH.Artifacts} artifacts
   * @return {LH.Audit.Product}
   */
  static audit(artifacts) {
    const results = ViolationAudit.getViolationResults(artifacts, /passive event listener/);

    /** @type {LH.Audit.Details.Table['headings']} */
    const headings = [
      {key: 'source', itemType: 'source-location', text: str_(i18n.UIStrings.columnSource)},
    ];
    // TODO(bckenny): see TODO in geolocation-on-start
    const details = ViolationAudit.makeTableDetails(headings, results);

    return {
      score: Number(results.length === 0),
      details,
    };
  }
}

module.exports = PassiveEventsAudit;
module.exports.UIStrings = UIStrings;

}).call(this)}).call(this,"/lighthouse-core/audits/dobetterweb/uses-passive-event-listeners.js")
},{"../../lib/i18n/i18n.js":96,"../violation-audit.js":8}],"../audits/errors-in-console":[function(require,module,exports){
(function (__filename){(function (){
/**
 * @license Copyright 2017 The Lighthouse Authors. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.
 */
'use strict';

/**
 * @fileoverview Audits a page to determine whether it contains console errors.
 * This is done by collecting Chrome console log messages and filtering out the non-error ones.
 */

const log = require('lighthouse-logger');
const Audit = require('./audit.js');
const i18n = require('../lib/i18n/i18n.js');

const UIStrings = {
  /** Title of a Lighthouse audit that provides detail on browser errors. This descriptive title is shown to users when no browser errors were logged into the devtools console. */
  title: 'No browser errors logged to the console',
  /** Title of a Lighthouse audit that provides detail on browser errors. This descriptive title is shown to users when browser errors occurred and were logged into the devtools console. */
  failureTitle: 'Browser errors were logged to the console',
  /** Description of a Lighthouse audit that tells the user why errors being logged to the devtools console are a cause for concern and so should be fixed. This is displayed after a user expands the section to see more. No character length limits. */
  description: 'Errors logged to the console indicate unresolved problems. ' +
    'They can come from network request failures and other browser concerns. ' +
    '[Learn more](https://web.dev/errors-in-console/)',
};

const str_ = i18n.createMessageInstanceIdFn(__filename, UIStrings);

/** @typedef {{ignoredPatterns?: Array<RegExp|string>}} AuditOptions */

class ErrorLogs extends Audit {
  /**
   * @return {LH.Audit.Meta}
   */
  static get meta() {
    return {
      id: 'errors-in-console',
      title: str_(UIStrings.title),
      failureTitle: str_(UIStrings.failureTitle),
      description: str_(UIStrings.description),
      requiredArtifacts: ['ConsoleMessages'],
    };
  }

  /** @return {AuditOptions} */
  static get defaultOptions() {
    // Any failed network requests with error messsage aren't actionable
    return {ignoredPatterns: ['ERR_BLOCKED_BY_CLIENT.Inspector']};
  }

  /**
   * @template {{description: string | undefined}} T
   * @param {Array<T>} items
   * @param {AuditOptions} options
   * @return {Array<T>}
   */
  static filterAccordingToOptions(items, options) {
    const {ignoredPatterns, ...restOfOptions} = options;
    const otherOptionKeys = Object.keys(restOfOptions);
    if (otherOptionKeys.length) log.warn(this.meta.id, 'Unrecognized options', otherOptionKeys);
    if (!ignoredPatterns) return items;

    return items.filter(({description}) => {
      if (!description) return true;
      for (const pattern of ignoredPatterns) {
        if (pattern instanceof RegExp && pattern.test(description)) return false;
        if (typeof pattern === 'string' && description.includes(pattern)) return false;
      }

      return true;
    });
  }

  /**
   * @param {LH.Artifacts} artifacts
   * @param {LH.Audit.Context} context
   * @return {LH.Audit.Product}
   */
  static audit(artifacts, context) {
    /** @type {AuditOptions} */
    const auditOptions = context.options;

    /** @type {Array<{source: string, description: string|undefined, sourceLocation: LH.Audit.Details.SourceLocationValue|undefined}>} */
    const consoleRows = artifacts.ConsoleMessages
      .filter(item => item.level === 'error')
      .map(item => {
        return {
          source: item.source,
          description: item.text,
          // TODO: remove for v8 (url is covered in sourceLocation)
          url: item.url,
          sourceLocation: Audit.makeSourceLocationFromConsoleMessage(item),
        };
      });

    const tableRows = ErrorLogs.filterAccordingToOptions(consoleRows, auditOptions)
      .sort((a, b) => (a.description || '').localeCompare(b.description || ''));

    /** @type {LH.Audit.Details.Table['headings']} */
    const headings = [
      {key: 'sourceLocation', itemType: 'source-location', text: str_(i18n.UIStrings.columnSource)},
      {key: 'description', itemType: 'code', text: str_(i18n.UIStrings.columnDescription)},
    ];

    const details = Audit.makeTableDetails(headings, tableRows);
    const numErrors = tableRows.length;

    return {
      score: Number(numErrors === 0),
      details,
    };
  }
}

module.exports = ErrorLogs;
module.exports.UIStrings = UIStrings;

}).call(this)}).call(this,"/lighthouse-core/audits/errors-in-console.js")
},{"../lib/i18n/i18n.js":96,"./audit.js":3,"lighthouse-logger":188}],"../audits/final-screenshot":[function(require,module,exports){
/**
 * @license Copyright 2018 The Lighthouse Authors. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.
 */
'use strict';

const Audit = require('./audit.js');
const LHError = require('../lib/lh-error.js');
const ProcessedTrace = require('../computed/processed-trace.js');
const Screenshots = require('../computed/screenshots.js');

class FinalScreenshot extends Audit {
  /**
   * @return {LH.Audit.Meta}
   */
  static get meta() {
    return {
      id: 'final-screenshot',
      scoreDisplayMode: Audit.SCORING_MODES.INFORMATIVE,
      title: 'Final Screenshot',
      description: 'The last screenshot captured of the pageload.',
      requiredArtifacts: ['traces', 'GatherContext'],
    };
  }

  /**
   * @param {LH.Artifacts} artifacts
   * @param {LH.Audit.Context} context
   * @return {Promise<LH.Audit.Product>}
   */
  static async audit(artifacts, context) {
    const trace = artifacts.traces[Audit.DEFAULT_PASS];
    const processedTrace = await ProcessedTrace.request(trace, context);
    const screenshots = await Screenshots.request(trace, context);
    const {timeOrigin} = processedTrace.timestamps;
    const finalScreenshot = screenshots[screenshots.length - 1];

    if (!finalScreenshot) {
      // If a timespan didn't happen to contain frames, that's fine. Just mark not applicable.
      if (artifacts.GatherContext.gatherMode === 'timespan') return {notApplicable: true, score: 1};

      // If it was another mode, that's a fatal error.
      throw new LHError(LHError.errors.NO_SCREENSHOTS);
    }

    return {
      score: 1,
      details: {
        type: 'screenshot',
        timing: Math.round((finalScreenshot.timestamp - timeOrigin) / 1000),
        timestamp: finalScreenshot.timestamp,
        data: finalScreenshot.datauri,
      },
    };
  }
}

module.exports = FinalScreenshot;

},{"../computed/processed-trace.js":43,"../computed/screenshots.js":45,"../lib/lh-error.js":103,"./audit.js":3}],"../audits/font-display":[function(require,module,exports){
(function (__filename){(function (){
/**
 * @license Copyright 2017 The Lighthouse Authors. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.
 */
'use strict';

const Audit = require('./audit.js');
const URL = require('../lib/url-shim.js');
const PASSING_FONT_DISPLAY_REGEX = /^(block|fallback|optional|swap)$/;
const CSS_URL_REGEX = /url\((.*?)\)/;
const CSS_URL_GLOBAL_REGEX = new RegExp(CSS_URL_REGEX, 'g');
const i18n = require('../lib/i18n/i18n.js');
const Sentry = require('../lib/sentry.js');
const NetworkRecords = require('../computed/network-records.js');

const UIStrings = {
  /** Title of a diagnostic audit that provides detail on if all the text on a webpage was visible while the page was loading its webfonts. This descriptive title is shown to users when the amount is acceptable and no user action is required. */
  title: 'All text remains visible during webfont loads',
  /** Title of a diagnostic audit that provides detail on the load of the page's webfonts. Often the text is invisible for seconds before the webfont resource is loaded. This imperative title is shown to users when there is a significant amount of execution time that could be reduced. */
  failureTitle: 'Ensure text remains visible during webfont load',
  /** Description of a Lighthouse audit that tells the user *why* they should use the font-display CSS feature. This is displayed after a user expands the section to see more. No character length limits. 'Learn More' becomes link text to additional documentation. */
  description:
    'Leverage the font-display CSS feature to ensure text is user-visible while ' +
    'webfonts are loading. ' +
    '[Learn more](https://web.dev/font-display/).',
  /**
   * @description [ICU Syntax] A warning message that is shown when Lighthouse couldn't automatically check some of the page's fonts, telling the user that they will need to manually check the fonts coming from a certain URL origin.
   * @example {https://font.cdn.com/} fontOrigin
   */
  undeclaredFontOriginWarning:
    '{fontCountForOrigin, plural, ' +
    // eslint-disable-next-line max-len
    '=1 {Lighthouse was unable to automatically check the `font-display` value for the origin {fontOrigin}.} ' +
    // eslint-disable-next-line max-len
    'other {Lighthouse was unable to automatically check the `font-display` values for the origin {fontOrigin}.}}',
};

const str_ = i18n.createMessageInstanceIdFn(__filename, UIStrings);

class FontDisplay extends Audit {
  /**
   * @return {LH.Audit.Meta}
   */
  static get meta() {
    return {
      id: 'font-display',
      title: str_(UIStrings.title),
      failureTitle: str_(UIStrings.failureTitle),
      description: str_(UIStrings.description),
      supportedModes: ['navigation'],
      requiredArtifacts: ['devtoolsLogs', 'CSSUsage', 'URL'],
    };
  }

  /**
   * @param {LH.Artifacts} artifacts
   * @param {RegExp} passingFontDisplayRegex
   * @return {{passingURLs: Set<string>, failingURLs: Set<string>}}
   */
  static findFontDisplayDeclarations(artifacts, passingFontDisplayRegex) {
    /** @type {Set<string>} */
    const passingURLs = new Set();
    /** @type {Set<string>} */
    const failingURLs = new Set();

    // Go through all the stylesheets to find all @font-face declarations
    for (const stylesheet of artifacts.CSSUsage.stylesheets) {
      // Eliminate newlines so we can more easily scan through with a regex
      const newlinesStripped = stylesheet.content.replace(/(\r|\n)+/g, ' ');
      // Find the @font-faces
      const fontFaceDeclarations = newlinesStripped.match(/@font-face\s*{(.*?)}/g) || [];
      // Go through all the @font-face declarations to find a declared `font-display: ` property
      for (const declaration of fontFaceDeclarations) {
        // We'll try to find the URL it's referencing.
        const rawFontURLs = declaration.match(CSS_URL_GLOBAL_REGEX);
        // If no URLs, we can't really do anything; bail
        if (!rawFontURLs) continue;
        // Find the font-display value by matching a single token, optionally surrounded by whitespace,
        // followed either by a semicolon or the end of a block.
        const fontDisplayMatch = declaration.match(/font-display\s*:\s*(\w+)\s*(;|\})/);
        const rawFontDisplay = (fontDisplayMatch && fontDisplayMatch[1]) || '';
        const hasPassingFontDisplay = passingFontDisplayRegex.test(rawFontDisplay);
        const targetURLSet = hasPassingFontDisplay ? passingURLs : failingURLs;

        // Finally convert the raw font URLs to the absolute URLs and add them to the set.
        const relativeURLs = rawFontURLs
          // @ts-expect-error - guaranteed to match from previous regex, pull URL group out
          .map(s => s.match(CSS_URL_REGEX)[1].trim())
          .map(s => {
            // remove any quotes surrounding the URL
            if (/^('|").*\1$/.test(s)) {
              return s.substr(1, s.length - 2);
            }

            return s;
          });

        // Convert the relative CSS URL to an absolute URL and add it to the target set.
        for (const relativeURL of relativeURLs) {
          try {
            const relativeRoot = URL.isValid(stylesheet.header.sourceURL) ?
              stylesheet.header.sourceURL : artifacts.URL.finalUrl;
            const absoluteURL = new URL(relativeURL, relativeRoot);
            targetURLSet.add(absoluteURL.href);
          } catch (err) {
            Sentry.captureException(err, {tags: {audit: this.meta.id}});
          }
        }
      }
    }

    return {passingURLs, failingURLs};
  }

  /**
   * Some pages load many fonts we can't check, so dedupe on origin.
   * @param {Array<string>} warningUrls
   * @return {Array<LH.IcuMessage>}
   */
  static getWarningsForFontUrls(warningUrls) {
    /** @type {Map<string, number>} */
    const warningCountByOrigin = new Map();
    for (const warningUrl of warningUrls) {
      const origin = URL.getOrigin(warningUrl);
      if (!origin) continue;

      const count = warningCountByOrigin.get(origin) || 0;
      warningCountByOrigin.set(origin, count + 1);
    }

    const warnings = [...warningCountByOrigin].map(([fontOrigin, fontCountForOrigin]) => {
      return str_(UIStrings.undeclaredFontOriginWarning, {fontCountForOrigin, fontOrigin});
    });
    return warnings;
  }

  /**
   * @param {LH.Artifacts} artifacts
   * @param {LH.Audit.Context} context
   * @return {Promise<LH.Audit.Product>}
   */
  static async audit(artifacts, context) {
    const devtoolsLogs = artifacts.devtoolsLogs[this.DEFAULT_PASS];
    const networkRecords = await NetworkRecords.request(devtoolsLogs, context);
    const {passingURLs, failingURLs} =
      FontDisplay.findFontDisplayDeclarations(artifacts, PASSING_FONT_DISPLAY_REGEX);
    /** @type {Array<string>} */
    const warningURLs = [];

    const results = networkRecords
      // Find all fonts...
      .filter(record => record.resourceType === 'Font')
      // ...and that aren't data URLs, the blocking concern doesn't really apply
      .filter(record => !/^data:/.test(record.url))
      .filter(record => !/^blob:/.test(record.url))
      // ...that have a failing font-display value
      .filter(record => {
        // Failing URLs should be considered.
        if (failingURLs.has(record.url)) return true;
        // Everything else shouldn't be, but we should warn if we don't recognize the URL at all.
        if (!passingURLs.has(record.url)) warningURLs.push(record.url);
        return false;
      })
      .map(record => {
        // In reality the end time should be calculated with paint time included
        // all browsers wait 3000ms to block text so we make sure 3000 is our max wasted time
        const wastedMs = Math.min((record.endTime - record.startTime) * 1000, 3000);

        return {
          url: record.url,
          wastedMs,
        };
      });

    /** @type {LH.Audit.Details.Table['headings']} */
    const headings = [
      {key: 'url', itemType: 'url', text: str_(i18n.UIStrings.columnURL)},
      {key: 'wastedMs', itemType: 'ms', text: str_(i18n.UIStrings.columnWastedMs)},
    ];

    const details = Audit.makeTableDetails(headings, results);

    return {
      score: Number(results.length === 0),
      details,
      warnings: FontDisplay.getWarningsForFontUrls(warningURLs),
    };
  }
}

module.exports = FontDisplay;
module.exports.UIStrings = UIStrings;

}).call(this)}).call(this,"/lighthouse-core/audits/font-display.js")
},{"../computed/network-records.js":40,"../lib/i18n/i18n.js":96,"../lib/sentry.js":112,"../lib/url-shim.js":"url","./audit.js":3}],"../audits/full-page-screenshot":[function(require,module,exports){
/**
 * @license Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.
 */
'use strict';

const Audit = require('./audit.js');

class FullPageScreenshot extends Audit {
  /**
   * @return {LH.Audit.Meta}
   */
  static get meta() {
    return {
      id: 'full-page-screenshot',
      scoreDisplayMode: Audit.SCORING_MODES.INFORMATIVE,
      title: 'Full-page screenshot',
      description: 'A full-height screenshot of the final rendered page',
      requiredArtifacts: ['FullPageScreenshot'],
    };
  }

  /**
   * @param {LH.Artifacts} artifacts
   * @return {Promise<LH.Audit.Product>}
   */
  static async audit(artifacts) {
    if (!artifacts.FullPageScreenshot) {
      return {score: 0, notApplicable: true};
    }

    return {
      score: 1,
      details: {
        type: 'full-page-screenshot',
        ...artifacts.FullPageScreenshot,
      },
    };
  }
}

module.exports = FullPageScreenshot;

},{"./audit.js":3}],"../audits/image-aspect-ratio":[function(require,module,exports){
(function (__filename){(function (){
/**
 * @license Copyright 2017 The Lighthouse Authors. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.
 */
/**
 * @fileoverview Checks to see if the aspect ratio of the images used on
 *   the page are equal to the aspect ratio of their display sizes. The
 *   audit will list all images that don't match with their display size
 *   aspect ratio.
 */
'use strict';

const Audit = require('./audit.js');
const URL = require('../lib/url-shim.js');
const i18n = require('../lib/i18n/i18n.js');

const UIStrings = {
  /** Title of a Lighthouse audit that provides detail on the aspect ratios of all images on the page. This descriptive title is shown to users when all images use correct aspect ratios. */
  title: 'Displays images with correct aspect ratio',
  /** Title of a Lighthouse audit that provides detail on the aspect ratios of all images on the page. This descriptive title is shown to users when not all images use correct aspect ratios. */
  failureTitle: 'Displays images with incorrect aspect ratio',
  /** Description of a Lighthouse audit that tells the user why they should maintain the correct aspect ratios for all images. This is displayed after a user expands the section to see more. No character length limits. 'Learn More' becomes link text to additional documentation. */
  description: 'Image display dimensions should match natural aspect ratio. ' +
    '[Learn more](https://web.dev/image-aspect-ratio/).',
  /**  Label for a column in a data table; entries in the column will be the numeric aspect ratio of an image as displayed in a web page. */
  columnDisplayed: 'Aspect Ratio (Displayed)',
  /**  Label for a column in a data table; entries in the column will be the numeric aspect ratio of the raw (actual) image. */
  columnActual: 'Aspect Ratio (Actual)',
};

const str_ = i18n.createMessageInstanceIdFn(__filename, UIStrings);

const THRESHOLD_PX = 2;

/** @typedef {Required<LH.Artifacts.ImageElement>} WellDefinedImage */

class ImageAspectRatio extends Audit {
  /**
   * @return {LH.Audit.Meta}
   */
  static get meta() {
    return {
      id: 'image-aspect-ratio',
      title: str_(UIStrings.title),
      failureTitle: str_(UIStrings.failureTitle),
      description: str_(UIStrings.description),
      requiredArtifacts: ['ImageElements'],
    };
  }

  /**
   * @param {WellDefinedImage} image
   * @return {{url: string, displayedAspectRatio: string, actualAspectRatio: string, doRatiosMatch: boolean}}
   */
  static computeAspectRatios(image) {
    const url = URL.elideDataURI(image.src);
    const actualAspectRatio = image.naturalDimensions.width / image.naturalDimensions.height;
    const displayedAspectRatio = image.displayedWidth / image.displayedHeight;

    const targetDisplayHeight = image.displayedWidth / actualAspectRatio;
    const doRatiosMatch = Math.abs(targetDisplayHeight - image.displayedHeight) < THRESHOLD_PX;

    return {
      url,
      displayedAspectRatio: `${image.displayedWidth} x ${image.displayedHeight}
        (${displayedAspectRatio.toFixed(2)})`,
      actualAspectRatio: `${image.naturalDimensions.width} x ${image.naturalDimensions.height}
        (${actualAspectRatio.toFixed(2)})`,
      doRatiosMatch,
    };
  }

  /**
   * @param {LH.Artifacts} artifacts
   * @return {LH.Audit.Product}
   */
  static audit(artifacts) {
    const images = artifacts.ImageElements;

    /** @type {Array<{url: string, displayedAspectRatio: string, actualAspectRatio: string, doRatiosMatch: boolean}>} */
    const results = [];
    images.filter(image => {
      // - filter out css background images since we don't have a reliable way to tell if it's a
      //   sprite sheet, repeated for effect, etc
      // - filter out images that don't have following properties:
      //   networkRecord, width, height, `object-fit` property
      // - filter all svgs as they have no natural dimensions to audit
      // - filter out images that have falsy naturalWidth or naturalHeight
      return !image.isCss &&
        image.mimeType &&
        image.mimeType !== 'image/svg+xml' &&
        image.naturalDimensions &&
        image.naturalDimensions.height > 5 &&
        image.naturalDimensions.width > 5 &&
        image.displayedWidth &&
        image.displayedHeight &&
        image.computedStyles.objectFit === 'fill';
    }).forEach(image => {
      const wellDefinedImage = /** @type {WellDefinedImage} */ (image);
      const processed = ImageAspectRatio.computeAspectRatios(wellDefinedImage);

      if (!processed.doRatiosMatch) results.push(processed);
    });

    /** @type {LH.Audit.Details.Table['headings']} */
    const headings = [
      {key: 'url', itemType: 'thumbnail', text: ''},
      {key: 'url', itemType: 'url', text: str_(i18n.UIStrings.columnURL)},
      {key: 'displayedAspectRatio', itemType: 'text', text: str_(UIStrings.columnDisplayed)},
      {key: 'actualAspectRatio', itemType: 'text', text: str_(UIStrings.columnActual)},
    ];

    return {
      score: Number(results.length === 0),
      details: Audit.makeTableDetails(headings, results),
    };
  }
}

module.exports = ImageAspectRatio;
module.exports.UIStrings = UIStrings;

}).call(this)}).call(this,"/lighthouse-core/audits/image-aspect-ratio.js")
},{"../lib/i18n/i18n.js":96,"../lib/url-shim.js":"url","./audit.js":3}],"../audits/image-size-responsive":[function(require,module,exports){
(function (__filename){(function (){
/**
 * @license Copyright 2020 The Lighthouse Authors. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.
 */
/**
 * @fileoverview Checks to see if the size of the visible images used on
 *   the page are large enough with respect to the pixel ratio. The
 *   audit will list all visible images that are too small.
 */
'use strict';

const Audit = require('./audit.js');
const URL = require('../lib/url-shim.js');
const i18n = require('../lib/i18n/i18n.js');

/** @typedef {LH.Artifacts.ImageElement & Required<Pick<LH.Artifacts.ImageElement, 'naturalDimensions'>>} ImageWithNaturalDimensions */

const UIStrings = {
  /** Title of a Lighthouse audit that provides detail on the size of visible images on the page. This descriptive title is shown to users when all images have correct sizes. */
  title: 'Serves images with appropriate resolution',
  /** Title of a Lighthouse audit that provides detail on the size of visible images on the page. This descriptive title is shown to users when not all images have correct sizes. */
  failureTitle: 'Serves images with low resolution',
  /** Description of a Lighthouse audit that tells the user why they should maintain an appropriate size for all images. This is displayed after a user expands the section to see more. No character length limits. 'Learn More' becomes link text to additional documentation. */
  description: 'Image natural dimensions should be proportional to the display size and the ' +
    'pixel ratio to maximize image clarity. [Learn more](https://web.dev/serve-responsive-images/).',
  /**  Label for a column in a data table; entries in the column will be a string representing the displayed size of the image. */
  columnDisplayed: 'Displayed size',
  /**  Label for a column in a data table; entries in the column will be a string representing the actual size of the image. */
  columnActual: 'Actual size',
  /**  Label for a column in a data table; entries in the column will be a string representing the expected size of the image. */
  columnExpected: 'Expected size',
};

const str_ = i18n.createMessageInstanceIdFn(__filename, UIStrings);

// Factors used to allow for smaller effective density.
// A factor of 1 means the actual device pixel density will be used.
// A factor of 0.5, means half the density is required. For example if the device pixel ratio is 3,
// then the images should have at least a density of 1.5.
const SMALL_IMAGE_FACTOR = 1.0;
const LARGE_IMAGE_FACTOR = 0.75;

// An image has must have both its dimensions lower or equal to the threshold in order to be
// considered SMALL.
const SMALL_IMAGE_THRESHOLD = 64;

/** @typedef {{url: string, elidedUrl: string, displayedSize: string, actualSize: string, actualPixels: number, expectedSize: string, expectedPixels: number}} Result */

/**
 * @param {{top: number, bottom: number, left: number, right: number}} imageRect
 * @param {{innerWidth: number, innerHeight: number}} viewportDimensions
 * @return {boolean}
 */
function isVisible(imageRect, viewportDimensions) {
  return (
    (imageRect.bottom - imageRect.top) * (imageRect.right - imageRect.left) > 0 &&
    imageRect.top <= viewportDimensions.innerHeight &&
    imageRect.bottom >= 0 &&
    imageRect.left <= viewportDimensions.innerWidth &&
    imageRect.right >= 0
  );
}

/**
 * @param {{top: number, bottom: number, left: number, right: number}} imageRect
 * @param {{innerWidth: number, innerHeight: number}} viewportDimensions
 * @return {boolean}
 */
function isSmallerThanViewport(imageRect, viewportDimensions) {
  return (
    (imageRect.bottom - imageRect.top) <= viewportDimensions.innerHeight &&
    (imageRect.right - imageRect.left) <= viewportDimensions.innerWidth
  );
}

/**
 * @param {LH.Artifacts.ImageElement} image
 * @return {boolean}
 */
function isCandidate(image) {
  /** image-rendering solution for pixel art scaling.
   * https://developer.mozilla.org/en-US/docs/Games/Techniques/Crisp_pixel_art_look
  */
  const artisticImageRenderingValues = ['pixelated', 'crisp-edges'];
  // https://html.spec.whatwg.org/multipage/images.html#pixel-density-descriptor
  const densityDescriptorRegex = / \d+(\.\d+)?x/;
  if (image.displayedWidth <= 1 || image.displayedHeight <= 1) {
    return false;
  }
  if (
    !image.naturalDimensions ||
    !image.naturalDimensions.width ||
    !image.naturalDimensions.height
  ) {
    return false;
  }
  if (image.mimeType === 'image/svg+xml') {
    return false;
  }
  if (image.isCss) {
    return false;
  }
  if (image.computedStyles.objectFit !== 'fill') {
    return false;
  }
  // Check if pixel art scaling is used.
  if (artisticImageRenderingValues.includes(image.computedStyles.imageRendering)) {
    return false;
  }
  // Check if density descriptor is used.
  if (densityDescriptorRegex.test(image.srcset)) {
    return false;
  }
  return true;
}

/**
 * Type check to ensure that the ImageElement has natural dimensions.
 *
 * @param {LH.Artifacts.ImageElement} image
 * @return {image is ImageWithNaturalDimensions}
 */
function imageHasNaturalDimensions(image) {
  return !!image.naturalDimensions;
}

/**
 * @param {ImageWithNaturalDimensions} image
 * @param {number} DPR
 * @return {boolean}
 */
function imageHasRightSize(image, DPR) {
  const [expectedWidth, expectedHeight] =
      allowedImageSize(image.displayedWidth, image.displayedHeight, DPR);
  return image.naturalDimensions.width >= expectedWidth &&
    image.naturalDimensions.height >= expectedHeight;
}

/**
 * @param {ImageWithNaturalDimensions} image
 * @param {number} DPR
 * @return {Result}
 */
function getResult(image, DPR) {
  const [expectedWidth, expectedHeight] =
      expectedImageSize(image.displayedWidth, image.displayedHeight, DPR);
  return {
    url: image.src,
    elidedUrl: URL.elideDataURI(image.src),
    displayedSize: `${image.displayedWidth} x ${image.displayedHeight}`,
    actualSize: `${image.naturalDimensions.width} x ${image.naturalDimensions.height}`,
    actualPixels: image.naturalDimensions.width * image.naturalDimensions.height,
    expectedSize: `${expectedWidth} x ${expectedHeight}`,
    expectedPixels: expectedWidth * expectedHeight,
  };
}

/**
 * Compute the size an image should have given the display dimensions and pixel density in order to
 * pass the audit.
 *
 * For smaller images, typically icons, the size must be proportional to the density.
 * For larger images some tolerance is allowed as in those cases the perceived degradation is not
 * that bad.
 *
 * @param {number} displayedWidth
 * @param {number} displayedHeight
 * @param {number} DPR
 * @return {[number, number]}
 */
function allowedImageSize(displayedWidth, displayedHeight, DPR) {
  let factor = SMALL_IMAGE_FACTOR;
  if (displayedWidth > SMALL_IMAGE_THRESHOLD || displayedHeight > SMALL_IMAGE_THRESHOLD) {
    factor = LARGE_IMAGE_FACTOR;
  }
  const requiredDpr = quantizeDpr(DPR);
  const width = Math.ceil(factor * requiredDpr * displayedWidth);
  const height = Math.ceil(factor * requiredDpr * displayedHeight);
  return [width, height];
}

/**
 * Compute the size an image should have given the display dimensions and pixel density.
 *
 * @param {number} displayedWidth
 * @param {number} displayedHeight
 * @param {number} DPR
 * @return {[number, number]}
 */
function expectedImageSize(displayedWidth, displayedHeight, DPR) {
  const width = Math.ceil(quantizeDpr(DPR) * displayedWidth);
  const height = Math.ceil(quantizeDpr(DPR) * displayedHeight);
  return [width, height];
}

/**
 * Remove repeated entries for the same source.
 *
 * It will keep the entry with the largest expected size.
 *
 * @param {Result[]} results
 * @return {Result[]}
 */
function deduplicateResultsByUrl(results) {
  results.sort((a, b) => a.url === b.url ? 0 : (a.url < b. url ? -1 : 1));
  /** @type {Result[]} */
  const deduplicated = [];
  for (const r of results) {
    const previousResult = deduplicated[deduplicated.length - 1];
    if (previousResult && previousResult.url === r.url) {
      // If the URL was the same, this is a duplicate. Keep the largest image.
      if (previousResult.expectedPixels < r.expectedPixels) {
        deduplicated[deduplicated.length - 1] = r;
      }
    } else {
      deduplicated.push(r);
    }
  }
  return deduplicated;
}

/**
 * Sort entries in descending order by the magnitude of the size deficit, i.e. most pressing issues listed first.
 *
 * @param {Result[]} results
 * @return {Result[]}
 */
function sortResultsBySizeDelta(results) {
  return results.sort(
      (a, b) => (b.expectedPixels - b.actualPixels) - (a.expectedPixels - a.actualPixels));
}

class ImageSizeResponsive extends Audit {
  /**
   * @return {LH.Audit.Meta}
   */
  static get meta() {
    return {
      id: 'image-size-responsive',
      title: str_(UIStrings.title),
      failureTitle: str_(UIStrings.failureTitle),
      description: str_(UIStrings.description),
      requiredArtifacts: ['ImageElements', 'ViewportDimensions'],
    };
  }

  /**
   * @param {LH.Artifacts} artifacts
   * @return {LH.Audit.Product}
   */
  static audit(artifacts) {
    const DPR = artifacts.ViewportDimensions.devicePixelRatio;

    const results = Array
      .from(artifacts.ImageElements)
      .filter(isCandidate)
      .filter(imageHasNaturalDimensions)
      .filter(image => !imageHasRightSize(image, DPR))
      .filter(image => isVisible(image.clientRect, artifacts.ViewportDimensions))
      .filter(image => isSmallerThanViewport(image.clientRect, artifacts.ViewportDimensions))
      .map(image => getResult(image, DPR));

    /** @type {LH.Audit.Details.Table['headings']} */
    const headings = [
      {key: 'url', itemType: 'thumbnail', text: ''},
      {key: 'elidedUrl', itemType: 'url', text: str_(i18n.UIStrings.columnURL)},
      {key: 'displayedSize', itemType: 'text', text: str_(UIStrings.columnDisplayed)},
      {key: 'actualSize', itemType: 'text', text: str_(UIStrings.columnActual)},
      {key: 'expectedSize', itemType: 'text', text: str_(UIStrings.columnExpected)},
    ];

    const finalResults = sortResultsBySizeDelta(deduplicateResultsByUrl(results));

    return {
      score: Number(results.length === 0),
      details: Audit.makeTableDetails(headings, finalResults),
    };
  }
}

/**
 * Return a quantized version of the DPR.
 *
 * This is to relax the required size of the image.
 * There's strong evidence that 3 DPR images are not perceived to be significantly better to mobile users than
 * 2 DPR images. The additional high byte cost (3x images are ~225% the file size of 2x images) makes this practice
 * difficult to recommend.
 *
 * Human minimum visual acuity angle = 0.016 degrees (see Sun Microsystems paper)
 * Typical phone operating distance from eye = 12 in
 *
 *        A
 *        _
 *       \ | B
 *        \|
 *         θ
 * A = minimum observable pixel size = ?
 * B = viewing distance = 12 in
 * θ = human minimum visual acuity angle = 0.016 degrees
 *
 * tan θ = A / B ---- Solve for A
 * A = tan (0.016 degrees) * B = 0.00335 in
 *
 * Moto G4 display width = 2.7 in
 * Moto G4 horizontal 2x resolution = 720 pixels
 * Moto G4 horizontal 3x resolution = 1080 pixels
 *
 * Moto G4 1x pixel size = 2.7 / 360 = 0.0075 in
 * Moto G4 2x pixel size = 2.7 / 720 = 0.00375 in
 * Moto G4 3x pixel size = 2.7 / 1080 = 0.0025 in
 *
 * Wasted additional pixels in 3x image = (.00335 - .0025) / (.00375 - .0025) = 68% waste
 *
 *
 * @see https://www.swift.ac.uk/about/files/vision.pdf
 * @param {number} dpr
 * @return {number}
 */
function quantizeDpr(dpr) {
  if (dpr >= 2) {
    return 2;
  }
  if (dpr >= 1.5) {
    return 1.5;
  }
  return 1.0;
}

module.exports = ImageSizeResponsive;
module.exports.UIStrings = UIStrings;

}).call(this)}).call(this,"/lighthouse-core/audits/image-size-responsive.js")
},{"../lib/i18n/i18n.js":96,"../lib/url-shim.js":"url","./audit.js":3}],"../audits/installable-manifest":[function(require,module,exports){
(function (__filename){(function (){
/**
 * @license Copyright 2017 The Lighthouse Authors. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.
 */
'use strict';

const Audit = require('./audit.js');
const i18n = require('../lib/i18n/i18n.js');
const ManifestValues = require('../computed/manifest-values.js');

/* eslint-disable max-len */
const UIStrings = {
  /** Title of a Lighthouse audit that provides detail on if a website is installable as an application. This descriptive title is shown to users when a webapp is installable. */
  'title': 'Web app manifest and service worker meet the installability requirements',
  /** Title of a Lighthouse audit that provides detail on if a website is installable as an application. This descriptive title is shown to users when a webapp is not installable. */
  'failureTitle': 'Web app manifest or service worker do not meet the installability requirements',
  /** Description of a Lighthouse audit that tells the user why installability is important for webapps. This is displayed after a user expands the section to see more. No character length limits. 'Learn More' becomes link text to additional documentation. */
  'description': `Service worker is the technology that enables your app to use many Progressive Web App features, such as offline, add to homescreen, and push notifications. With proper service worker and manifest implementations, browsers can proactively prompt users to add your app to their homescreen, which can lead to higher engagement. [Learn more](https://web.dev/installable-manifest/).`,
  /** Description Table column header for the observed value of the Installability failure reason statistic. */
  'columnValue': 'Failure reason',
  /**
   * @description [ICU Syntax] Label for an audit identifying the number of installability errors found in the page.
  */
  'displayValue': `{itemCount, plural,
    =1 {1 reason}
    other {# reasons}
    }`,
  /**
   * @description Error message describing a DevTools error id that was found and has not been identified by this audit.
   * @example {platform-not-supported-on-android} errorId
   */
  'noErrorId': `Installability error id '{errorId}' is not recognized`,
  /** Error message explaining that the page is not loaded in the frame.  */
  'not-in-main-frame': `Page is not loaded in the main frame`,
  /** Error message explaining that the page is served from a secure origin. */
  'not-from-secure-origin': 'Page is not served from a secure origin',
  /** Error message explaining that the page has no manifest URL. */
  'no-manifest': 'Page has no manifest <link> URL',
  /** Error message explaining that the provided manifest URL is invalid. */
  'start-url-not-valid': `Manifest start URL is not valid`,
  /** Error message explaining that the provided manifest does not contain a name or short_name field. */
  'manifest-missing-name-or-short-name': `Manifest does not contain a 'name' or 'short_name' field`,
  /** Error message explaining that the manifest display property must be one of 'standalone', 'fullscreen', or 'minimal-ui'. */
  'manifest-display-not-supported': `Manifest 'display' property must be one of 'standalone', 'fullscreen', or 'minimal-ui'`,
  /** Error message explaining that the manifest could not be fetched, might be empty, or could not be parsed. */
  'manifest-empty': `Manifest could not be fetched, is empty, or could not be parsed`,
  /** Error message explaining that no matching service worker was detected,
   * and provides a suggestion to reload the page or check whether the scope of the service worker
   * for the current page encloses the scope and start URL from the manifest. */
  'no-matching-service-worker': `No matching service worker detected. You may need to reload the page, or check that the scope of the service worker for the current page encloses the scope and start URL from the manifest.`,
  /**
  * @description Error message explaining that the manifest does not contain a suitable icon.
  * @example {192} value0
  */
  'manifest-missing-suitable-icon': `Manifest does not contain a suitable icon - PNG, SVG or WebP format of at least {value0}\xa0px is required, the sizes attribute must be set, and the purpose attribute, if set, must include "any".`,

  /**
  * @description Error message explaining that the manifest does not supply an icon of the correct format.
  * @example {192} value0
  */
  'no-acceptable-icon': `No supplied icon is at least {value0}\xa0px square in PNG, SVG or WebP format, with the purpose attribute unset or set to "any"`,

  /** Error message explaining that the icon could not be downloaded. */
  'cannot-download-icon': `Could not download a required icon from the manifest`,
  /** Error message explaining that the downloaded icon was empty or corrupt. */
  'no-icon-available': `Downloaded icon was empty or corrupted`,
  /** Error message explaining that the specified application platform is not supported on Android. */
  'platform-not-supported-on-android': `The specified application platform is not supported on Android`,
  /** Error message explaining that a Play store ID was not provided. */
  'no-id-specified': `No Play store ID provided`,
  /** Error message explaining that the Play Store app URL and Play Store ID do not match. */
  'ids-do-not-match': `The Play Store app URL and Play Store ID do not match`,
  /** Error message explaining that the app is already installed. */
  'already-installed': `The app is already installed`,
  /** Error message explaining that a URL in the manifest contains a username, password, or port. */
  'url-not-supported-for-webapk': `A URL in the manifest contains a username, password, or port`,
  /** Error message explaining that the page is loaded in an incognito window. */
  'in-incognito': `Page is loaded in an incognito window`,
  // TODO: perhaps edit this message to make it more actionable for LH users
  /** Error message explaining that the page does not work offline. */
  'not-offline-capable': `Page does not work offline`,
  /** Error message explaining that service worker could not be checked without a start_url. */
  'no-url-for-service-worker': `Could not check service worker without a 'start_url' field in the manifest`,
  /** Error message explaining that the manifest specifies prefer_related_applications: true. */
  'prefer-related-applications': `Manifest specifies prefer_related_applications: true`,
  /** Error message explaining that prefer_related_applications is only supported on Chrome Beta and Stable channels on Android. */
  'prefer-related-applications-only-beta-stable': `prefer_related_applications is only supported on Chrome Beta and Stable channels on Android.`,
  /** Error message explaining that the manifest contains 'display_override' field, and the
      first supported display mode must be one of 'standalone', 'fullscreen', or 'minimal-ui'. */
  'manifest-display-override-not-supported': `Manifest contains 'display_override' field, and the first supported display mode must be one of 'standalone', 'fullscreen', or 'minimal-ui'`,
  /** Error message explaining that the web manifest's URL changed while the manifest was being downloaded by the browser. */
  'manifest-location-changed': `Manifest URL changed while the manifest was being fetched.`,
  /** Warning message explaining that the page does not work offline. */
  'warn-not-offline-capable': `Page does not work offline. The page will not be regarded as installable after Chrome 93, stable release August 2021.`,
};
/* eslint-enable max-len */

const str_ = i18n.createMessageInstanceIdFn(__filename, UIStrings);

/**
 * @fileoverview
 * Audits if the page's web app manifest and service worker qualify for triggering a beforeinstallprompt event.
 * https://github.com/GoogleChrome/lighthouse/issues/23#issuecomment-270453303
 *
 * Requirements based on Chrome Devtools' installability requirements.
 * Origin of logging:
 * https://source.chromium.org/chromium/chromium/src/+/main:chrome/browser/installable/installable_logging.cc
 * DevTools InstallabilityError implementation:
 * https://source.chromium.org/search?q=getInstallabilityErrorMessages&ss=chromium%2Fchromium%2Fsrc:third_party%2Fdevtools-frontend%2Fsrc%2Ffront_end%2Fresources%2F
 */

class InstallableManifest extends Audit {
  /**
   * @return {LH.Audit.Meta}
   */
  static get meta() {
    return {
      id: 'installable-manifest',
      title: str_(UIStrings.title),
      failureTitle: str_(UIStrings.failureTitle),
      description: str_(UIStrings.description),
      supportedModes: ['navigation'],
      requiredArtifacts: ['URL', 'WebAppManifest', 'InstallabilityErrors'],
    };
  }

  /**
   * @param {LH.Artifacts} artifacts
   * @return {{i18nErrors: Array<LH.IcuMessage | string>; warnings: Array<LH.IcuMessage>}}
   */
  static getInstallabilityErrors(artifacts) {
    const installabilityErrors = artifacts.InstallabilityErrors.errors;
    const i18nErrors = [];
    const warnings = [];
    const errorArgumentsRegex = /{([^}]+)}/g;

    for (const err of installabilityErrors) {
      // Filter out errorId 'in-incognito' since Lighthouse recommends incognito.
      if (err.errorId === 'in-incognito') continue;

      if (err.errorId === 'warn-not-offline-capable') {
        warnings.push(str_(UIStrings[err.errorId]));
        continue;
      }

      // @ts-expect-error errorIds from protocol should match up against the strings dict
      const matchingString = UIStrings[err.errorId];

      // Handle an errorId we don't recognize.
      if (matchingString === undefined) {
        i18nErrors.push(str_(UIStrings.noErrorId, {errorId: err.errorId}));
        continue;
      }

      // Get the i18m argument names of the installability error message, if any.
      const UIStringArguments = matchingString.match(errorArgumentsRegex) || [];

      /**
       * If there is an argument value, get it.
       * We only expect a `minimum-icon-size-in-pixels` errorArg[0] for two errorIds, currently.
       */
      const value0 = err.errorArguments && err.errorArguments.length && err.errorArguments[0].value;

      if (matchingString && err.errorArguments.length !== UIStringArguments.length) {
        // Matching string, but have the incorrect number of arguments for the message.
        const stringArgs = JSON.stringify(err.errorArguments);
        const msg = err.errorArguments.length > UIStringArguments.length ?
          `${err.errorId} has unexpected arguments ${stringArgs}` :
          `${err.errorId} does not have the expected number of arguments.`;
        i18nErrors.push(msg);
      } else if (matchingString && value0) {
        i18nErrors.push(str_(matchingString, {value0}));
      } else if (matchingString) {
        i18nErrors.push(str_(matchingString));
      }
    }

    return {i18nErrors, warnings};
  }

  /**
   * @param {LH.Artifacts} artifacts
   * @param {LH.Audit.Context} context
   * @return {Promise<LH.Audit.Product>}
   *
   */
  static async audit(artifacts, context) {
    const manifestValues = await ManifestValues.request(artifacts, context);
    const {i18nErrors, warnings} = InstallableManifest.getInstallabilityErrors(artifacts);

    const manifestUrl = artifacts.WebAppManifest ? artifacts.WebAppManifest.url : null;

    /** @type {LH.Audit.Details.Table['headings']} */
    const headings = [
      {key: 'reason', itemType: 'text', text: str_(UIStrings.columnValue)},
    ];

    // Errors for report table.
    /** @type {LH.Audit.Details.Table['items']} */
    const errorReasons = i18nErrors.map(reason => {
      return {reason};
    });
    /** DevTools InstallabilityErrors does not emit an error unless there is a manifest, so include manifestValues's error */
    if (manifestValues.isParseFailure) {
      errorReasons.push({
        reason: manifestValues.parseFailureReason});
    }

    // Include the detailed pass/fail checklist as a diagnostic.
    /** @type {LH.Audit.Details.DebugData} */
    const debugData = {
      type: 'debugdata',
      manifestUrl,
    };

    if (errorReasons.length > 0) {
      return {
        score: 0,
        warnings,
        numericValue: errorReasons.length,
        numericUnit: 'element',
        displayValue: str_(UIStrings.displayValue, {itemCount: errorReasons.length}),
        details: {...Audit.makeTableDetails(headings, errorReasons), debugData},
      };
    }
    return {
      score: 1,
      warnings,
      details: {...Audit.makeTableDetails(headings, errorReasons), debugData},
    };
  }
}

module.exports = InstallableManifest;
module.exports.UIStrings = UIStrings;

}).call(this)}).call(this,"/lighthouse-core/audits/installable-manifest.js")
},{"../computed/manifest-values.js":16,"../lib/i18n/i18n.js":96,"./audit.js":3}],"../audits/is-on-https":[function(require,module,exports){
(function (__filename){(function (){
/**
 * @license Copyright 2016 The Lighthouse Authors. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.
 */
'use strict';

const Audit = require('./audit.js');
const URL = require('../lib/url-shim.js');
const NetworkRequest = require('../lib/network-request.js');
const NetworkRecords = require('../computed/network-records.js');
const i18n = require('../lib/i18n/i18n.js');

const UIStrings = {
  /** Title of a Lighthouse audit that provides detail on the useage of HTTPS on a page. This descriptive title is shown to users when all requests on a page are fufilled using HTTPS. */
  title: 'Uses HTTPS',
  /** Title of a Lighthouse audit that provides detail on the useage of HTTPS on a page. This descriptive title is shown to users when some, or all, requests on the page use HTTP instead of HTTPS. */
  failureTitle: 'Does not use HTTPS',
  /** Description of a Lighthouse audit that tells the user *why* HTTPS use *for all resources* is important. This is displayed after a user expands the section to see more. No character length limits. 'Learn More' becomes link text to additional documentation. */
  description: 'All sites should be protected with HTTPS, even ones that don\'t handle ' +
      'sensitive data. This includes avoiding [mixed content](https://developers.google.com/web/fundamentals/security/prevent-mixed-content/what-is-mixed-content), ' +
      'where some resources are loaded over HTTP despite the initial request being served ' +
      'over HTTPS. HTTPS prevents intruders from tampering with or passively listening ' +
      'in on the communications between your app and your users, and is a prerequisite for ' +
      'HTTP/2 and many new web platform APIs. ' +
      '[Learn more](https://web.dev/is-on-https/).',
  /** [ICU Syntax] Label identifying the number of insecure network requests found by an audit of a web page. */
  displayValue: `{itemCount, plural,
    =1 {1 insecure request found}
    other {# insecure requests found}
    }`,
  /** Label for a column in a data table; entries in the column will be the URLs of insecure (non-HTTPS) network requests. */
  columnInsecureURL: 'Insecure URL',
  /** Label for a column in a data table; entries in the column will be how the browser handled insecure (non-HTTPS) network requests. */
  columnResolution: 'Request Resolution',
  /** Value for the resolution column in a data table; denotes that the insecure URL was allowed by the browser. */
  allowed: 'Allowed',
  /** Value for the resolution column in a data table; denotes that the insecure URL was blocked by the browser. */
  blocked: 'Blocked',
  /** Value for the resolution column in a data table; denotes that the insecure URL may be blocked by the browser in the future. */
  warning: 'Allowed with warning',
  /** Value for the resolution column in a data table; denotes that the insecure URL was upgraded to a secure request by the browser. */
  upgraded: 'Automatically upgraded to HTTPS',
};

const resolutionToString = {
  MixedContentAutomaticallyUpgraded: UIStrings.upgraded,
  MixedContentBlocked: UIStrings.blocked,
  MixedContentWarning: UIStrings.warning,
};

const str_ = i18n.createMessageInstanceIdFn(__filename, UIStrings);


class HTTPS extends Audit {
  /**
   * @return {LH.Audit.Meta}
   */
  static get meta() {
    return {
      id: 'is-on-https',
      title: str_(UIStrings.title),
      failureTitle: str_(UIStrings.failureTitle),
      description: str_(UIStrings.description),
      requiredArtifacts: ['devtoolsLogs', 'InspectorIssues'],
    };
  }

  /**
   * @param {LH.Artifacts} artifacts
   * @param {LH.Audit.Context} context
   * @return {Promise<LH.Audit.Product>}
   */
  static audit(artifacts, context) {
    const devtoolsLogs = artifacts.devtoolsLogs[Audit.DEFAULT_PASS];
    return NetworkRecords.request(devtoolsLogs, context).then(networkRecords => {
      const insecureURLs = networkRecords
          .filter(record => !NetworkRequest.isSecureRequest(record))
          .map(record => URL.elideDataURI(record.url));

      /** @type {Array<{url: string, resolution?: LH.IcuMessage|string}>}  */
      const items = Array.from(new Set(insecureURLs)).map(url => ({url, resolution: undefined}));

      /** @type {LH.Audit.Details.Table['headings']} */
      const headings = [
        {key: 'url', itemType: 'url', text: str_(UIStrings.columnInsecureURL)},
        {key: 'resolution', itemType: 'text', text: str_(UIStrings.columnResolution)},
      ];

      for (const details of artifacts.InspectorIssues.mixedContent) {
        let item = items.find(item => item.url === details.insecureURL);
        if (!item) {
          item = {url: details.insecureURL};
          items.push(item);
        }
        item.resolution = resolutionToString[details.resolutionStatus] ?
          str_(resolutionToString[details.resolutionStatus]) :
          details.resolutionStatus;
      }

      // If a resolution wasn't assigned from an InspectorIssue, then the item
      // is not blocked by the browser but we've determined it is insecure anyhow.
      // For example, if the URL is localhost, all `http` requests are valid
      // (localhost is a secure context), but we still identify `http` requests
      // as an "Allowed" insecure URL.
      for (const item of items) {
        if (!item.resolution) item.resolution = str_(UIStrings.allowed);
      }

      let displayValue;
      if (items.length > 0) {
        displayValue = str_(UIStrings.displayValue, {itemCount: items.length});
      }

      return {
        score: Number(items.length === 0),
        displayValue,
        details: Audit.makeTableDetails(headings, items),
      };
    });
  }
}

module.exports = HTTPS;
module.exports.UIStrings = UIStrings;

}).call(this)}).call(this,"/lighthouse-core/audits/is-on-https.js")
},{"../computed/network-records.js":40,"../lib/i18n/i18n.js":96,"../lib/network-request.js":109,"../lib/url-shim.js":"url","./audit.js":3}],"../audits/large-javascript-libraries":[function(require,module,exports){
(function (__filename){(function (){
/**
 * @license Copyright 2020 The Lighthouse Authors. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.
 */

/**
 * @fileoverview This audit checks a page for any large JS libraries with smaller alternatives.
 * These libraries can be replaced with functionally equivalent, smaller ones.
 * @see https://docs.google.com/document/d/1TgKO3cWqMpcS4dn0xbjDG5fyuqgVvYYoXg--knaxJnM
 */

'use strict';
/** @typedef {{repository: string, lastScraped: number|'Error', versions: Record<string, {gzip: number}>}} BundlePhobiaLibrary */

/** @typedef {{gzip: number, name: string, repository: string}} MinifiedBundlePhobiaLibrary */

/** @type {Record<string, BundlePhobiaLibrary>} */
const libStats = require('../lib/large-javascript-libraries/bundlephobia-database.json');

/** @type {Record<string, string[]>} */
const librarySuggestions = require('../lib/large-javascript-libraries/library-suggestions.js')
  .suggestions;

const Audit = require('./audit.js');
const i18n = require('../lib/i18n/i18n.js');

const UIStrings = {
  /** Title of a Lighthouse audit that provides detail on large Javascript libraries that are used on the page that have better alternatives. This descriptive title is shown when to users when no known unnecessarily large libraries are detected on the page.*/
  title: 'Avoids large JavaScript libraries with smaller alternatives',
  /** Title of a Lighthouse audit that provides detail on large Javascript libraries that are used on the page that have better alternatives. This descriptive title is shown when to users when some known unnecessarily large libraries are detected on the page.*/
  failureTitle: 'Replace unnecessarily large JavaScript libraries',
  /** Description of a Lighthouse audit that tells the user why they should care about the large Javascript libraries that have better alternatives. This is displayed after a user expands the section to see more. No character length limits. */
  description: 'Large JavaScript libraries can lead to poor performance. ' +
    'Prefer smaller, functionally equivalent libraries to reduce your bundle size.' +
    ' [Learn more](https://developers.google.com/web/fundamentals/performance/webpack/decrease-frontend-size#optimize_dependencies).',
  /** Label for a column in a data table. Entries will be names of large JavaScript libraries that could be replaced. */
  columnLibraryName: 'Library',
  /** [ICU Syntax] Label for the Large JavaScrip Libraries audit identifying how many large libraries were found. */
  displayValue: `{libraryCount, plural,
    =1 {1 large library found}
    other {# large libraries found}
    }`,
};

const str_ = i18n.createMessageInstanceIdFn(__filename, UIStrings);

class LargeJavascriptLibraries extends Audit {
  /**
   * @return {LH.Audit.Meta}
   */
  static get meta() {
    return {
      id: 'large-javascript-libraries',
      title: str_(UIStrings.title),
      failureTitle: str_(UIStrings.failureTitle),
      description: str_(UIStrings.description),
      requiredArtifacts: ['Stacks'],
    };
  }

  /**
   * @param {LH.Artifacts} artifacts
   * @return {LH.Audit.Product}
   */
  static audit(artifacts) {
    /** @type {Array<{original: MinifiedBundlePhobiaLibrary, suggestions: MinifiedBundlePhobiaLibrary[]}>} */
    const libraryPairings = [];
    const detectedLibs = artifacts.Stacks;

    const seenLibraries = new Set();

    for (const detectedLib of detectedLibs) {
      if (!detectedLib.npm || !libStats[detectedLib.npm]) continue;

      const suggestions = librarySuggestions[detectedLib.npm];
      if (!suggestions) continue;

      if (seenLibraries.has(detectedLib.npm)) continue;
      seenLibraries.add(detectedLib.npm);

      let version = 'latest';
      if (detectedLib.version && libStats[detectedLib.npm].versions[detectedLib.version]) {
        version = detectedLib.version;
      }

      const originalLib = libStats[detectedLib.npm].versions[version];

      /** @type {Array<{name: string, repository: string, gzip: number}>} */
      const smallerSuggestions = [];
      for (const suggestion of suggestions) {
        if (libStats[suggestion].versions['latest'].gzip >= originalLib.gzip) continue;

        smallerSuggestions.push({
          name: suggestion,
          repository: libStats[suggestion].repository,
          gzip: libStats[suggestion].versions['latest'].gzip,
        });
      }

      smallerSuggestions.sort((a, b) => a.gzip - b.gzip);
      if (!smallerSuggestions.length) continue;

      libraryPairings.push({
        original: {
          gzip: originalLib.gzip,
          name: detectedLib.npm,
          repository: libStats[detectedLib.npm].repository,
        },
        suggestions: smallerSuggestions,
      });
    }

    /** @type {LH.Audit.Details.Table['items']} */
    const tableDetails = libraryPairings.map(libraryPairing => {
      const original = libraryPairing.original;
      const suggestions = libraryPairing.suggestions;
      const suggestionItems = suggestions.map(suggestion => {
        return {
          suggestion: {
            type: /** @type {'link'} */ ('link'),
            text: suggestion.name,
            url: suggestion.repository,
          },
          transferSize: suggestion.gzip,
          wastedBytes: original.gzip - suggestion.gzip,
        };
      });

      return {
        name: {
          type: /** @type {'link'} */ ('link'),
          text: original.name,
          url: original.repository,
        },
        transferSize: original.gzip,
        subItems: {
          type: /** @type {'subitems'} */ ('subitems'),
          items: suggestionItems,
        },
      };
    });

    /** @type {LH.Audit.Details.TableColumnHeading[]} */
    const headings = [
      /* eslint-disable max-len */
      {key: 'name', itemType: 'text', subItemsHeading: {key: 'suggestion'}, text: str_(UIStrings.columnLibraryName)},
      {key: 'transferSize', itemType: 'bytes', subItemsHeading: {key: 'transferSize'}, text: str_(i18n.UIStrings.columnTransferSize)},
      {key: null, itemType: 'bytes', subItemsHeading: {key: 'wastedBytes'}, text: str_(i18n.UIStrings.columnWastedBytes)},
      /* eslint-enable max-len */
    ];

    const displayValue = str_(UIStrings.displayValue, {libraryCount: tableDetails.length});

    const details = Audit.makeTableDetails(headings, tableDetails, {});

    return {
      score: libraryPairings.length > 0 ? 0 : 1,
      displayValue,
      details,
    };
  }
}

module.exports = LargeJavascriptLibraries;
module.exports.UIStrings = UIStrings;

}).call(this)}).call(this,"/lighthouse-core/audits/large-javascript-libraries.js")
},{"../lib/i18n/i18n.js":96,"../lib/large-javascript-libraries/bundlephobia-database.json":100,"../lib/large-javascript-libraries/library-suggestions.js":101,"./audit.js":3}],"../audits/largest-contentful-paint-element":[function(require,module,exports){
(function (__filename){(function (){
/**
 * @license Copyright 2020 The Lighthouse Authors. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.
 */
'use strict';

const Audit = require('./audit.js');
const i18n = require('../lib/i18n/i18n.js');

const UIStrings = {
  /** Descriptive title of a diagnostic audit that provides the element that was determined to be the Largest Contentful Paint. */
  title: 'Largest Contentful Paint element',
  /** Description of a Lighthouse audit that tells the user that the element shown was determined to be the Largest Contentful Paint. */
  description: 'This is the largest contentful element painted within the viewport. ' +
    '[Learn More](https://web.dev/lighthouse-largest-contentful-paint/)',
};

const str_ = i18n.createMessageInstanceIdFn(__filename, UIStrings);

class LargestContentfulPaintElement extends Audit {
  /**
   * @return {LH.Audit.Meta}
   */
  static get meta() {
    return {
      id: 'largest-contentful-paint-element',
      title: str_(UIStrings.title),
      description: str_(UIStrings.description),
      scoreDisplayMode: Audit.SCORING_MODES.INFORMATIVE,
      supportedModes: ['navigation'],
      requiredArtifacts: ['traces', 'TraceElements'],
    };
  }

  /**
   * @param {LH.Artifacts} artifacts
   * @return {LH.Audit.Product}
   */
  static audit(artifacts) {
    const lcpElement = artifacts.TraceElements
      .find(element => element.traceEventType === 'largest-contentful-paint');
    const lcpElementDetails = [];
    if (lcpElement) {
      lcpElementDetails.push({
        node: Audit.makeNodeItem(lcpElement.node),
      });
    }

    /** @type {LH.Audit.Details.Table['headings']} */
    const headings = [
      {key: 'node', itemType: 'node', text: str_(i18n.UIStrings.columnElement)},
    ];

    const details = Audit.makeTableDetails(headings, lcpElementDetails);

    const displayValue = str_(i18n.UIStrings.displayValueElementsFound,
      {nodeCount: lcpElementDetails.length});

    return {
      score: 1,
      notApplicable: lcpElementDetails.length === 0,
      displayValue,
      details,
    };
  }
}

module.exports = LargestContentfulPaintElement;
module.exports.UIStrings = UIStrings;

}).call(this)}).call(this,"/lighthouse-core/audits/largest-contentful-paint-element.js")
},{"../lib/i18n/i18n.js":96,"./audit.js":3}],"../audits/layout-shift-elements":[function(require,module,exports){
(function (__filename){(function (){
/**
 * @license Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.
 */
'use strict';

const Audit = require('./audit.js');
const i18n = require('../lib/i18n/i18n.js');

const UIStrings = {
  /** Descriptive title of a diagnostic audit that provides up to the top five elements contributing to Cumulative Layout Shift. */
  title: 'Avoid large layout shifts',
  /** Description of a diagnostic audit that provides up to the top five elements contributing to Cumulative Layout Shift. */
  description: 'These DOM elements contribute most to the CLS of the page.',
  /**  Label for a column in a data table; entries in this column will be the amount that the corresponding element contributes to the total CLS metric score. */
  columnContribution: 'CLS Contribution',
};

const str_ = i18n.createMessageInstanceIdFn(__filename, UIStrings);

class LayoutShiftElements extends Audit {
  /**
   * @return {LH.Audit.Meta}
   */
  static get meta() {
    return {
      id: 'layout-shift-elements',
      title: str_(UIStrings.title),
      description: str_(UIStrings.description),
      scoreDisplayMode: Audit.SCORING_MODES.INFORMATIVE,
      requiredArtifacts: ['traces', 'TraceElements'],
    };
  }

  /**
   * @param {LH.Artifacts} artifacts
   * @return {LH.Audit.Product}
   */
  static audit(artifacts) {
    const clsElements = artifacts.TraceElements
      .filter(element => element.traceEventType === 'layout-shift');

    const clsElementData = clsElements.map(element => {
      return {
        node: Audit.makeNodeItem(element.node),
        score: element.score,
      };
    });

    /** @type {LH.Audit.Details.Table['headings']} */
    const headings = [
      {key: 'node', itemType: 'node', text: str_(i18n.UIStrings.columnElement)},
      {key: 'score', itemType: 'numeric',
        granularity: 0.001, text: str_(UIStrings.columnContribution)},
    ];

    const details = Audit.makeTableDetails(headings, clsElementData);
    let displayValue;
    if (clsElementData.length > 0) {
      displayValue = str_(i18n.UIStrings.displayValueElementsFound,
        {nodeCount: clsElementData.length});
    }

    return {
      score: 1,
      notApplicable: details.items.length === 0,
      displayValue,
      details,
    };
  }
}

module.exports = LayoutShiftElements;
module.exports.UIStrings = UIStrings;

}).call(this)}).call(this,"/lighthouse-core/audits/layout-shift-elements.js")
},{"../lib/i18n/i18n.js":96,"./audit.js":3}],"../audits/long-tasks":[function(require,module,exports){
(function (__filename){(function (){
/**
 * @license Copyright 2020 The Lighthouse Authors. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.
 */
'use strict';

const Audit = require('./audit.js');
const NetworkRecords = require('../computed/network-records.js');
const i18n = require('../lib/i18n/i18n.js');
const MainThreadTasks = require('../computed/main-thread-tasks.js');
const BootupTime = require('./bootup-time.js');
const PageDependencyGraph = require('../computed/page-dependency-graph.js');
const LoadSimulator = require('../computed/load-simulator.js');

/** We don't always have timing data for short tasks, if we're missing timing data. Treat it as though it were 0ms. */
const DEFAULT_TIMING = {startTime: 0, endTime: 0, duration: 0};

const UIStrings = {
  /** Title of a diagnostic LH audit that provides details on the longest running tasks that occur when the page loads. */
  title: 'Avoid long main-thread tasks',
  /** Description of a diagnostic LH audit that shows the user the longest running tasks that occur when the page loads. */
  description: 'Lists the longest tasks on the main thread, ' +
    'useful for identifying worst contributors to input delay. ' +
    '[Learn more](https://web.dev/long-tasks-devtools/)',
  /** [ICU Syntax] Label identifying the number of long-running CPU tasks that occurred while loading a web page. */
  displayValue: `{itemCount, plural,
  =1 {# long task found}
  other {# long tasks found}
  }`,
};

const str_ = i18n.createMessageInstanceIdFn(__filename, UIStrings);

class LongTasks extends Audit {
  /**
   * @return {LH.Audit.Meta}
   */
  static get meta() {
    return {
      id: 'long-tasks',
      scoreDisplayMode: Audit.SCORING_MODES.INFORMATIVE,
      title: str_(UIStrings.title),
      description: str_(UIStrings.description),
      requiredArtifacts: ['traces', 'devtoolsLogs'],
    };
  }

  /**
   * @param {LH.Artifacts} artifacts
   * @param {LH.Audit.Context} context
   * @return {Promise<LH.Audit.Product>}
   */
  static async audit(artifacts, context) {
    const settings = context.settings || {};
    const trace = artifacts.traces[Audit.DEFAULT_PASS];
    const tasks = await MainThreadTasks.request(trace, context);
    const devtoolsLog = artifacts.devtoolsLogs[LongTasks.DEFAULT_PASS];
    const networkRecords = await NetworkRecords.request(devtoolsLog, context);

    /** @type {Map<LH.TraceEvent, LH.Gatherer.Simulation.NodeTiming>} */
    const taskTimingsByEvent = new Map();

    if (settings.throttlingMethod === 'simulate') {
      const simulatorOptions = {devtoolsLog, settings: context.settings};
      const pageGraph = await PageDependencyGraph.request({trace, devtoolsLog}, context);
      const simulator = await LoadSimulator.request(simulatorOptions, context);
      const simulation = await simulator.simulate(pageGraph, {label: 'long-tasks-diagnostic'});
      for (const [node, timing] of simulation.nodeTimings.entries()) {
        if (node.type !== 'cpu') continue;
        taskTimingsByEvent.set(node.event, timing);
      }
    } else {
      for (const task of tasks) {
        if (task.unbounded || task.parent) continue;
        taskTimingsByEvent.set(task.event, task);
      }
    }

    const jsURLs = BootupTime.getJavaScriptURLs(networkRecords);
    // Only consider up to 20 long, top-level (no parent) tasks that have an explicit endTime
    const longtasks = tasks
      .map(t => {
        const timing = taskTimingsByEvent.get(t.event) || DEFAULT_TIMING;
        return {...t, duration: timing.duration, startTime: timing.startTime};
      })
      .filter(t => t.duration >= 50 && !t.unbounded && !t.parent)
      .sort((a, b) => b.duration - a.duration)
      .slice(0, 20);

    // TODO(beytoven): Add start time that matches with the simulated throttling
    const results = longtasks.map(task => ({
      url: BootupTime.getAttributableURLForTask(task, jsURLs),
      duration: task.duration,
      startTime: task.startTime,
    }));

    /** @type {LH.Audit.Details.Table['headings']} */
    const headings = [
      /* eslint-disable max-len */
      {key: 'url', itemType: 'url', text: str_(i18n.UIStrings.columnURL)},
      {key: 'startTime', itemType: 'ms', granularity: 1, text: str_(i18n.UIStrings.columnStartTime)},
      {key: 'duration', itemType: 'ms', granularity: 1, text: str_(i18n.UIStrings.columnDuration)},
      /* eslint-enable max-len */
    ];

    const tableDetails = Audit.makeTableDetails(headings, results);

    let displayValue;
    if (results.length > 0) {
      displayValue = str_(UIStrings.displayValue, {itemCount: results.length});
    }

    return {
      score: results.length === 0 ? 1 : 0,
      notApplicable: results.length === 0,
      details: tableDetails,
      displayValue,
    };
  }
}

module.exports = LongTasks;
module.exports.UIStrings = UIStrings;

}).call(this)}).call(this,"/lighthouse-core/audits/long-tasks.js")
},{"../computed/load-simulator.js":13,"../computed/main-thread-tasks.js":15,"../computed/network-records.js":40,"../computed/page-dependency-graph.js":41,"../lib/i18n/i18n.js":96,"./audit.js":3,"./bootup-time.js":"../audits/bootup-time"}],"../audits/main-thread-tasks":[function(require,module,exports){
/**
 * @license Copyright 2019 The Lighthouse Authors. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.
 */
'use strict';

const Audit = require('./audit.js');
const MainThreadTasksComputed = require('../computed/main-thread-tasks.js');

class MainThreadTasks extends Audit {
  /**
   * @return {LH.Audit.Meta}
   */
  static get meta() {
    return {
      id: 'main-thread-tasks',
      scoreDisplayMode: Audit.SCORING_MODES.INFORMATIVE,
      title: 'Tasks',
      description: 'Lists the toplevel main thread tasks that executed during page load.',
      requiredArtifacts: ['traces'],
    };
  }

  /**
   * @param {LH.Artifacts} artifacts
   * @param {LH.Audit.Context} context
   * @return {Promise<LH.Audit.Product>}
   */
  static async audit(artifacts, context) {
    const trace = artifacts.traces[Audit.DEFAULT_PASS];
    const tasks = await MainThreadTasksComputed.request(trace, context);

    const results = tasks
      // Filter to just the sizable toplevel tasks; toplevel tasks are tasks without a parent.
      .filter(task => task.duration > 5 && !task.parent)
      .map(task => {
        return {
          duration: task.duration,
          startTime: task.startTime,
        };
      });

    /** @type {LH.Audit.Details.Table['headings']} */
    const headings = [
      {key: 'startTime', itemType: 'ms', granularity: 1, text: 'Start Time'},
      {key: 'duration', itemType: 'ms', granularity: 1, text: 'End Time'},
    ];

    const tableDetails = Audit.makeTableDetails(headings, results);

    return {
      score: 1,
      details: tableDetails,
    };
  }
}

module.exports = MainThreadTasks;

},{"../computed/main-thread-tasks.js":15,"./audit.js":3}],"../audits/mainthread-work-breakdown":[function(require,module,exports){
(function (__filename){(function (){
/**
 * @license Copyright 2017 The Lighthouse Authors. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.
 */

/**
 * @fileoverview Audit a page to show a breakdown of execution timings on the main thread
 */

'use strict';

const Audit = require('./audit.js');
const {taskGroups} = require('../lib/tracehouse/task-groups.js');
const i18n = require('../lib/i18n/i18n.js');
const MainThreadTasks = require('../computed/main-thread-tasks.js');

const UIStrings = {
  /** Title of a diagnostic audit that provides detail on the main thread work the browser did to load the page. This descriptive title is shown to users when the amount is acceptable and no user action is required. */
  title: 'Minimizes main-thread work',
  /** Title of a diagnostic audit that provides detail on the main thread work the browser did to load the page. This imperative title is shown to users when there is a significant amount of execution time that could be reduced. */
  failureTitle: 'Minimize main-thread work',
  /** Description of a Lighthouse audit that tells the user *why* they should reduce JS execution times. This is displayed after a user expands the section to see more. No character length limits. 'Learn More' becomes link text to additional documentation. */
  description: 'Consider reducing the time spent parsing, compiling and executing JS. ' +
    'You may find delivering smaller JS payloads helps with this. ' +
    '[Learn more](https://web.dev/mainthread-work-breakdown/)',
  /** Label for the Main Thread Category column in data tables, rows will have a main thread Category and main thread Task Name. */
  columnCategory: 'Category',
};

const str_ = i18n.createMessageInstanceIdFn(__filename, UIStrings);

/** @typedef {import('../lib/tracehouse/task-groups.js').TaskGroupIds} TaskGroupIds */

class MainThreadWorkBreakdown extends Audit {
  /**
   * @return {LH.Audit.Meta}
   */
  static get meta() {
    return {
      id: 'mainthread-work-breakdown',
      title: str_(UIStrings.title),
      failureTitle: str_(UIStrings.failureTitle),
      description: str_(UIStrings.description),
      scoreDisplayMode: Audit.SCORING_MODES.NUMERIC,
      requiredArtifacts: ['traces'],
    };
  }

  /**
   * @return {LH.Audit.ScoreOptions}
   */
  static get defaultOptions() {
    return {
      // see https://www.desmos.com/calculator/vhglu1x8zv
      p10: 2017,
      median: 4000,
    };
  }

  /**
   * @param {LH.Artifacts.TaskNode[]} tasks
   * @return {Map<TaskGroupIds, number>}
   */
  static getExecutionTimingsByGroup(tasks) {
    /** @type {Map<TaskGroupIds, number>} */
    const result = new Map();

    for (const task of tasks) {
      const originalTime = result.get(task.group.id) || 0;
      result.set(task.group.id, originalTime + task.selfTime);
    }

    return result;
  }

  /**
   * @param {LH.Artifacts} artifacts
   * @param {LH.Audit.Context} context
   * @return {Promise<LH.Audit.Product>}
   */
  static async audit(artifacts, context) {
    const settings = context.settings || {};
    const trace = artifacts.traces[MainThreadWorkBreakdown.DEFAULT_PASS];

    const tasks = await MainThreadTasks.request(trace, context);
    const multiplier = settings.throttlingMethod === 'simulate' ?
      settings.throttling.cpuSlowdownMultiplier : 1;

    const executionTimings = MainThreadWorkBreakdown.getExecutionTimingsByGroup(tasks);

    let totalExecutionTime = 0;
    /** @type {Record<string, number>} */
    const categoryTotals = {};
    const results = Array.from(executionTimings).map(([groupId, rawDuration]) => {
      const duration = rawDuration * multiplier;
      totalExecutionTime += duration;

      const categoryTotal = categoryTotals[groupId] || 0;
      categoryTotals[groupId] = categoryTotal + duration;

      return {
        group: groupId,
        groupLabel: taskGroups[groupId].label,
        duration: duration,
      };
    });

    /** @type {LH.Audit.Details.Table['headings']} */
    const headings = [
      {key: 'groupLabel', itemType: 'text', text: str_(UIStrings.columnCategory)},
      {key: 'duration', itemType: 'ms', granularity: 1, text: str_(i18n.UIStrings.columnTimeSpent)},
    ];

    results.sort((a, b) => categoryTotals[b.group] - categoryTotals[a.group]);
    const tableDetails = MainThreadWorkBreakdown.makeTableDetails(headings, results);

    const score = Audit.computeLogNormalScore(
      {p10: context.options.p10, median: context.options.median},
      totalExecutionTime
    );

    return {
      score,
      numericValue: totalExecutionTime,
      numericUnit: 'millisecond',
      displayValue: str_(i18n.UIStrings.seconds, {timeInMs: totalExecutionTime}),
      details: tableDetails,
    };
  }
}

module.exports = MainThreadWorkBreakdown;
module.exports.UIStrings = UIStrings;

}).call(this)}).call(this,"/lighthouse-core/audits/mainthread-work-breakdown.js")
},{"../computed/main-thread-tasks.js":15,"../lib/i18n/i18n.js":96,"../lib/tracehouse/task-groups.js":118,"./audit.js":3}],"../audits/manual/pwa-cross-browser":[function(require,module,exports){
(function (__filename){(function (){

/**
 * @license Copyright 2017 The Lighthouse Authors. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.
 */
'use strict';

const ManualAudit = require('./manual-audit.js');
const i18n = require('../../lib/i18n/i18n.js');

const UIStrings = {
  /** Title of a Lighthouse audit that prompts the user to manually check that their site works across different web browsers. */
  title: 'Site works cross-browser',
  /** Description of a Lighthouse audit that tells the user why they should make sites work across different browsers. This is displayed after a user expands the section to see more. No character length limits. 'Learn More' becomes link text to additional documentation. */
  description: 'To reach the most number of users, sites should work across ' +
  'every major browser. [Learn more](https://web.dev/pwa-cross-browser/).',
};

const str_ = i18n.createMessageInstanceIdFn(__filename, UIStrings);

/**
 * @fileoverview Manual PWA audit for cross browser support.
 */

class PWACrossBrowser extends ManualAudit {
  /**
   * @return {LH.Audit.Meta}
   */
  static get meta() {
    return Object.assign({
      id: 'pwa-cross-browser',
      title: str_(UIStrings.title),
      description: str_(UIStrings.description),
    }, super.partialMeta);
  }
}

module.exports = PWACrossBrowser;
module.exports.UIStrings = UIStrings;


}).call(this)}).call(this,"/lighthouse-core/audits/manual/pwa-cross-browser.js")
},{"../../lib/i18n/i18n.js":96,"./manual-audit.js":6}],"../audits/manual/pwa-each-page-has-url":[function(require,module,exports){
(function (__filename){(function (){
/**
 * @license Copyright 2017 The Lighthouse Authors. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.
 */
'use strict';

const ManualAudit = require('./manual-audit.js');
const i18n = require('../../lib/i18n/i18n.js');

const UIStrings = {
  /** Title of a Lighthouse audit that prompts the user to manually check that each page on their website uses a unique URL. */
  title: 'Each page has a URL',
  /** Description of a Lighthouse audit that tells the user why they should use unique URLs for each web page. This is displayed after a user expands the section to see more. No character length limits. 'Learn More' becomes link text to additional documentation. */
  description: 'Ensure individual pages are deep linkable via URL and that URLs are ' +
      'unique for the purpose of shareability on social media. [Learn more](https://web.dev/pwa-each-page-has-url/).',
};

const str_ = i18n.createMessageInstanceIdFn(__filename, UIStrings);

/**
 * @fileoverview Manual PWA audit to ensure every page has a deep link.
 */

class PWAEachPageHasURL extends ManualAudit {
  /**
   * @return {LH.Audit.Meta}
   */
  static get meta() {
    return Object.assign({
      id: 'pwa-each-page-has-url',
      title: str_(UIStrings.title),
      description: str_(UIStrings.description),
    }, super.partialMeta);
  }
}

module.exports = PWAEachPageHasURL;
module.exports.UIStrings = UIStrings;

}).call(this)}).call(this,"/lighthouse-core/audits/manual/pwa-each-page-has-url.js")
},{"../../lib/i18n/i18n.js":96,"./manual-audit.js":6}],"../audits/manual/pwa-page-transitions":[function(require,module,exports){
(function (__filename){(function (){
/**
 * @license Copyright 2017 The Lighthouse Authors. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.
 */
'use strict';

const ManualAudit = require('./manual-audit.js');
const i18n = require('../../lib/i18n/i18n.js');

const UIStrings = {
  /** Title of a Lighthouse audit that prompts the user to manually check that page transitions (navigating to other pages on a website) shouldn't feel like they are waiting for the network to load. */
  title: 'Page transitions don\'t feel like they block on the network',
  /** Description of a Lighthouse audit that tells the user why they should make transitions in their web app feel fast. This is displayed after a user expands the section to see more. No character length limits. 'Learn More' becomes link text to additional documentation. */
  description: 'Transitions should feel snappy as you tap around, even on a slow network. ' +
    'This experience is key to a user\'s perception of performance. [Learn more](https://web.dev/pwa-page-transitions/).',
};

const str_ = i18n.createMessageInstanceIdFn(__filename, UIStrings);

/**
 * @fileoverview Manual PWA audit for janky-free page transitions.
 */

class PWAPageTransitions extends ManualAudit {
  /**
   * @return {LH.Audit.Meta}
   */
  static get meta() {
    return Object.assign({
      id: 'pwa-page-transitions',
      title: str_(UIStrings.title),
      description: str_(UIStrings.description),
    }, super.partialMeta);
  }
}

module.exports = PWAPageTransitions;
module.exports.UIStrings = UIStrings;

}).call(this)}).call(this,"/lighthouse-core/audits/manual/pwa-page-transitions.js")
},{"../../lib/i18n/i18n.js":96,"./manual-audit.js":6}],"../audits/maskable-icon":[function(require,module,exports){
(function (__filename){(function (){
/**
 * @license Copyright 2020 The Lighthouse Authors. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.
 */
'use strict';

const Audit = require('./audit.js');
const ManifestValues = require('../computed/manifest-values.js');
const i18n = require('../lib/i18n/i18n.js');

const UIStrings = {
  /** Title of a Lighthouse audit that provides detail on if the manifest contains a maskable icon. This descriptive title is shown to users when the manifest contains at least one maskable icon. */
  title: 'Manifest has a maskable icon',
  /** Title of a Lighthouse audit that provides detial on if the manifest contains a maskable icon. this descriptive title is shown to users when the manifest contains no icons that are maskable. */
  failureTitle: 'Manifest doesn\'t have a maskable icon',
  /** Description of a Lighthouse audit that tells the user why they their manifest should have at least one maskable icon. This is displayed after a user expands the section to see more. No character length limits. 'Learn More' becomes link text to additional documentation. */
  description: 'A maskable icon ensures that the image fills the entire ' +
    'shape without being letterboxed when installing ' +
    'the app on a device. [Learn more](https://web.dev/maskable-icon-audit/).',
};

const str_ = i18n.createMessageInstanceIdFn(__filename, UIStrings);

/**
 * @fileoverview
 * Audits if a manifest contains at least one icon that is maskable
 *
 * Requirements:
 *    * manifest is not empty
 *    * manifest has valid icons
 *    * at least one of the icons has a purpose of 'maskable'
 */

class MaskableIcon extends Audit {
  /**
   * @return {LH.Audit.Meta}
   */
  static get meta() {
    return {
      id: 'maskable-icon',
      title: str_(UIStrings.title),
      failureTitle: str_(UIStrings.failureTitle),
      description: str_(UIStrings.description),
      supportedModes: ['navigation'],
      requiredArtifacts: ['WebAppManifest', 'InstallabilityErrors'],
    };
  }

  /**
   * @param {LH.Artifacts} artifacts
   * @param {LH.Audit.Context} context
   * @return {Promise<LH.Audit.Product>}
   */
  static async audit(artifacts, context) {
    const manifestValues = await ManifestValues.request(artifacts, context);
    if (manifestValues.isParseFailure) {
      return {
        score: 0,
        explanation: manifestValues.parseFailureReason,
      };
    }
    const maskableIconCheck = manifestValues.allChecks.find(i => i.id === 'hasMaskableIcon');
    return {
      score: (maskableIconCheck && maskableIconCheck.passing) ? 1 : 0,
    };
  }
}

module.exports = MaskableIcon;
module.exports.UIStrings = UIStrings;

}).call(this)}).call(this,"/lighthouse-core/audits/maskable-icon.js")
},{"../computed/manifest-values.js":16,"../lib/i18n/i18n.js":96,"./audit.js":3}],"../audits/metrics/cumulative-layout-shift":[function(require,module,exports){
(function (__filename){(function (){
/**
 * @license Copyright 2019 The Lighthouse Authors. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.
 */
'use strict';

const Audit = require('../audit.js');
const ComputedCLS = require('../../computed/metrics/cumulative-layout-shift.js');
const i18n = require('../../lib/i18n/i18n.js');

const UIStrings = {
  /** Description of the Cumulative Layout Shift metric that indicates how much the page changes its layout while it loads. If big segments of the page shift their location during load, the Cumulative Layout Shift will be higher. This description is displayed within a tooltip when the user hovers on the metric name to see more. No character length limits. 'Learn More' becomes link text to additional documentation. */
  description: 'Cumulative Layout Shift measures the movement of visible ' +
               'elements within the viewport. [Learn more](https://web.dev/cls/).',
};

const str_ = i18n.createMessageInstanceIdFn(__filename, UIStrings);

/**
 * @fileoverview This metric represents the amount of visual shifting of DOM elements during page load.
 */
class CumulativeLayoutShift extends Audit {
  /**
   * @return {LH.Audit.Meta}
   */
  static get meta() {
    return {
      id: 'cumulative-layout-shift',
      title: str_(i18n.UIStrings.cumulativeLayoutShiftMetric),
      description: str_(UIStrings.description),
      scoreDisplayMode: Audit.SCORING_MODES.NUMERIC,
      requiredArtifacts: ['traces'],
    };
  }

  /**
   * @return {LH.Audit.ScoreOptions}
   */
  static get defaultOptions() {
    return {
      // https://web.dev/cls/#what-is-a-good-cls-score
      // This 0.1 target score was determined through both manual evaluation and large-scale analysis.
      // see https://www.desmos.com/calculator/ksp7q91nop
      p10: 0.1,
      median: 0.25,
    };
  }

  /**
   * @param {LH.Artifacts} artifacts
   * @param {LH.Audit.Context} context
   * @return {Promise<LH.Audit.Product>}
   */
  static async audit(artifacts, context) {
    const trace = artifacts.traces[Audit.DEFAULT_PASS];
    const {cumulativeLayoutShift, ...rest} = await ComputedCLS.request(trace, context);

    /** @type {LH.Audit.Details.DebugData} */
    const details = {
      type: 'debugdata',
      items: [rest],
    };

    return {
      score: Audit.computeLogNormalScore(
        {p10: context.options.p10, median: context.options.median},
        cumulativeLayoutShift
      ),
      numericValue: cumulativeLayoutShift,
      numericUnit: 'unitless',
      displayValue: cumulativeLayoutShift.toLocaleString(context.settings.locale),
      details,
    };
  }
}

module.exports = CumulativeLayoutShift;
module.exports.UIStrings = UIStrings;

}).call(this)}).call(this,"/lighthouse-core/audits/metrics/cumulative-layout-shift.js")
},{"../../computed/metrics/cumulative-layout-shift.js":17,"../../lib/i18n/i18n.js":96,"../audit.js":3}],"../audits/metrics/first-contentful-paint-3g":[function(require,module,exports){
/**
 * @license Copyright 2019 The Lighthouse Authors. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.
 */
'use strict';

const Audit = require('../audit.js');
const regular3G = require('../../config/constants.js').throttling.mobileRegular3G;
const ComputedFcp = require('../../computed/metrics/first-contentful-paint.js');

class FirstContentfulPaint3G extends Audit {
  /**
   * @return {LH.Audit.Meta}
   */
  static get meta() {
    return {
      id: 'first-contentful-paint-3g',
      title: 'First Contentful Paint (3G)',
      description: 'First Contentful Paint 3G marks the time at which the first text or image is ' +
        `painted while on a 3G network. [Learn more](https://developers.google.com/web/tools/lighthouse/audits/first-contentful-paint).`,
      scoreDisplayMode: Audit.SCORING_MODES.NUMERIC,
      supportedModes: ['navigation'],
      requiredArtifacts: ['traces', 'devtoolsLogs', 'GatherContext'],
    };
  }

  /**
   * @return {LH.Audit.ScoreOptions}
   */
  static get defaultOptions() {
    return {
      // 25th and 8th percentiles HTTPArchive on Slow 4G -> multiply by 1.5 for RTT differential -> median and p10.
      // https://bigquery.cloud.google.com/table/httparchive:lighthouse.2021_05_01_mobile
      // https://www.desmos.com/calculator/xi5oympawp
      p10: 2700,
      median: 4500,
    };
  }

  /**
   * @param {LH.Artifacts} artifacts
   * @param {LH.Audit.Context} context
   * @return {Promise<LH.Audit.Product>}
   */
  static async audit(artifacts, context) {
    const gatherContext = artifacts.GatherContext;
    const trace = artifacts.traces[Audit.DEFAULT_PASS];
    const devtoolsLog = artifacts.devtoolsLogs[Audit.DEFAULT_PASS];
    /** @type {Immutable<LH.Config.Settings>} */
    const settings = {...context.settings, throttlingMethod: 'simulate', throttling: regular3G};
    const metricComputationData = {trace, devtoolsLog, gatherContext, settings};
    const metricResult = await ComputedFcp.request(metricComputationData, context);

    return {
      score: Audit.computeLogNormalScore(
        {p10: context.options.p10, median: context.options.median},
        metricResult.timing
      ),
      numericValue: metricResult.timing,
      numericUnit: 'millisecond',
      displayValue: `${metricResult.timing}\xa0ms`,
    };
  }
}

module.exports = FirstContentfulPaint3G;

},{"../../computed/metrics/first-contentful-paint.js":19,"../../config/constants.js":56,"../audit.js":3}],"../audits/metrics/first-contentful-paint":[function(require,module,exports){
(function (__filename){(function (){
/**
 * @license Copyright 2018 The Lighthouse Authors. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.
 */
'use strict';

const Audit = require('../audit.js');
const i18n = require('../../lib/i18n/i18n.js');
const ComputedFcp = require('../../computed/metrics/first-contentful-paint.js');

const UIStrings = {
  /** Description of the First Contentful Paint (FCP) metric, which marks the time at which the first text or image is painted by the browser. This is displayed within a tooltip when the user hovers on the metric name to see more. No character length limits. 'Learn More' becomes link text to additional documentation. */
  description: 'First Contentful Paint marks the time at which the first text or image is ' +
      `painted. [Learn more](https://web.dev/first-contentful-paint/).`,
};

const str_ = i18n.createMessageInstanceIdFn(__filename, UIStrings);

class FirstContentfulPaint extends Audit {
  /**
   * @return {LH.Audit.Meta}
   */
  static get meta() {
    return {
      id: 'first-contentful-paint',
      title: str_(i18n.UIStrings.firstContentfulPaintMetric),
      description: str_(UIStrings.description),
      scoreDisplayMode: Audit.SCORING_MODES.NUMERIC,
      supportedModes: ['navigation'],
      requiredArtifacts: ['traces', 'devtoolsLogs', 'GatherContext'],
    };
  }

  /**
   * @return {{mobile: {scoring: LH.Audit.ScoreOptions}, desktop: {scoring: LH.Audit.ScoreOptions}}}
   */
  static get defaultOptions() {
    return {
      mobile: {
        // 25th and 8th percentiles HTTPArchive -> median and p10.
        // https://bigquery.cloud.google.com/table/httparchive:lighthouse.2021_05_01_mobile
        // see https://www.desmos.com/calculator/6wi8rhipve
        scoring: {
          p10: 1800,
          median: 3000,
        },
      },
      desktop: {
        // SELECT QUANTILES(renderStart, 21) FROM [httparchive:summary_pages.2020_07_01_desktop] LIMIT 1000
        scoring: {
          p10: 934,
          median: 1600,
        },
      },
    };
  }

  /**
   * @param {LH.Artifacts} artifacts
   * @param {LH.Audit.Context} context
   * @return {Promise<LH.Audit.Product>}
   */
  static async audit(artifacts, context) {
    const trace = artifacts.traces[Audit.DEFAULT_PASS];
    const devtoolsLog = artifacts.devtoolsLogs[Audit.DEFAULT_PASS];
    const gatherContext = artifacts.GatherContext;
    const metricComputationData = {trace, devtoolsLog, gatherContext, settings: context.settings};
    const metricResult = await ComputedFcp.request(metricComputationData, context);
    const options = context.options[context.settings.formFactor];

    return {
      score: Audit.computeLogNormalScore(
        options.scoring,
        metricResult.timing
      ),
      numericValue: metricResult.timing,
      numericUnit: 'millisecond',
      displayValue: str_(i18n.UIStrings.seconds, {timeInMs: metricResult.timing}),
    };
  }
}

module.exports = FirstContentfulPaint;
module.exports.UIStrings = UIStrings;

}).call(this)}).call(this,"/lighthouse-core/audits/metrics/first-contentful-paint.js")
},{"../../computed/metrics/first-contentful-paint.js":19,"../../lib/i18n/i18n.js":96,"../audit.js":3}],"../audits/metrics/first-meaningful-paint":[function(require,module,exports){
(function (__filename){(function (){
/**
 * @license Copyright 2016 The Lighthouse Authors. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.
 */
'use strict';

const Audit = require('../audit.js');
const i18n = require('../../lib/i18n/i18n.js');
const ComputedFmp = require('../../computed/metrics/first-meaningful-paint.js');

const UIStrings = {
  /** Description of the First Meaningful Paint (FMP) metric, which marks the time at which a majority of the content has been painted by the browser. This is displayed within a tooltip when the user hovers on the metric name to see more. No character length limits. 'Learn More' becomes link text to additional documentation. */
  description: 'First Meaningful Paint measures when the primary content of a page is ' +
      'visible. [Learn more](https://web.dev/first-meaningful-paint/).',
};

const str_ = i18n.createMessageInstanceIdFn(__filename, UIStrings);

class FirstMeaningfulPaint extends Audit {
  /**
   * @return {LH.Audit.Meta}
   */
  static get meta() {
    return {
      id: 'first-meaningful-paint',
      title: str_(i18n.UIStrings.firstMeaningfulPaintMetric),
      description: str_(UIStrings.description),
      scoreDisplayMode: Audit.SCORING_MODES.NUMERIC,
      supportedModes: ['navigation'],
      requiredArtifacts: ['traces', 'devtoolsLogs', 'GatherContext'],
    };
  }

  /**
   * @return {{mobile: {scoring: LH.Audit.ScoreOptions}, desktop: {scoring: LH.Audit.ScoreOptions}}}
   */
  static get defaultOptions() {
    return {
      mobile: {
        // 25th and 5th percentiles HTTPArchive -> median and PODR, then p10 derived from them.
        // https://bigquery.cloud.google.com/table/httparchive:lighthouse.2018_04_01_mobile?pli=1
        // see https://www.desmos.com/calculator/i4znkdccut
        scoring: {
          p10: 2336,
          median: 4000,
        },
      },
      desktop: {
        // SELECT QUANTILES(renderStart, 21) FROM [httparchive:summary_pages.2018_12_15_desktop] LIMIT 1000
        scoring: {
          p10: 934,
          median: 1600,
        },
      },
    };
  }

  /**
   * Audits the page to give a score for First Meaningful Paint.
   * @see https://github.com/GoogleChrome/lighthouse/issues/26
   * @see https://docs.google.com/document/d/1BR94tJdZLsin5poeet0XoTW60M0SjvOJQttKT-JK8HI/view
   * @param {LH.Artifacts} artifacts The artifacts from the gather phase.
   * @param {LH.Audit.Context} context
   * @return {Promise<LH.Audit.Product>}
   */
  static async audit(artifacts, context) {
    const trace = artifacts.traces[Audit.DEFAULT_PASS];
    const devtoolsLog = artifacts.devtoolsLogs[Audit.DEFAULT_PASS];
    const gatherContext = artifacts.GatherContext;
    const metricComputationData = {trace, devtoolsLog, gatherContext, settings: context.settings};
    const metricResult = await ComputedFmp.request(metricComputationData, context);
    const options = context.options[context.settings.formFactor];


    return {
      score: Audit.computeLogNormalScore(
        options.scoring,
        metricResult.timing
      ),
      numericValue: metricResult.timing,
      numericUnit: 'millisecond',
      displayValue: str_(i18n.UIStrings.seconds, {timeInMs: metricResult.timing}),
    };
  }
}

module.exports = FirstMeaningfulPaint;
module.exports.UIStrings = UIStrings;

}).call(this)}).call(this,"/lighthouse-core/audits/metrics/first-meaningful-paint.js")
},{"../../computed/metrics/first-meaningful-paint.js":20,"../../lib/i18n/i18n.js":96,"../audit.js":3}],"../audits/metrics/interactive":[function(require,module,exports){
(function (__filename){(function (){
/**
 * @license Copyright 2017 The Lighthouse Authors. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.
 */
'use strict';

const Audit = require('../audit.js');
const i18n = require('../../lib/i18n/i18n.js');
const Interactive = require('../../computed/metrics/interactive.js');

const UIStrings = {
  /** Description of the Time to Interactive (TTI) metric, which evaluates when a page has completed its primary network activity and main thread work. This is displayed within a tooltip when the user hovers on the metric name to see more. No character length limits. 'Learn More' becomes link text to additional documentation. */
  description: 'Time to interactive is the amount of time it takes for the page to become fully ' +
    'interactive. [Learn more](https://web.dev/interactive/).',
};

const str_ = i18n.createMessageInstanceIdFn(__filename, UIStrings);

/**
 * @fileoverview This audit identifies the time the page is "consistently interactive".
 * Looks for the first period of at least 5 seconds after FMP where both CPU and network were quiet,
 * and returns the timestamp of the beginning of the CPU quiet period.
 * @see https://docs.google.com/document/d/1GGiI9-7KeY3TPqS3YT271upUVimo-XiL5mwWorDUD4c/edit#
 */
class InteractiveMetric extends Audit {
  /**
   * @return {LH.Audit.Meta}
   */
  static get meta() {
    return {
      id: 'interactive',
      title: str_(i18n.UIStrings.interactiveMetric),
      description: str_(UIStrings.description),
      scoreDisplayMode: Audit.SCORING_MODES.NUMERIC,
      supportedModes: ['navigation'],
      requiredArtifacts: ['traces', 'devtoolsLogs', 'GatherContext'],
    };
  }

  /**
   * @return {{mobile: {scoring: LH.Audit.ScoreOptions}, desktop: {scoring: LH.Audit.ScoreOptions}}}
   */
  static get defaultOptions() {
    return {
      mobile: {
        // 25th and 5th percentiles HTTPArchive -> median and PODR, then p10 derived from them.
        // https://bigquery.cloud.google.com/table/httparchive:lighthouse.2018_04_01_mobile?pli=1
        // see https://www.desmos.com/calculator/o98tbeyt1t
        scoring: {
          p10: 3785,
          median: 7300,
        },
      },
      desktop: {
        // SELECT QUANTILES(fullyLoaded, 21) FROM [httparchive:summary_pages.2018_12_15_desktop] LIMIT 1000
        scoring: {
          p10: 2468,
          median: 4500,
        },
      },
    };
  }

  /**
   * @param {LH.Artifacts} artifacts
   * @param {LH.Audit.Context} context
   * @return {Promise<LH.Audit.Product>}
   */
  static async audit(artifacts, context) {
    const trace = artifacts.traces[Audit.DEFAULT_PASS];
    const devtoolsLog = artifacts.devtoolsLogs[Audit.DEFAULT_PASS];
    const gatherContext = artifacts.GatherContext;
    const metricComputationData = {trace, devtoolsLog, gatherContext, settings: context.settings};
    const metricResult = await Interactive.request(metricComputationData, context);
    const timeInMs = metricResult.timing;
    const options = context.options[context.settings.formFactor];


    return {
      score: Audit.computeLogNormalScore(
        options.scoring,
        timeInMs
      ),
      numericValue: timeInMs,
      numericUnit: 'millisecond',
      displayValue: str_(i18n.UIStrings.seconds, {timeInMs}),
    };
  }
}

module.exports = InteractiveMetric;
module.exports.UIStrings = UIStrings;

}).call(this)}).call(this,"/lighthouse-core/audits/metrics/interactive.js")
},{"../../computed/metrics/interactive.js":21,"../../lib/i18n/i18n.js":96,"../audit.js":3}],"../audits/metrics/largest-contentful-paint":[function(require,module,exports){
(function (__filename){(function (){
/**
 * @license Copyright 2019 The Lighthouse Authors. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.
 */
'use strict';

const Audit = require('../audit.js');
const i18n = require('../../lib/i18n/i18n.js');
const ComputedLcp = require('../../computed/metrics/largest-contentful-paint.js');
const LHError = require('../../lib/lh-error.js');

const UIStrings = {
  /** Description of the Largest Contentful Paint (LCP) metric, which marks the time at which the largest text or image is painted by the browser. This is displayed within a tooltip when the user hovers on the metric name to see more. No character length limits. 'Learn More' becomes link text to additional documentation. */
  description: 'Largest Contentful Paint marks the time at which the largest text or image is ' +
      `painted. [Learn more](https://web.dev/lighthouse-largest-contentful-paint/)`,
};

const str_ = i18n.createMessageInstanceIdFn(__filename, UIStrings);

class LargestContentfulPaint extends Audit {
  /**
   * @return {LH.Audit.Meta}
   */
  static get meta() {
    return {
      id: 'largest-contentful-paint',
      title: str_(i18n.UIStrings.largestContentfulPaintMetric),
      description: str_(UIStrings.description),
      scoreDisplayMode: Audit.SCORING_MODES.NUMERIC,
      supportedModes: ['navigation'],
      requiredArtifacts: ['HostUserAgent', 'traces', 'devtoolsLogs', 'GatherContext'],
    };
  }

  /**
   * @return {{mobile: {scoring: LH.Audit.ScoreOptions}, desktop: {scoring: LH.Audit.ScoreOptions}}}
   */
  static get defaultOptions() {
    return {
      mobile: {
        // 25th and 13th percentiles HTTPArchive -> median and p10 points.
        // https://bigquery.cloud.google.com/table/httparchive:lighthouse.2020_02_01_mobile?pli=1
        // https://web.dev/lcp/#what-is-a-good-lcp-score
        // see https://www.desmos.com/calculator/1etesp32kt
        scoring: {
          p10: 2500,
          median: 4000,
        },
      },
      desktop: {
        // 25th and 5th percentiles HTTPArchive -> median and p10 points.
        // SELECT
        //   APPROX_QUANTILES(lcpValue, 100)[OFFSET(5)] AS p05_lcp,
        //   APPROX_QUANTILES(lcpValue, 100)[OFFSET(25)] AS p25_lcp
        // FROM (
        //   SELECT CAST(JSON_EXTRACT_SCALAR(payload, "$['_chromeUserTiming.LargestContentfulPaint']") AS NUMERIC) AS lcpValue
        //   FROM `httparchive.pages.2020_04_01_desktop`
        // )
        scoring: {
          p10: 1200,
          median: 2400,
        },
      },
    };
  }

  /**
   * @param {LH.Artifacts} artifacts
   * @param {LH.Audit.Context} context
   * @return {Promise<LH.Audit.Product>}
   */
  static async audit(artifacts, context) {
    const trace = artifacts.traces[Audit.DEFAULT_PASS];
    const devtoolsLog = artifacts.devtoolsLogs[Audit.DEFAULT_PASS];
    const gatherContext = artifacts.GatherContext;
    const metricComputationData = {trace, devtoolsLog, gatherContext, settings: context.settings};

    let metricResult;
    try {
      metricResult = await ComputedLcp.request(metricComputationData, context);
    } catch (err) {
      const match = artifacts.HostUserAgent.match(/Chrome\/(\d+)/);
      if (!match) throw err;
      const milestone = Number(match[1]);

      // m79 is the minimum version which supports LCP
      // https://chromium.googlesource.com/chromium/src/+/master/docs/speed/metrics_changelog/lcp.md
      if (milestone < 79 && err.code === 'NO_LCP') {
        throw new LHError(
          LHError.errors.UNSUPPORTED_OLD_CHROME,
          {featureName: 'Largest Contentful Paint'}
        );
      }
      throw err;
    }

    const options = context.options[context.settings.formFactor];


    return {
      score: Audit.computeLogNormalScore(
        options.scoring,
        metricResult.timing
      ),
      numericValue: metricResult.timing,
      numericUnit: 'millisecond',
      displayValue: str_(i18n.UIStrings.seconds, {timeInMs: metricResult.timing}),
    };
  }
}

module.exports = LargestContentfulPaint;
module.exports.UIStrings = UIStrings;

}).call(this)}).call(this,"/lighthouse-core/audits/metrics/largest-contentful-paint.js")
},{"../../computed/metrics/largest-contentful-paint.js":31,"../../lib/i18n/i18n.js":96,"../../lib/lh-error.js":103,"../audit.js":3}],"../audits/metrics/max-potential-fid":[function(require,module,exports){
(function (__filename){(function (){
/**
 * @license Copyright 2018 The Lighthouse Authors. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.
 */
'use strict';

const Audit = require('../audit.js');
const ComputedFid = require('../../computed/metrics/max-potential-fid.js');
const i18n = require('../../lib/i18n/i18n.js');

const UIStrings = {
  /** Description of the Maximum Potential First Input Delay metric that marks the maximum estimated time between the page receiving input (a user clicking, tapping, or typing) and the page responding. This description is displayed within a tooltip when the user hovers on the metric name to see more. No character length limits. 'Learn More' becomes link text to additional documentation. */
  description: 'The maximum potential First Input Delay that your users could experience is the ' +
      'duration of the longest task. [Learn more](https://web.dev/lighthouse-max-potential-fid/).',
};

const str_ = i18n.createMessageInstanceIdFn(__filename, UIStrings);

/**
 * @fileoverview This metric is the duration of the longest task after FCP. It is meant to capture
 * the worst case First Input Delay that a user might experience.
 * Tasks before FCP are excluded because it is unlikely that the user will try to interact with a page before it has painted anything.
 */
class MaxPotentialFID extends Audit {
  /**
   * @return {LH.Audit.Meta}
   */
  static get meta() {
    return {
      id: 'max-potential-fid',
      title: str_(i18n.UIStrings.maxPotentialFIDMetric),
      description: str_(UIStrings.description),
      scoreDisplayMode: Audit.SCORING_MODES.NUMERIC,
      supportedModes: ['navigation'],
      requiredArtifacts: ['traces', 'devtoolsLogs', 'GatherContext'],
    };
  }

  /**
   * @return {LH.Audit.ScoreOptions}
   */
  static get defaultOptions() {
    return {
      // see https://www.desmos.com/calculator/onxmbblyqo
      p10: 130,
      median: 250,
    };
  }

  /**
   * @param {LH.Artifacts} artifacts
   * @param {LH.Audit.Context} context
   * @return {Promise<LH.Audit.Product>}
   */
  static async audit(artifacts, context) {
    const trace = artifacts.traces[Audit.DEFAULT_PASS];
    const devtoolsLog = artifacts.devtoolsLogs[Audit.DEFAULT_PASS];
    const gatherContext = artifacts.GatherContext;
    const metricComputationData = {trace, devtoolsLog, gatherContext, settings: context.settings};
    const metricResult = await ComputedFid.request(metricComputationData, context);

    return {
      score: Audit.computeLogNormalScore(
        {p10: context.options.p10, median: context.options.median},
        metricResult.timing
      ),
      numericValue: metricResult.timing,
      numericUnit: 'millisecond',
      displayValue: str_(i18n.UIStrings.ms, {timeInMs: metricResult.timing}),
    };
  }
}

module.exports = MaxPotentialFID;
module.exports.UIStrings = UIStrings;

}).call(this)}).call(this,"/lighthouse-core/audits/metrics/max-potential-fid.js")
},{"../../computed/metrics/max-potential-fid.js":32,"../../lib/i18n/i18n.js":96,"../audit.js":3}],"../audits/metrics/speed-index":[function(require,module,exports){
(function (__filename){(function (){
/**
 * @license Copyright 2016 The Lighthouse Authors. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.
 */
'use strict';

const Audit = require('../audit.js');
const i18n = require('../../lib/i18n/i18n.js');
const ComputedSi = require('../../computed/metrics/speed-index.js');

const UIStrings = {
  /** Description of the Speed Index metric, which summarizes how quickly the page looked visually complete. This is displayed within a tooltip when the user hovers on the metric name to see more. No character length limits. 'Learn More' becomes link text to additional documentation. */
  description: 'Speed Index shows how quickly the contents of a page are visibly populated. ' +
      '[Learn more](https://web.dev/speed-index/).',
};

const str_ = i18n.createMessageInstanceIdFn(__filename, UIStrings);

class SpeedIndex extends Audit {
  /**
   * @return {LH.Audit.Meta}
   */
  static get meta() {
    return {
      id: 'speed-index',
      title: str_(i18n.UIStrings.speedIndexMetric),
      description: str_(UIStrings.description),
      scoreDisplayMode: Audit.SCORING_MODES.NUMERIC,
      supportedModes: ['navigation'],
      requiredArtifacts: ['traces', 'devtoolsLogs', 'GatherContext'],
    };
  }

  /**
   * @return {{mobile: {scoring: LH.Audit.ScoreOptions}, desktop: {scoring: LH.Audit.ScoreOptions}}}
   */
  static get defaultOptions() {
    return {
      mobile: {
        // 25th and 5th percentiles HTTPArchive -> median and PODR, then p10 derived from them.
        // https://bigquery.cloud.google.com/table/httparchive:lighthouse.2018_04_01_mobile?pli=1
        // see https://www.desmos.com/calculator/dvuzvpl7mi
        scoring: {
          p10: 3387,
          median: 5800,
        },
      },
      desktop: {
        // SELECT QUANTILES(SpeedIndex, 21) FROM [httparchive:summary_pages.2018_12_15_desktop] LIMIT 1000
        scoring: {
          p10: 1311,
          median: 2300,
        },
      },
    };
  }

  /**
   * Audits the page to give a score for the Speed Index.
   * @see https://github.com/GoogleChrome/lighthouse/issues/197
   * @param {LH.Artifacts} artifacts The artifacts from the gather phase.
   * @param {LH.Audit.Context} context
   * @return {Promise<LH.Audit.Product>}
   */
  static async audit(artifacts, context) {
    const trace = artifacts.traces[Audit.DEFAULT_PASS];
    const devtoolsLog = artifacts.devtoolsLogs[Audit.DEFAULT_PASS];
    const gatherContext = artifacts.GatherContext;
    const metricComputationData = {trace, devtoolsLog, gatherContext, settings: context.settings};
    const metricResult = await ComputedSi.request(metricComputationData, context);
    const options = context.options[context.settings.formFactor];


    return {
      score: Audit.computeLogNormalScore(
        options.scoring,
        metricResult.timing
      ),
      numericValue: metricResult.timing,
      numericUnit: 'millisecond',
      displayValue: str_(i18n.UIStrings.seconds, {timeInMs: metricResult.timing}),
    };
  }
}

module.exports = SpeedIndex;
module.exports.UIStrings = UIStrings;

}).call(this)}).call(this,"/lighthouse-core/audits/metrics/speed-index.js")
},{"../../computed/metrics/speed-index.js":35,"../../lib/i18n/i18n.js":96,"../audit.js":3}],"../audits/metrics/total-blocking-time":[function(require,module,exports){
(function (__filename){(function (){
/**
 * @license Copyright 2019 The Lighthouse Authors. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.
 */
'use strict';

const Audit = require('../audit.js');
const ComputedTBT = require('../../computed/metrics/total-blocking-time.js');
const i18n = require('../../lib/i18n/i18n.js');

const UIStrings = {
  /** Description of the Total Blocking Time (TBT) metric, which calculates the total duration of blocking time for a web page. Blocking times are time periods when the page would be blocked (prevented) from responding to user input (clicks, taps, and keypresses will feel slow to respond). This is displayed within a tooltip when the user hovers on the metric name to see more. No character length limits.*/
  description: 'Sum of all time periods between FCP and Time to Interactive, ' +
      'when task length exceeded 50ms, expressed in milliseconds. [Learn more](https://web.dev/lighthouse-total-blocking-time/).',
};

const str_ = i18n.createMessageInstanceIdFn(__filename, UIStrings);

class TotalBlockingTime extends Audit {
  /**
   * @return {LH.Audit.Meta}
   */
  static get meta() {
    return {
      id: 'total-blocking-time',
      title: str_(i18n.UIStrings.totalBlockingTimeMetric),
      description: str_(UIStrings.description),
      scoreDisplayMode: Audit.SCORING_MODES.NUMERIC,
      requiredArtifacts: ['traces', 'devtoolsLogs', 'GatherContext'],
    };
  }

  /**
   * @return {{mobile: {scoring: LH.Audit.ScoreOptions}, desktop: {scoring: LH.Audit.ScoreOptions}}}
   */
  static get defaultOptions() {
    return {
      mobile: {
        // If determined from HTTP Archive data…
        //     SELECT
        //         APPROX_QUANTILES(tbt_value, 100)[OFFSET(8)] AS p08_tbt,
        //         APPROX_QUANTILES(tbt_value, 100)[OFFSET(25)] AS p25_tbt
        //     FROM (
        //         SELECT CAST(JSON_EXTRACT_SCALAR(report, '$.audits.total-blocking-time.numericValue') AS FLOAT64) AS tbt_value
        //         FROM `httparchive.lighthouse.2021_05_01_mobile`
        //         WHERE report is not NULL
        //     )
        // …we'd use control points of 19 and 189, which leads to surprisingly harsh scoring.
        //
        // The following coefficients are semi-arbitrarily chosen, but start to approach the "correct" ones:
        // See https://www.desmos.com/calculator/pwcgna1cvf go/lh8-tbt-curves
        scoring: {
          p10: 200,
          median: 600,
        },
      },
      desktop: {
        // Chosen in HTTP Archive desktop results to approximate curve easing described above.
        // SELECT
        //   APPROX_QUANTILES(tbtValue, 100)[OFFSET(40)] AS p40_tbt,
        //   APPROX_QUANTILES(tbtValue, 100)[OFFSET(60)] AS p60_tbt
        // FROM (
        //   SELECT CAST(JSON_EXTRACT_SCALAR(payload, '$._TotalBlockingTime') AS NUMERIC) AS tbtValue
        //   FROM `httparchive.pages.2020_04_01_desktop`
        // )
        scoring: {
          p10: 150,
          median: 350,
        },
      },
    };
  }

  /**
   * Audits the page to calculate Total Blocking Time.
   *
   * We define Blocking Time as any time interval in the loading timeline where task length exceeds
   * 50ms. For example, if there is a 110ms main thread task, the last 60ms of it is blocking time.
   * Total Blocking Time is the sum of all Blocking Time between First Contentful Paint and
   * Interactive Time (TTI).
   *
   * @param {LH.Artifacts} artifacts
   * @param {LH.Audit.Context} context
   * @return {Promise<LH.Audit.Product>}
   */
  static async audit(artifacts, context) {
    const trace = artifacts.traces[Audit.DEFAULT_PASS];
    const devtoolsLog = artifacts.devtoolsLogs[Audit.DEFAULT_PASS];
    const gatherContext = artifacts.GatherContext;
    const metricComputationData = {trace, devtoolsLog, gatherContext, settings: context.settings};
    if (
      gatherContext.gatherMode === 'timespan' &&
      context.settings.throttlingMethod === 'simulate'
    ) {
      return {score: 1, notApplicable: true};
    }

    const metricResult = await ComputedTBT.request(metricComputationData, context);

    const options = context.options[context.settings.formFactor];


    return {
      score: Audit.computeLogNormalScore(
        options.scoring,
        metricResult.timing
      ),
      numericValue: metricResult.timing,
      numericUnit: 'millisecond',
      displayValue: str_(i18n.UIStrings.ms, {timeInMs: metricResult.timing}),
    };
  }
}

module.exports = TotalBlockingTime;
module.exports.UIStrings = UIStrings;

}).call(this)}).call(this,"/lighthouse-core/audits/metrics/total-blocking-time.js")
},{"../../computed/metrics/total-blocking-time.js":37,"../../lib/i18n/i18n.js":96,"../audit.js":3}],"../audits/metrics":[function(require,module,exports){
/**
 * @license Copyright 2018 The Lighthouse Authors. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.
 */
'use strict';

const Audit = require('./audit.js');
const ComputedTimingSummary = require('../computed/metrics/timing-summary.js');

/** @type {Set<keyof LH.Artifacts.TimingSummary>} */
const DECIMAL_METRIC_KEYS = new Set([
  'cumulativeLayoutShift',
  'cumulativeLayoutShiftMainFrame',
  'totalCumulativeLayoutShift',
  'observedCumulativeLayoutShift',
  'observedCumulativeLayoutShiftMainFrame',
  'observedTotalCumulativeLayoutShift',
]);

class Metrics extends Audit {
  /**
   * @return {LH.Audit.Meta}
   */
  static get meta() {
    return {
      id: 'metrics',
      scoreDisplayMode: Audit.SCORING_MODES.INFORMATIVE,
      title: 'Metrics',
      description: 'Collects all available metrics.',
      supportedModes: ['navigation'],
      requiredArtifacts: ['traces', 'devtoolsLogs', 'GatherContext'],
    };
  }

  /**
   * @param {LH.Artifacts} artifacts
   * @param {LH.Audit.Context} context
   * @return {Promise<LH.Audit.Product>}
   */
  static async audit(artifacts, context) {
    const gatherContext = artifacts.GatherContext;
    const trace = artifacts.traces[Audit.DEFAULT_PASS];
    const devtoolsLog = artifacts.devtoolsLogs[Audit.DEFAULT_PASS];
    const summary = await ComputedTimingSummary
      .request({trace, devtoolsLog, gatherContext, settings: context.settings}, context);
    const metrics = summary.metrics;
    const debugInfo = summary.debugInfo;

    for (const [name, value] of Object.entries(metrics)) {
      const key = /** @type {keyof LH.Artifacts.TimingSummary} */ (name);
      if (typeof value === 'number' && !DECIMAL_METRIC_KEYS.has(key)) {
        metrics[key] = Math.round(value);
      }
    }

    /** @type {LH.Audit.Details.DebugData} */
    const details = {
      type: 'debugdata',
      // TODO: Consider not nesting metrics under `items`.
      items: [metrics, debugInfo],
    };

    return {
      score: 1,
      numericValue: metrics.interactive || 0,
      numericUnit: 'millisecond',
      details,
    };
  }
}

module.exports = Metrics;

},{"../computed/metrics/timing-summary.js":36,"./audit.js":3}],"../audits/network-requests":[function(require,module,exports){
/**
 * @license Copyright 2018 The Lighthouse Authors. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.
 */
'use strict';

const Audit = require('./audit.js');
const URL = require('../lib/url-shim.js');
const NetworkRecords = require('../computed/network-records.js');

class NetworkRequests extends Audit {
  /**
   * @return {LH.Audit.Meta}
   */
  static get meta() {
    return {
      id: 'network-requests',
      scoreDisplayMode: Audit.SCORING_MODES.INFORMATIVE,
      title: 'Network Requests',
      description: 'Lists the network requests that were made during page load.',
      requiredArtifacts: ['devtoolsLogs'],
    };
  }

  /**
   * @param {LH.Artifacts} artifacts
   * @param {LH.Audit.Context} context
   * @return {Promise<LH.Audit.Product>}
   */
  static audit(artifacts, context) {
    const devtoolsLog = artifacts.devtoolsLogs[Audit.DEFAULT_PASS];
    return NetworkRecords.request(devtoolsLog, context).then(records => {
      const earliestStartTime = records.reduce(
        (min, record) => Math.min(min, record.startTime),
        Infinity
      );

      /** @param {number} time */
      const timeToMs = time => time < earliestStartTime || !Number.isFinite(time) ?
        undefined : (time - earliestStartTime) * 1000;

      const results = records.map(record => {
        const endTimeDeltaMs = record.lrStatistics && record.lrStatistics.endTimeDeltaMs;
        const TCPMs = record.lrStatistics && record.lrStatistics.TCPMs;
        const requestMs = record.lrStatistics && record.lrStatistics.requestMs;
        const responseMs = record.lrStatistics && record.lrStatistics.responseMs;

        return {
          url: URL.elideDataURI(record.url),
          protocol: record.protocol,
          startTime: timeToMs(record.startTime),
          endTime: timeToMs(record.endTime),
          finished: record.finished,
          transferSize: record.transferSize,
          resourceSize: record.resourceSize,
          statusCode: record.statusCode,
          mimeType: record.mimeType,
          resourceType: record.resourceType,
          lrEndTimeDeltaMs: endTimeDeltaMs, // Only exists on Lightrider runs
          lrTCPMs: TCPMs, // Only exists on Lightrider runs
          lrRequestMs: requestMs, // Only exists on Lightrider runs
          lrResponseMs: responseMs, // Only exists on Lightrider runs
        };
      });

      // NOTE(i18n): this audit is only for debug info in the LHR and does not appear in the report.
      /** @type {LH.Audit.Details.Table['headings']} */
      const headings = [
        {key: 'url', itemType: 'url', text: 'URL'},
        {key: 'protocol', itemType: 'text', text: 'Protocol'},
        {key: 'startTime', itemType: 'ms', granularity: 1, text: 'Start Time'},
        {key: 'endTime', itemType: 'ms', granularity: 1, text: 'End Time'},
        {
          key: 'transferSize',
          itemType: 'bytes',
          displayUnit: 'kb',
          granularity: 1,
          text: 'Transfer Size',
        },
        {
          key: 'resourceSize',
          itemType: 'bytes',
          displayUnit: 'kb',
          granularity: 1,
          text: 'Resource Size',
        },
        {key: 'statusCode', itemType: 'text', text: 'Status Code'},
        {key: 'mimeType', itemType: 'text', text: 'MIME Type'},
        {key: 'resourceType', itemType: 'text', text: 'Resource Type'},
      ];

      const tableDetails = Audit.makeTableDetails(headings, results);

      return {
        score: 1,
        details: tableDetails,
      };
    });
  }
}

module.exports = NetworkRequests;

},{"../computed/network-records.js":40,"../lib/url-shim.js":"url","./audit.js":3}],"../audits/network-rtt":[function(require,module,exports){
(function (__filename){(function (){
/**
 * @license Copyright 2019 The Lighthouse Authors. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.
 */
'use strict';

const Audit = require('./audit.js');
const i18n = require('../lib/i18n/i18n.js');
const NetworkAnalysisComputed = require('../computed/network-analysis.js');

const UIStrings = {
  /** Descriptive title of a Lighthouse audit that tells the user the round trip times to each origin the page connected to. This is displayed in a list of audit titles that Lighthouse generates. */
  title: 'Network Round Trip Times',
  /** Description of a Lighthouse audit that tells the user that a high network round trip time (RTT) can effect their website's performance because the server is physically far away from them thus making the RTT high. This is displayed after a user expands the section to see more. No character length limits. 'Learn More' becomes link text to additional documentation. */
  description: 'Network round trip times (RTT) have a large impact on performance. ' +
    'If the RTT to an origin is high, it\'s an indication that servers closer to the user could ' +
    'improve performance. [Learn more](https://hpbn.co/primer-on-latency-and-bandwidth/).',
};

const str_ = i18n.createMessageInstanceIdFn(__filename, UIStrings);

class NetworkRTT extends Audit {
  /**
   * @return {LH.Audit.Meta}
   */
  static get meta() {
    return {
      id: 'network-rtt',
      scoreDisplayMode: Audit.SCORING_MODES.INFORMATIVE,
      title: str_(UIStrings.title),
      description: str_(UIStrings.description),
      requiredArtifacts: ['devtoolsLogs'],
    };
  }

  /**
   * @param {LH.Artifacts} artifacts
   * @param {LH.Audit.Context} context
   * @return {Promise<LH.Audit.Product>}
   */
  static async audit(artifacts, context) {
    const devtoolsLog = artifacts.devtoolsLogs[Audit.DEFAULT_PASS];
    const analysis = await NetworkAnalysisComputed.request(devtoolsLog, context);

    /** @type {number} */
    let maxRtt = 0;
    const baseRtt = analysis.rtt;
    /** @type {Array<{origin: string, rtt: number}>} */
    const results = [];
    for (const [origin, additionalRtt] of analysis.additionalRttByOrigin.entries()) {
      // Ignore entries that don't look like real origins, like the __SUMMARY__ entry.
      if (!origin.startsWith('http')) continue;

      const rtt = additionalRtt + baseRtt;
      results.push({origin, rtt});
      maxRtt = Number.isFinite(rtt) ? Math.max(rtt, maxRtt) : maxRtt;
    }

    results.sort((a, b) => b.rtt - a.rtt);

    /** @type {LH.Audit.Details.Table['headings']} */
    const headings = [
      {key: 'origin', itemType: 'text', text: str_(i18n.UIStrings.columnURL)},
      {key: 'rtt', itemType: 'ms', granularity: 1, text: str_(i18n.UIStrings.columnTimeSpent)},
    ];

    const tableDetails = Audit.makeTableDetails(headings, results);

    return {
      score: 1,
      numericValue: maxRtt,
      numericUnit: 'millisecond',
      displayValue: str_(i18n.UIStrings.ms, {timeInMs: maxRtt}),
      details: tableDetails,
    };
  }
}

module.exports = NetworkRTT;
module.exports.UIStrings = UIStrings;

}).call(this)}).call(this,"/lighthouse-core/audits/network-rtt.js")
},{"../computed/network-analysis.js":39,"../lib/i18n/i18n.js":96,"./audit.js":3}],"../audits/network-server-latency":[function(require,module,exports){
(function (__filename){(function (){
/**
 * @license Copyright 2019 The Lighthouse Authors. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.
 */
'use strict';

const Audit = require('./audit.js');
const i18n = require('../lib/i18n/i18n.js');
const NetworkAnalysisComputed = require('../computed/network-analysis.js');

const UIStrings = {
  /** Descriptive title of a Lighthouse audit that tells the user the server latencies observed from each origin the page connected to. This is displayed in a list of audit titles that Lighthouse generates. */
  title: 'Server Backend Latencies',
  /** Description of a Lighthouse audit that tells the user that server latency can effect their website's performance negatively. This is displayed after a user expands the section to see more. No character length limits. 'Learn More' becomes link text to additional documentation. */
  description: 'Server latencies can impact web performance. ' +
    'If the server latency of an origin is high, it\'s an indication the server is overloaded ' +
    'or has poor backend performance. [Learn more](https://hpbn.co/primer-on-web-performance/#analyzing-the-resource-waterfall).',
};

const str_ = i18n.createMessageInstanceIdFn(__filename, UIStrings);

class NetworkServerLatency extends Audit {
  /**
   * @return {LH.Audit.Meta}
   */
  static get meta() {
    return {
      id: 'network-server-latency',
      scoreDisplayMode: Audit.SCORING_MODES.INFORMATIVE,
      title: str_(UIStrings.title),
      description: str_(UIStrings.description),
      requiredArtifacts: ['devtoolsLogs'],
    };
  }

  /**
   * @param {LH.Artifacts} artifacts
   * @param {LH.Audit.Context} context
   * @return {Promise<LH.Audit.Product>}
   */
  static async audit(artifacts, context) {
    const devtoolsLog = artifacts.devtoolsLogs[Audit.DEFAULT_PASS];
    const analysis = await NetworkAnalysisComputed.request(devtoolsLog, context);

    /** @type {number} */
    let maxLatency = 0;
    /** @type {Array<{origin: string, serverResponseTime: number}>} */
    const results = [];
    for (const [origin, serverResponseTime] of analysis.serverResponseTimeByOrigin.entries()) {
      // Ignore entries that don't look like real origins, like the __SUMMARY__ entry.
      if (!origin.startsWith('http')) continue;

      maxLatency = Math.max(serverResponseTime, maxLatency);
      results.push({origin, serverResponseTime});
    }

    results.sort((a, b) => b.serverResponseTime - a.serverResponseTime);

    /** @type {LH.Audit.Details.Table['headings']} */
    const headings = [
      {key: 'origin', itemType: 'text', text: str_(i18n.UIStrings.columnURL)},
      {key: 'serverResponseTime', itemType: 'ms', granularity: 1,
        text: str_(i18n.UIStrings.columnTimeSpent)},
    ];

    const tableDetails = Audit.makeTableDetails(headings, results);

    return {
      score: Math.max(1 - (maxLatency / 500), 0),
      numericValue: maxLatency,
      numericUnit: 'millisecond',
      displayValue: str_(i18n.UIStrings.ms, {timeInMs: maxLatency}),
      details: tableDetails,
    };
  }
}

module.exports = NetworkServerLatency;
module.exports.UIStrings = UIStrings;

}).call(this)}).call(this,"/lighthouse-core/audits/network-server-latency.js")
},{"../computed/network-analysis.js":39,"../lib/i18n/i18n.js":96,"./audit.js":3}],"../audits/no-unload-listeners":[function(require,module,exports){
(function (__filename){(function (){
/**
 * @license Copyright 2020 The Lighthouse Authors. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.
 */
'use strict';

const Audit = require('./audit.js');
const i18n = require('./../lib/i18n/i18n.js');

const UIStrings = {
  /** Descriptive title of a Lighthouse audit that checks if a web page has 'unload' event listeners and finds none. */
  title: 'Avoids `unload` event listeners',
  /** Descriptive title of a Lighthouse audit that checks if a web page has 'unload' event listeners and finds that it is using them. */
  failureTitle: 'Registers an `unload` listener',
  /** Description of a Lighthouse audit that tells the user why pages should not use the 'unload' event. This is displayed after a user expands the section to see more. 'Learn More' becomes link text to additional documentation. */
  description: 'The `unload` event does not fire reliably and listening for it can prevent browser optimizations like the Back-Forward Cache. Consider using the `pagehide` or `visibilitychange` events instead. [Learn more](https://developers.google.com/web/updates/2018/07/page-lifecycle-api#the-unload-event)',
};

const str_ = i18n.createMessageInstanceIdFn(__filename, UIStrings);

class NoUnloadListeners extends Audit {
  /**
   * @return {LH.Audit.Meta}
   */
  static get meta() {
    return {
      id: 'no-unload-listeners',
      title: str_(UIStrings.title),
      failureTitle: str_(UIStrings.failureTitle),
      description: str_(UIStrings.description),
      requiredArtifacts: ['GlobalListeners', 'JsUsage'],
    };
  }

  /**
   * @param {LH.Artifacts} artifacts
   * @return {LH.Audit.Product}
   */
  static audit(artifacts) {
    const unloadListeners = artifacts.GlobalListeners.filter(l => l.type === 'unload');
    if (!unloadListeners.length) {
      return {
        score: 1,
      };
    }

    /** @type {LH.Audit.Details.Table['headings']} */
    const headings = [
      {key: 'source', itemType: 'source-location', text: str_(i18n.UIStrings.columnSource)},
    ];

    // Look up scriptId to script URL via the JsUsage artifact.
    /** @type {Map<string, string>} */
    const scriptIdToUrl = new Map();
    for (const [url, usages] of Object.entries(artifacts.JsUsage)) {
      for (const usage of usages) {
        scriptIdToUrl.set(usage.scriptId, url);
      }
    }

    /** @type {Array<{source: LH.Audit.Details.ItemValue}>} */
    const tableItems = unloadListeners.map(listener => {
      const url = scriptIdToUrl.get(listener.scriptId);

      // If we can't find a url, still show something so the user can manually
      // look for where an `unload` handler is being created.
      if (!url) {
        return {
          source: {
            type: 'url',
            value: '(unknown)',
          },
        };
      }

      return {
        source: {
          type: 'source-location',
          url,
          urlProvider: 'network',
          line: listener.lineNumber,
          column: listener.columnNumber,
        },
      };
    });

    return {
      score: 0,
      details: Audit.makeTableDetails(headings, tableItems),
    };
  }
}

module.exports = NoUnloadListeners;
module.exports.UIStrings = UIStrings;

}).call(this)}).call(this,"/lighthouse-core/audits/no-unload-listeners.js")
},{"./../lib/i18n/i18n.js":96,"./audit.js":3}],"../audits/non-composited-animations":[function(require,module,exports){
(function (__filename){(function (){
/**
 * @license Copyright 2020 The Lighthouse Authors. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.
 */
'use strict';

/**
 * @fileoverview Audit which reports all animations that failed to composite along
 * with the failure reasons. Failure reasons are only reported if they are actionable.
 * https://docs.google.com/document/d/1XKcJP2CKmNKfOcDsVvliAQ-e1H9C1nf2H-pzTdyafAA/edit?usp=sharing
 */

const Audit = require('./audit.js');
const i18n = require('../lib/i18n/i18n.js');

const UIStrings = {
  /** Title of a diagnostic LH audit that provides details on animations that are not composited. */
  title: 'Avoid non-composited animations',
  /** Description of a diagnostic LH audit that shows the user animations that are not composited. Janky means frames may be skipped and the animation will look bad. Acceptable alternatives here might be 'poor', or 'slow'. */
  description: 'Animations which are not composited can be janky and increase CLS. ' +
    '[Learn more](https://web.dev/non-composited-animations)',
  /** [ICU Syntax] Label identifying the number of animated elements that are not composited. */
  displayValue: `{itemCount, plural,
  =1 {# animated element found}
  other {# animated elements found}
  }`,
  /**
   * @description [ICU Syntax] Descriptive reason for why a user-provided animation failed to be optimized by the browser due to the animated CSS property not being supported on the compositor. Shown in a table with a list of other potential failure reasons.
   * @example {height, width} properties
   */
  unsupportedCSSProperty: `{propertyCount, plural,
    =1 {Unsupported CSS Property: {properties}}
    other {Unsupported CSS Properties: {properties}}
  }`,
  /** Descriptive reason for why a user-provided animation failed to be optimized by the browser due to a `transform` property being dependent on the size of the element itself. Shown in a table with a list of other potential failure reasons.  */
  transformDependsBoxSize: 'Transform-related property depends on box size',
  /** Descriptive reason for why a user-provided animation failed to be optimized by the browser due to a `filter` property possibly moving pixels. Shown in a table with a list of other potential failure reasons.  */
  filterMayMovePixels: 'Filter-related property may move pixels',
  /** Descriptive reason for why a user-provided animation failed to be optimized by the browser due to an effect having a composite mode which is not `replace`. Shown in a table with a list of other potential failure reasons.  */
  nonReplaceCompositeMode: 'Effect has composite mode other than "replace"',
  /** Descriptive reason for why a user-provided animation failed to be optimized by the browser due to another animation on the same target being incompatible. Shown in a table with a list of other potential failure reasons.  */
  incompatibleAnimations: 'Target has another animation which is incompatible',
  /** Descriptive reason for why a user-provided animation failed to be optimized by the browser due to an effect having unsupported timing parameters. Shown in a table with a list of other potential failure reasons.  */
  unsupportedTimingParameters: 'Effect has unsupported timing parameters',
};

const str_ = i18n.createMessageInstanceIdFn(__filename, UIStrings);

/**
 * Each failure reason is represented by a bit flag. The bit shift operator '<<' is used to define which bit corresponds to each failure reason.
 * https://source.chromium.org/search?q=f:compositor_animations.h%20%22enum%20FailureReason%22
 * @type {{flag: number, text: string}[]}
 */
const ACTIONABLE_FAILURE_REASONS = [
  {
    flag: 1 << 13,
    text: UIStrings.unsupportedCSSProperty,
  },
  {
    flag: 1 << 11,
    text: UIStrings.transformDependsBoxSize,
  },
  {
    flag: 1 << 12,
    text: UIStrings.filterMayMovePixels,
  },
  {
    flag: 1 << 4,
    text: UIStrings.nonReplaceCompositeMode,
  },
  {
    flag: 1 << 6,
    text: UIStrings.incompatibleAnimations,
  },
  {
    flag: 1 << 3,
    text: UIStrings.unsupportedTimingParameters,
  },
];

/**
 * Return list of actionable failure reasons and a boolean if some reasons are not actionable.
 * Each flag is a number with a single bit set to 1 in the position corresponding to a failure reason.
 * We can check if a specific bit is true in the failure coding using bitwise and '&' with the flag.
 * @param {number} failureCode
 * @param {string[]} unsupportedProperties
 * @return {LH.IcuMessage[]}
 */
function getActionableFailureReasons(failureCode, unsupportedProperties) {
  return ACTIONABLE_FAILURE_REASONS
    .filter(reason => failureCode & reason.flag)
    .map(reason => {
      if (reason.text === UIStrings.unsupportedCSSProperty) {
        return str_(reason.text, {
          propertyCount: unsupportedProperties.length,
          properties: unsupportedProperties.join(', '),
        });
      }
      return str_(reason.text);
    });
}

class NonCompositedAnimations extends Audit {
  /**
   * @return {LH.Audit.Meta}
   */
  static get meta() {
    return {
      id: 'non-composited-animations',
      scoreDisplayMode: Audit.SCORING_MODES.INFORMATIVE,
      title: str_(UIStrings.title),
      description: str_(UIStrings.description),
      requiredArtifacts: ['TraceElements', 'HostUserAgent'],
    };
  }

  /**
   * @param {LH.Artifacts} artifacts
   * @return {Promise<LH.Audit.Product>}
   */
  static async audit(artifacts) {
    // COMPAT: This audit requires m86
    const match = artifacts.HostUserAgent.match(/Chrome\/(\d+)/);
    if (!match || Number(match[1]) < 86) {
      return {
        score: 1,
        notApplicable: true,
      };
    }

    /** @type {LH.Audit.Details.TableItem[]} */
    const results = [];
    let shouldAddAnimationNameColumn = false;
    artifacts.TraceElements.forEach(element => {
      if (element.traceEventType !== 'animation') return;

      const animations = element.animations || [];
      const animationReasons = new Map();
      for (const {name, failureReasonsMask, unsupportedProperties} of animations) {
        if (!failureReasonsMask) continue;
        const failureReasons =
          getActionableFailureReasons(failureReasonsMask, unsupportedProperties || []);
        for (const failureReason of failureReasons) {
          if (name) {
            shouldAddAnimationNameColumn = true;
          }
          const reasons = animationReasons.get(name) || new Set();
          reasons.add(failureReason);
          animationReasons.set(name, reasons);
        }
      }
      if (!animationReasons.size) return;

      const allFailureReasons = [];
      for (const [name, reasons] of animationReasons) {
        for (const failureReason of reasons) {
          allFailureReasons.push({
            failureReason,
            animation: name,
          });
        }
      }

      results.push({
        node: Audit.makeNodeItem(element.node),
        subItems: {
          type: 'subitems',
          items: allFailureReasons,
        },
      });
    });

    /** @type {LH.Audit.Details.Table['headings']} */
    const headings = [
      /* eslint-disable max-len */
      {key: 'node', itemType: 'node', subItemsHeading: {key: 'failureReason', itemType: 'text'}, text: str_(i18n.UIStrings.columnElement)},
      /* eslint-enable max-len */
    ];

    if (shouldAddAnimationNameColumn) {
      headings.push(
        /* eslint-disable max-len */
        {key: null, itemType: 'text', subItemsHeading: {key: 'animation', itemType: 'text'}, text: str_(i18n.UIStrings.columnName)}
        /* eslint-enable max-len */
      );
    }

    const details = Audit.makeTableDetails(headings, results);

    let displayValue;
    if (results.length > 0) {
      displayValue = str_(UIStrings.displayValue, {itemCount: results.length});
    }

    return {
      score: results.length === 0 ? 1 : 0,
      notApplicable: results.length === 0,
      details,
      displayValue,
    };
  }
}

module.exports = NonCompositedAnimations;
module.exports.UIStrings = UIStrings;

}).call(this)}).call(this,"/lighthouse-core/audits/non-composited-animations.js")
},{"../lib/i18n/i18n.js":96,"./audit.js":3}],"../audits/performance-budget":[function(require,module,exports){
(function (__filename){(function (){
/**
 * @license Copyright 2019 The Lighthouse Authors. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.
 */
'use strict';

const Audit = require('./audit.js');
const ResourceSummary = require('../computed/resource-summary.js');
const MainResource = require('../computed/main-resource.js');
const Budget = require('../config/budget.js');
const i18n = require('../lib/i18n/i18n.js');

const UIStrings = {
  /** Title of a Lighthouse audit that compares the size and quantity of page resources against targets set by the user. These targets are thought of as "performance budgets" because these metrics impact page performance (i.e. how quickly a page loads). */
  title: 'Performance budget',
  /** Description of a Lighthouse audit where a user sets budgets for the quantity and size of page resources. No character length limits. 'Learn More' becomes link text to additional documentation. */
  description: 'Keep the quantity and size of network requests under the targets ' +
    'set by the provided performance budget. [Learn more](https://developers.google.com/web/tools/lighthouse/audits/budgets).',
  /** [ICU Syntax] Entry in a data table identifying the number of network requests of a particular type. Count will be a whole number. String should be as short as possible to be able to fit well into the table. */
  requestCountOverBudget: `{count, plural,
    =1 {1 request}
    other {# requests}
   }`,
};

const str_ = i18n.createMessageInstanceIdFn(__filename, UIStrings);

/** @typedef {import('../computed/resource-summary.js').ResourceEntry} ResourceEntry */
/** @typedef {{resourceType: LH.Budget.ResourceType, label: LH.IcuMessage, requestCount: number, transferSize: number, sizeOverBudget: number | undefined, countOverBudget: LH.IcuMessage | undefined}} BudgetItem */

class ResourceBudget extends Audit {
  /**
   * @return {LH.Audit.Meta}
   */
  static get meta() {
    return {
      id: 'performance-budget',
      title: str_(UIStrings.title),
      description: str_(UIStrings.description),
      scoreDisplayMode: Audit.SCORING_MODES.INFORMATIVE,
      supportedModes: ['navigation'],
      requiredArtifacts: ['devtoolsLogs', 'URL'],
    };
  }

  /**
   * @param {LH.Budget.ResourceType} resourceType
   * @return {string}
   */
  static getRowLabel(resourceType) {
    /** @type {Record<LH.Budget.ResourceType,string>} */
    const strMappings = {
      'total': i18n.UIStrings.totalResourceType,
      'document': i18n.UIStrings.documentResourceType,
      'script': i18n.UIStrings.scriptResourceType,
      'stylesheet': i18n.UIStrings.stylesheetResourceType,
      'image': i18n.UIStrings.imageResourceType,
      'media': i18n.UIStrings.mediaResourceType,
      'font': i18n.UIStrings.fontResourceType,
      'other': i18n.UIStrings.otherResourceType,
      'third-party': i18n.UIStrings.thirdPartyResourceType,
    };
    return strMappings[resourceType];
  }

  /**
   * @param {Immutable<LH.Budget>} budget
   * @param {Record<LH.Budget.ResourceType, ResourceEntry>} summary
   * @return {Array<BudgetItem>}
   */
  static tableItems(budget, summary) {
    const resourceTypes = /** @type {Array<LH.Budget.ResourceType>} */ (Object.keys(summary));
    return resourceTypes.map((resourceType) => {
      const label = str_(this.getRowLabel(resourceType));
      const requestCount = summary[resourceType].count;
      const transferSize = summary[resourceType].transferSize;

      let sizeOverBudget;
      let countOverBudget;

      if (budget.resourceSizes) {
        const sizeBudget = budget.resourceSizes.find(b => b.resourceType === resourceType);
        if (sizeBudget && (transferSize > (sizeBudget.budget * 1024))) {
          sizeOverBudget = transferSize - (sizeBudget.budget * 1024);
        }
      }
      if (budget.resourceCounts) {
        const countBudget = budget.resourceCounts.find(b => b.resourceType === resourceType);
        if (countBudget && (requestCount > countBudget.budget)) {
          const requestDifference = requestCount - countBudget.budget;
          countOverBudget = str_(UIStrings.requestCountOverBudget, {count: requestDifference});
        }
      }
      return {
        resourceType,
        label,
        requestCount,
        transferSize,
        countOverBudget,
        sizeOverBudget,
      };
    }).filter((row) => {
      // Only resources with budgets should be included in the table
      if (budget.resourceSizes) {
        if (budget.resourceSizes.some(b => b.resourceType === row.resourceType)) return true;
      }
      if (budget.resourceCounts) {
        if (budget.resourceCounts.some(b => b.resourceType === row.resourceType)) return true;
      }
      return false;
    }).sort((a, b) => {
      return (b.sizeOverBudget || 0) - (a.sizeOverBudget || 0);
    });
  }

  /**
   * @param {LH.Artifacts} artifacts
   * @param {LH.Audit.Context} context
   * @return {Promise<LH.Audit.Product>}
   */
  static async audit(artifacts, context) {
    const devtoolsLog = artifacts.devtoolsLogs[Audit.DEFAULT_PASS];
    const data = {devtoolsLog, URL: artifacts.URL, budgets: context.settings.budgets};
    const summary = await ResourceSummary.request(data, context);
    const mainResource = await MainResource.request({URL: artifacts.URL, devtoolsLog}, context);
    const budget = Budget.getMatchingBudget(context.settings.budgets, mainResource.url);

    if (!budget) {
      return {
        score: 0,
        notApplicable: true,
      };
    }

    /** @type {LH.Audit.Details.Table['headings']} */
    const headers = [
      {key: 'label', itemType: 'text', text: str_(i18n.UIStrings.columnResourceType)},
      {key: 'requestCount', itemType: 'numeric', text: str_(i18n.UIStrings.columnRequests)},
      {key: 'transferSize', itemType: 'bytes', text: str_(i18n.UIStrings.columnTransferSize)},
      {key: 'countOverBudget', itemType: 'text', text: ''},
      {key: 'sizeOverBudget', itemType: 'bytes', text: str_(i18n.UIStrings.columnOverBudget)},
    ];

    return {
      details: Audit.makeTableDetails(headers,
        this.tableItems(budget, summary)),
      score: 1,
    };
  }
}

module.exports = ResourceBudget;
module.exports.UIStrings = UIStrings;

}).call(this)}).call(this,"/lighthouse-core/audits/performance-budget.js")
},{"../computed/main-resource.js":14,"../computed/resource-summary.js":44,"../config/budget.js":52,"../lib/i18n/i18n.js":96,"./audit.js":3}],"../audits/predictive-perf":[function(require,module,exports){
(function (__filename){(function (){
/**
 * @license Copyright 2017 The Lighthouse Authors. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.
 */
'use strict';

const Audit = require('./audit.js');
const i18n = require('../lib/i18n/i18n.js');

const LanternFcp = require('../computed/metrics/lantern-first-contentful-paint.js');
const LanternFmp = require('../computed/metrics/lantern-first-meaningful-paint.js');
const LanternInteractive = require('../computed/metrics/lantern-interactive.js');
const LanternSpeedIndex = require('../computed/metrics/lantern-speed-index.js');
const LanternLcp = require('../computed/metrics/lantern-largest-contentful-paint.js');

// Parameters (in ms) for log-normal CDF scoring. To see the curve:
//   https://www.desmos.com/calculator/bksgkihhj8
const SCORING_P10 = 3651;
const SCORING_MEDIAN = 10000;

const str_ = i18n.createMessageInstanceIdFn(__filename, {});

class PredictivePerf extends Audit {
  /**
   * @return {LH.Audit.Meta}
   */
  static get meta() {
    return {
      id: 'predictive-perf',
      title: 'Predicted Performance (beta)',
      description:
        'Predicted performance evaluates how your site will perform under ' +
        'a cellular connection on a mobile device.',
      scoreDisplayMode: Audit.SCORING_MODES.NUMERIC,
      supportedModes: ['navigation'],
      requiredArtifacts: ['traces', 'devtoolsLogs', 'GatherContext'],
    };
  }

  /**
   * @param {LH.Artifacts} artifacts
   * @param {LH.Audit.Context} context
   * @return {Promise<LH.Audit.Product>}
   */
  static async audit(artifacts, context) {
    const gatherContext = artifacts.GatherContext;
    const trace = artifacts.traces[Audit.DEFAULT_PASS];
    const devtoolsLog = artifacts.devtoolsLogs[Audit.DEFAULT_PASS];
    /** @type {LH.Config.Settings} */
    // @ts-expect-error - TODO(bckenny): allow optional `throttling` settings
    const settings = {}; // Use default settings.
    const computationData = {trace, devtoolsLog, gatherContext, settings};
    const fcp = await LanternFcp.request(computationData, context);
    const fmp = await LanternFmp.request(computationData, context);
    const tti = await LanternInteractive.request(computationData, context);
    const si = await LanternSpeedIndex.request(computationData, context);
    const lcp = await LanternLcp.request(computationData, context);

    const values = {
      roughEstimateOfFCP: fcp.timing,
      optimisticFCP: fcp.optimisticEstimate.timeInMs,
      pessimisticFCP: fcp.pessimisticEstimate.timeInMs,

      roughEstimateOfFMP: fmp.timing,
      optimisticFMP: fmp.optimisticEstimate.timeInMs,
      pessimisticFMP: fmp.pessimisticEstimate.timeInMs,

      roughEstimateOfTTI: tti.timing,
      optimisticTTI: tti.optimisticEstimate.timeInMs,
      pessimisticTTI: tti.pessimisticEstimate.timeInMs,

      roughEstimateOfSI: si.timing,
      optimisticSI: si.optimisticEstimate.timeInMs,
      pessimisticSI: si.pessimisticEstimate.timeInMs,

      roughEstimateOfLCP: lcp.timing,
      optimisticLCP: lcp.optimisticEstimate.timeInMs,
      pessimisticLCP: lcp.pessimisticEstimate.timeInMs,
    };

    const score = Audit.computeLogNormalScore(
      {p10: SCORING_P10, median: SCORING_MEDIAN},
      values.roughEstimateOfTTI
    );

    return {
      score,
      numericValue: values.roughEstimateOfTTI,
      numericUnit: 'millisecond',
      displayValue: str_(i18n.UIStrings.ms, {timeInMs: values.roughEstimateOfTTI}),
      details: {
        type: 'debugdata',
        // TODO: Consider not nesting values under `items`.
        items: [values],
      },
    };
  }
}

module.exports = PredictivePerf;

}).call(this)}).call(this,"/lighthouse-core/audits/predictive-perf.js")
},{"../computed/metrics/lantern-first-contentful-paint.js":22,"../computed/metrics/lantern-first-meaningful-paint.js":23,"../computed/metrics/lantern-interactive.js":24,"../computed/metrics/lantern-largest-contentful-paint.js":25,"../computed/metrics/lantern-speed-index.js":28,"../lib/i18n/i18n.js":96,"./audit.js":3}],"../audits/preload-fonts":[function(require,module,exports){
(function (__filename){(function (){
/**
 * @license Copyright 2020 The Lighthouse Authors. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.
 */
'use strict';

/**
 * @fileoverview
 * Audit that checks whether fonts that use `font-display: optional` were preloaded.
 */

const Audit = require('./audit.js');
const i18n = require('./../lib/i18n/i18n.js');
const FontDisplay = require('./../audits/font-display.js');
const PASSING_FONT_DISPLAY_REGEX = /^(optional)$/;
const NetworkRecords = require('../computed/network-records.js');

const UIStrings = {
  /** Title of a Lighthouse audit that provides detail on whether fonts that used `font-display: optional` were preloaded. This descriptive title is shown to users when all fonts that used `font-display: optional` were preloaded. */
  title: 'Fonts with `font-display: optional` are preloaded',
  /** Title of a Lighthouse audit that provides detail on whether fonts that used `font-display: optional` were preloaded. This descriptive title is shown to users when one or more fonts used `font-display: optional` and were not preloaded. */
  failureTitle: 'Fonts with `font-display: optional` are not preloaded',
  /** Description of a Lighthouse audit that tells the user why they should preload fonts if they are using `font-display: optional`. This is displayed after a user expands the section to see more. No character length limits. 'Learn More' becomes link text to additional documentation. */
  description: 'Preload `optional` fonts so first-time visitors may use them. [Learn more](https://web.dev/preload-optional-fonts/)',
};

const str_ = i18n.createMessageInstanceIdFn(__filename, UIStrings);

class PreloadFontsAudit extends Audit {
  /**
   * @return {LH.Audit.Meta}
   */
  static get meta() {
    return {
      id: 'preload-fonts',
      title: str_(UIStrings.title),
      failureTitle: str_(UIStrings.failureTitle),
      description: str_(UIStrings.description),
      requiredArtifacts: ['devtoolsLogs', 'URL', 'CSSUsage'],
    };
  }

  /**
   * Finds which font URLs were attempted to be preloaded,
   * ignoring those that failed to be reused and were requested again.
   * Note: document.fonts.load() is a valid way to preload fonts,
   * but we are not currently checking for that.
   * @param {Array<LH.Artifacts.NetworkRequest>} networkRecords
   * @return {Set<string>}
   */
  static getURLsAttemptedToPreload(networkRecords) {
    const attemptedURLs = networkRecords
      .filter(req => req.resourceType === 'Font')
      .filter(req => req.isLinkPreload)
      .map(req => req.url);

    return new Set(attemptedURLs);
  }

  /**
   * @param {LH.Artifacts} artifacts
   * @param {LH.Audit.Context} context
   * @return {Promise<LH.Audit.Product>}
   */
  static async audit_(artifacts, context) {
    const devtoolsLog = artifacts.devtoolsLogs[this.DEFAULT_PASS];
    const networkRecords = await NetworkRecords.request(devtoolsLog, context);

    // Gets the URLs of fonts where font-display: optional.
    const optionalFontURLs =
      FontDisplay.findFontDisplayDeclarations(artifacts, PASSING_FONT_DISPLAY_REGEX).passingURLs;

    // Gets the URLs of fonts attempted to be preloaded.
    const preloadedFontURLs =
      PreloadFontsAudit.getURLsAttemptedToPreload(networkRecords);

    const results = Array.from(optionalFontURLs)
      .filter(url => !preloadedFontURLs.has(url))
      .map(url => {
        return {url};
      });

    /** @type {LH.Audit.Details.Table['headings']} */
    const headings = [
      {key: 'url', itemType: 'url', text: str_(i18n.UIStrings.columnURL)},
    ];

    return {
      score: results.length > 0 ? 0 : 1,
      details: Audit.makeTableDetails(headings, results),
      notApplicable: optionalFontURLs.size === 0,
    };
  }

  /**
   * @return {Promise<LH.Audit.Product>}
   */
  static async audit() {
    // Preload advice is dangerous until https://bugs.chromium.org/p/chromium/issues/detail?id=788757
    // has been fixed and validated. All preload audits are on hold until then.
    // See https://github.com/GoogleChrome/lighthouse/issues/11960 for more discussion.
    return {score: 1, notApplicable: true};
  }
}

module.exports = PreloadFontsAudit;
module.exports.UIStrings = UIStrings;

}).call(this)}).call(this,"/lighthouse-core/audits/preload-fonts.js")
},{"../computed/network-records.js":40,"./../audits/font-display.js":"../audits/font-display","./../lib/i18n/i18n.js":96,"./audit.js":3}],"../audits/preload-lcp-image":[function(require,module,exports){
(function (__filename){(function (){
/**
 * @license Copyright 2020 The Lighthouse Authors. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.
 */
'use strict';

const Audit = require('./audit.js');
const i18n = require('../lib/i18n/i18n.js');
const NetworkRequest = require('../lib/network-request.js');
const MainResource = require('../computed/main-resource.js');
const LanternLCP = require('../computed/metrics/lantern-largest-contentful-paint.js');
const LoadSimulator = require('../computed/load-simulator.js');
const UnusedBytes = require('./byte-efficiency/byte-efficiency-audit.js');

const UIStrings = {
  /** Title of a lighthouse audit that tells a user to preload an image in order to improve their LCP time. */
  title: 'Preload Largest Contentful Paint image',
  /** Description of a lighthouse audit that tells a user to preload an image in order to improve their LCP time.  */
  description: 'Preload the image used by ' +
    'the LCP element in order to improve your LCP time. [Learn more](https://web.dev/optimize-lcp/#preload-important-resources).',
};

const str_ = i18n.createMessageInstanceIdFn(__filename, UIStrings);

class PreloadLCPImageAudit extends Audit {
  /**
   * @return {LH.Audit.Meta}
   */
  static get meta() {
    return {
      id: 'preload-lcp-image',
      title: str_(UIStrings.title),
      description: str_(UIStrings.description),
      supportedModes: ['navigation'],
      requiredArtifacts: ['traces', 'devtoolsLogs', 'GatherContext', 'URL', 'TraceElements',
        'ImageElements'],
      scoreDisplayMode: Audit.SCORING_MODES.NUMERIC,
    };
  }

  /**
   *
   * @param {LH.Artifacts.NetworkRequest} request
   * @param {LH.Artifacts.NetworkRequest} mainResource
   * @param {Array<LH.Gatherer.Simulation.GraphNode>} initiatorPath
   * @return {boolean}
   */
  static shouldPreloadRequest(request, mainResource, initiatorPath) {
    const mainResourceDepth = mainResource.redirects ? mainResource.redirects.length : 0;

    // If it's already preloaded, no need to recommend it.
    if (request.isLinkPreload) return false;
    // It's not a request loaded over the network, don't recommend it.
    if (NetworkRequest.isNonNetworkRequest(request)) return false;
    // It's already discoverable from the main document, don't recommend it.
    if (initiatorPath.length <= mainResourceDepth) return false;
    // Finally, return whether or not it belongs to the main frame
    return request.frameId === mainResource.frameId;
  }

  /**
   * @param {LH.Gatherer.Simulation.GraphNode} graph
   * @param {string} imageUrl
   * @return {{lcpNode: LH.Gatherer.Simulation.GraphNetworkNode|undefined, path: Array<LH.Gatherer.Simulation.GraphNetworkNode>|undefined}}
   */
  static findLCPNode(graph, imageUrl) {
    let lcpNode;
    let path;
    graph.traverse((node, traversalPath) => {
      if (node.type !== 'network') return;
      if (node.record.url === imageUrl) {
        lcpNode = node;
        path =
          traversalPath.slice(1).filter(initiator => initiator.type === 'network');
      }
    });
    return {
      lcpNode,
      path,
    };
  }

  /**
   * @param {LH.Artifacts.NetworkRequest} mainResource
   * @param {LH.Gatherer.Simulation.GraphNode} graph
   * @param {LH.Artifacts.TraceElement|undefined} lcpElement
   * @param {Array<LH.Artifacts.ImageElement>} imageElements
   * @return {LH.Gatherer.Simulation.GraphNetworkNode|undefined}
   */
  static getLCPNodeToPreload(mainResource, graph, lcpElement, imageElements) {
    if (!lcpElement) return undefined;

    const lcpImageElement = imageElements.find(elem => {
      return elem.node.devtoolsNodePath === lcpElement.node.devtoolsNodePath;
    });

    if (!lcpImageElement) return undefined;
    const lcpUrl = lcpImageElement.src;
    const {lcpNode, path} = PreloadLCPImageAudit.findLCPNode(graph, lcpUrl);
    if (!lcpNode || !path) return undefined;
    // eslint-disable-next-line max-len
    const shouldPreload = PreloadLCPImageAudit.shouldPreloadRequest(lcpNode.record, mainResource, path);
    return shouldPreload ? lcpNode : undefined;
  }

  /**
   * Computes the estimated effect of preloading the LCP image.
   * @param {LH.Gatherer.Simulation.GraphNetworkNode|undefined} lcpNode
   * @param {LH.Gatherer.Simulation.GraphNode} graph
   * @param {LH.Gatherer.Simulation.Simulator} simulator
   * @return {{wastedMs: number, results: Array<{url: string, wastedMs: number}>}}
   */
  static computeWasteWithGraph(lcpNode, graph, simulator) {
    if (!lcpNode) {
      return {
        wastedMs: 0,
        results: [],
      };
    }

    const modifiedGraph = graph.cloneWithRelationships();

    // Store the IDs of the LCP Node's dependencies for later
    /** @type {Set<string>} */
    const dependenciesIds = new Set();
    for (const node of lcpNode.getDependencies()) {
      dependenciesIds.add(node.id);
    }

    /** @type {LH.Gatherer.Simulation.GraphNode|null} */
    let modifiedLCPNode = null;
    /** @type {LH.Gatherer.Simulation.GraphNode|null} */
    let mainDocumentNode = null;

    for (const {node} of modifiedGraph.traverseGenerator()) {
      if (node.type !== 'network') continue;

      if (node.isMainDocument()) {
        mainDocumentNode = node;
      } else if (node.id === lcpNode.id) {
        modifiedLCPNode = node;
      }
    }

    if (!mainDocumentNode) {
      // Should always find the main document node
      throw new Error('Could not find main document node');
    }

    if (!modifiedLCPNode) {
      // Should always find the LCP node as well or else this function wouldn't have been called
      throw new Error('Could not find the LCP node');
    }

    // Preload will request the resource as soon as its discovered in the main document.
    // Reflect this change in the dependencies in our modified graph.
    modifiedLCPNode.removeAllDependencies();
    modifiedLCPNode.addDependency(mainDocumentNode);

    const simulationBeforeChanges = simulator.simulate(graph, {flexibleOrdering: true});
    const simulationAfterChanges = simulator.simulate(modifiedGraph, {flexibleOrdering: true});
    const lcpTimingsBefore = simulationBeforeChanges.nodeTimings.get(lcpNode);
    if (!lcpTimingsBefore) throw new Error('Impossible - node timings should never be undefined');
    const lcpTimingsAfter = simulationAfterChanges.nodeTimings.get(modifiedLCPNode);
    if (!lcpTimingsAfter) throw new Error('Impossible - node timings should never be undefined');
    /** @type {Map<String, LH.Gatherer.Simulation.GraphNode>} */
    const modifiedNodesById = Array.from(simulationAfterChanges.nodeTimings.keys())
      .reduce((map, node) => map.set(node.id, node), new Map());

    // Even with preload, the image can't be painted before it's even inserted into the DOM.
    // New LCP time will be the max of image download and image in DOM (endTime of its deps).
    let maxDependencyEndTime = 0;
    for (const nodeId of Array.from(dependenciesIds)) {
      const node = modifiedNodesById.get(nodeId);
      if (!node) throw new Error('Impossible - node should never be undefined');
      const timings = simulationAfterChanges.nodeTimings.get(node);
      const endTime = timings && timings.endTime || 0;
      maxDependencyEndTime = Math.max(maxDependencyEndTime, endTime);
    }

    const wastedMs = lcpTimingsBefore.endTime -
      Math.max(lcpTimingsAfter.endTime, maxDependencyEndTime);

    return {
      wastedMs,
      results: [{
        url: lcpNode.record.url,
        wastedMs,
      }],
    };
  }

  /**
   * @param {LH.Artifacts} artifacts
   * @param {LH.Audit.Context} context
   * @return {Promise<LH.Audit.Product>}
   */
  static async audit_(artifacts, context) {
    const gatherContext = artifacts.GatherContext;
    const trace = artifacts.traces[PreloadLCPImageAudit.DEFAULT_PASS];
    const devtoolsLog = artifacts.devtoolsLogs[PreloadLCPImageAudit.DEFAULT_PASS];
    const URL = artifacts.URL;
    const metricData = {trace, devtoolsLog, gatherContext, settings: context.settings};
    const lcpElement = artifacts.TraceElements
      .find(element => element.traceEventType === 'largest-contentful-paint');

    const [mainResource, lanternLCP, simulator] = await Promise.all([
      MainResource.request({devtoolsLog, URL}, context),
      LanternLCP.request(metricData, context),
      LoadSimulator.request({devtoolsLog, settings: context.settings}, context),
    ]);

    const graph = lanternLCP.pessimisticGraph;
    // eslint-disable-next-line max-len
    const lcpNode = PreloadLCPImageAudit.getLCPNodeToPreload(mainResource, graph, lcpElement, artifacts.ImageElements);

    const {results, wastedMs} =
      PreloadLCPImageAudit.computeWasteWithGraph(lcpNode, graph, simulator);

    /** @type {LH.Audit.Details.Opportunity['headings']} */
    const headings = [
      {key: 'url', valueType: 'thumbnail', label: ''},
      {key: 'url', valueType: 'url', label: str_(i18n.UIStrings.columnURL)},
      {key: 'wastedMs', valueType: 'timespanMs', label: str_(i18n.UIStrings.columnWastedMs)},
    ];
    const details = Audit.makeOpportunityDetails(headings, results, wastedMs);

    return {
      score: UnusedBytes.scoreForWastedMs(wastedMs),
      numericValue: wastedMs,
      numericUnit: 'millisecond',
      displayValue: wastedMs ? str_(i18n.UIStrings.displayValueMsSavings, {wastedMs}) : '',
      details,
    };
  }

  /**
   * @return {Promise<LH.Audit.Product>}
   */
  static async audit() {
    // Preload advice is dangerous until https://bugs.chromium.org/p/chromium/issues/detail?id=788757
    // has been fixed and validated. All preload audits are on hold until then.
    // See https://github.com/GoogleChrome/lighthouse/issues/11960 for more discussion.
    return {score: 1, notApplicable: true, details: Audit.makeOpportunityDetails([], [], 0)};
  }
}

module.exports = PreloadLCPImageAudit;
module.exports.UIStrings = UIStrings;

}).call(this)}).call(this,"/lighthouse-core/audits/preload-lcp-image.js")
},{"../computed/load-simulator.js":13,"../computed/main-resource.js":14,"../computed/metrics/lantern-largest-contentful-paint.js":25,"../lib/i18n/i18n.js":96,"../lib/network-request.js":109,"./audit.js":3,"./byte-efficiency/byte-efficiency-audit.js":4}],"../audits/redirects-http":[function(require,module,exports){
(function (__filename){(function (){
/**
 * @license Copyright 2016 The Lighthouse Authors. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.
 */
'use strict';

const Audit = require('./audit.js');
const i18n = require('../lib/i18n/i18n.js');
const URL = require('../lib/url-shim.js');

const UIStrings = {
  /** Title of a Lighthouse audit that provides detail on HTTP to HTTPS redirects. This descriptive title is shown to users when HTTP traffic is redirected to HTTPS. */
  title: 'Redirects HTTP traffic to HTTPS',
  /** Title of a Lighthouse audit that provides detail on HTTP to HTTPS redirects. This descriptive title is shown to users when HTTP traffic is not redirected to HTTPS. */
  failureTitle: 'Does not redirect HTTP traffic to HTTPS',
  /** Description of a Lighthouse audit that tells the user why they should direct HTTP traffic to HTTPS. This is displayed after a user expands the section to see more. No character length limits. 'Learn More' becomes link text to additional documentation. */
  description: 'If you\'ve already set up HTTPS, make sure that you redirect all HTTP ' +
    'traffic to HTTPS in order to enable secure web features for all your users. [Learn more](https://web.dev/redirects-http/).',
};

const str_ = i18n.createMessageInstanceIdFn(__filename, UIStrings);

class RedirectsHTTP extends Audit {
  /**
   * @return {LH.Audit.Meta}
   */
  static get meta() {
    return {
      id: 'redirects-http',
      title: str_(UIStrings.title),
      failureTitle: str_(UIStrings.failureTitle),
      description: str_(UIStrings.description),
      requiredArtifacts: ['HTTPRedirect', 'URL'],
    };
  }

  /**
   * @param {LH.Artifacts} artifacts
   * @return {LH.Audit.Product}
   */
  static audit(artifacts) {
    // Redirecting HTTP to HTTPS makes no sense on localhost
    const url = new URL(artifacts.URL.finalUrl);
    if (URL.isLikeLocalhost(url.hostname)) {
      return {
        score: 1,
        notApplicable: true,
      };
    }

    return {
      score: Number(artifacts.HTTPRedirect.value),
    };
  }
}

module.exports = RedirectsHTTP;
module.exports.UIStrings = UIStrings;

}).call(this)}).call(this,"/lighthouse-core/audits/redirects-http.js")
},{"../lib/i18n/i18n.js":96,"../lib/url-shim.js":"url","./audit.js":3}],"../audits/redirects":[function(require,module,exports){
(function (__filename){(function (){
/**
 * @license Copyright 2017 The Lighthouse Authors. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.
 */
'use strict';

const Audit = require('./audit.js');
const UnusedBytes = require('./byte-efficiency/byte-efficiency-audit.js');
const i18n = require('../lib/i18n/i18n.js');
const ProcessedTrace = require('../computed/processed-trace.js');
const NetworkRecords = require('../computed/network-records.js');
const MainResource = require('../computed/main-resource.js');
const LanternInteractive = require('../computed/metrics/lantern-interactive.js');

const UIStrings = {
  /** Imperative title of a Lighthouse audit that tells the user to eliminate the redirects taken through multiple URLs to load the page. This is shown in a list of audits that Lighthouse generates. */
  title: 'Avoid multiple page redirects',
  /** Description of a Lighthouse audit that tells users why they should reduce the number of server-side redirects on their page. This is displayed after a user expands the section to see more. No character length limits. 'Learn More' becomes link text to additional documentation. */
  description: 'Redirects introduce additional delays before the page can be loaded. [Learn more](https://web.dev/redirects/).',
};

const str_ = i18n.createMessageInstanceIdFn(__filename, UIStrings);

class Redirects extends Audit {
  /**
   * @return {LH.Audit.Meta}
   */
  static get meta() {
    return {
      id: 'redirects',
      title: str_(UIStrings.title),
      description: str_(UIStrings.description),
      scoreDisplayMode: Audit.SCORING_MODES.NUMERIC,
      supportedModes: ['navigation'],
      requiredArtifacts: ['URL', 'GatherContext', 'devtoolsLogs', 'traces'],
    };
  }

  /**
   * This method generates the document request chain including client-side and server-side redirects.
   *
   * Example:
   *    GET /initialUrl => 302 /firstRedirect
   *    GET /firstRedirect => 200 /firstRedirect, window.location = '/secondRedirect'
   *    GET /secondRedirect => 302 /finalUrl
   *    GET /finalUrl => 200 /finalUrl
   *
   * Returns network records [/initialUrl, /firstRedirect, /secondRedirect, /thirdRedirect, /finalUrl]
   *
   * @param {LH.Artifacts.NetworkRequest} mainResource
   * @param {Array<LH.Artifacts.NetworkRequest>} networkRecords
   * @param {LH.Artifacts.ProcessedTrace} processedTrace
   * @return {Array<LH.Artifacts.NetworkRequest>}
   */
  static getDocumentRequestChain(mainResource, networkRecords, processedTrace) {
    /** @type {Array<LH.Artifacts.NetworkRequest>} */
    const documentRequests = [];

    // Find all the document requests by examining navigation events and their redirects
    for (const event of processedTrace.processEvents) {
      if (event.name !== 'navigationStart') continue;

      const data = event.args.data || {};
      if (!data.documentLoaderURL || !data.isLoadingMainFrame) continue;

      let networkRecord = networkRecords.find(record => record.url === data.documentLoaderURL);
      while (networkRecord) {
        documentRequests.push(networkRecord);
        networkRecord = networkRecord.redirectDestination;
      }
    }

    // If we found documents in the trace, just use this directly.
    if (documentRequests.length) return documentRequests;

    // Use the main resource as a backup if we didn't find any modern navigationStart events
    return (mainResource.redirects || []).concat(mainResource);
  }

  /**
   * @param {LH.Artifacts} artifacts
   * @param {LH.Audit.Context} context
   * @return {Promise<LH.Audit.Product>}
   */
  static async audit(artifacts, context) {
    const settings = context.settings;
    const trace = artifacts.traces[Audit.DEFAULT_PASS];
    const devtoolsLog = artifacts.devtoolsLogs[Audit.DEFAULT_PASS];
    const gatherContext = artifacts.GatherContext;

    const processedTrace = await ProcessedTrace.request(trace, context);
    const networkRecords = await NetworkRecords.request(devtoolsLog, context);
    const mainResource = await MainResource.request({URL: artifacts.URL, devtoolsLog}, context);

    const metricComputationData = {trace, devtoolsLog, gatherContext, settings};
    const metricResult = await LanternInteractive.request(metricComputationData, context);

    /** @type {Map<string, LH.Gatherer.Simulation.NodeTiming>} */
    const nodeTimingsByUrl = new Map();
    for (const [node, timing] of metricResult.pessimisticEstimate.nodeTimings.entries()) {
      if (node.type === 'network') {
        nodeTimingsByUrl.set(node.record.url, timing);
      }
    }

    const documentRequests = Redirects.getDocumentRequestChain(
      mainResource, networkRecords, processedTrace);

    let totalWastedMs = 0;
    const tableRows = [];

    // Iterate through all the document requests and report how much time was wasted until the
    // next document request was issued. The final document request will have a `wastedMs` of 0.
    for (let i = 0; i < documentRequests.length; i++) {
      // If we didn't have enough documents for at least 1 redirect, just skip this loop.
      if (documentRequests.length < 2) break;

      const initialRequest = documentRequests[i];
      const redirectedRequest = documentRequests[i + 1] || initialRequest;

      const initialTiming = nodeTimingsByUrl.get(initialRequest.url);
      const redirectedTiming = nodeTimingsByUrl.get(redirectedRequest.url);
      if (!initialTiming || !redirectedTiming) {
        throw new Error('Could not find redirects in graph');
      }

      const lanternTimingDeltaMs = redirectedTiming.startTime - initialTiming.startTime;
      const observedTimingDeltaS = redirectedRequest.startTime - initialRequest.startTime;
      const wastedMs = settings.throttlingMethod === 'simulate' ?
        lanternTimingDeltaMs : observedTimingDeltaS * 1000;
      totalWastedMs += wastedMs;

      tableRows.push({
        url: initialRequest.url,
        wastedMs,
      });
    }

    /** @type {LH.Audit.Details.Opportunity['headings']} */
    const headings = [
      {key: 'url', valueType: 'url', label: str_(i18n.UIStrings.columnURL)},
      {key: 'wastedMs', valueType: 'timespanMs', label: str_(i18n.UIStrings.columnTimeSpent)},
    ];
    const details = Audit.makeOpportunityDetails(headings, tableRows, totalWastedMs);

    return {
      // We award a passing grade if you only have 1 redirect
      // TODO(phulce): reconsider if cases like the example in https://github.com/GoogleChrome/lighthouse/issues/8984
      // should fail this audit.
      score: documentRequests.length <= 2 ? 1 : UnusedBytes.scoreForWastedMs(totalWastedMs),
      numericValue: totalWastedMs,
      numericUnit: 'millisecond',
      displayValue: totalWastedMs ?
        str_(i18n.UIStrings.displayValueMsSavings, {wastedMs: totalWastedMs}) :
        '',
      details,
    };
  }
}

module.exports = Redirects;
module.exports.UIStrings = UIStrings;

}).call(this)}).call(this,"/lighthouse-core/audits/redirects.js")
},{"../computed/main-resource.js":14,"../computed/metrics/lantern-interactive.js":24,"../computed/network-records.js":40,"../computed/processed-trace.js":43,"../lib/i18n/i18n.js":96,"./audit.js":3,"./byte-efficiency/byte-efficiency-audit.js":4}],"../audits/resource-summary":[function(require,module,exports){
(function (__filename){(function (){
/**
 * @license Copyright 2019 The Lighthouse Authors. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.
 */
'use strict';

const Audit = require('./audit.js');
const ComputedResourceSummary = require('../computed/resource-summary.js');
const i18n = require('../lib/i18n/i18n.js');

const UIStrings = {
  /** Imperative title of a Lighthouse audit that tells the user to minimize the size and quantity of resources used to load the page. */
  title: 'Keep request counts low and transfer sizes small',
  /** Description of a Lighthouse audit that tells the user that they can setup a budgets for the quantity and size of page resources. No character length limits. 'Learn More' becomes link text to additional documentation. */
  description: 'To set budgets for the quantity and size of page resources,' +
    ' add a budget.json file. [Learn more](https://web.dev/use-lighthouse-for-performance-budgets/).',
  /** [ICU Syntax] Label for an audit identifying the number of requests and kibibytes used to load the page. */
  displayValue: `{requestCount, plural, ` +
    `=1 {1 request • {byteCount, number, bytes} KiB} ` +
    `other {# requests • {byteCount, number, bytes} KiB}}`,
};

const str_ = i18n.createMessageInstanceIdFn(__filename, UIStrings);

class ResourceSummary extends Audit {
  /**
   * @return {LH.Audit.Meta}
   */
  static get meta() {
    return {
      id: 'resource-summary',
      title: str_(UIStrings.title),
      description: str_(UIStrings.description),
      scoreDisplayMode: Audit.SCORING_MODES.INFORMATIVE,
      requiredArtifacts: ['devtoolsLogs', 'URL'],
    };
  }

  /**
   * @param {LH.Artifacts} artifacts
   * @param {LH.Audit.Context} context
   * @return {Promise<LH.Audit.Product>}
   */
  static async audit(artifacts, context) {
    const devtoolsLog = artifacts.devtoolsLogs[Audit.DEFAULT_PASS];
    const summary = await ComputedResourceSummary
      .request({devtoolsLog, URL: artifacts.URL, budgets: context.settings.budgets}, context);

    /** @type {LH.Audit.Details.Table['headings']} */
    const headings = [
      {key: 'label', itemType: 'text', text: str_(i18n.UIStrings.columnResourceType)},
      {key: 'requestCount', itemType: 'numeric', text: str_(i18n.UIStrings.columnRequests)},
      {key: 'transferSize', itemType: 'bytes', text: str_(i18n.UIStrings.columnTransferSize)},
    ];


    /** @type {Record<LH.Budget.ResourceType, LH.IcuMessage>} */
    const strMappings = {
      'total': str_(i18n.UIStrings.totalResourceType),
      'document': str_(i18n.UIStrings.documentResourceType),
      'script': str_(i18n.UIStrings.scriptResourceType),
      'stylesheet': str_(i18n.UIStrings.stylesheetResourceType),
      'image': str_(i18n.UIStrings.imageResourceType),
      'media': str_(i18n.UIStrings.mediaResourceType),
      'font': str_(i18n.UIStrings.fontResourceType),
      'other': str_(i18n.UIStrings.otherResourceType),
      'third-party': str_(i18n.UIStrings.thirdPartyResourceType),
    };

    const types = /** @type {Array<LH.Budget.ResourceType>} */ (Object.keys(summary));
    const rows = types.map(type => {
      return {
        // ResourceType is included as an "id" for ease of use.
        // It does not appear directly in the table.
        resourceType: type,
        label: strMappings[type],
        requestCount: summary[type].count,
        transferSize: summary[type].transferSize,
      };
    });
    // Force third-party to be last, descending by size otherwise
    const thirdPartyRow = rows.find(r => r.resourceType === 'third-party') || [];
    const otherRows = rows.filter(r => r.resourceType !== 'third-party')
      .sort((a, b) => {
        return b.transferSize - a.transferSize;
      });
    const tableItems = otherRows.concat(thirdPartyRow);

    const tableDetails = Audit.makeTableDetails(headings, tableItems);

    return {
      details: tableDetails,
      score: 1,
      displayValue: str_(UIStrings.displayValue, {
        requestCount: summary.total.count,
        byteCount: summary.total.transferSize,
      }),
    };
  }
}

module.exports = ResourceSummary;
module.exports.UIStrings = UIStrings;

}).call(this)}).call(this,"/lighthouse-core/audits/resource-summary.js")
},{"../computed/resource-summary.js":44,"../lib/i18n/i18n.js":96,"./audit.js":3}],"../audits/screenshot-thumbnails":[function(require,module,exports){
/**
 * @license Copyright 2017 The Lighthouse Authors. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.
 */
'use strict';

const Audit = require('./audit.js');
const LHError = require('../lib/lh-error.js');
const jpeg = require('jpeg-js');
const Speedline = require('../computed/speedline.js');

const NUMBER_OF_THUMBNAILS = 10;
const THUMBNAIL_WIDTH = 120;

/** @typedef {LH.Artifacts.Speedline['frames'][0]} SpeedlineFrame */

class ScreenshotThumbnails extends Audit {
  /**
   * @return {LH.Audit.Meta}
   */
  static get meta() {
    return {
      id: 'screenshot-thumbnails',
      scoreDisplayMode: Audit.SCORING_MODES.INFORMATIVE,
      title: 'Screenshot Thumbnails',
      description: 'This is what the load of your site looked like.',
      requiredArtifacts: ['traces', 'GatherContext'],
    };
  }

  /**
   * Scales down an image to THUMBNAIL_WIDTH using nearest neighbor for speed, maintains aspect
   * ratio of the original thumbnail.
   *
   * @param {ReturnType<SpeedlineFrame['getParsedImage']>} imageData
   * @return {{width: number, height: number, data: Uint8Array}}
   */
  static scaleImageToThumbnail(imageData) {
    const scaledWidth = THUMBNAIL_WIDTH;
    const scaleFactor = imageData.width / scaledWidth;
    const scaledHeight = Math.floor(imageData.height / scaleFactor);

    const outPixels = new Uint8Array(scaledWidth * scaledHeight * 4);

    for (let i = 0; i < scaledWidth; i++) {
      for (let j = 0; j < scaledHeight; j++) {
        const origX = Math.floor(i * scaleFactor);
        const origY = Math.floor(j * scaleFactor);

        const origPos = (origY * imageData.width + origX) * 4;
        const outPos = (j * scaledWidth + i) * 4;

        outPixels[outPos] = imageData.data[origPos];
        outPixels[outPos + 1] = imageData.data[origPos + 1];
        outPixels[outPos + 2] = imageData.data[origPos + 2];
        outPixels[outPos + 3] = imageData.data[origPos + 3];
      }
    }

    return {
      width: scaledWidth,
      height: scaledHeight,
      data: outPixels,
    };
  }

  /**
   * @param {LH.Artifacts} artifacts
   * @param {LH.Audit.Context} context
   * @return {Promise<LH.Audit.Product>}
   */
  static async _audit(artifacts, context) {
    const trace = artifacts.traces[Audit.DEFAULT_PASS];
    /** @type {Map<SpeedlineFrame, string>} */
    const cachedThumbnails = new Map();

    const speedline = await Speedline.request(trace, context);

    // Make the minimum time range 3s so sites that load super quickly don't get a single screenshot
    const minimumTimelineDuration = context.options.minimumTimelineDuration || 3000;

    const thumbnails = [];
    const analyzedFrames = speedline.frames.filter(frame => !frame.isProgressInterpolated());
    const maxFrameTime =
      speedline.complete ||
      Math.max(...speedline.frames.map(frame => frame.getTimeStamp() - speedline.beginning));
    const timelineEnd = Math.max(maxFrameTime, minimumTimelineDuration);

    if (!analyzedFrames.length || !Number.isFinite(timelineEnd)) {
      throw new LHError(LHError.errors.INVALID_SPEEDLINE);
    }

    for (let i = 1; i <= NUMBER_OF_THUMBNAILS; i++) {
      const targetTimestamp = speedline.beginning + timelineEnd * i / NUMBER_OF_THUMBNAILS;

      /** @type {SpeedlineFrame} */
      // @ts-expect-error - there will always be at least one frame by this point. TODO: use nonnullable assertion in TS2.9
      let frameForTimestamp = null;
      if (i === NUMBER_OF_THUMBNAILS) {
        frameForTimestamp = analyzedFrames[analyzedFrames.length - 1];
      } else {
        analyzedFrames.forEach(frame => {
          if (frame.getTimeStamp() <= targetTimestamp) {
            frameForTimestamp = frame;
          }
        });
      }

      let base64Data;
      const cachedThumbnail = cachedThumbnails.get(frameForTimestamp);
      if (cachedThumbnail) {
        base64Data = cachedThumbnail;
      } else {
        const imageData = frameForTimestamp.getParsedImage();
        const thumbnailImageData = ScreenshotThumbnails.scaleImageToThumbnail(imageData);
        base64Data = jpeg.encode(thumbnailImageData, 90).data.toString('base64');
        cachedThumbnails.set(frameForTimestamp, base64Data);
      }
      thumbnails.push({
        timing: Math.round(targetTimestamp - speedline.beginning),
        timestamp: targetTimestamp * 1000,
        data: `data:image/jpeg;base64,${base64Data}`,
      });
    }

    return {
      score: 1,
      details: {
        type: 'filmstrip',
        scale: timelineEnd,
        items: thumbnails,
      },
    };
  }

  /**
   * @param {LH.Artifacts} artifacts
   * @param {LH.Audit.Context} context
   * @return {Promise<LH.Audit.Product>}
   */
  static async audit(artifacts, context) {
    try {
      return await this._audit(artifacts, context);
    } catch (err) {
      const noFramesErrors = new Set([
        LHError.errors.NO_SCREENSHOTS.code,
        LHError.errors.SPEEDINDEX_OF_ZERO.code,
        LHError.errors.NO_SPEEDLINE_FRAMES.code,
        LHError.errors.INVALID_SPEEDLINE.code,
      ]);

      // If a timespan didn't happen to contain frames, that's fine. Just mark not applicable.
      if (noFramesErrors.has(err.code) && artifacts.GatherContext.gatherMode === 'timespan') {
        return {notApplicable: true, score: 1};
      }

      throw err;
    }
  }
}

module.exports = ScreenshotThumbnails;

},{"../computed/speedline.js":46,"../lib/lh-error.js":103,"./audit.js":3,"jpeg-js":185}],"../audits/script-treemap-data":[function(require,module,exports){
/**
 * @license Copyright 2020 The Lighthouse Authors. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.
 */
'use strict';

/**
 * @fileoverview
 * Creates nodes for treemap app.
 * Example output: lighthouse-treemap/app/debug.json
 */

/**
 * @typedef {Omit<LH.Treemap.Node, 'name'|'children'>} SourceData
 */

const Audit = require('./audit.js');
const JsBundles = require('../computed/js-bundles.js');
const UnusedJavaScriptSummary = require('../computed/unused-javascript-summary.js');
const ModuleDuplication = require('../computed/module-duplication.js');

class ScriptTreemapDataAudit extends Audit {
  /**
   * @return {LH.Audit.Meta}
   */
  static get meta() {
    return {
      id: 'script-treemap-data',
      scoreDisplayMode: Audit.SCORING_MODES.INFORMATIVE,
      title: 'Script Treemap Data',
      description: 'Used for treemap app',
      requiredArtifacts:
        ['traces', 'devtoolsLogs', 'SourceMaps', 'ScriptElements', 'JsUsage', 'URL'],
    };
  }

  /**
   * Returns a tree data structure where leaf nodes are sources (ie. real files from source tree)
   * from a source map, and non-leaf nodes are directories. Leaf nodes have data
   * for bytes, coverage, etc., when available, and non-leaf nodes have the
   * same data as the sum of all descendant leaf nodes.
   * @param {string} src
   * @param {string} sourceRoot
   * @param {Record<string, SourceData>} sourcesData
   * @return {LH.Treemap.Node}
   */
  static makeScriptNode(src, sourceRoot, sourcesData) {
    /**
     * @param {string} name
     * @return {LH.Treemap.Node}
     */
    function newNode(name) {
      return {
        name,
        resourceBytes: 0,
      };
    }

    const sourceRootNode = newNode(sourceRoot);

    /**
     * Given a slash-delimited path, traverse the Node structure and increment
     * the data provided for each node in the chain. Creates nodes as needed.
     * Ex: path/to/file.js will find or create "path" on `node`, increment the data fields,
     *     and continue with "to", and so on.
     * @param {string} source
     * @param {SourceData} data
     */
    function addAllNodesInSourcePath(source, data) {
      let node = sourceRootNode;

      // Apply the data to the sourceRootNode.
      sourceRootNode.resourceBytes += data.resourceBytes;
      if (data.unusedBytes) {
        sourceRootNode.unusedBytes = (sourceRootNode.unusedBytes || 0) + data.unusedBytes;
      }

      // Strip off the shared root.
      const sourcePathSegments = source.replace(sourceRoot, '').split(/\/+/);
      sourcePathSegments.forEach((sourcePathSegment, i) => {
        if (sourcePathSegment.length === 0) return;

        const isLeaf = i === sourcePathSegments.length - 1;

        let child = node.children && node.children.find(child => child.name === sourcePathSegment);
        if (!child) {
          child = newNode(sourcePathSegment);
          node.children = node.children || [];
          node.children.push(child);
        }
        node = child;

        // Now that we've found or created the next node in the path, apply the data.
        node.resourceBytes += data.resourceBytes;
        if (data.unusedBytes) node.unusedBytes = (node.unusedBytes || 0) + data.unusedBytes;

        // Only leaf nodes might have duplication data.
        if (isLeaf && data.duplicatedNormalizedModuleName !== undefined) {
          node.duplicatedNormalizedModuleName = data.duplicatedNormalizedModuleName;
        }
      });
    }

    // For every source file, apply the data to all components
    // of the source path, creating nodes as necessary.
    for (const [source, data] of Object.entries(sourcesData)) {
      addAllNodesInSourcePath(source, data);
    }

    /**
     * Collapse nodes that have only one child.
     * @param {LH.Treemap.Node} node
     */
    function collapseAll(node) {
      while (node.children && node.children.length === 1) {
        node.name += '/' + node.children[0].name;
        node.children = node.children[0].children;
      }

      if (node.children) {
        for (const child of node.children) {
          collapseAll(child);
        }
      }
    }
    collapseAll(sourceRootNode);

    // If sourceRootNode.name is falsy (no defined sourceRoot + no collapsed common prefix),
    // collapse the sourceRootNode children into the scriptNode.
    // Otherwise, we add another node.
    if (!sourceRootNode.name) {
      return {
        ...sourceRootNode,
        name: src,
        children: sourceRootNode.children,
      };
    }

    // Script node should be just the script src.
    const scriptNode = {...sourceRootNode};
    scriptNode.name = src;
    scriptNode.children = [sourceRootNode];
    return scriptNode;
  }

  /**
   * Returns nodes where the first level of nodes are URLs.
   * Every external script has a node.
   * All inline scripts are combined into a single node.
   * If a script has a source map, that node will be set by makeNodeFromSourceMapData.
   *
   * Example return result:
     - index.html (inlines scripts)
     - main.js
     - - webpack://
     - - - react.js
     - - - app.js
     - i-have-no-map.js
   *
   * @param {LH.Artifacts} artifacts
   * @param {LH.Audit.Context} context
   * @return {Promise<LH.Treemap.Node[]>}
   */
  static async makeNodes(artifacts, context) {
    /** @type {LH.Treemap.Node[]} */
    const nodes = [];

    let inlineScriptLength = 0;
    for (const scriptElement of artifacts.ScriptElements) {
      // No src means script is inline.
      // Combine these ScriptElements so that inline scripts show up as a single root node.
      if (!scriptElement.src) {
        inlineScriptLength += (scriptElement.content || '').length;
      }
    }
    if (inlineScriptLength) {
      const name = artifacts.URL.finalUrl;
      nodes.push({
        name,
        resourceBytes: inlineScriptLength,
      });
    }

    const bundles = await JsBundles.request(artifacts, context);
    const duplicationByPath = await ModuleDuplication.request(artifacts, context);

    for (const scriptElement of artifacts.ScriptElements) {
      if (!scriptElement.src) continue;

      const name = scriptElement.src;
      const bundle = bundles.find(bundle => scriptElement.src === bundle.script.src);
      const scriptCoverages = artifacts.JsUsage[scriptElement.src] || [];
      if (!bundle && scriptCoverages.length === 0) {
        // No bundle and no coverage information, so simply make a single node
        // detailing how big the script is.

        nodes.push({
          name,
          resourceBytes: scriptElement.src.length,
        });
        continue;
      }

      const unusedJavascriptSummary = await UnusedJavaScriptSummary.request(
        {url: scriptElement.src, scriptCoverages, bundle}, context);

      /** @type {LH.Treemap.Node} */
      let node;
      if (bundle && !('errorMessage' in bundle.sizes)) {
        // Create nodes for each module in a bundle.

        /** @type {Record<string, SourceData>} */
        const sourcesData = {};
        for (const source of Object.keys(bundle.sizes.files)) {
          /** @type {SourceData} */
          const sourceData = {
            resourceBytes: bundle.sizes.files[source],
          };

          if (unusedJavascriptSummary.sourcesWastedBytes) {
            sourceData.unusedBytes = unusedJavascriptSummary.sourcesWastedBytes[source];
          }

          // ModuleDuplication uses keys without the source root prepended, but
          // bundle.sizes uses keys with it prepended, so we remove the source root before
          // using it with duplicationByPath.
          let sourceWithoutSourceRoot = source;
          if (bundle.rawMap.sourceRoot && source.startsWith(bundle.rawMap.sourceRoot)) {
            sourceWithoutSourceRoot = source.replace(bundle.rawMap.sourceRoot, '');
          }

          const key = ModuleDuplication.normalizeSource(sourceWithoutSourceRoot);
          if (duplicationByPath.has(key)) sourceData.duplicatedNormalizedModuleName = key;

          sourcesData[source] = sourceData;
        }

        if (bundle.sizes.unmappedBytes) {
          /** @type {SourceData} */
          const sourceData = {
            resourceBytes: bundle.sizes.unmappedBytes,
          };
          if (unusedJavascriptSummary.sourcesWastedBytes) {
            sourceData.unusedBytes = unusedJavascriptSummary.sourcesWastedBytes['(unmapped)'];
          }
          sourcesData['(unmapped)'] = sourceData;
        }

        node = this.makeScriptNode(scriptElement.src, bundle.rawMap.sourceRoot || '', sourcesData);
      } else {
        // No valid source map for this script, so we can only produce a single node.

        node = {
          name,
          resourceBytes: unusedJavascriptSummary.totalBytes,
          unusedBytes: unusedJavascriptSummary.wastedBytes,
        };
      }

      nodes.push(node);
    }

    return nodes;
  }

  /**
   * @param {LH.Artifacts} artifacts
   * @param {LH.Audit.Context} context
   * @return {Promise<LH.Audit.Product>}
   */
  static async audit(artifacts, context) {
    const nodes = await ScriptTreemapDataAudit.makeNodes(artifacts, context);

    /** @type {LH.Audit.Details.TreemapData} */
    const details = {
      type: 'treemap-data',
      nodes,
    };

    return {
      score: 1,
      details,
    };
  }
}

module.exports = ScriptTreemapDataAudit;

},{"../computed/js-bundles.js":12,"../computed/module-duplication.js":38,"../computed/unused-javascript-summary.js":49,"./audit.js":3}],"../audits/seo/canonical":[function(require,module,exports){
(function (__filename){(function (){
/**
 * @license Copyright 2017 The Lighthouse Authors. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.
 */
'use strict';

const Audit = require('../audit.js');
const URL = require('../../lib/url-shim.js');
const MainResource = require('../../computed/main-resource.js');
const i18n = require('../../lib/i18n/i18n.js');

const UIStrings = {
  /** Title of a Lighthouse audit that provides detail on a page's rel=canonical link. This descriptive title is shown to users when the rel=canonical link is valid. "rel=canonical" is an HTML attribute and value and so should not be translated. */
  title: 'Document has a valid `rel=canonical`',
  /** Title of a Lighthouse audit that provides detail on a page's rel=canonical link. This descriptive title is shown to users when the rel=canonical link is invalid and should be fixed. "rel=canonical" is an HTML attribute and value and so should not be translated. */
  failureTitle: 'Document does not have a valid `rel=canonical`',
  /** Description of a Lighthouse audit that tells the user *why* they need to have a valid rel=canonical link. This is displayed after a user expands the section to see more. No character length limits. 'Learn More' becomes link text to additional documentation. */
  description: 'Canonical links suggest which URL to show in search results. ' +
    '[Learn more](https://web.dev/canonical/).',
  /**
   * @description Explanatory message stating that there was a failure in an audit caused by multiple URLs conflicting with each other.
   * @example {https://example.com, https://example2.com} urlList
   * */
  explanationConflict: 'Multiple conflicting URLs ({urlList})',
  /**
   * @description Explanatory message stating that there was a failure in an audit caused by a URL being invalid.
   * @example {https://example.com/} url
   * */
  explanationInvalid: 'Invalid URL ({url})',
  /**
   * @description Explanatory message stating that there was a failure in an audit caused by a URL being relative instead of absolute.
   * @example {https://example.com/} url
   * */
  explanationRelative: 'Is not an absolute URL ({url})',
  /**
   * @description Explanatory message stating that there was a failure in an audit caused by a URL pointing to a different hreflang than the current context.'hreflang' is an HTML attribute and should not be translated.
   * @example {https://example.com/} url
   */
  explanationPointsElsewhere: 'Points to another `hreflang` location ({url})',
  /**
   * @description Explanatory message stating that there was a failure in an audit caused by a URL pointing to a different domain.
   * @example {https://example.com/} url
   * */
  explanationDifferentDomain: 'Points to a different domain ({url})',
  /** Explanatory message stating that the page's canonical URL was pointing to the domain's root URL, which is a common mistake. "points" refers to the action of the 'rel=canonical' referencing another link. "root" refers to the starting/home page of the website. "domain" refers to the registered domain name of the website. */
  explanationRoot: 'Points to the domain\'s root URL (the homepage), ' +
    'instead of an equivalent page of content',
};

const str_ = i18n.createMessageInstanceIdFn(__filename, UIStrings);

/**
 * @typedef CanonicalURLData
 * @property {Set<string>} uniqueCanonicalURLs
 * @property {Set<string>} hreflangURLs
 * @property {LH.Artifacts.LinkElement|undefined} invalidCanonicalLink
 * @property {LH.Artifacts.LinkElement|undefined} relativeCanonicallink
 */

class Canonical extends Audit {
  /**
   * @return {LH.Audit.Meta}
   */
  static get meta() {
    return {
      id: 'canonical',
      title: str_(UIStrings.title),
      failureTitle: str_(UIStrings.failureTitle),
      description: str_(UIStrings.description),
      supportedModes: ['navigation'],
      requiredArtifacts: ['LinkElements', 'URL', 'devtoolsLogs'],
    };
  }

  /**
   * @param {LH.Artifacts.LinkElement[]} linkElements
   * @return {CanonicalURLData}
   */
  static collectCanonicalURLs(linkElements) {
    /** @type {Set<string>} */
    const uniqueCanonicalURLs = new Set();
    /** @type {Set<string>} */
    const hreflangURLs = new Set();

    /** @type {LH.Artifacts.LinkElement|undefined} */
    let invalidCanonicalLink;
    /** @type {LH.Artifacts.LinkElement|undefined} */
    let relativeCanonicallink;
    for (const link of linkElements) {
      // Links in the body aren't canonical references for SEO, skip them
      /** @see https://html.spec.whatwg.org/multipage/links.html#body-ok */
      if (link.source === 'body') continue;

      if (link.rel === 'canonical') {
        // Links that don't have an href aren't canonical references for SEO, skip them
        if (!link.hrefRaw) continue;

        // Links that had an hrefRaw but didn't have a valid href were invalid, flag them
        if (!link.href) invalidCanonicalLink = link;
        // Links that had a valid href but didn't have a valid hrefRaw must have been relatively resolved, flag them
        else if (!URL.isValid(link.hrefRaw)) relativeCanonicallink = link;
        // Otherwise, it was a valid canonical URL
        else uniqueCanonicalURLs.add(link.href);
      } else if (link.rel === 'alternate') {
        if (link.href && link.hreflang) hreflangURLs.add(link.href);
      }
    }

    return {uniqueCanonicalURLs, hreflangURLs, invalidCanonicalLink, relativeCanonicallink};
  }

  /**
   * @param {CanonicalURLData} canonicalURLData
   * @return {LH.Audit.Product|undefined}
   */
  static findInvalidCanonicalURLReason(canonicalURLData) {
    const {uniqueCanonicalURLs, invalidCanonicalLink, relativeCanonicallink} = canonicalURLData;

    // the canonical link is totally invalid
    if (invalidCanonicalLink) {
      return {
        score: 0,
        explanation: str_(UIStrings.explanationInvalid, {url: invalidCanonicalLink.hrefRaw}),
      };
    }

    // the canonical link is valid, but it's relative which isn't allowed
    if (relativeCanonicallink) {
      return {
        score: 0,
        explanation: str_(UIStrings.explanationRelative, {url: relativeCanonicallink.hrefRaw}),
      };
    }

    /** @type {string[]} */
    const canonicalURLs = Array.from(uniqueCanonicalURLs);

    // there's no canonical URL at all, we're done
    if (canonicalURLs.length === 0) {
      return {
        score: 1,
        notApplicable: true,
      };
    }

    // we have multiple conflicting canonical URls, we're done
    if (canonicalURLs.length > 1) {
      return {
        score: 0,
        explanation: str_(UIStrings.explanationConflict, {urlList: canonicalURLs.join(', ')}),
      };
    }
  }

  /**
   * @param {CanonicalURLData} canonicalURLData
   * @param {URL} canonicalURL
   * @param {URL} baseURL
   * @return {LH.Audit.Product|undefined}
   */
  static findCommonCanonicalURLMistakes(canonicalURLData, canonicalURL, baseURL) {
    const {hreflangURLs} = canonicalURLData;

    // cross-language or cross-country canonicals are a common issue
    if (
      hreflangURLs.has(baseURL.href) &&
      hreflangURLs.has(canonicalURL.href) &&
      baseURL.href !== canonicalURL.href
    ) {
      return {
        score: 0,
        explanation: str_(UIStrings.explanationPointsElsewhere, {url: baseURL.href}),
      };
    }

    // bing and yahoo don't allow canonical URLs pointing to different domains, it's also
    // a common mistake to publish a page with canonical pointing to e.g. a test domain or localhost
    if (!URL.rootDomainsMatch(canonicalURL, baseURL)) {
      return {
        score: 0,
        explanation: str_(UIStrings.explanationDifferentDomain, {url: canonicalURL.href}),
      };
    }

    // another common mistake is to have canonical pointing from all pages of the website to its root
    if (
      canonicalURL.origin === baseURL.origin &&
      canonicalURL.pathname === '/' &&
      baseURL.pathname !== '/'
    ) {
      return {
        score: 0,
        explanation: str_(UIStrings.explanationRoot),
      };
    }
  }

  /**
   * @param {LH.Artifacts} artifacts
   * @param {LH.Audit.Context} context
   * @return {Promise<LH.Audit.Product>}
   */
  static async audit(artifacts, context) {
    const devtoolsLog = artifacts.devtoolsLogs[Audit.DEFAULT_PASS];

    const mainResource = await MainResource.request({devtoolsLog, URL: artifacts.URL}, context);
    const baseURL = new URL(mainResource.url);
    const canonicalURLData = Canonical.collectCanonicalURLs(artifacts.LinkElements);

    // First we'll check that there was a single valid canonical URL.
    const invalidURLAuditProduct = Canonical.findInvalidCanonicalURLReason(canonicalURLData);
    if (invalidURLAuditProduct) return invalidURLAuditProduct;

    // There was a single valid canonical URL, so now we'll just check for common mistakes.
    const canonicalURL = new URL([...canonicalURLData.uniqueCanonicalURLs][0]);
    const mistakeAuditProduct = Canonical.findCommonCanonicalURLMistakes(
      canonicalURLData,
      canonicalURL,
      baseURL
    );

    if (mistakeAuditProduct) return mistakeAuditProduct;

    return {
      score: 1,
    };
  }
}

module.exports = Canonical;
module.exports.UIStrings = UIStrings;

}).call(this)}).call(this,"/lighthouse-core/audits/seo/canonical.js")
},{"../../computed/main-resource.js":14,"../../lib/i18n/i18n.js":96,"../../lib/url-shim.js":"url","../audit.js":3}],"../audits/seo/crawlable-anchors":[function(require,module,exports){
(function (__filename){(function (){
/**
 * @license Copyright 2020 The Lighthouse Authors. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.
 */
'use strict';

const Audit = require('../audit.js');
const i18n = require('../../lib/i18n/i18n.js');

const UIStrings = {
  /** Title of a Lighthouse audit that provides detail on whether links have potentially-crawlable href attributes. This descriptive title is shown when all links on the page are potentially-crawlable. */
  title: 'Links are crawlable',
  /** Descriptive title of a Lighthouse audit that provides detail on whether links have potentially-crawlable href attributes. This descriptive title is shown when there are href attributes which are not crawlable by search engines. */
  failureTitle: 'Links are not crawlable',
  /** Description of a Lighthouse audit that tells the user why href attributes on links should be crawlable. This is displayed after a user expands the section to see more. 'Learn More' becomes link text to additional documentation. */
  description: 'Search engines may use `href` attributes on links to crawl websites. Ensure that the `href` attribute of anchor elements links to an appropriate destination, so more pages of the site can be discovered. [Learn More](https://support.google.com/webmasters/answer/9112205)',
  /** Label for a column in a data table; entries will be the HTML anchor elements that failed the audit. Anchors are DOM elements that are links. */
  columnFailingLink: 'Uncrawlable Link',
};

const str_ = i18n.createMessageInstanceIdFn(__filename, UIStrings);

class CrawlableAnchors extends Audit {
  /**
   * @return {LH.Audit.Meta}
   */
  static get meta() {
    return {
      id: 'crawlable-anchors',
      title: str_(UIStrings.title),
      failureTitle: str_(UIStrings.failureTitle),
      description: str_(UIStrings.description),
      requiredArtifacts: ['AnchorElements'],
    };
  }

  /**
   * @param {LH.Artifacts} artifacts
   * @return {LH.Audit.Product}
   */
  static audit({AnchorElements: anchorElements}) {
    const failingAnchors = anchorElements.filter(({
      rawHref,
      listeners = [],
      onclick = '',
      name = '',
      role = '',
    }) => {
      onclick = onclick.replace( /\s/g, '');
      rawHref = rawHref.replace( /\s/g, '');
      name = name.trim();
      role = role.trim();

      if (role.length > 0) return;
      // Ignore mailto links even if they use one of the failing patterns. See https://github.com/GoogleChrome/lighthouse/issues/11443#issuecomment-694898412
      if (rawHref.startsWith('mailto:')) return;

      const windowLocationRegExp = /window\.location=/;
      const windowOpenRegExp = /window\.open\(/;
      const javaScriptVoidRegExp = /javascript:void(\(|)0(\)|)/;

      if (rawHref.startsWith('file:')) return true;
      if (windowLocationRegExp.test(onclick)) return true;
      if (windowOpenRegExp.test(onclick)) return true;

      const hasClickHandler = listeners.some(({type}) => type === 'click');
      if (hasClickHandler || name.length > 0) return;

      if (rawHref === '') return true;
      if (javaScriptVoidRegExp.test(rawHref)) return true;
    });

    /** @type {LH.Audit.Details.Table['headings']} */
    const headings = [{
      key: 'node',
      itemType: 'node',
      text: str_(UIStrings.columnFailingLink),
    }];

    /** @type {LH.Audit.Details.Table['items']} */
    const itemsToDisplay = failingAnchors.map(anchor => {
      return {
        node: Audit.makeNodeItem(anchor.node),
      };
    });

    return {
      score: Number(failingAnchors.length === 0),
      details: Audit.makeTableDetails(headings, itemsToDisplay),
    };
  }
}

module.exports = CrawlableAnchors;
module.exports.UIStrings = UIStrings;

}).call(this)}).call(this,"/lighthouse-core/audits/seo/crawlable-anchors.js")
},{"../../lib/i18n/i18n.js":96,"../audit.js":3}],"../audits/seo/font-size":[function(require,module,exports){
(function (__filename){(function (){
/**
 * @license Copyright 2017 The Lighthouse Authors. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.
 */
'use strict';

/** @typedef {LH.Artifacts.FontSize['analyzedFailingNodesData'][0]} FailingNodeData */

const i18n = require('../../lib/i18n/i18n.js');
const Audit = require('../audit.js');
const ComputedViewportMeta = require('../../computed/viewport-meta.js');
const MINIMAL_PERCENTAGE_OF_LEGIBLE_TEXT = 60;

const UIStrings = {
  /** Title of a Lighthouse audit that provides detail on the font sizes used on the page. This descriptive title is shown to users when the fonts used on the page are large enough to be considered legible. */
  title: 'Document uses legible font sizes',
  /** Title of a Lighthouse audit that provides detail on the font sizes used on the page. This descriptive title is shown to users when there is a font that may be too small to be read by users. */
  failureTitle: 'Document doesn\'t use legible font sizes',
  /** Description of a Lighthouse audit that tells the user *why* they need to use a larger font size. This is displayed after a user expands the section to see more. No character length limits. 'Learn More' becomes link text to additional documentation. */
  description: 'Font sizes less than 12px are too small to be legible and require mobile visitors to “pinch to zoom” in order to read. Strive to have >60% of page text ≥12px. [Learn more](https://web.dev/font-size/).',
  /** Label for the audit identifying font sizes that are too small. */
  displayValue: '{decimalProportion, number, extendedPercent} legible text',
  /** Explanatory message stating that there was a failure in an audit caused by a missing page viewport meta tag configuration. "viewport" and "meta" are HTML terms and should not be translated. */
  explanationViewport: 'Text is illegible because there\'s no viewport meta tag optimized ' +
    'for mobile screens.',
  /** Label for the table row which summarizes all failing nodes that were not fully analyzed. "Add'l" is shorthand for "Additional" */
  additionalIllegibleText: 'Add\'l illegible text',
  /** Label for the table row which displays the percentage of nodes that have proper font size. */
  legibleText: 'Legible text',
  /** Label for a column in a data table; entries will be css style rule selectors. */
  columnSelector: 'Selector',
  /** Label for a column in a data table; entries will be the percent of page text a specific CSS rule applies to. */
  columnPercentPageText: '% of Page Text',
  /** Label for a column in a data table; entries will be text font sizes. */
  columnFontSize: 'Font Size',
};

const str_ = i18n.createMessageInstanceIdFn(__filename, UIStrings);

/**
 * @param {Array<FailingNodeData>} fontSizeArtifact
 * @return {Array<FailingNodeData>}
 */
function getUniqueFailingRules(fontSizeArtifact) {
  /** @type {Map<string, FailingNodeData>} */
  const failingRules = new Map();

  fontSizeArtifact.forEach((failingNodeData) => {
    const {nodeId, cssRule, fontSize, textLength, parentNode} = failingNodeData;
    const artifactId = getFontArtifactId(cssRule, nodeId);
    const failingRule = failingRules.get(artifactId);

    if (!failingRule) {
      failingRules.set(artifactId, {
        nodeId,
        parentNode,
        cssRule,
        fontSize,
        textLength,
      });
    } else {
      failingRule.textLength += textLength;
    }
  });

  return [...failingRules.values()];
}

/**
 * @param {Array<string|undefined>=} attributes
 * @return {Map<string, string>}
 */
function getAttributeMap(attributes = []) {
  const map = new Map();

  for (let i = 0; i < attributes.length; i += 2) {
    const name = attributes[i];
    const value = attributes[i + 1];
    if (!name || !value) continue;

    const normalizedValue = value.trim();

    if (normalizedValue) {
      map.set(name.toLowerCase(), normalizedValue);
    }
  }

  return map;
}

/**
 * TODO: return unique selector, like axe-core does, instead of just id/class/name of a single node
 * @param {FailingNodeData['parentNode']} parentNode
 * @return {string}
 */
function getSelector(parentNode) {
  const attributeMap = getAttributeMap(parentNode.attributes);

  if (attributeMap.has('id')) {
    return '#' + attributeMap.get('id');
  } else {
    const attrClass = attributeMap.get('class');
    if (attrClass) {
      return '.' + attrClass.split(/\s+/).join('.');
    }
  }

  return parentNode.nodeName.toLowerCase();
}

/**
 * @param {FailingNodeData['parentNode']} parentNode
 * @return {LH.Audit.Details.NodeValue}
 */
function nodeToTableNode(parentNode) {
  const attributes = parentNode.attributes || [];
  const attributesString = attributes.map((value, idx) =>
    (idx % 2 === 0) ? ` ${value}` : `="${value}"`
  ).join('');

  return {
    type: 'node',
    selector: parentNode.parentNode ? getSelector(parentNode.parentNode) : '',
    snippet: `<${parentNode.nodeName.toLowerCase()}${attributesString}>`,
  };
}

/**
 * @param {string} baseURL
 * @param {FailingNodeData['cssRule']} styleDeclaration
 * @param {FailingNodeData['parentNode']} parentNode
 * @return {{source: LH.Audit.Details.UrlValue | LH.Audit.Details.SourceLocationValue | LH.Audit.Details.CodeValue, selector: string | LH.Audit.Details.NodeValue}}
 */
function findStyleRuleSource(baseURL, styleDeclaration, parentNode) {
  if (!styleDeclaration ||
    styleDeclaration.type === 'Attributes' ||
    styleDeclaration.type === 'Inline'
  ) {
    return {
      source: {type: 'url', value: baseURL},
      selector: nodeToTableNode(parentNode),
    };
  }

  if (styleDeclaration.parentRule &&
    styleDeclaration.parentRule.origin === 'user-agent') {
    return {
      source: {type: 'code', value: 'User Agent Stylesheet'},
      selector: styleDeclaration.parentRule.selectors.map(item => item.text).join(', '),
    };
  }

  // Combine all the selectors for the associated style rule
  // example: .some-selector, .other-selector {...} => `.some-selector, .other-selector`
  let selector = '';
  if (styleDeclaration.parentRule) {
    const rule = styleDeclaration.parentRule;
    selector = rule.selectors.map(item => item.text).join(', ');
  }

  if (styleDeclaration.stylesheet && !styleDeclaration.stylesheet.sourceURL) {
    // Dynamically injected into page.
    return {
      source: {type: 'code', value: 'dynamic'},
      selector,
    };
  }

  // !!range == has defined location in a source file (.css or .html)
  // sourceURL == stylesheet URL || raw value of magic `sourceURL` comment
  // hasSourceURL == flag that signals sourceURL is the raw value of a magic `sourceURL` comment, *not* a real resource
  if (styleDeclaration.stylesheet && styleDeclaration.range) {
    const {range, stylesheet} = styleDeclaration;

    // DevTools protocol does not provide the resource URL if there is a magic `sourceURL` comment.
    // `sourceURL` will be the raw value of the magic `sourceURL` comment, which likely refers to
    // a file at build time, not one that is served over the network that we could link to.
    const urlProvider = stylesheet.hasSourceURL ? 'comment' : 'network';

    let line = range.startLine;
    let column = range.startColumn;

    // Add the startLine/startColumn of the <style> element to the range, if stylesheet
    // is inline.
    // Always use the rule's location if a sourceURL magic comment is
    // present (`hasSourceURL` is true) - this makes the line/col relative to the start
    // of the style tag, which makes them relevant when the "file" is open in DevTool's
    // Sources panel.
    const addHtmlLocationOffset = stylesheet.isInline && urlProvider !== 'comment';
    if (addHtmlLocationOffset) {
      line += stylesheet.startLine;
      // The column the stylesheet begins on is only relevant if the rule is declared on the same line.
      if (range.startLine === 0) {
        column += stylesheet.startColumn;
      }
    }

    const url = stylesheet.sourceURL;
    return {
      source: {type: 'source-location', url, urlProvider, line, column},
      selector,
    };
  }

  // The responsible style declaration was not captured in the font-size gatherer due to
  // the rate limiting we do in `fetchFailingNodeSourceRules`.
  return {
    selector,
    source: {type: 'code', value: 'Unknown'},
  };
}

/**
 * @param {FailingNodeData['cssRule']} styleDeclaration
 * @param {number} textNodeId
 * @return {string}
 */
function getFontArtifactId(styleDeclaration, textNodeId) {
  if (styleDeclaration && styleDeclaration.type === 'Regular') {
    const startLine = styleDeclaration.range ? styleDeclaration.range.startLine : 0;
    const startColumn = styleDeclaration.range ? styleDeclaration.range.startColumn : 0;
    return `${styleDeclaration.styleSheetId}@${startLine}:${startColumn}`;
  } else {
    return `node_${textNodeId}`;
  }
}

class FontSize extends Audit {
  /**
   * @return {LH.Audit.Meta}
   */
  static get meta() {
    return {
      id: 'font-size',
      title: str_(UIStrings.title),
      failureTitle: str_(UIStrings.failureTitle),
      description: str_(UIStrings.description),
      requiredArtifacts: ['FontSize', 'URL', 'MetaElements'],
    };
  }

  /**
   * @param {LH.Artifacts} artifacts
   * @param {LH.Audit.Context} context
   * @return {Promise<LH.Audit.Product>}
   */
  static async audit(artifacts, context) {
    if (context.settings.formFactor === 'desktop') {
      // Font size isn't important to desktop SEO
      return {
        score: 1,
        notApplicable: true,
      };
    }

    const viewportMeta = await ComputedViewportMeta.request(artifacts.MetaElements, context);
    if (!viewportMeta.isMobileOptimized) {
      return {
        score: 0,
        explanation: str_(UIStrings.explanationViewport),
      };
    }

    const {
      analyzedFailingNodesData,
      analyzedFailingTextLength,
      failingTextLength,
      totalTextLength,
    } = artifacts.FontSize;

    if (totalTextLength === 0) {
      return {
        score: 1,
      };
    }

    const failingRules = getUniqueFailingRules(analyzedFailingNodesData);
    const percentageOfPassingText =
      (totalTextLength - failingTextLength) / totalTextLength * 100;
    const pageUrl = artifacts.URL.finalUrl;

    /** @type {LH.Audit.Details.Table['headings']} */
    const headings = [
      {key: 'source', itemType: 'source-location', text: str_(i18n.UIStrings.columnSource)},
      {key: 'selector', itemType: 'code', text: str_(UIStrings.columnSelector)},
      {key: 'coverage', itemType: 'text', text: str_(UIStrings.columnPercentPageText)},
      {key: 'fontSize', itemType: 'text', text: str_(UIStrings.columnFontSize)},
    ];

    const tableData = failingRules.sort((a, b) => b.textLength - a.textLength)
      .map(({cssRule, textLength, fontSize, parentNode}) => {
        const percentageOfAffectedText = textLength / totalTextLength * 100;
        const origin = findStyleRuleSource(pageUrl, cssRule, parentNode);

        return {
          source: origin.source,
          selector: origin.selector,
          coverage: `${percentageOfAffectedText.toFixed(2)}%`,
          fontSize: `${fontSize}px`,
        };
      });

    // all failing nodes that were not fully analyzed will be displayed in a single row
    if (analyzedFailingTextLength < failingTextLength) {
      const percentageOfUnanalyzedFailingText =
        (failingTextLength - analyzedFailingTextLength) / totalTextLength * 100;

      tableData.push({
        // Overrides default `source-location`
        source: {type: 'code', value: str_(UIStrings.additionalIllegibleText)},
        selector: '',
        coverage: `${percentageOfUnanalyzedFailingText.toFixed(2)}%`,
        fontSize: '< 12px',
      });
    }

    if (percentageOfPassingText > 0) {
      tableData.push({
        // Overrides default `source-location`
        source: {type: 'code', value: str_(UIStrings.legibleText)},
        selector: '',
        coverage: `${percentageOfPassingText.toFixed(2)}%`,
        fontSize: '≥ 12px',
      });
    }

    const decimalProportion = (percentageOfPassingText / 100);
    const displayValue = str_(UIStrings.displayValue, {decimalProportion});
    const details = Audit.makeTableDetails(headings, tableData);
    const passed = percentageOfPassingText >= MINIMAL_PERCENTAGE_OF_LEGIBLE_TEXT;

    return {
      score: Number(passed),
      details,
      displayValue,
    };
  }
}

module.exports = FontSize;
module.exports.UIStrings = UIStrings;

}).call(this)}).call(this,"/lighthouse-core/audits/seo/font-size.js")
},{"../../computed/viewport-meta.js":51,"../../lib/i18n/i18n.js":96,"../audit.js":3}],"../audits/seo/hreflang":[function(require,module,exports){
(function (__filename){(function (){
/**
 * @license Copyright 2017 The Lighthouse Authors. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.
 */
'use strict';

/** @typedef {string|LH.Audit.Details.NodeValue|undefined} Source */
/** @typedef {{source: Source, subItems: {type: 'subitems', items: SubItem[]}}} InvalidHreflang */
/** @typedef {{reason: LH.IcuMessage}} SubItem */

const Audit = require('../audit.js');
const i18n = require('../../lib/i18n/i18n.js');
const axeLibSource = require('../../lib/axe.js').source;

const VALID_LANGS = importValidLangs();
const NO_LANGUAGE = 'x-default';

const UIStrings = {
  /** Title of a Lighthouse audit that provides detail on the `hreflang` attribute on a page. This descriptive title is shown when the page's `hreflang` attribute is configured correctly. "hreflang" is an HTML attribute and should not be translated. */
  title: 'Document has a valid `hreflang`',
  /** Title of a Lighthouse audit that provides detail on the `hreflang` attribute on a page. This descriptive title is shown when the page's `hreflang` attribute is not valid and needs to be fixed. "hreflang" is an HTML attribute and should not be translated. */
  failureTitle: 'Document doesn\'t have a valid `hreflang`',
  /** Description of a Lighthouse audit that tells the user *why* they need to have an hreflang link on their page. This is displayed after a user expands the section to see more. No character length limits. 'Learn More' becomes link text to additional documentation. "hreflang" is an HTML attribute and should not be translated. */
  description: 'hreflang links tell search engines what version of a page they should ' +
    'list in search results for a given language or region. [Learn more]' +
    '(https://web.dev/hreflang/).',
  /** A failure reason for a Lighthouse audit that flags incorrect use of the `hreflang` attribute on `link` elements. This failure reason is shown when the hreflang language code is unexpected. */
  unexpectedLanguage: 'Unexpected language code',
  /** A failure reason for a Lighthouse audit that flags incorrect use of the `hreflang` attribute on `link` elements. This failure reason is shown when the `href` attribute value is not fully-qualified. */
  notFullyQualified: 'Relative href value',
};

const str_ = i18n.createMessageInstanceIdFn(__filename, UIStrings);

/**
 * Import list of valid languages from axe core.
 * This is a huge array of language codes that can be stored more efficiently if we will need to
 * shrink the bundle size.
 * @return {Array<string>}
 */
function importValidLangs() {
  // Define a window-ish object so axe will export to it.
  const window = {getComputedStyle: () => {}};
  eval(axeLibSource);
  // @ts-expect-error
  return window.axe.utils.validLangs();
}

/**
 * @param {string} href
 * @return {boolean}
 */
function isFullyQualified(href) {
  return href.startsWith('http:') || href.startsWith('https:');
}

/**
 * @param {string} hreflang
 * @return {boolean}
 */
function isExpectedLanguageCode(hreflang) {
  if (hreflang.toLowerCase() === NO_LANGUAGE) {
    return true;
  }

  // hreflang can consist of language-script-region, we are validating only language
  const [lang] = hreflang.split('-');
  return VALID_LANGS.includes(lang.toLowerCase());
}

class Hreflang extends Audit {
  /**
   * @return {LH.Audit.Meta}
   */
  static get meta() {
    return {
      id: 'hreflang',
      title: str_(UIStrings.title),
      failureTitle: str_(UIStrings.failureTitle),
      description: str_(UIStrings.description),
      supportedModes: ['navigation'],
      requiredArtifacts: ['LinkElements', 'URL'],
    };
  }

  /**
   * @param {LH.Artifacts} artifacts
   * @return {LH.Audit.Product}
   */
  static audit({LinkElements}) {
    /** @type {InvalidHreflang[]} */
    const invalidHreflangs = [];

    const auditableLinkElements = LinkElements.filter(linkElement => {
      const isAlternate = linkElement.rel === 'alternate';
      const hasHreflang = linkElement.hreflang;
      const isInBody = linkElement.source === 'body';

      return isAlternate && hasHreflang && !isInBody;
    });

    for (const link of auditableLinkElements) {
      const reasons = [];
      /** @type {Source} */
      let source;

      if (!isExpectedLanguageCode(link.hreflang)) {
        reasons.push(str_(UIStrings.unexpectedLanguage));
      }

      if (!isFullyQualified(link.hrefRaw.toLowerCase())) {
        reasons.push(str_(UIStrings.notFullyQualified));
      }

      if (link.source === 'head') {
        if (link.node) {
          source = {
            ...Audit.makeNodeItem(link.node),
            snippet: `<link rel="alternate" hreflang="${link.hreflang}" href="${link.hrefRaw}" />`,
          };
        } else {
          source = {
            type: 'node',
            snippet: `<link rel="alternate" hreflang="${link.hreflang}" href="${link.hrefRaw}" />`,
          };
        }
      } else if (link.source === 'headers') {
        source = `Link: <${link.hrefRaw}>; rel="alternate"; hreflang="${link.hreflang}"`;
      }

      if (!source || !reasons.length) continue;

      invalidHreflangs.push({
        source,
        subItems: {
          type: 'subitems',
          items: reasons.map(reason => ({reason})),
        },
      });
    }

    /** @type {LH.Audit.Details.Table['headings']} */
    const headings = [{
      key: 'source',
      itemType: 'code',
      subItemsHeading: {
        key: 'reason',
        itemType: 'text',
      },
      text: '',
    }];

    const details = Audit.makeTableDetails(headings, invalidHreflangs);

    return {
      score: Number(invalidHreflangs.length === 0),
      details,
    };
  }
}

module.exports = Hreflang;
module.exports.UIStrings = UIStrings;

}).call(this)}).call(this,"/lighthouse-core/audits/seo/hreflang.js")
},{"../../lib/axe.js":81,"../../lib/i18n/i18n.js":96,"../audit.js":3}],"../audits/seo/http-status-code":[function(require,module,exports){
(function (__filename){(function (){
/**
 * @license Copyright 2017 The Lighthouse Authors. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.
 */
'use strict';

const Audit = require('../audit.js');
const NetworkRecords = require('../../computed/network-records.js');
const HTTP_UNSUCCESSFUL_CODE_LOW = 400;
const HTTP_UNSUCCESSFUL_CODE_HIGH = 599;
const i18n = require('../../lib/i18n/i18n.js');
const NetworkAnalyzer = require('../../lib/dependency-graph/simulator/network-analyzer.js');

const UIStrings = {
  /** Title of a Lighthouse audit that provides detail on the HTTP status code a page responds with. This descriptive title is shown when the page has responded with a valid HTTP status code. */
  title: 'Page has successful HTTP status code',
  /** Descriptive title of a Lighthouse audit that provides detail on the HTTP status code a page responds with. This descriptive title is shown when the page responds to requests with an HTTP status code that indicates the request was unsuccessful. */
  failureTitle: 'Page has unsuccessful HTTP status code',
  /** Description of a Lighthouse audit that tells the user *why* they need to serve pages with a valid HTTP status code. This is displayed after a user expands the section to see more. No character length limits. 'Learn More' becomes link text to additional documentation. */
  description: 'Pages with unsuccessful HTTP status codes may not be indexed properly. ' +
  '[Learn more](https://web.dev/http-status-code/).',
};

const str_ = i18n.createMessageInstanceIdFn(__filename, UIStrings);

class HTTPStatusCode extends Audit {
  /**
   * @return {LH.Audit.Meta}
   */
  static get meta() {
    return {
      id: 'http-status-code',
      title: str_(UIStrings.title),
      failureTitle: str_(UIStrings.failureTitle),
      description: str_(UIStrings.description),
      requiredArtifacts: ['devtoolsLogs', 'URL', 'GatherContext'],
    };
  }

  /**
   * @param {LH.Artifacts} artifacts
   * @param {LH.Audit.Context} context
   * @return {Promise<LH.Audit.Product>}
   */
  static async audit(artifacts, context) {
    const devtoolsLog = artifacts.devtoolsLogs[Audit.DEFAULT_PASS];
    const URL = artifacts.URL;
    const networkRecords = await NetworkRecords.request(devtoolsLog, context);
    const mainResource = NetworkAnalyzer.findOptionalMainDocument(networkRecords, URL.finalUrl);

    if (!mainResource) {
      if (artifacts.GatherContext.gatherMode === 'timespan') return {notApplicable: true, score: 1};
      throw new Error(`Unable to locate main resource`);
    }

    const statusCode = mainResource.statusCode;

    if (statusCode >= HTTP_UNSUCCESSFUL_CODE_LOW &&
          statusCode <= HTTP_UNSUCCESSFUL_CODE_HIGH) {
      return {
        score: 0,
        displayValue: `${statusCode}`,
      };
    }

    return {
      score: 1,
    };
  }
}

module.exports = HTTPStatusCode;
module.exports.UIStrings = UIStrings;

}).call(this)}).call(this,"/lighthouse-core/audits/seo/http-status-code.js")
},{"../../computed/network-records.js":40,"../../lib/dependency-graph/simulator/network-analyzer.js":91,"../../lib/i18n/i18n.js":96,"../audit.js":3}],"../audits/seo/is-crawlable":[function(require,module,exports){
(function (__filename){(function (){
/**
 * @license Copyright 2017 The Lighthouse Authors. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.
 */
'use strict';

const Audit = require('../audit.js');
const robotsParser = require('robots-parser');
const URL = require('../../lib/url-shim.js');
const MainResource = require('../../computed/main-resource.js');
const BLOCKLIST = new Set([
  'noindex',
  'none',
]);
const ROBOTS_HEADER = 'x-robots-tag';
const UNAVAILABLE_AFTER = 'unavailable_after';
const i18n = require('../../lib/i18n/i18n.js');

const UIStrings = {
  /** Title of a Lighthouse audit that provides detail on if search-engine crawlers are blocked from indexing the page. This title is shown when the page is not blocked from indexing and can be crawled. */
  title: 'Page isn’t blocked from indexing',
  /** Title of a Lighthouse audit that provides detail on if search-engine crawlers are blocked from indexing the page. This title is shown when the page has been configured to block indexing and therefore cannot be indexed by search engines. */
  failureTitle: 'Page is blocked from indexing',
  /** Description of a Lighthouse audit that tells the user *why* allowing search-engine crawling of their page is beneficial. This is displayed after a user expands the section to see more. No character length limits. 'Learn More' becomes link text to additional documentation. */
  description: 'Search engines are unable to include your pages in search results ' +
      'if they don\'t have permission to crawl them. [Learn more](https://web.dev/is-crawable/).',
};

const str_ = i18n.createMessageInstanceIdFn(__filename, UIStrings);

/**
 * Checks if given directive is a valid unavailable_after directive with a date in the past
 * @param {string} directive
 * @return {boolean}
 */
function isUnavailable(directive) {
  const parts = directive.split(':');

  if (parts.length <= 1 || parts[0] !== UNAVAILABLE_AFTER) {
    return false;
  }

  const date = Date.parse(parts.slice(1).join(':'));

  return !isNaN(date) && date < Date.now();
}

/**
 * Returns true if any of provided directives blocks page from being indexed
 * @param {string} directives
 * @return {boolean}
 */
function hasBlockingDirective(directives) {
  return directives.split(',')
    .map(d => d.toLowerCase().trim())
    .some(d => BLOCKLIST.has(d) || isUnavailable(d));
}

/**
 * Returns true if robots header specifies user agent (e.g. `googlebot: noindex`)
 * @param {string} directives
 * @return {boolean}
 */
function hasUserAgent(directives) {
  const parts = directives.match(/^([^,:]+):/);

  // Check if directives are prefixed with `googlebot:`, `googlebot-news:`, `otherbot:`, etc.
  // but ignore `unavailable_after:` which is a valid directive
  return !!parts && parts[1].toLowerCase() !== UNAVAILABLE_AFTER;
}

class IsCrawlable extends Audit {
  /**
   * @return {LH.Audit.Meta}
   */
  static get meta() {
    return {
      id: 'is-crawlable',
      title: str_(UIStrings.title),
      failureTitle: str_(UIStrings.failureTitle),
      description: str_(UIStrings.description),
      supportedModes: ['navigation'],
      requiredArtifacts: ['MetaElements', 'RobotsTxt', 'URL', 'devtoolsLogs'],
    };
  }

  /**
   * @param {LH.Artifacts} artifacts
   * @param {LH.Audit.Context} context
   * @return {Promise<LH.Audit.Product>}
   */
  static audit(artifacts, context) {
    const devtoolsLog = artifacts.devtoolsLogs[Audit.DEFAULT_PASS];
    const metaRobots = artifacts.MetaElements.find(meta => meta.name === 'robots');

    return MainResource.request({devtoolsLog, URL: artifacts.URL}, context)
      .then(mainResource => {
        /** @type {LH.Audit.Details.Table['items']} */
        const blockingDirectives = [];

        if (metaRobots) {
          const metaRobotsContent = metaRobots.content || '';
          const isBlocking = hasBlockingDirective(metaRobotsContent);

          if (isBlocking) {
            blockingDirectives.push({
              source: {
                ...Audit.makeNodeItem(metaRobots.node),
                snippet: `<meta name="robots" content="${metaRobotsContent}" />`,
              },
            });
          }
        }

        mainResource.responseHeaders && mainResource.responseHeaders
          .filter(h => h.name.toLowerCase() === ROBOTS_HEADER && !hasUserAgent(h.value) &&
            hasBlockingDirective(h.value))
          .forEach(h => blockingDirectives.push({source: `${h.name}: ${h.value}`}));

        if (artifacts.RobotsTxt.content) {
          const robotsFileUrl = new URL('/robots.txt', mainResource.url);
          const robotsTxt = robotsParser(robotsFileUrl.href, artifacts.RobotsTxt.content);

          if (!robotsTxt.isAllowed(mainResource.url)) {
            const line = robotsTxt.getMatchingLineNumber(mainResource.url) || 1;
            blockingDirectives.push({
              source: {
                type: /** @type {'source-location'} */ ('source-location'),
                url: robotsFileUrl.href,
                urlProvider: /** @type {'network'} */ ('network'),
                line: line - 1,
                column: 0,
              },
            });
          }
        }

        /** @type {LH.Audit.Details.Table['headings']} */
        const headings = [
          {key: 'source', itemType: 'code', text: 'Blocking Directive Source'},
        ];
        const details = Audit.makeTableDetails(headings, blockingDirectives);

        return {
          score: Number(blockingDirectives.length === 0),
          details,
        };
      });
  }
}

module.exports = IsCrawlable;
module.exports.UIStrings = UIStrings;

}).call(this)}).call(this,"/lighthouse-core/audits/seo/is-crawlable.js")
},{"../../computed/main-resource.js":14,"../../lib/i18n/i18n.js":96,"../../lib/url-shim.js":"url","../audit.js":3,"robots-parser":228}],"../audits/seo/link-text":[function(require,module,exports){
(function (__filename){(function (){
/**
 * @license Copyright 2017 The Lighthouse Authors. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.
 */
'use strict';

const Audit = require('../audit.js');
const URL = require('../../lib/url-shim.js');
const BLOCKLIST = new Set([
  // English
  'click here',
  'click this',
  'go',
  'here',
  'information',
  'learn more',
  'more',
  'more info',
  'more information',
  'right here',
  'read more',
  'see more',
  'start',
  'this',
  // Japanese
  'ここをクリック',
  'こちらをクリック',
  'リンク',
  '続きを読む',
  '続く',
  '全文表示',
  // Spanish
  'click aquí',
  'click aqui',
  'clicka aquí',
  'clicka aqui',
  'pincha aquí',
  'pincha aqui',
  'aquí',
  'aqui',
  'más',
  'mas',
  'más información',
  'más informacion',
  'mas información',
  'mas informacion',
  'este',
  'enlace',
  'este enlace',
  'empezar',
  // Portuguese
  'clique aqui',
  'ir',
  'mais informação',
  'mais informações',
  'mais',
  'veja mais',
  // Korean
  '여기',
  '여기를 클릭',
  '클릭',
  '링크',
  '자세히',
  '자세히 보기',
  '계속',
  '이동',
  '전체 보기',
  // Swedish
  'här',
  'klicka här',
  'läs mer',
  'mer',
  'mer info',
  'mer information',
]);
const i18n = require('../../lib/i18n/i18n.js');

const UIStrings = {
  /** Title of a Lighthouse audit that tests if each link on a page contains a sufficient description of what a user will find when they click it. Generic, non-descriptive text like "click here" doesn't give an indication of what the link leads to. This descriptive title is shown when all links on the page have sufficient textual descriptions. */
  title: 'Links have descriptive text',
  /** Title of a Lighthouse audit that tests if each link on a page contains a sufficient description of what a user will find when they click it. Generic, non-descriptive text like "click here" doesn't give an indication of what the link leads to. This descriptive title is shown when one or more links on the page contain generic, non-descriptive text. */
  failureTitle: 'Links do not have descriptive text',
  /** Description of a Lighthouse audit that tells the user *why* they need to have descriptive text on the links in their page. This is displayed after a user expands the section to see more. No character length limits. 'Learn More' becomes link text to additional documentation. */
  description: 'Descriptive link text helps search engines understand your content. ' +
  '[Learn more](https://web.dev/link-text/).',
  /** [ICU Syntax] Label for the audit identifying the number of links found. "link" here refers to the links in a web page to other web pages. */
  displayValue: `{itemCount, plural,
    =1 {1 link found}
    other {# links found}
    }`,
};

const str_ = i18n.createMessageInstanceIdFn(__filename, UIStrings);

class LinkText extends Audit {
  /**
   * @return {LH.Audit.Meta}
   */
  static get meta() {
    return {
      id: 'link-text',
      title: str_(UIStrings.title),
      failureTitle: str_(UIStrings.failureTitle),
      description: str_(UIStrings.description),
      requiredArtifacts: ['URL', 'AnchorElements'],
    };
  }

  /**
   * @param {LH.Artifacts} artifacts
   * @return {LH.Audit.Product}
   */
  static audit(artifacts) {
    const failingLinks = artifacts.AnchorElements
      .filter(link => link.href && !link.rel.includes('nofollow'))
      .filter(link => {
        const href = link.href.toLowerCase();
        if (
          href.startsWith('javascript:') ||
          href.startsWith('mailto:') ||
          URL.equalWithExcludedFragments(link.href, artifacts.URL.finalUrl)
        ) {
          return false;
        }

        return BLOCKLIST.has(link.text.trim().toLowerCase());
      })
      .map(link => {
        return {
          href: link.href,
          text: link.text.trim(),
        };
      });

    /** @type {LH.Audit.Details.Table['headings']} */
    const headings = [
      {key: 'href', itemType: 'url', text: 'Link destination'},
      {key: 'text', itemType: 'text', text: 'Link Text'},
    ];

    const details = Audit.makeTableDetails(headings, failingLinks, {});
    let displayValue;

    if (failingLinks.length) {
      displayValue = str_(UIStrings.displayValue, {itemCount: failingLinks.length});
    }

    return {
      score: Number(failingLinks.length === 0),
      details,
      displayValue,
    };
  }
}

module.exports = LinkText;
module.exports.UIStrings = UIStrings;

}).call(this)}).call(this,"/lighthouse-core/audits/seo/link-text.js")
},{"../../lib/i18n/i18n.js":96,"../../lib/url-shim.js":"url","../audit.js":3}],"../audits/seo/manual/structured-data":[function(require,module,exports){
(function (__filename){(function (){
/**
 * @license Copyright 2017 The Lighthouse Authors. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.
 */
'use strict';

const ManualAudit = require('../../manual/manual-audit.js');
const i18n = require('../../../lib/i18n/i18n.js');

const UIStrings = {
  /** Description of a Lighthouse audit that provides detail on the structured data in a page. "Structured data" is a standardized data format on a page that helps a search engine categorize and understand its contents. This description is displayed after a user expands the section to see more. No character length limits. 'Learn More' becomes link text to additional documentation. */
  description: 'Run the [Structured Data Testing Tool](https://search.google.com/structured-data/testing-tool/) and the [Structured Data Linter](http://linter.structured-data.org/) to validate structured data. [Learn more](https://web.dev/structured-data/).',
  /** Title of a Lighthouse audit that prompts users to manually check their page for valid structured data. "Structured data" is a standardized data format on a page that helps a search engine categorize and understand its contents. */
  title: 'Structured data is valid',
};

const str_ = i18n.createMessageInstanceIdFn(__filename, UIStrings);

/**
 * @fileoverview Manual SEO audit to check if structured data on page is valid.
 */

class StructuredData extends ManualAudit {
  /**
   * @return {LH.Audit.Meta}
   */
  static get meta() {
    return Object.assign({
      id: 'structured-data',
      description: str_(UIStrings.description),
      title: str_(UIStrings.title),
    }, super.partialMeta);
  }
}

module.exports = StructuredData;
module.exports.UIStrings = UIStrings;

}).call(this)}).call(this,"/lighthouse-core/audits/seo/manual/structured-data.js")
},{"../../../lib/i18n/i18n.js":96,"../../manual/manual-audit.js":6}],"../audits/seo/meta-description":[function(require,module,exports){
(function (__filename){(function (){
/**
 * @license Copyright 2017 The Lighthouse Authors. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.
 */
'use strict';

const Audit = require('../audit.js');
const i18n = require('../../lib/i18n/i18n.js');

const UIStrings = {
  /** Title of a Lighthouse audit that provides detail on the web page's document meta description. This descriptive title is shown when the document has a meta description. "meta" should be left untranslated because it refers to an HTML element. */
  title: 'Document has a meta description',
  /** Title of a Lighthouse audit that provides detail on the web page's document meta description. This descriptive title is shown when the document does not have a meta description. "meta" should be left untranslated because it refers to an HTML element. */
  failureTitle: 'Document does not have a meta description',
  /** Description of a Lighthouse audit that tells the user *why* they need to have meta descriptions on their page. This is displayed after a user expands the section to see more. No character length limits. 'Learn More' becomes link text to additional documentation. */
  description: 'Meta descriptions may be included in search results to concisely summarize ' +
      'page content. ' +
      '[Learn more](https://web.dev/meta-description/).',
  /** Explanatory message stating that there was a failure in an audit caused by the page's meta description text being empty. */
  explanation: 'Description text is empty.',
};

const str_ = i18n.createMessageInstanceIdFn(__filename, UIStrings);

class Description extends Audit {
  /**
   * @return {LH.Audit.Meta}
   */
  static get meta() {
    return {
      id: 'meta-description',
      title: str_(UIStrings.title),
      failureTitle: str_(UIStrings.failureTitle),
      description: str_(UIStrings.description),
      requiredArtifacts: ['MetaElements'],
    };
  }

  /**
   * @param {LH.Artifacts} artifacts
   * @return {LH.Audit.Product}
   */
  static audit(artifacts) {
    const metaDescription = artifacts.MetaElements.find(meta => meta.name === 'description');
    if (!metaDescription) {
      return {
        score: 0,
      };
    }

    const description = metaDescription.content || '';
    if (description.trim().length === 0) {
      return {
        score: 0,
        explanation: str_(UIStrings.explanation),
      };
    }

    return {
      score: 1,
    };
  }
}

module.exports = Description;
module.exports.UIStrings = UIStrings;

}).call(this)}).call(this,"/lighthouse-core/audits/seo/meta-description.js")
},{"../../lib/i18n/i18n.js":96,"../audit.js":3}],"../audits/seo/plugins":[function(require,module,exports){
(function (__filename){(function (){
/**
 * @license Copyright 2018 The Lighthouse Authors. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.
 */
'use strict';

const Audit = require('../audit.js');
const URL = require('../../lib/url-shim.js');

const JAVA_APPLET_TYPE = 'application/x-java-applet';
const JAVA_BEAN_TYPE = 'application/x-java-bean';
const TYPE_BLOCKLIST = new Set([
  'application/x-shockwave-flash',
  // See https://docs.oracle.com/cd/E19683-01/816-0378/using_tags/index.html
  JAVA_APPLET_TYPE,
  JAVA_BEAN_TYPE,
  // See https://msdn.microsoft.com/es-es/library/cc265156(v=vs.95).aspx
  'application/x-silverlight',
  'application/x-silverlight-2',
]);
const FILE_EXTENSION_BLOCKLIST = new Set([
  'swf',
  'flv',
  'class',
  'xap',
]);
const SOURCE_PARAMS = new Set([
  'code',
  'movie',
  'source',
  'src',
]);
const i18n = require('../../lib/i18n/i18n.js');

const UIStrings = {
  /** Title of a Lighthouse audit that provides detail on the browser plugins used by the page. This descriptive title is shown when there is no plugin content on the page that would restrict search indexing. */
  title: 'Document avoids plugins',
  /** Descriptive title of a Lighthouse audit that provides detail on the browser plugins used by the page. This title is shown when there is plugin content on the page. */
  failureTitle: 'Document uses plugins',
  /** Description of a Lighthouse audit that tells the user *why* they need to avoid using browser plugins in their content. This is displayed after a user expands the section to see more. No character length limits. 'Learn More' becomes link text to additional documentation. */
  description: 'Search engines can\'t index plugin content, and ' +
    'many devices restrict plugins or don\'t support them. ' +
    '[Learn more](https://web.dev/plugins/).',
};

const str_ = i18n.createMessageInstanceIdFn(__filename, UIStrings);

/**
 * Verifies if given MIME type matches any known plugin MIME type
 * @param {string} type
 * @return {boolean}
 */
function isPluginType(type) {
  type = type.trim().toLowerCase();

  return TYPE_BLOCKLIST.has(type) ||
    type.startsWith(JAVA_APPLET_TYPE) || // e.g. "application/x-java-applet;jpi-version=1.4"
    type.startsWith(JAVA_BEAN_TYPE);
}

/**
 * Verifies if given url points to a file that has a known plugin extension
 * @param {string} url
 * @return {boolean}
 */
function isPluginURL(url) {
  try {
    // in order to support relative URLs we need to provied a base URL
    const filePath = new URL(url, 'http://example.com').pathname;
    const parts = filePath.split('.');

    if (parts.length < 2) {
      return false;
    }
    const part = parts[parts.length - 1];
    return FILE_EXTENSION_BLOCKLIST.has(part.trim().toLowerCase());
  } catch (e) {
    return false;
  }
}

class Plugins extends Audit {
  /**
   * @return {LH.Audit.Meta}
   */
  static get meta() {
    return {
      id: 'plugins',
      title: str_(UIStrings.title),
      failureTitle: str_(UIStrings.failureTitle),
      description: str_(UIStrings.description),
      requiredArtifacts: ['EmbeddedContent'],
    };
  }

  /**
   * @param {LH.Artifacts} artifacts
   * @return {LH.Audit.Product}
   */
  static audit(artifacts) {
    const plugins = artifacts.EmbeddedContent
      .filter(item => {
        if (item.tagName === 'APPLET') {
          return true;
        }

        if (
          (item.tagName === 'EMBED' || item.tagName === 'OBJECT') &&
          item.type &&
          isPluginType(item.type)
        ) {
          return true;
        }

        const embedSrc = item.src || item.code;
        if (item.tagName === 'EMBED' && embedSrc && isPluginURL(embedSrc)) {
          return true;
        }

        if (item.tagName === 'OBJECT' && item.data && isPluginURL(item.data)) {
          return true;
        }

        const failingParams = item.params.filter(param =>
          SOURCE_PARAMS.has(param.name.trim().toLowerCase()) && isPluginURL(param.value)
        );

        return failingParams.length > 0;
      })
      .map(plugin => {
        return {
          source: Audit.makeNodeItem(plugin.node),
        };
      });

    /** @type {LH.Audit.Details.Table['headings']} */
    const headings = [
      {key: 'source', itemType: 'code', text: 'Element source'},
    ];

    const details = Audit.makeTableDetails(headings, plugins);

    return {
      score: Number(plugins.length === 0),
      details,
    };
  }
}

module.exports = Plugins;
module.exports.UIStrings = UIStrings;

}).call(this)}).call(this,"/lighthouse-core/audits/seo/plugins.js")
},{"../../lib/i18n/i18n.js":96,"../../lib/url-shim.js":"url","../audit.js":3}],"../audits/seo/robots-txt":[function(require,module,exports){
(function (__filename){(function (){
/**
 * @license Copyright 2018 The Lighthouse Authors. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.
 */
'use strict';

/**
 * @fileoverview Validates robots.txt file according to the official standard and its various
 * extensions respected by the popular web crawlers.
 * Validator rules, and the resources backing these rules, can be found here:
 * https://github.com/GoogleChrome/lighthouse/issues/4356#issuecomment-375489925
 */

const Audit = require('../audit.js');
const URL = require('../../lib/url-shim.js');

const HTTP_CLIENT_ERROR_CODE_LOW = 400;
const HTTP_SERVER_ERROR_CODE_LOW = 500;

const DIRECTIVE_SITEMAP = 'sitemap';
const DIRECTIVE_USER_AGENT = 'user-agent';
const DIRECTIVE_ALLOW = 'allow';
const DIRECTIVE_DISALLOW = 'disallow';
const DIRECTIVES_GROUP_MEMBERS = new Set([DIRECTIVE_ALLOW, DIRECTIVE_DISALLOW]);
const DIRECTIVE_SAFELIST = new Set([
  DIRECTIVE_USER_AGENT, DIRECTIVE_DISALLOW, // standard
  DIRECTIVE_ALLOW, DIRECTIVE_SITEMAP, // universally supported
  'crawl-delay', // yahoo, bing, yandex
  'clean-param', 'host', // yandex
  'request-rate', 'visit-time', 'noindex', // not officially supported, but used in the wild
]);
const SITEMAP_VALID_PROTOCOLS = new Set(['https:', 'http:', 'ftp:']);
const i18n = require('../../lib/i18n/i18n.js');

const UIStrings = {
  /** Title of a Lighthouse audit that provides detail on the site's robots.txt file. Note: "robots.txt" is a canonical filename and should not be translated. This descriptive title is shown when the robots.txt file is present and configured correctly. */
  title: 'robots.txt is valid',
  /** Title of a Lighthouse audit that provides detail on the site's robots.txt file. Note: "robots.txt" is a canonical filename and should not be translated. This descriptive title is shown when the robots.txt file is misconfigured, which makes the page hard or impossible to scan via web crawler. */
  failureTitle: 'robots.txt is not valid',
  /** Description of a Lighthouse audit that tells the user *why* they need to have a valid robots.txt file. Note: "robots.txt" is a canonical filename and should not be translated. This is displayed after a user expands the section to see more. No character length limits. */
  description: 'If your robots.txt file is malformed, crawlers may not be able to understand ' +
  'how you want your website to be crawled or indexed. [Learn more](https://web.dev/robots-txt/).',
  /**
   * @description Label for the audit identifying that the robots.txt request has returned a specific HTTP status code. Note: "robots.txt" is a canonical filename and should not be translated.
   * @example {500} statusCode
   * */
  displayValueHttpBadCode: 'Request for robots.txt returned HTTP status: {statusCode}',
  /** [ICU Syntax] Label for the audit identifying the number of errors that occured while validating the robots.txt file. "itemCount" will be replaced by the integer count of errors encountered. */
  displayValueValidationError: `{itemCount, plural,
    =1 {1 error found}
    other {# errors found}
    }`,
  /** Explanatory message stating that there was a failure in an audit caused by Lighthouse not being able to download the robots.txt file for the site.  Note: "robots.txt" is a canonical filename and should not be translated. */
  explanation: 'Lighthouse was unable to download a robots.txt file',
};

const str_ = i18n.createMessageInstanceIdFn(__filename, UIStrings);

/**
 * @param {string} directiveName
 * @param {string} directiveValue
 * @throws will throw an exception if given directive is invalid
 */
function verifyDirective(directiveName, directiveValue) {
  if (!DIRECTIVE_SAFELIST.has(directiveName)) {
    throw new Error('Unknown directive');
  }

  if (directiveName === DIRECTIVE_SITEMAP) {
    let sitemapUrl;

    try {
      sitemapUrl = new URL(directiveValue);
    } catch (e) {
      throw new Error('Invalid sitemap URL');
    }

    if (!SITEMAP_VALID_PROTOCOLS.has(sitemapUrl.protocol)) {
      throw new Error('Invalid sitemap URL protocol');
    }
  }

  if (directiveName === DIRECTIVE_USER_AGENT && !directiveValue) {
    throw new Error('No user-agent specified');
  }

  if (directiveName === DIRECTIVE_ALLOW || directiveName === DIRECTIVE_DISALLOW) {
    if (directiveValue !== '' && directiveValue[0] !== '/' && directiveValue[0] !== '*') {
      throw new Error('Pattern should either be empty, start with "/" or "*"');
    }

    const dollarIndex = directiveValue.indexOf('$');

    if (dollarIndex !== -1 && dollarIndex !== directiveValue.length - 1) {
      throw new Error('"$" should only be used at the end of the pattern');
    }
  }
}

/**
 * @param {string} line single line from a robots.txt file
 * @throws will throw an exception if given line has errors
 * @return {{directive: string, value: string}|null}
 */
function parseLine(line) {
  const hashIndex = line.indexOf('#');

  if (hashIndex !== -1) {
    line = line.substr(0, hashIndex);
  }

  line = line.trim();

  if (line.length === 0) {
    return null;
  }

  const colonIndex = line.indexOf(':');

  if (colonIndex === -1) {
    throw new Error('Syntax not understood');
  }

  const directiveName = line.slice(0, colonIndex).trim().toLowerCase();
  const directiveValue = line.slice(colonIndex + 1).trim();

  verifyDirective(directiveName, directiveValue);

  return {
    directive: directiveName,
    value: directiveValue,
  };
}

/**
 * @param {string} content
 * @return {Array<{index: string, line: string, message: string}>}
 */
function validateRobots(content) {
  /**
   * @type Array<{index: string, line: string, message: string}>
   */
  const errors = [];
  let inGroup = false;

  content
    .split(/\r\n|\r|\n/)
    .forEach((line, index) => {
      let parsedLine;

      try {
        parsedLine = parseLine(line);
      } catch (e) {
        errors.push({
          index: (index + 1).toString(),
          line: line,
          message: e.message.toString(),
        });
      }

      if (!parsedLine) {
        return;
      }

      // group-member records (allow, disallow) have to be precided with a start-of-group record (user-agent)
      // see: https://developers.google.com/search/reference/robots_txt#grouping-of-records
      if (parsedLine.directive === DIRECTIVE_USER_AGENT) {
        inGroup = true;
      } else if (!inGroup && DIRECTIVES_GROUP_MEMBERS.has(parsedLine.directive)) {
        errors.push({
          index: (index + 1).toString(),
          line: line,
          message: 'No user-agent specified',
        });
      }
    });

  return errors;
}

class RobotsTxt extends Audit {
  /**
   * @return {LH.Audit.Meta}
   */
  static get meta() {
    return {
      id: 'robots-txt',
      title: str_(UIStrings.title),
      failureTitle: str_(UIStrings.failureTitle),
      description: str_(UIStrings.description),
      requiredArtifacts: ['RobotsTxt'],
    };
  }

  /**
   * @param {LH.Artifacts} artifacts
   * @return {LH.Audit.Product}
   */
  static audit(artifacts) {
    const {
      status,
      content,
    } = artifacts.RobotsTxt;

    if (!status) {
      return {
        score: 0,
        explanation: str_(UIStrings.explanation),
      };
    }

    if (status >= HTTP_SERVER_ERROR_CODE_LOW) {
      return {
        score: 0,
        displayValue: str_(UIStrings.displayValueHttpBadCode, {statusCode: status}),
      };
    } else if (status >= HTTP_CLIENT_ERROR_CODE_LOW || content === '') {
      return {
        score: 1,
        notApplicable: true,
      };
    }

    // If status is good, content must be not null.
    if (content === null) {
      throw new Error(`Status ${status} was valid, but content was null`);
    }

    const validationErrors = validateRobots(content);

    /** @type {LH.Audit.Details.Table['headings']} */
    const headings = [
      {key: 'index', itemType: 'text', text: 'Line #'},
      {key: 'line', itemType: 'code', text: 'Content'},
      {key: 'message', itemType: 'code', text: 'Error'},
    ];

    const details = Audit.makeTableDetails(headings, validationErrors, {});
    let displayValue;

    if (validationErrors.length) {
      displayValue =
        str_(UIStrings.displayValueValidationError, {itemCount: validationErrors.length});
    }

    return {
      score: Number(validationErrors.length === 0),
      details,
      displayValue,
    };
  }
}

module.exports = RobotsTxt;
module.exports.UIStrings = UIStrings;

}).call(this)}).call(this,"/lighthouse-core/audits/seo/robots-txt.js")
},{"../../lib/i18n/i18n.js":96,"../../lib/url-shim.js":"url","../audit.js":3}],"../audits/seo/tap-targets":[function(require,module,exports){
(function (__filename){(function (){
/**
 * @license Copyright 2018 The Lighthouse Authors. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.
 */
'use strict';

/**
 * @fileoverview Checks that links, buttons, etc. are sufficiently large and that there's
 * no other tap target that's too close so that the user might accidentally tap on.
 */
const Audit = require('../audit.js');
const ComputedViewportMeta = require('../../computed/viewport-meta.js');
const {
  rectsTouchOrOverlap,
  getRectOverlapArea,
  getRectAtCenter,
  allRectsContainedWithinEachOther,
  getLargestRect,
  getBoundingRectWithPadding,
} = require('../../lib/rect-helpers.js');
const {getTappableRectsFromClientRects} = require('../../lib/tappable-rects.js');
const i18n = require('../../lib/i18n/i18n.js');

const UIStrings = {
  /** Title of a Lighthouse audit that provides detail on whether tap targets (like buttons and links) on a page are big enough so they can easily be tapped on a mobile device. This descriptive title is shown when tap targets are easy to tap on. */
  title: 'Tap targets are sized appropriately',
  /** Descriptive title of a Lighthouse audit that provides detail on whether tap targets (like buttons and links) on a page are big enough so they can easily be tapped on a mobile device. This descriptive title is shown when tap targets are not easy to tap on. */
  failureTitle: 'Tap targets are not sized appropriately',
  /** Description of a Lighthouse audit that tells the user why buttons and links need to be big enough and what 'big enough' means. This is displayed after a user expands the section to see more. No character length limits. 'Learn More' becomes link text to additional documentation. */
  description: 'Interactive elements like buttons and links should be large enough (48x48px), and have enough space around them, to be easy enough to tap without overlapping onto other elements. [Learn more](https://web.dev/tap-targets/).',
  /** Label of a table column that identifies tap targets (like buttons and links) that have failed the audit and aren't easy to tap on. */
  tapTargetHeader: 'Tap Target',
  /** Label of a table column that identifies a tap target (like a link or button) that overlaps with another tap target. */
  overlappingTargetHeader: 'Overlapping Target',
  /** Explanatory message stating that there was a failure in an audit caused by the viewport meta tag not being optimized for mobile screens, which caused tap targets like buttons and links to be too small to tap on. */
  /* eslint-disable-next-line max-len */
  explanationViewportMetaNotOptimized: 'Tap targets are too small because there\'s no viewport meta tag optimized for mobile screens',
  /** Explanatory message stating that a certain percentage of the tap targets (like buttons and links) on the page are of an appropriately large size. */
  displayValue: '{decimalProportion, number, percent} appropriately sized tap targets',
};

const str_ = i18n.createMessageInstanceIdFn(__filename, UIStrings);

const FINGER_SIZE_PX = 48;
// Ratio of the finger area tapping on an unintended element
// to the finger area tapping on the intended element
const MAX_ACCEPTABLE_OVERLAP_SCORE_RATIO = 0.25;

/**
 * Returns a tap target augmented with a bounding rect for quick overlapping
 * rejections. Rect contains all the client rects, padded to half FINGER_SIZE_PX.
 * @param {LH.Artifacts.TapTarget[]} targets
 * @return {BoundedTapTarget[]}
 */
function getBoundedTapTargets(targets) {
  return targets.map(tapTarget => {
    return {
      tapTarget,
      paddedBoundsRect: getBoundingRectWithPadding(tapTarget.clientRects, FINGER_SIZE_PX),
    };
  });
}

/**
 * @param {LH.Artifacts.Rect} cr
 */
function clientRectBelowMinimumSize(cr) {
  return cr.width < FINGER_SIZE_PX || cr.height < FINGER_SIZE_PX;
}

/**
 * A target is "too small" if none of its clientRects are at least the size of a finger.
 * @param {BoundedTapTarget[]} targets
 * @return {BoundedTapTarget[]}
 */
function getTooSmallTargets(targets) {
  return targets.filter(target => {
    return target.tapTarget.clientRects.every(clientRectBelowMinimumSize);
  });
}

/**
 * @param {BoundedTapTarget[]} tooSmallTargets
 * @param {BoundedTapTarget[]} allTargets
 * @return {TapTargetOverlapFailure[]}
 */
function getAllOverlapFailures(tooSmallTargets, allTargets) {
  /** @type {TapTargetOverlapFailure[]} */
  const failures = [];

  tooSmallTargets.forEach(target => {
    // Convert client rects to unique tappable areas from a user's perspective
    const tappableRects = getTappableRectsFromClientRects(target.tapTarget.clientRects);

    for (const maybeOverlappingTarget of allTargets) {
      if (maybeOverlappingTarget === target) {
        // Checking the same target with itself, skip.
        continue;
      }

      if (!rectsTouchOrOverlap(target.paddedBoundsRect, maybeOverlappingTarget.paddedBoundsRect)) {
        // Bounding boxes (padded with half FINGER_SIZE_PX) don't overlap, skip.
        continue;
      }

      if (target.tapTarget.href === maybeOverlappingTarget.tapTarget.href) {
        const isHttpOrHttpsLink = /https?:\/\//.test(target.tapTarget.href);
        if (isHttpOrHttpsLink) {
          // No overlap because same target action, skip.
          continue;
        }
      }

      const maybeOverlappingRects = maybeOverlappingTarget.tapTarget.clientRects;
      if (allRectsContainedWithinEachOther(tappableRects, maybeOverlappingRects)) {
        // If one tap target is fully contained within the other that's
        // probably intentional (e.g. an item with a delete button inside).
        // We'll miss some problems because of this, but that's better
        // than falsely reporting a failure.
        continue;
      }

      const rectFailure = getOverlapFailureForTargetPair(tappableRects, maybeOverlappingRects);
      if (rectFailure) {
        failures.push({
          ...rectFailure,
          tapTarget: target.tapTarget,
          overlappingTarget: maybeOverlappingTarget.tapTarget,
        });
      }
    }
  });

  return failures;
}

/**
 * @param {LH.Artifacts.Rect[]} tappableRects
 * @param {LH.Artifacts.Rect[]} maybeOverlappingRects
 * @return {ClientRectOverlapFailure | null}
 */
function getOverlapFailureForTargetPair(tappableRects, maybeOverlappingRects) {
  /** @type ClientRectOverlapFailure | null */
  let greatestFailure = null;

  for (const targetCR of tappableRects) {
    const fingerRect = getRectAtCenter(targetCR, FINGER_SIZE_PX);
    // Score indicates how much of the finger area overlaps each target when the user
    // taps on the center of targetCR
    const tapTargetScore = getRectOverlapArea(fingerRect, targetCR);

    for (const maybeOverlappingCR of maybeOverlappingRects) {
      const overlappingTargetScore = getRectOverlapArea(fingerRect, maybeOverlappingCR);

      const overlapScoreRatio = overlappingTargetScore / tapTargetScore;
      if (overlapScoreRatio < MAX_ACCEPTABLE_OVERLAP_SCORE_RATIO) {
        // low score means it's clear that the user tried to tap on the targetCR,
        // rather than the other tap target client rect
        continue;
      }

      // only update our state if this was the biggest failure we've seen for this pair
      if (!greatestFailure || overlapScoreRatio > greatestFailure.overlapScoreRatio) {
        greatestFailure = {
          overlapScoreRatio,
          tapTargetScore,
          overlappingTargetScore,
        };
      }
    }
  }
  return greatestFailure;
}

/**
 * Only report one failure if two targets overlap each other
 * @param {TapTargetOverlapFailure[]} overlapFailures
 * @return {TapTargetOverlapFailure[]}
 */
function mergeSymmetricFailures(overlapFailures) {
  /** @type TapTargetOverlapFailure[] */
  const failuresAfterMerging = [];

  overlapFailures.forEach((failure, overlapFailureIndex) => {
    const symmetricFailure = overlapFailures.find(f =>
      f.tapTarget === failure.overlappingTarget &&
      f.overlappingTarget === failure.tapTarget
    );

    if (!symmetricFailure) {
      failuresAfterMerging.push(failure);
      return;
    }

    const {overlapScoreRatio: failureOSR} = failure;
    const {overlapScoreRatio: symmetricOSR} = symmetricFailure;
    // Push if:
    // - the current failure has a higher OSR
    // - OSRs are the same, and the current failure comes before its symmetric partner in the list
    // Otherwise do nothing and let the symmetric partner be pushed later.
    if (failureOSR > symmetricOSR || (
      failureOSR === symmetricOSR &&
      overlapFailureIndex < overlapFailures.indexOf(symmetricFailure)
    )) {
      failuresAfterMerging.push(failure);
    }
  });

  return failuresAfterMerging;
}

/**
 * @param {TapTargetOverlapFailure[]} overlapFailures
 * @return {TapTargetTableItem[]}
 */
function getTableItems(overlapFailures) {
  const tableItems = overlapFailures.map(failure => {
    const largestCR = getLargestRect(failure.tapTarget.clientRects);
    const width = Math.floor(largestCR.width);
    const height = Math.floor(largestCR.height);
    const size = width + 'x' + height;
    return {
      tapTarget: Audit.makeNodeItem(failure.tapTarget.node),
      overlappingTarget: Audit.makeNodeItem(failure.overlappingTarget.node),
      tapTargetScore: failure.tapTargetScore,
      overlappingTargetScore: failure.overlappingTargetScore,
      overlapScoreRatio: failure.overlapScoreRatio,
      size,
      width,
      height,
    };
  });

  tableItems.sort((a, b) => {
    return b.overlapScoreRatio - a.overlapScoreRatio;
  });

  return tableItems;
}

class TapTargets extends Audit {
  /**
   * @return {LH.Audit.Meta}
   */
  static get meta() {
    return {
      id: 'tap-targets',
      title: str_(UIStrings.title),
      failureTitle: str_(UIStrings.failureTitle),
      description: str_(UIStrings.description),
      requiredArtifacts: ['MetaElements', 'TapTargets'],
    };
  }

  /**
   * @param {LH.Artifacts} artifacts
   * @param {LH.Audit.Context} context
   * @return {Promise<LH.Audit.Product>}
   */
  static async audit(artifacts, context) {
    if (context.settings.formFactor === 'desktop') {
      // Tap target sizes aren't important for desktop SEO, so disable the audit there.
      // On desktop people also tend to have more precise pointing devices than fingers.
      return {
        score: 1,
        notApplicable: true,
      };
    }

    const viewportMeta = await ComputedViewportMeta.request(artifacts.MetaElements, context);
    if (!viewportMeta.isMobileOptimized) {
      return {
        score: 0,
        explanation: str_(UIStrings.explanationViewportMetaNotOptimized),
      };
    }

    // Augment the targets with padded bounding rects for quick intersection testing.
    const boundedTapTargets = getBoundedTapTargets(artifacts.TapTargets);

    const tooSmallTargets = getTooSmallTargets(boundedTapTargets);
    const overlapFailures = getAllOverlapFailures(tooSmallTargets, boundedTapTargets);
    const overlapFailuresForDisplay = mergeSymmetricFailures(overlapFailures);
    const tableItems = getTableItems(overlapFailuresForDisplay);

    /** @type {LH.Audit.Details.Table['headings']} */
    const headings = [
      {key: 'tapTarget', itemType: 'node', text: str_(UIStrings.tapTargetHeader)},
      {key: 'size', itemType: 'text', text: str_(i18n.UIStrings.columnSize)},
      {key: 'overlappingTarget', itemType: 'node', text: str_(UIStrings.overlappingTargetHeader)},
    ];

    const details = Audit.makeTableDetails(headings, tableItems);

    const tapTargetCount = artifacts.TapTargets.length;
    const failingTapTargetCount = new Set(overlapFailures.map(f => f.tapTarget)).size;
    const passingTapTargetCount = tapTargetCount - failingTapTargetCount;

    let score = 1;
    let passingTapTargetRatio = 1;
    if (failingTapTargetCount > 0) {
      passingTapTargetRatio = (passingTapTargetCount / tapTargetCount);
      // If there are any failures then we don't want the audit to pass,
      // so keep the score below 90.
      score = passingTapTargetRatio * 0.89;
    }
    const displayValue = str_(UIStrings.displayValue, {decimalProportion: passingTapTargetRatio});

    return {
      score,
      details,
      displayValue,
    };
  }
}

TapTargets.FINGER_SIZE_PX = FINGER_SIZE_PX;

module.exports = TapTargets;
module.exports.UIStrings = UIStrings;


/** @typedef {{
  overlapScoreRatio: number;
  tapTargetScore: number;
  overlappingTargetScore: number;
}} ClientRectOverlapFailure */

/** @typedef {{
  overlapScoreRatio: number;
  tapTargetScore: number;
  overlappingTargetScore: number;
  tapTarget: LH.Artifacts.TapTarget;
  overlappingTarget: LH.Artifacts.TapTarget;
}} TapTargetOverlapFailure */

/** @typedef {{
  paddedBoundsRect: LH.Artifacts.Rect;
  tapTarget: LH.Artifacts.TapTarget;
}} BoundedTapTarget */

/** @typedef {{
  tapTarget: LH.Audit.Details.NodeValue;
  overlappingTarget: LH.Audit.Details.NodeValue;
  size: string;
  overlapScoreRatio: number;
  height: number;
  width: number;
  tapTargetScore: number;
  overlappingTargetScore: number;
}} TapTargetTableItem */

}).call(this)}).call(this,"/lighthouse-core/audits/seo/tap-targets.js")
},{"../../computed/viewport-meta.js":51,"../../lib/i18n/i18n.js":96,"../../lib/rect-helpers.js":111,"../../lib/tappable-rects.js":115,"../audit.js":3}],"../audits/server-response-time":[function(require,module,exports){
(function (__filename){(function (){
/**
 * @license Copyright 2017 The Lighthouse Authors. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.
 */
'use strict';

const Audit = require('./audit.js');
const i18n = require('../lib/i18n/i18n.js');
const MainResource = require('../computed/main-resource.js');
const NetworkRecords = require('../computed/network-records.js');
const NetworkAnalyzer = require('../lib/dependency-graph/simulator/network-analyzer.js');

const UIStrings = {
  /** Title of a diagnostic audit that provides detail on how long it took from starting a request to when the server started responding. This descriptive title is shown to users when the amount is acceptable and no user action is required. */
  title: 'Initial server response time was short',
  /** Title of a diagnostic audit that provides detail on how long it took from starting a request to when the server started responding. This imperative title is shown to users when there is a significant amount of execution time that could be reduced. */
  failureTitle: 'Reduce initial server response time',
  /** Description of a Lighthouse audit that tells the user *why* they should reduce the amount of time it takes their server to start responding to requests. This is displayed after a user expands the section to see more. No character length limits. 'Learn More' becomes link text to additional documentation. */
  description: 'Keep the server response time for the main document short because all other requests depend on it. [Learn more](https://web.dev/time-to-first-byte/).',
  /** Used to summarize the total Server Response Time duration for the primary HTML response. The `{timeInMs}` placeholder will be replaced with the time duration, shown in milliseconds (e.g. 210 ms) */
  displayValue: `Root document took {timeInMs, number, milliseconds}\xa0ms`,
};

const str_ = i18n.createMessageInstanceIdFn(__filename, UIStrings);

// Due to the way that DevTools throttling works we cannot see if server response took less than ~570ms.
// We set our failure threshold to 600ms to avoid those false positives but we want devs to shoot for 100ms.
const TOO_SLOW_THRESHOLD_MS = 600;
const TARGET_MS = 100;

class ServerResponseTime extends Audit {
  /**
   * @return {LH.Audit.Meta}
   */
  static get meta() {
    return {
      id: 'server-response-time',
      title: str_(UIStrings.title),
      failureTitle: str_(UIStrings.failureTitle),
      description: str_(UIStrings.description),
      supportedModes: ['timespan', 'navigation'],
      requiredArtifacts: ['devtoolsLogs', 'URL', 'GatherContext'],
    };
  }

  /**
   * @param {LH.Artifacts.NetworkRequest} record
   */
  static calculateResponseTime(record) {
    const timing = record.timing;
    return timing ? timing.receiveHeadersEnd - timing.sendEnd : 0;
  }

  /**
   * @param {LH.Artifacts} artifacts
   * @param {LH.Audit.Context} context
   * @return {Promise<LH.Audit.Product>}
   */
  static async audit(artifacts, context) {
    const devtoolsLog = artifacts.devtoolsLogs[Audit.DEFAULT_PASS];

    /** @type {LH.Artifacts.NetworkRequest} */
    let mainResource;
    if (artifacts.GatherContext.gatherMode === 'timespan') {
      const networkRecords = await NetworkRecords.request(devtoolsLog, context);
      const optionalMainResource = NetworkAnalyzer.findOptionalMainDocument(
        networkRecords,
        artifacts.URL.finalUrl
      );
      if (!optionalMainResource) {
        return {score: null, notApplicable: true};
      }
      mainResource = optionalMainResource;
    } else {
      mainResource = await MainResource.request({devtoolsLog, URL: artifacts.URL}, context);
    }

    const responseTime = ServerResponseTime.calculateResponseTime(mainResource);
    const passed = responseTime < TOO_SLOW_THRESHOLD_MS;
    const displayValue = str_(UIStrings.displayValue, {timeInMs: responseTime});

    /** @type {LH.Audit.Details.Opportunity['headings']} */
    const headings = [
      {key: 'url', valueType: 'url', label: str_(i18n.UIStrings.columnURL)},
      {key: 'responseTime', valueType: 'timespanMs', label: str_(i18n.UIStrings.columnTimeSpent)},
    ];

    const details = Audit.makeOpportunityDetails(
      headings,
      [{url: mainResource.url, responseTime}],
      responseTime - TARGET_MS
    );

    return {
      numericValue: responseTime,
      numericUnit: 'millisecond',
      score: Number(passed),
      displayValue,
      details,
    };
  }
}

module.exports = ServerResponseTime;
module.exports.UIStrings = UIStrings;

}).call(this)}).call(this,"/lighthouse-core/audits/server-response-time.js")
},{"../computed/main-resource.js":14,"../computed/network-records.js":40,"../lib/dependency-graph/simulator/network-analyzer.js":91,"../lib/i18n/i18n.js":96,"./audit.js":3}],"../audits/service-worker":[function(require,module,exports){
(function (__filename){(function (){
/**
 * @license Copyright 2016 The Lighthouse Authors. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.
 */
'use strict';

const URL = require('../lib/url-shim.js');
const Audit = require('./audit.js');
const i18n = require('../lib/i18n/i18n.js');

const UIStrings = {
  /** Title of a Lighthouse audit that provides detail on a page's service worker. This descriptive title is shown to users when a service worker is registered and valid. */
  title: 'Registers a service worker that controls page and `start_url`',
  /** Title of a Lighthouse audit that provides detail on a page's service worker. This descriptive title is shown to users when a service worker is not present or invalid. */
  failureTitle: 'Does not register a service worker that controls page and `start_url`',
  /** Description of a Lighthouse audit that tells the user why they should use a service worker. This is displayed after a user expands the section to see more. No character length limits. 'Learn More' becomes link text to additional documentation. */
  description: 'The service worker is the technology that enables your app to use many ' +
    'Progressive Web App features, such as offline, add to homescreen, and push ' +
    'notifications. [Learn more](https://web.dev/service-worker/).',
  /**
   * @description Message explaining that the website may have service workers, but none are in scope to control the tested web page.
   * @example {https://example.com/} pageUrl
   * */
  explanationOutOfScope: 'This origin has one or more service workers, however the page ' +
    '({pageUrl}) is not in scope.',
  /** Message explaining that the page has no manifest file so can't specify a starting url. */
  explanationNoManifest: 'This page is controlled by a service worker, however ' +
    'no `start_url` was found because no manifest was fetched.',
  /** Message explaining that the page had an invalid manifest file so can't specify a starting url. */
  explanationBadManifest: 'This page is controlled by a service worker, however ' +
    'no `start_url` was found because manifest failed to parse as valid JSON',
  /**
   * @description Message explaining that the website has a service worker, but none are in scope to control the tested starting url.
   * @example {https://example.com/} startUrl
   * @example {https://othersite.com/} scopeUrl
   * */
  explanationBadStartUrl: 'This page is controlled by a service worker, however ' +
    'the `start_url` ({startUrl}) is not in the service worker\'s scope ({scopeUrl})',
};

const str_ = i18n.createMessageInstanceIdFn(__filename, UIStrings);

class ServiceWorker extends Audit {
  /**
   * @return {LH.Audit.Meta}
   */
  static get meta() {
    return {
      id: 'service-worker',
      title: str_(UIStrings.title),
      failureTitle: str_(UIStrings.failureTitle),
      description: str_(UIStrings.description),
      requiredArtifacts: ['URL', 'ServiceWorker', 'WebAppManifest'],
    };
  }

  /**
   * Find active service workers for this origin.
   * @param {Array<LH.Crdp.ServiceWorker.ServiceWorkerVersion>} versions
   * @param {URL} pageUrl
   * @return {Array<LH.Crdp.ServiceWorker.ServiceWorkerVersion>}
   */
  static getVersionsForOrigin(versions, pageUrl) {
    return versions
      .filter(v => v.status === 'activated')
      .filter(v => new URL(v.scriptURL).origin === pageUrl.origin);
  }

  /**
   * From the set of active service workers for this origin, find the controlling SW (if any)
   * and return its scope URL.
   * @param {Array<LH.Crdp.ServiceWorker.ServiceWorkerVersion>} matchingSWVersions
   * @param {Array<LH.Crdp.ServiceWorker.ServiceWorkerRegistration>} registrations
   * @param {URL} pageUrl
   * @return {{scopeUrl: string; scriptUrl: string} | undefined}
   */
  static getControllingServiceWorker(matchingSWVersions, registrations, pageUrl) {
    // Find the normalized scope URLs of possibly-controlling SWs.
    /** @type {Array<{scopeUrl: string; scriptUrl: string}>} */
    const scriptByScopeUrlList = [];

    // Populate serviceWorkerUrls map with the scriptURLs and scopeUrls of matchingSWVersions and registrations
    for (const version of matchingSWVersions) {
      const matchedRegistration = registrations
        .find(r => r.registrationId === version.registrationId);

      if (matchedRegistration) {
        const scopeUrl = new URL(matchedRegistration.scopeURL).href;
        const scriptUrl = new URL(version.scriptURL).href;
        scriptByScopeUrlList.push({scopeUrl, scriptUrl});
      }
    }

    // Find most-specific applicable scope, the one controlling the page.
    // See https://w3c.github.io/ServiceWorker/v1/#scope-match-algorithm
    const pageControllingUrls = scriptByScopeUrlList
      .filter(ss => pageUrl.href.startsWith(ss.scopeUrl))
      .sort((ssA, ssB) => ssA.scopeUrl.length - ssB.scopeUrl.length)
      .pop();

    return pageControllingUrls;
  }

  /**
   * Returns a failure message if there is no start_url or if the start_url isn't
   * contolled by the scopeUrl.
   * @param {LH.Artifacts['WebAppManifest']} WebAppManifest
   * @param {string} scopeUrl
   * @return {LH.IcuMessage|undefined}
   */
  static checkStartUrl(WebAppManifest, scopeUrl) {
    if (!WebAppManifest) {
      return str_(UIStrings.explanationNoManifest);
    }
    if (!WebAppManifest.value) {
      return str_(UIStrings.explanationBadManifest);
    }

    const startUrl = WebAppManifest.value.start_url.value;
    if (!startUrl.startsWith(scopeUrl)) {
      return str_(UIStrings.explanationBadStartUrl, {startUrl, scopeUrl});
    }
  }

  /**
   * @param {LH.Artifacts} artifacts
   * @return {LH.Audit.Product}
   */
  static audit(artifacts) {
    // Match against artifacts.URL.finalUrl so audit accounts for any redirects.
    const pageUrl = new URL(artifacts.URL.finalUrl);
    const {versions, registrations} = artifacts.ServiceWorker;

    const versionsForOrigin = ServiceWorker.getVersionsForOrigin(versions, pageUrl);
    if (versionsForOrigin.length === 0) {
      return {
        score: 0,
      };
    }

    const serviceWorkerUrls = ServiceWorker.getControllingServiceWorker(versionsForOrigin,
        registrations, pageUrl);
    if (!serviceWorkerUrls) {
      return {
        score: 0,
        explanation: str_(UIStrings.explanationOutOfScope, {pageUrl: pageUrl.href}),
      };
    }

    // Include the SW details as diagnostic data.
    const {scriptUrl, scopeUrl} = serviceWorkerUrls;
    /** @type {LH.Audit.Details.DebugData} */
    const details = {
      type: 'debugdata',
      scriptUrl,
      scopeUrl,
    };

    const startUrlFailure = ServiceWorker.checkStartUrl(artifacts.WebAppManifest,
      serviceWorkerUrls.scopeUrl);
    if (startUrlFailure) {
      return {
        score: 0,
        details,
        explanation: startUrlFailure,
      };
    }

    // SW controls both finalUrl and start_url.
    return {
      score: 1,
      details,
    };
  }
}

module.exports = ServiceWorker;
module.exports.UIStrings = UIStrings;

}).call(this)}).call(this,"/lighthouse-core/audits/service-worker.js")
},{"../lib/i18n/i18n.js":96,"../lib/url-shim.js":"url","./audit.js":3}],"../audits/splash-screen":[function(require,module,exports){
(function (__filename){(function (){
/**
 * @license Copyright 2017 The Lighthouse Authors. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.
 */
'use strict';

const MultiCheckAudit = require('./multi-check-audit.js');
const ManifestValues = require('../computed/manifest-values.js');
const i18n = require('../lib/i18n/i18n.js');

const UIStrings = {
  /** Title of a Lighthouse audit that provides detail on splash screens. This descriptive title is shown to users when the site has a custom splash screen. */
  title: 'Configured for a custom splash screen',
  /** Title of a Lighthouse audit that provides detail on splash screens. This descriptive title is shown to users when the site does not have a custom splash screen. */
  failureTitle: 'Is not configured for a custom splash screen',
  /** Description of a Lighthouse audit that tells the user why they should configure a custom splash screen. This is displayed after a user expands the section to see more. No character length limits. 'Learn More' becomes link text to additional documentation. */
  description: 'A themed splash screen ensures a high-quality experience when ' +
    'users launch your app from their homescreens. [Learn ' +
    'more](https://web.dev/splash-screen/).',
};

const str_ = i18n.createMessageInstanceIdFn(__filename, UIStrings);

/**
 * @fileoverview
 * Audits if a page is configured for a custom splash screen when launched
 * https://github.com/GoogleChrome/lighthouse/issues/24
 *
 * Requirements:
 *   * manifest is not empty
 *   * manifest has a valid name
 *   * manifest has a valid background_color
 *   * manifest has a valid theme_color
 *   * manifest contains icon that's a png and size >= 512px
 */

class SplashScreen extends MultiCheckAudit {
  /**
   * @return {LH.Audit.Meta}
   */
  static get meta() {
    return {
      id: 'splash-screen',
      title: str_(UIStrings.title),
      failureTitle: str_(UIStrings.failureTitle),
      description: str_(UIStrings.description),
      supportedModes: ['navigation'],
      requiredArtifacts: ['WebAppManifest', 'InstallabilityErrors'],
    };
  }

  /**
   * @param {LH.Artifacts.ManifestValues} manifestValues
   * @param {Array<string>} failures
   */
  static assessManifest(manifestValues, failures) {
    if (manifestValues.isParseFailure && manifestValues.parseFailureReason) {
      failures.push(manifestValues.parseFailureReason);
      return;
    }

    const splashScreenCheckIds = [
      'hasName',
      'hasBackgroundColor',
      'hasThemeColor',
      'hasIconsAtLeast512px',
    ];

    manifestValues.allChecks
      .filter(item => splashScreenCheckIds.includes(item.id))
      .forEach(item => {
        if (!item.passing) {
          failures.push(item.failureText);
        }
      });
  }

  /**
   * @param {LH.Artifacts} artifacts
   * @param {LH.Audit.Context} context
   * @return {Promise<{failures: Array<string>, manifestValues: LH.Artifacts.ManifestValues}>}
   */
  static async audit_(artifacts, context) {
    /** @type {Array<string>} */
    const failures = [];

    const manifestValues = await ManifestValues.request(artifacts, context);
    SplashScreen.assessManifest(manifestValues, failures);

    return {
      failures,
      manifestValues,
    };
  }
}

module.exports = SplashScreen;
module.exports.UIStrings = UIStrings;

}).call(this)}).call(this,"/lighthouse-core/audits/splash-screen.js")
},{"../computed/manifest-values.js":16,"../lib/i18n/i18n.js":96,"./multi-check-audit.js":7}],"../audits/themed-omnibox":[function(require,module,exports){
(function (__filename){(function (){
/**
 * @license Copyright 2017 The Lighthouse Authors. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.
 */
'use strict';

const MultiCheckAudit = require('./multi-check-audit.js');
const ManifestValues = require('../computed/manifest-values.js');
const cssParsers = require('cssstyle/lib/parsers');
const i18n = require('../lib/i18n/i18n.js');

const UIStrings = {
  /** Title of a Lighthouse audit that provides detail on the theme color the web page has set for the browser's address bar. This descriptive title is shown to users when an address-bar theme color has been set. */
  title: 'Sets a theme color for the address bar.',
  /** Title of a Lighthouse audit that provides detail on the theme color the web page has set for the browser's address bar. This descriptive title is shown to users when an address-bar theme color has not been set. */
  failureTitle: 'Does not set a theme color for the address bar.',
  /** Description of a Lighthouse audit that tells the user why they should set a theme color for the browser's address bar. This is displayed after a user expands the section to see more. No character length limits. 'Learn More' becomes link text to additional documentation. */
  description: 'The browser address bar can be themed to match your site. ' +
    '[Learn more](https://web.dev/themed-omnibox/).',
};

const str_ = i18n.createMessageInstanceIdFn(__filename, UIStrings);

/**
 * @fileoverview
 * Audits if a page is configured for a themed address bar
 *
 * Requirements:
 *   * manifest is not empty
 *   * manifest has a valid theme_color
 *   * HTML has a valid theme-color meta
 */

class ThemedOmnibox extends MultiCheckAudit {
  /**
   * @return {LH.Audit.Meta}
   */
  static get meta() {
    return {
      id: 'themed-omnibox',
      title: str_(UIStrings.title),
      failureTitle: str_(UIStrings.failureTitle),
      description: str_(UIStrings.description),
      supportedModes: ['navigation'],
      requiredArtifacts: ['WebAppManifest', 'InstallabilityErrors', 'MetaElements'],
    };
  }

  /**
   * @param {string} color
   * @return {boolean}
   */
  static isValidColor(color) {
    return cssParsers.valueType(color) === cssParsers.TYPES.COLOR;
  }

  /**
   * @param {LH.Artifacts.MetaElement|undefined} themeColorMeta
   * @param {Array<string>} failures
   */
  static assessMetaThemecolor(themeColorMeta, failures) {
    if (!themeColorMeta) {
      // TODO(#7238): i18n
      failures.push('No `<meta name="theme-color">` tag found');
    } else if (!ThemedOmnibox.isValidColor(themeColorMeta.content || '')) {
      failures.push('The theme-color meta tag did not contain a valid CSS color');
    }
  }

  /**
   * @param {LH.Artifacts.ManifestValues} manifestValues
   * @param {Array<string>} failures
   */
  static assessManifest(manifestValues, failures) {
    if (manifestValues.isParseFailure && manifestValues.parseFailureReason) {
      failures.push(manifestValues.parseFailureReason);
      return;
    }

    const themeColorCheck = manifestValues.allChecks.find(i => i.id === 'hasThemeColor');
    if (themeColorCheck && !themeColorCheck.passing) {
      failures.push(themeColorCheck.failureText);
    }
  }

  /**
   * @param {LH.Artifacts} artifacts
   * @param {LH.Audit.Context} context
   * @return {Promise<{failures: Array<string>, manifestValues: LH.Artifacts.ManifestValues, themeColor: ?string}>}
   */
  static async audit_(artifacts, context) {
    /** @type {Array<string>} */
    const failures = [];

    const themeColorMeta = artifacts.MetaElements.find(meta => meta.name === 'theme-color');
    const manifestValues = await ManifestValues.request(artifacts, context);
    ThemedOmnibox.assessManifest(manifestValues, failures);
    ThemedOmnibox.assessMetaThemecolor(themeColorMeta, failures);

    return {
      failures,
      manifestValues,
      themeColor: (themeColorMeta && themeColorMeta.content) || null,
    };
  }
}

module.exports = ThemedOmnibox;
module.exports.UIStrings = UIStrings;

}).call(this)}).call(this,"/lighthouse-core/audits/themed-omnibox.js")
},{"../computed/manifest-values.js":16,"../lib/i18n/i18n.js":96,"./multi-check-audit.js":7,"cssstyle/lib/parsers":160}],"../audits/third-party-facades":[function(require,module,exports){
(function (__filename){(function (){
/**
 * @license Copyright 2020 The Lighthouse Authors. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.
 */
'use strict';

/**
 * @fileoverview Audit which identifies third-party code on the page which can be lazy loaded.
 * The audit will recommend a facade alternative which is used to imitate the third-party resource until it is needed.
 *
 * Entity: Set of domains which are used by a company or product area to deliver third-party resources
 * Product: Specific piece of software belonging to an entity. Entities can have multiple products.
 * Facade: Placeholder for a product which looks likes the actual product and replaces itself with that product when the user needs it.
 */

/** @typedef {import("third-party-web").IEntity} ThirdPartyEntity */
/** @typedef {import("third-party-web").IProduct} ThirdPartyProduct*/
/** @typedef {import("third-party-web").IFacade} ThirdPartyFacade*/

/** @typedef {{product: ThirdPartyProduct, entity: ThirdPartyEntity}} FacadableProduct */

const Audit = require('./audit.js');
const i18n = require('../lib/i18n/i18n.js');
const thirdPartyWeb = require('../lib/third-party-web.js');
const NetworkRecords = require('../computed/network-records.js');
const MainResource = require('../computed/main-resource.js');
const MainThreadTasks = require('../computed/main-thread-tasks.js');
const ThirdPartySummary = require('./third-party-summary.js');

const UIStrings = {
  /** Title of a diagnostic audit that provides details about the third-party code on a web page that can be lazy loaded with a facade alternative. This descriptive title is shown to users when no resources have facade alternatives available. A facade is a lightweight component which looks like the desired resource. Lazy loading means resources are deferred until they are needed. Third-party code refers to resources that are not within the control of the site owner. */
  title: 'Lazy load third-party resources with facades',
  /** Title of a diagnostic audit that provides details about the third-party code on a web page that can be lazy loaded with a facade alternative. This descriptive title is shown to users when one or more third-party resources have available facade alternatives. A facade is a lightweight component which looks like the desired resource. Lazy loading means resources are deferred until they are needed. Third-party code refers to resources that are not within the control of the site owner. */
  failureTitle: 'Some third-party resources can be lazy loaded with a facade',
  /** Description of a Lighthouse audit that identifies the third-party code on the page that can be lazy loaded with a facade alternative. This is displayed after a user expands the section to see more. No character length limits. 'Learn More' becomes link text to additional documentation. A facade is a lightweight component which looks like the desired resource. Lazy loading means resources are deferred until they are needed. Third-party code refers to resources that are not within the control of the site owner. */
  description: 'Some third-party embeds can be lazy loaded. ' +
    'Consider replacing them with a facade until they are required. [Learn more](https://web.dev/third-party-facades/).',
  /** Summary text for the result of a Lighthouse audit that identifies the third-party code on a web page that can be lazy loaded with a facade alternative. This text summarizes the number of lazy loading facades that can be used on the page. A facade is a lightweight component which looks like the desired resource. */
  displayValue: `{itemCount, plural,
  =1 {# facade alternative available}
  other {# facade alternatives available}
  }`,
  /** Label for a table column that displays the name of the product that a URL is used for. The products in the column will be pieces of software used on the page, like the "YouTube Embedded Player" or the "Drift Live Chat" box. */
  columnProduct: 'Product',
  /**
   * @description Template for a table entry that gives the name of a product which we categorize as video related.
   * @example {YouTube Embedded Player} productName
   */
  categoryVideo: '{productName} (Video)',
  /**
   * @description Template for a table entry that gives the name of a product which we categorize as customer success related. Customer success means the product supports customers by offering chat and contact solutions.
   * @example {Intercom Widget} productName
   */
  categoryCustomerSuccess: '{productName} (Customer Success)',
  /**
   * @description Template for a table entry that gives the name of a product which we categorize as marketing related.
   * @example {Drift Live Chat} productName
   */
  categoryMarketing: '{productName} (Marketing)',
  /**
   * @description Template for a table entry that gives the name of a product which we categorize as social related.
   * @example {Facebook Messenger Customer Chat} productName
   */
  categorySocial: '{productName} (Social)',
};

const str_ = i18n.createMessageInstanceIdFn(__filename, UIStrings);

/** @type {Record<string, string>} */
const CATEGORY_UI_MAP = {
  'video': UIStrings.categoryVideo,
  'customer-success': UIStrings.categoryCustomerSuccess,
  'marketing': UIStrings.categoryMarketing,
  'social': UIStrings.categorySocial,
};

class ThirdPartyFacades extends Audit {
  /**
   * @return {LH.Audit.Meta}
   */
  static get meta() {
    return {
      id: 'third-party-facades',
      title: str_(UIStrings.title),
      failureTitle: str_(UIStrings.failureTitle),
      description: str_(UIStrings.description),
      supportedModes: ['navigation'],
      requiredArtifacts: ['traces', 'devtoolsLogs', 'URL'],
    };
  }

  /**
   * Sort items by transfer size and combine small items into a single row.
   * Items will be mutated in place to a maximum of 6 rows.
   * @param {ThirdPartySummary.URLSummary[]} items
   */
  static condenseItems(items) {
    items.sort((a, b) => b.transferSize - a.transferSize);

    // Items <1KB are condensed. If all items are <1KB, condense all but the largest.
    let splitIndex = items.findIndex((item) => item.transferSize < 1000) || 1;
    // Show details for top 5 items.
    if (splitIndex === -1 || splitIndex > 5) splitIndex = 5;
    // If there is only 1 item to condense, leave it as is.
    if (splitIndex >= items.length - 1) return;

    const remainder = items.splice(splitIndex);
    const finalItem = remainder.reduce((result, item) => {
      result.transferSize += item.transferSize;
      result.blockingTime += item.blockingTime;
      return result;
    });

    // If condensed row is still <1KB, don't show it.
    if (finalItem.transferSize < 1000) return;

    finalItem.url = str_(i18n.UIStrings.otherResourcesLabel);
    items.push(finalItem);
  }

  /**
   * @param {Map<string, ThirdPartySummary.Summary>} byURL
   * @param {ThirdPartyEntity | undefined} mainEntity
   * @return {FacadableProduct[]}
   */
  static getProductsWithFacade(byURL, mainEntity) {
    /** @type {Map<string, FacadableProduct>} */
    const facadableProductMap = new Map();
    for (const url of byURL.keys()) {
      const entity = thirdPartyWeb.getEntity(url);
      if (!entity || thirdPartyWeb.isFirstParty(url, mainEntity)) continue;

      const product = thirdPartyWeb.getProduct(url);
      if (!product || !product.facades || !product.facades.length) continue;

      if (facadableProductMap.has(product.name)) continue;
      facadableProductMap.set(product.name, {product, entity});
    }

    return Array.from(facadableProductMap.values());
  }

  /**
   * @param {LH.Artifacts} artifacts
   * @param {LH.Audit.Context} context
   * @return {Promise<LH.Audit.Product>}
   */
  static async audit(artifacts, context) {
    const settings = context.settings;
    const trace = artifacts.traces[Audit.DEFAULT_PASS];
    const devtoolsLog = artifacts.devtoolsLogs[Audit.DEFAULT_PASS];
    const networkRecords = await NetworkRecords.request(devtoolsLog, context);
    const mainResource = await MainResource.request({devtoolsLog, URL: artifacts.URL}, context);
    const mainEntity = thirdPartyWeb.getEntity(mainResource.url);
    const tasks = await MainThreadTasks.request(trace, context);
    const multiplier = settings.throttlingMethod === 'simulate' ?
      settings.throttling.cpuSlowdownMultiplier : 1;
    const summaries = ThirdPartySummary.getSummaries(networkRecords, tasks, multiplier);
    const facadableProducts =
      ThirdPartyFacades.getProductsWithFacade(summaries.byURL, mainEntity);

    /** @type {LH.Audit.Details.TableItem[]} */
    const results = [];
    for (const {product, entity} of facadableProducts) {
      const categoryTemplate = CATEGORY_UI_MAP[product.categories[0]];

      let productWithCategory;
      if (categoryTemplate) {
        // Display product name with category next to it in the same column.
        productWithCategory = str_(categoryTemplate, {productName: product.name});
      } else {
        // Just display product name if no category is found.
        productWithCategory = product.name;
      }

      const urls = summaries.urls.get(entity);
      const entitySummary = summaries.byEntity.get(entity);
      if (!urls || !entitySummary) continue;

      const items = Array.from(urls).map((url) => {
        const urlStats = summaries.byURL.get(url);
        return /** @type {ThirdPartySummary.URLSummary} */ ({url, ...urlStats});
      });
      this.condenseItems(items);
      results.push({
        product: productWithCategory,
        transferSize: entitySummary.transferSize,
        blockingTime: entitySummary.blockingTime,
        subItems: {type: 'subitems', items},
      });
    }

    if (!results.length) {
      return {
        score: 1,
        notApplicable: true,
      };
    }

    /** @type {LH.Audit.Details.Table['headings']} */
    const headings = [
      /* eslint-disable max-len */
      {key: 'product', itemType: 'text', subItemsHeading: {key: 'url', itemType: 'url'}, text: str_(UIStrings.columnProduct)},
      {key: 'transferSize', itemType: 'bytes', subItemsHeading: {key: 'transferSize'}, granularity: 1, text: str_(i18n.UIStrings.columnTransferSize)},
      {key: 'blockingTime', itemType: 'ms', subItemsHeading: {key: 'blockingTime'}, granularity: 1, text: str_(i18n.UIStrings.columnBlockingTime)},
      /* eslint-enable max-len */
    ];

    return {
      score: 0,
      displayValue: str_(UIStrings.displayValue, {
        itemCount: results.length,
      }),
      details: Audit.makeTableDetails(headings, results),
    };
  }
}

module.exports = ThirdPartyFacades;
module.exports.UIStrings = UIStrings;

}).call(this)}).call(this,"/lighthouse-core/audits/third-party-facades.js")
},{"../computed/main-resource.js":14,"../computed/main-thread-tasks.js":15,"../computed/network-records.js":40,"../lib/i18n/i18n.js":96,"../lib/third-party-web.js":116,"./audit.js":3,"./third-party-summary.js":"../audits/third-party-summary"}],"../audits/third-party-summary":[function(require,module,exports){
(function (__filename){(function (){
/**
 * @license Copyright 2019 The Lighthouse Authors. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.
 */
'use strict';

const Audit = require('./audit.js');
const BootupTime = require('./bootup-time.js');
const i18n = require('../lib/i18n/i18n.js');
const thirdPartyWeb = require('../lib/third-party-web.js');
const NetworkRecords = require('../computed/network-records.js');
const MainThreadTasks = require('../computed/main-thread-tasks.js');

const UIStrings = {
  /** Title of a diagnostic audit that provides details about the code on a web page that the user doesn't control (referred to as "third-party code"). This descriptive title is shown to users when the amount is acceptable and no user action is required. */
  title: 'Minimize third-party usage',
  /** Title of a diagnostic audit that provides details about the code on a web page that the user doesn't control (referred to as "third-party code"). This imperative title is shown to users when there is a significant amount of page execution time caused by third-party code that should be reduced. */
  failureTitle: 'Reduce the impact of third-party code',
  /** Description of a Lighthouse audit that identifies the code on the page that the user doesn't control. This is displayed after a user expands the section to see more. No character length limits. 'Learn More' becomes link text to additional documentation. */
  description: 'Third-party code can significantly impact load performance. ' +
    'Limit the number of redundant third-party providers and try to load third-party code after ' +
    'your page has primarily finished loading. [Learn more](https://developers.google.com/web/fundamentals/performance/optimizing-content-efficiency/loading-third-party-javascript/).',
  /** Label for a table column that displays the name of a third-party provider that potentially links to their website. */
  columnThirdParty: 'Third-Party',
  /** Summary text for the result of a Lighthouse audit that identifies the code on a web page that the user doesn't control (referred to as "third-party code"). This text summarizes the number of distinct entities that were found on the page. */
  displayValue: 'Third-party code blocked the main thread for ' +
    `{timeInMs, number, milliseconds}\xa0ms`,
};

const str_ = i18n.createMessageInstanceIdFn(__filename, UIStrings);

// A page passes when all third-party code blocks for less than 250 ms.
const PASS_THRESHOLD_IN_MS = 250;

/** @typedef {import("third-party-web").IEntity} ThirdPartyEntity */

/**
 * @typedef Summary
 * @property {number} mainThreadTime
 * @property {number} transferSize
 * @property {number} blockingTime
 */

/**
 * @typedef URLSummary
 * @property {number} transferSize
 * @property {number} blockingTime
 * @property {string | LH.IcuMessage} url
 */

/** @typedef SummaryMaps
 * @property {Map<ThirdPartyEntity, Summary>} byEntity Map of impact summaries for each entity.
 * @property {Map<string, Summary>} byURL Map of impact summaries for each URL.
 * @property {Map<ThirdPartyEntity, string[]>} urls Map of URLs under each entity.
 */

/**
 * Don't bother showing resources smaller than 4KiB since they're likely to be pixels, which isn't
 * too actionable.
 */
const MIN_TRANSFER_SIZE_FOR_SUBITEMS = 4096;

/** Show at most 5 sub items in the resource breakdown. */
const MAX_SUBITEMS = 5;

class ThirdPartySummary extends Audit {
  /**
   * @return {LH.Audit.Meta}
   */
  static get meta() {
    return {
      id: 'third-party-summary',
      title: str_(UIStrings.title),
      failureTitle: str_(UIStrings.failureTitle),
      description: str_(UIStrings.description),
      requiredArtifacts: ['traces', 'devtoolsLogs', 'URL'],
    };
  }

  /**
   *
   * @param {Array<LH.Artifacts.NetworkRequest>} networkRecords
   * @param {Array<LH.Artifacts.TaskNode>} mainThreadTasks
   * @param {number} cpuMultiplier
   * @return {SummaryMaps}
   */
  static getSummaries(networkRecords, mainThreadTasks, cpuMultiplier) {
    /** @type {Map<string, Summary>} */
    const byURL = new Map();
    /** @type {Map<ThirdPartyEntity, Summary>} */
    const byEntity = new Map();
    const defaultSummary = {mainThreadTime: 0, blockingTime: 0, transferSize: 0};

    for (const request of networkRecords) {
      const urlSummary = byURL.get(request.url) || {...defaultSummary};
      urlSummary.transferSize += request.transferSize;
      byURL.set(request.url, urlSummary);
    }

    const jsURLs = BootupTime.getJavaScriptURLs(networkRecords);

    for (const task of mainThreadTasks) {
      const attributableURL = BootupTime.getAttributableURLForTask(task, jsURLs);

      const urlSummary = byURL.get(attributableURL) || {...defaultSummary};
      const taskDuration = task.selfTime * cpuMultiplier;
      // The amount of time spent on main thread is the sum of all durations.
      urlSummary.mainThreadTime += taskDuration;
      // The amount of time spent *blocking* on main thread is the sum of all time longer than 50ms.
      // Note that this is not totally equivalent to the TBT definition since it fails to account for FCP,
      // but a majority of third-party work occurs after FCP and should yield largely similar numbers.
      urlSummary.blockingTime += Math.max(taskDuration - 50, 0);
      byURL.set(attributableURL, urlSummary);
    }

    // Map each URL's stat to a particular third party entity.
    /** @type {Map<ThirdPartyEntity, string[]>} */
    const urls = new Map();
    for (const [url, urlSummary] of byURL.entries()) {
      const entity = thirdPartyWeb.getEntity(url);
      if (!entity) {
        byURL.delete(url);
        continue;
      }

      const entitySummary = byEntity.get(entity) || {...defaultSummary};
      entitySummary.transferSize += urlSummary.transferSize;
      entitySummary.mainThreadTime += urlSummary.mainThreadTime;
      entitySummary.blockingTime += urlSummary.blockingTime;
      byEntity.set(entity, entitySummary);

      const entityURLs = urls.get(entity) || [];
      entityURLs.push(url);
      urls.set(entity, entityURLs);
    }

    return {byURL, byEntity, urls};
  }

  /**
   * @param {ThirdPartyEntity} entity
   * @param {SummaryMaps} summaries
   * @param {Summary} stats
   * @return {Array<URLSummary>}
   */
  static makeSubItems(entity, summaries, stats) {
    const entityURLs = summaries.urls.get(entity) || [];
    let items = entityURLs
      .map(url => /** @type {URLSummary} */ ({url, ...summaries.byURL.get(url)}))
      // Filter out any cases where byURL was missing entries.
      .filter((stat) => stat.transferSize > 0)
      // Sort by blocking time first, then transfer size to break ties.
      .sort((a, b) => (b.blockingTime - a.blockingTime) || (b.transferSize - a.transferSize));

    const subitemSummary = {transferSize: 0, blockingTime: 0};
    const minTransferSize = Math.max(MIN_TRANSFER_SIZE_FOR_SUBITEMS, stats.transferSize / 20);
    const maxSubItems = Math.min(MAX_SUBITEMS, items.length);
    let numSubItems = 0;
    while (numSubItems < maxSubItems) {
      const nextSubItem = items[numSubItems];
      if (nextSubItem.blockingTime === 0 && nextSubItem.transferSize < minTransferSize) {
        // Don't include the resource in the sub-item breakdown because it didn't have a big
        // enough impact on its own.
        break;
      }

      numSubItems++;
      subitemSummary.transferSize += nextSubItem.transferSize;
      subitemSummary.blockingTime += nextSubItem.blockingTime;
    }
    if (!subitemSummary.blockingTime && !subitemSummary.transferSize) {
      // Don't bother breaking down if there are no large resources.
      return [];
    }
    // Only show the top N entries for brevity. If there is more than one remaining entry
    // we'll replace the tail entries with single remainder entry.
    items = items.slice(0, numSubItems);
    const remainder = {
      url: str_(i18n.UIStrings.otherResourcesLabel),
      transferSize: stats.transferSize - subitemSummary.transferSize,
      blockingTime: stats.blockingTime - subitemSummary.blockingTime,
    };
    if (remainder.transferSize > minTransferSize) {
      items.push(remainder);
    }
    return items;
  }

  /**
   * @param {LH.Artifacts} artifacts
   * @param {LH.Audit.Context} context
   * @return {Promise<LH.Audit.Product>}
   */
  static async audit(artifacts, context) {
    const settings = context.settings || {};
    const trace = artifacts.traces[Audit.DEFAULT_PASS];
    const devtoolsLog = artifacts.devtoolsLogs[Audit.DEFAULT_PASS];
    const networkRecords = await NetworkRecords.request(devtoolsLog, context);
    const mainEntity = thirdPartyWeb.getEntity(artifacts.URL.finalUrl);
    const tasks = await MainThreadTasks.request(trace, context);
    const multiplier = settings.throttlingMethod === 'simulate' ?
      settings.throttling.cpuSlowdownMultiplier : 1;

    const summaries = ThirdPartySummary.getSummaries(networkRecords, tasks, multiplier);
    const overallSummary = {wastedBytes: 0, wastedMs: 0};

    const results = Array.from(summaries.byEntity.entries())
      // Don't consider the page we're on to be third-party.
      // e.g. Facebook SDK isn't a third-party script on facebook.com
      .filter(([entity]) => !(mainEntity && mainEntity.name === entity.name))
      .map(([entity, stats]) => {
        overallSummary.wastedBytes += stats.transferSize;
        overallSummary.wastedMs += stats.blockingTime;

        return {
          ...stats,
          entity: {
            type: /** @type {'link'} */ ('link'),
            text: entity.name,
            url: entity.homepage || '',
          },
          subItems: {
            type: /** @type {'subitems'} */ ('subitems'),
            items: ThirdPartySummary.makeSubItems(entity, summaries, stats),
          },
        };
      })
      // Sort by blocking time first, then transfer size to break ties.
      .sort((a, b) => (b.blockingTime - a.blockingTime) || (b.transferSize - a.transferSize));

    /** @type {LH.Audit.Details.Table['headings']} */
    const headings = [
      /* eslint-disable max-len */
      {key: 'entity', itemType: 'link', text: str_(UIStrings.columnThirdParty), subItemsHeading: {key: 'url', itemType: 'url'}},
      {key: 'transferSize', granularity: 1, itemType: 'bytes', text: str_(i18n.UIStrings.columnTransferSize), subItemsHeading: {key: 'transferSize'}},
      {key: 'blockingTime', granularity: 1, itemType: 'ms', text: str_(i18n.UIStrings.columnBlockingTime), subItemsHeading: {key: 'blockingTime'}},
      /* eslint-enable max-len */
    ];

    if (!results.length) {
      return {
        score: 1,
        notApplicable: true,
      };
    }

    return {
      score: Number(overallSummary.wastedMs <= PASS_THRESHOLD_IN_MS),
      displayValue: str_(UIStrings.displayValue, {
        timeInMs: overallSummary.wastedMs,
      }),
      details: Audit.makeTableDetails(headings, results, overallSummary),
    };
  }
}

module.exports = ThirdPartySummary;
module.exports.UIStrings = UIStrings;

}).call(this)}).call(this,"/lighthouse-core/audits/third-party-summary.js")
},{"../computed/main-thread-tasks.js":15,"../computed/network-records.js":40,"../lib/i18n/i18n.js":96,"../lib/third-party-web.js":116,"./audit.js":3,"./bootup-time.js":"../audits/bootup-time"}],"../audits/timing-budget":[function(require,module,exports){
(function (__filename){(function (){
/**
 * @license Copyright 2019 The Lighthouse Authors. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.
 */
'use strict';

const Audit = require('./audit.js');
const TimingSummary = require('../computed/metrics/timing-summary.js');
const MainResource = require('../computed/main-resource.js');
const Budget = require('../config/budget.js');
const i18n = require('../lib/i18n/i18n.js');

const UIStrings = {
  /** Title of a Lighthouse audit that compares how quickly the page loads against targets set by the user. Timing budgets are a type of performance budget. */
  title: 'Timing budget',
  /** Description of a Lighthouse audit where a user sets budgets for how quickly the page loads. No character length limits. 'Learn More' becomes link text to additional documentation. */
  description: 'Set a timing budget to help you keep an eye on the performance of your site. Performant sites load fast and respond to user input events quickly. [Learn more](https://developers.google.com/web/tools/lighthouse/audits/budgets).',
  /** Label for a column in a data table; entries will be the names of different timing metrics, e.g. "Time to Interactive", "First Contentful Paint", etc. */
  columnTimingMetric: 'Metric',
  /** Label for a column in a data table; entries will be the measured value of a particular timing metric. Most entries will have a unit of milliseconds, but units could be other things as well. */
  columnMeasurement: 'Measurement',
};

const str_ = i18n.createMessageInstanceIdFn(__filename, UIStrings);

/** @typedef {{metric: LH.Budget.TimingMetric, label: LH.IcuMessage, measurement?: LH.Audit.Details.NumericValue|number, overBudget?: LH.Audit.Details.NumericValue|number}} BudgetItem */

class TimingBudget extends Audit {
  /**
   * @return {LH.Audit.Meta}
   */
  static get meta() {
    return {
      id: 'timing-budget',
      title: str_(UIStrings.title),
      description: str_(UIStrings.description),
      scoreDisplayMode: Audit.SCORING_MODES.INFORMATIVE,
      supportedModes: ['navigation'],
      requiredArtifacts: ['devtoolsLogs', 'traces', 'URL', 'GatherContext'],
    };
  }

  /**
   * @param {LH.Budget.TimingMetric} timingMetric
   * @return {LH.IcuMessage}
   */
  static getRowLabel(timingMetric) {
    /** @type {Record<LH.Budget.TimingMetric, string>} */
    const strMappings = {
      'first-contentful-paint': i18n.UIStrings.firstContentfulPaintMetric,
      'interactive': i18n.UIStrings.interactiveMetric,
      'first-meaningful-paint': i18n.UIStrings.firstMeaningfulPaintMetric,
      'max-potential-fid': i18n.UIStrings.maxPotentialFIDMetric,
      'total-blocking-time': i18n.UIStrings.totalBlockingTimeMetric,
      'speed-index': i18n.UIStrings.speedIndexMetric,
      'largest-contentful-paint': i18n.UIStrings.largestContentfulPaintMetric,
      'cumulative-layout-shift': i18n.UIStrings.cumulativeLayoutShiftMetric,
    };
    return str_(strMappings[timingMetric]);
  }

  /**
   * @param {LH.Budget.TimingMetric} timingMetric
   * @param {LH.Artifacts.TimingSummary} summary
   * @return {number|undefined}
   */
  static getMeasurement(timingMetric, summary) {
    /** @type {Record<LH.Budget.TimingMetric, number|undefined>} */
    const measurements = {
      'first-contentful-paint': summary.firstContentfulPaint,
      'interactive': summary.interactive,
      'first-meaningful-paint': summary.firstMeaningfulPaint,
      'max-potential-fid': summary.maxPotentialFID,
      'total-blocking-time': summary.totalBlockingTime,
      'speed-index': summary.speedIndex,
      'largest-contentful-paint': summary.largestContentfulPaint,
      'cumulative-layout-shift': summary.cumulativeLayoutShift,
    };
    return measurements[timingMetric];
  }

  /**
   * @param {Immutable<LH.Budget>} budget
   * @param {LH.Artifacts.TimingSummary} summary
   * @return {Array<BudgetItem>}
   */
  static tableItems(budget, summary) {
    /** @type {Array<BudgetItem>} */
    let items = [];
    if (!budget.timings) {
      return items;
    }

    items = budget.timings.map((timingBudget) => {
      const metricName = timingBudget.metric;
      const label = this.getRowLabel(metricName);
      const measurement = this.getMeasurement(metricName, summary);
      const overBudget = measurement && (measurement > timingBudget.budget)
        ? (measurement - timingBudget.budget) : undefined;
      return {
        metric: metricName,
        label,
        measurement,
        overBudget,
      };
    }).sort((a, b) => {
      return (b.overBudget || 0) - (a.overBudget || 0);
    });

    // CLS requires a different granularity and should be a numeric type.
    // Defining type here overrides the column setting so that it doesn't receive ms units.
    const clsItem = items.find(item => item.metric === 'cumulative-layout-shift');
    if (clsItem) {
      if (typeof clsItem.measurement === 'number') {
        clsItem.measurement = {
          type: 'numeric',
          value: Number(clsItem.measurement),
          granularity: 0.01,
        };
      }
      if (typeof clsItem.overBudget === 'number') {
        clsItem.overBudget = {
          type: 'numeric',
          value: Number(clsItem.overBudget),
          granularity: 0.01,
        };
      }
    }

    return items;
  }

  /**
   * @param {LH.Artifacts} artifacts
   * @param {LH.Audit.Context} context
   * @return {Promise<LH.Audit.Product>}
   */
  static async audit(artifacts, context) {
    const gatherContext = artifacts.GatherContext;
    const devtoolsLog = artifacts.devtoolsLogs[Audit.DEFAULT_PASS];
    const trace = artifacts.traces[Audit.DEFAULT_PASS];
    const mainResource = await MainResource.request({URL: artifacts.URL, devtoolsLog}, context);
    const data = {trace, devtoolsLog, gatherContext, settings: context.settings};
    const summary = (await TimingSummary.request(data, context)).metrics;
    const budget = Budget.getMatchingBudget(context.settings.budgets, mainResource.url);

    if (!budget) {
      return {
        score: 0,
        notApplicable: true,
      };
    }

    /** @type {LH.Audit.Details.Table['headings']} */
    const headers = [
      {key: 'label', itemType: 'text', text: str_(UIStrings.columnTimingMetric)},
      /**
       * Note: SpeedIndex, unlike other timing metrics, is not measured in milliseconds.
       * The renderer applies the correct units to the 'measurement' and 'overBudget' columns for SpeedIndex.
       */
      {key: 'measurement', itemType: 'ms', text: str_(UIStrings.columnMeasurement)},
      {key: 'overBudget', itemType: 'ms', text: str_(i18n.UIStrings.columnOverBudget)},
    ];

    return {
      details: Audit.makeTableDetails(headers, this.tableItems(budget, summary)),
      score: 1,
    };
  }
}

module.exports = TimingBudget;
module.exports.UIStrings = UIStrings;

}).call(this)}).call(this,"/lighthouse-core/audits/timing-budget.js")
},{"../computed/main-resource.js":14,"../computed/metrics/timing-summary.js":36,"../config/budget.js":52,"../lib/i18n/i18n.js":96,"./audit.js":3}],"../audits/unsized-images":[function(require,module,exports){
(function (__filename){(function (){
/**
 * @license Copyright 2020 The Lighthouse Authors. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.
 */
/**
 * @fileoverview
 * Audit that checks whether all images have explicit width and height.
 */

'use strict';

const Audit = require('./audit.js');
const i18n = require('./../lib/i18n/i18n.js');
const URL = require('./../lib/url-shim.js');

const UIStrings = {
  /** Title of a Lighthouse audit that provides detail on whether all images have explicit width and height. This descriptive title is shown to users when every image has explicit width and height */
  title: 'Image elements have explicit `width` and `height`',
  /** Title of a Lighthouse audit that provides detail on whether all images have explicit width and height. This descriptive title is shown to users when one or more images does not have explicit width and height */
  failureTitle: 'Image elements do not have explicit `width` and `height`',
  /** Description of a Lighthouse audit that tells the user why they should include explicit width and height for all images. This is displayed after a user expands the section to see more. No character length limits. 'Learn More' becomes link text to additional documentation. */
  description: 'Set an explicit width and height on image elements to reduce layout shifts and improve CLS. [Learn more](https://web.dev/optimize-cls/#images-without-dimensions)',
};

const str_ = i18n.createMessageInstanceIdFn(__filename, UIStrings);

class UnsizedImages extends Audit {
  /**
   * @return {LH.Audit.Meta}
   */
  static get meta() {
    return {
      id: 'unsized-images',
      title: str_(UIStrings.title),
      failureTitle: str_(UIStrings.failureTitle),
      description: str_(UIStrings.description),
      requiredArtifacts: ['ImageElements'],
    };
  }

  /**
   * An img size attribute prevents layout shifts if it is a non-negative integer (incl zero!).
   * @url https://html.spec.whatwg.org/multipage/embedded-content-other.html#dimension-attributes
   * @param {string | null} attrValue
   * @return {boolean}
   */
  static doesHtmlAttrProvideExplicitSize(attrValue) {
    if (!attrValue) return false;

    // First, superweird edge case of using the positive-sign. The spec _sorta_ says it's valid...
    // https://html.spec.whatwg.org/multipage/common-microsyntaxes.html#rules-for-parsing-integers
    //   > Otherwise, if the character is … (+): Advance position to the next character.
    //   > (The "+" is ignored, but it is not conforming.)
    // lol.  Irrelevant though b/c Chrome (at least) doesn't ignore. It rejects this as a non-conforming value.
    if (attrValue.startsWith('+')) return false;

    // parseInt isn't exactly the same as the html's spec for parsing integers, but it's close enough
    // https://tc39.es/ecma262/#sec-parseint-string-radix
    const int = parseInt(attrValue, 10);
    return int >= 0;
  }

  /**
   * An img css size property prevents layout shifts if it is defined, not empty, and not equal to 'auto'.
   * @param {string | null} property
   * @return {boolean}
   */
  static isCssPropExplicitlySet(property) {
    if (!property) return false;
    return !['auto', 'initial', 'unset', 'inherit'].includes(property);
  }

  /**
   * Images are considered sized if they have defined & valid values.
   * @param {LH.Artifacts.ImageElement} image
   * @return {boolean}
   */
  static isSizedImage(image) {
    // Perhaps we hit reachedGatheringBudget before collecting this image's cssWidth/Height
    // in fetchSourceRules. In this case, we don't have enough information to determine if it's sized.
    // We don't want to show the user a false positive, so we'll call it sized to give it as pass.
    // While this situation should only befall small-impact images, it means our analysis is incomplete. :(
    // Handwavey TODO: explore ways to avoid this.
    if (image.cssEffectiveRules === undefined) return true;

    const attrWidth = image.attributeWidth;
    const attrHeight = image.attributeHeight;
    const cssWidth = image.cssEffectiveRules.width;
    const cssHeight = image.cssEffectiveRules.height;
    const cssAspectRatio = image.cssEffectiveRules.aspectRatio;
    const htmlWidthIsExplicit = UnsizedImages.doesHtmlAttrProvideExplicitSize(attrWidth);
    const cssWidthIsExplicit = UnsizedImages.isCssPropExplicitlySet(cssWidth);
    const htmlHeightIsExplicit = UnsizedImages.doesHtmlAttrProvideExplicitSize(attrHeight);
    const cssHeightIsExplicit = UnsizedImages.isCssPropExplicitlySet(cssHeight);
    const explicitAspectRatio = UnsizedImages.isCssPropExplicitlySet(cssAspectRatio);
    const explicitWidth = htmlWidthIsExplicit || cssWidthIsExplicit;
    const explicitHeight = htmlHeightIsExplicit || cssHeightIsExplicit;
    return (explicitWidth && explicitHeight) ||
      (explicitWidth && explicitAspectRatio) ||
      (explicitHeight && explicitAspectRatio);
  }

  /**
   * @param {LH.Artifacts.ImageElement} image
   * @return {boolean}
   */
  static isNonNetworkSvg(image) {
    const isSvg = image.mimeType === 'image/svg+xml';
    const urlScheme = image.src.slice(0, image.src.indexOf(':'));
    const isNonNetwork = URL.isNonNetworkProtocol(urlScheme);
    return isSvg && isNonNetwork;
  }

  /**
   * @param {LH.Artifacts} artifacts
   * @return {Promise<LH.Audit.Product>}
   */
  static async audit(artifacts) {
    // CSS background-images & ShadowRoot images are ignored for this audit.
    const images = artifacts.ImageElements.filter(el => !el.isCss && !el.isInShadowDOM);
    const unsizedImages = [];

    for (const image of images) {
      // Fixed images are out of document flow and won't cause layout shifts
      const isFixedImage =
        image.computedStyles.position === 'fixed' || image.computedStyles.position === 'absolute';
      if (isFixedImage) continue;

      // Non-network SVGs with dimensions don't cause layout shifts in practice, skip them.
      // See https://github.com/GoogleChrome/lighthouse/issues/11631
      if (UnsizedImages.isNonNetworkSvg(image)) continue;

      // The image was sized with HTML or CSS. Good job.
      if (UnsizedImages.isSizedImage(image)) continue;

      // Images with a 0-size bounding rect (due to hidden parent) aren't part of layout. Cool.
      const boundingRect = image.node.boundingRect;
      const isNotDisplayed = boundingRect.width === 0 && boundingRect.height === 0;
      if (isNotDisplayed) continue;

      unsizedImages.push({
        url: URL.elideDataURI(image.src),
        node: Audit.makeNodeItem(image.node),
      });
    }

    /** @type {LH.Audit.Details.Table['headings']} */
    const headings = [
      {key: 'url', itemType: 'thumbnail', text: ''},
      {key: 'url', itemType: 'url', text: str_(i18n.UIStrings.columnURL)},
      {key: 'node', itemType: 'node', text: str_(i18n.UIStrings.columnFailingElem)},
    ];

    return {
      score: unsizedImages.length > 0 ? 0 : 1,
      notApplicable: images.length === 0,
      details: Audit.makeTableDetails(headings, unsizedImages),
    };
  }
}

module.exports = UnsizedImages;
module.exports.UIStrings = UIStrings;

}).call(this)}).call(this,"/lighthouse-core/audits/unsized-images.js")
},{"./../lib/i18n/i18n.js":96,"./../lib/url-shim.js":"url","./audit.js":3}],"../audits/user-timings":[function(require,module,exports){
(function (__filename){(function (){
/**
 * @license Copyright 2016 The Lighthouse Authors. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.
 */
'use strict';

const Audit = require('./audit.js');
const i18n = require('../lib/i18n/i18n.js');
const ComputedUserTimings = require('../computed/user-timings.js');

const UIStrings = {
  /** Descriptive title of a diagnostic audit that provides details on any timestamps generated by the page. User Timing refers to the 'User Timing API', which enables a website to record specific times as 'marks', or spans of time as 'measures'. */
  title: 'User Timing marks and measures',
  /** Description of a Lighthouse audit that tells the user they may want to use the User Timing API to help measure the performance of aspects of their page load and interaction. This is displayed after a user expands the section to see more. No character length limits. 'Learn More' becomes link text to additional documentation. */
  description: 'Consider instrumenting your app with the User Timing API to measure your ' +
      'app\'s real-world performance during key user experiences. ' +
      '[Learn more](https://web.dev/user-timings/).',
  /** [ICU Syntax] Label for an audit identifying the number of User Timing timestamps present in the page. */
  displayValue: `{itemCount, plural,
    =1 {1 user timing}
    other {# user timings}
    }`,
  /** Label for the Type column in the User Timing event data table. User Timing API entries are added by the developer of the web page. The only possible types are 'Mark' and Measure'. */
  columnType: 'Type',
};

const str_ = i18n.createMessageInstanceIdFn(__filename, UIStrings);

/** @typedef {{name: string, isMark: true, args: LH.TraceEvent['args'], startTime: number}} MarkEvent */
/** @typedef {{name: string, isMark: false, args: LH.TraceEvent['args'], startTime: number, endTime: number, duration: number}} MeasureEvent */

class UserTimings extends Audit {
  /**
   * @return {LH.Audit.Meta}
   */
  static get meta() {
    return {
      id: 'user-timings',
      title: str_(UIStrings.title),
      description: str_(UIStrings.description),
      scoreDisplayMode: Audit.SCORING_MODES.INFORMATIVE,
      requiredArtifacts: ['traces'],
    };
  }

  /**
   * @return {Array<string>}
   */
  static get excludedPrefixes() {
    return ['goog_'];
  }

  /**
   * We remove mark/measures entered by third parties not of interest to the user
   * @param {MarkEvent|MeasureEvent} evt
   * @return {boolean}
   */
  static excludeEvent(evt) {
    return UserTimings.excludedPrefixes.every(prefix => !evt.name.startsWith(prefix));
  }

  /**
   * @param {LH.Artifacts} artifacts
   * @param {LH.Audit.Context} context
   * @return {Promise<LH.Audit.Product>}
   */
  static audit(artifacts, context) {
    const trace = artifacts.traces[Audit.DEFAULT_PASS];
    return ComputedUserTimings.request(trace, context).then(computedUserTimings => {
      const userTimings = computedUserTimings.filter(UserTimings.excludeEvent);
      const tableRows = userTimings.map(item => {
        return {
          name: item.name,
          startTime: item.startTime,
          duration: item.isMark ? undefined : item.duration,
          timingType: item.isMark ? 'Mark' : 'Measure',
        };
      }).sort((itemA, itemB) => {
        if (itemA.timingType === itemB.timingType) {
          // If both items are the same type, sort in ascending order by time
          return itemA.startTime - itemB.startTime;
        } else if (itemA.timingType === 'Measure') {
          // Put measures before marks
          return -1;
        } else {
          return 1;
        }
      });

      /** @type {LH.Audit.Details.Table['headings']} */
      const headings = [
        {key: 'name', itemType: 'text', text: str_(i18n.UIStrings.columnName)},
        {key: 'timingType', itemType: 'text', text: str_(UIStrings.columnType)},
        {key: 'startTime', itemType: 'ms', granularity: 0.01,
          text: str_(i18n.UIStrings.columnStartTime)},
        {key: 'duration', itemType: 'ms', granularity: 0.01,
          text: str_(i18n.UIStrings.columnDuration)},
      ];

      const details = Audit.makeTableDetails(headings, tableRows);

      let displayValue;
      if (userTimings.length) {
        displayValue = str_(UIStrings.displayValue, {itemCount: userTimings.length});
      }

      return {
        // mark the audit as notApplicable if there were no user timings
        score: Number(userTimings.length === 0),
        notApplicable: userTimings.length === 0,
        displayValue,
        details,
      };
    });
  }
}

module.exports = UserTimings;
module.exports.UIStrings = UIStrings;

}).call(this)}).call(this,"/lighthouse-core/audits/user-timings.js")
},{"../computed/user-timings.js":50,"../lib/i18n/i18n.js":96,"./audit.js":3}],"../audits/uses-rel-preconnect":[function(require,module,exports){
(function (__filename){(function (){
/**
 * @license Copyright 2018 The Lighthouse Authors. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.
 */

'use strict';

const Audit = require('./audit.js');
const UnusedBytes = require('./byte-efficiency/byte-efficiency-audit.js');
const URL = require('../lib/url-shim.js');
const i18n = require('../lib/i18n/i18n.js');
const NetworkRecords = require('../computed/network-records.js');
const MainResource = require('../computed/main-resource.js');
const LoadSimulator = require('../computed/load-simulator.js');
const ProcessedTrace = require('../computed/processed-trace.js');
const ProcessedNavigation = require('../computed/processed-navigation.js');
const PageDependencyGraph = require('../computed/page-dependency-graph.js');
const LanternLCP = require('../computed/metrics/lantern-largest-contentful-paint.js');

// Preconnect establishes a "clean" socket. Chrome's socket manager will keep an unused socket
// around for 10s. Meaning, the time delta between processing preconnect a request should be <10s,
// otherwise it's wasted. We add a 5s margin so we are sure to capture all key requests.
// @see https://github.com/GoogleChrome/lighthouse/issues/3106#issuecomment-333653747
const PRECONNECT_SOCKET_MAX_IDLE = 15;

const IGNORE_THRESHOLD_IN_MS = 50;

const UIStrings = {
  /** Imperative title of a Lighthouse audit that tells the user to connect early to internet domains that will be used to load page resources. Origin is the correct term, however 'domain name' could be used if neccsesary. This is displayed in a list of audit titles that Lighthouse generates. */
  title: 'Preconnect to required origins',
  /** Description of a Lighthouse audit that tells the user how to connect early to third-party domains that will be used to load page resources. This is displayed after a user expands the section to see more. No character length limits. 'Learn More' becomes link text to additional documentation. */
  description:
    'Consider adding `preconnect` or `dns-prefetch` resource hints to establish early ' +
    'connections to important third-party origins. ' +
    '[Learn more](https://web.dev/uses-rel-preconnect/).',
  /**
   * @description A warning message that is shown when the user tried to follow the advice of the audit, but it's not working as expected.
   * @example {https://example.com} securityOrigin
   * */
  unusedWarning: 'A `<link rel=preconnect>` was found for "{securityOrigin}" but was not used ' +
    'by the browser. Only use `preconnect` for important origins ' +
    'that the page will certainly request.',
  /**
   * @description A warning message that is shown when the user tried to follow the advice of the audit, but it's not working as expected. Forgetting to set the `crossorigin` HTML attribute, or setting it to an incorrect value, on the link is a common mistake when adding preconnect links.
   * @example {https://example.com} securityOrigin
   * */
  crossoriginWarning: 'A `<link rel=preconnect>` was found for "{securityOrigin}" but was not ' +
    'used by the browser. Check that you are using the `crossorigin` attribute properly.',
  /** A warning message that is shown when found more than 2 preconnected links */
  tooManyPreconnectLinksWarning: 'More than 2 `<link rel=preconnect>` connections were found. ' +
   'These should be used sparingly and only to the most important origins.',
};

const str_ = i18n.createMessageInstanceIdFn(__filename, UIStrings);

class UsesRelPreconnectAudit extends Audit {
  /**
   * @return {LH.Audit.Meta}
   */
  static get meta() {
    return {
      id: 'uses-rel-preconnect',
      title: str_(UIStrings.title),
      description: str_(UIStrings.description),
      supportedModes: ['navigation'],
      requiredArtifacts: ['traces', 'devtoolsLogs', 'URL', 'LinkElements'],
      scoreDisplayMode: Audit.SCORING_MODES.NUMERIC,
    };
  }

  /**
   * Check if record has valid timing
   * @param {LH.Artifacts.NetworkRequest} record
   * @return {boolean}
   */
  static hasValidTiming(record) {
    return !!record.timing && record.timing.connectEnd > 0 && record.timing.connectStart > 0;
  }

  /**
   * Check is the connection is already open
   * @param {LH.Artifacts.NetworkRequest} record
   * @return {boolean}
   */
  static hasAlreadyConnectedToOrigin(record) {
    return (
      !!record.timing &&
      record.timing.dnsEnd - record.timing.dnsStart === 0 &&
      record.timing.connectEnd - record.timing.connectStart === 0
    );
  }

  /**
   * Check is the connection has started before the socket idle time
   * @param {LH.Artifacts.NetworkRequest} record
   * @param {LH.Artifacts.NetworkRequest} mainResource
   * @return {boolean}
   */
  static socketStartTimeIsBelowThreshold(record, mainResource) {
    return Math.max(0, record.startTime - mainResource.endTime) < PRECONNECT_SOCKET_MAX_IDLE;
  }

  /**
   * @param {LH.Artifacts} artifacts
   * @param {LH.Audit.Context} context
   * @return {Promise<LH.Audit.Product>}
   */
  static async audit(artifacts, context) {
    const trace = artifacts.traces[UsesRelPreconnectAudit.DEFAULT_PASS];
    const devtoolsLog = artifacts.devtoolsLogs[UsesRelPreconnectAudit.DEFAULT_PASS];
    const settings = context.settings;

    let maxWasted = 0;
    /** @type {Array<LH.IcuMessage>} */
    const warnings = [];

    const processedTrace = await ProcessedTrace.request(trace, context);

    const [networkRecords, mainResource, loadSimulator, processedNavigation, pageGraph] =
      await Promise.all([
        NetworkRecords.request(devtoolsLog, context),
        MainResource.request({devtoolsLog, URL: artifacts.URL}, context),
        LoadSimulator.request({devtoolsLog, settings}, context),
        ProcessedNavigation.request(processedTrace, context),
        PageDependencyGraph.request({trace, devtoolsLog}, context),
      ]);

    const {rtt, additionalRttByOrigin} = loadSimulator.getOptions();
    const lcpGraph = await LanternLCP.getPessimisticGraph(pageGraph, processedNavigation);
    /** @type {Set<string>} */
    const lcpGraphURLs = new Set();
    lcpGraph.traverse(node => {
      if (node.type === 'network' ) lcpGraphURLs.add(node.record.url);
    });

    /** @type {Map<string, LH.Artifacts.NetworkRequest[]>}  */
    const origins = new Map();
    networkRecords
      .forEach(record => {
        if (
          // Filter out all resources where timing info was invalid.
          !UsesRelPreconnectAudit.hasValidTiming(record) ||
          // Filter out all resources that are loaded by the document. Connections are already early.
          record.initiator.url === mainResource.url ||
          // Filter out urls that do not have an origin (data, file, etc).
          !record.parsedURL || !record.parsedURL.securityOrigin ||
          // Filter out all resources that have the same origin. We're already connected.
          mainResource.parsedURL.securityOrigin === record.parsedURL.securityOrigin ||
          // Filter out anything that wasn't part of LCP. Only recommend important origins.
          !lcpGraphURLs.has(record.url) ||
          // Filter out all resources where origins are already resolved.
          UsesRelPreconnectAudit.hasAlreadyConnectedToOrigin(record) ||
          // Make sure the requests are below the PRECONNECT_SOCKET_MAX_IDLE (15s) mark.
          !UsesRelPreconnectAudit.socketStartTimeIsBelowThreshold(record, mainResource)
        ) {
          return;
        }

        const securityOrigin = record.parsedURL.securityOrigin;
        const records = origins.get(securityOrigin) || [];
        records.push(record);
        origins.set(securityOrigin, records);
      });

    const preconnectLinks = artifacts.LinkElements.filter(el => el.rel === 'preconnect');
    const preconnectOrigins = new Set(preconnectLinks.map(link => URL.getOrigin(link.href || '')));

    /** @type {Array<{url: string, wastedMs: number}>}*/
    let results = [];
    origins.forEach(records => {
      // Sometimes requests are done simultaneous and the connection has not been made
      // chrome will try to connect for each network record, we get the first record
      const firstRecordOfOrigin = records.reduce((firstRecord, record) => {
        return (record.startTime < firstRecord.startTime) ? record : firstRecord;
      });

      // Skip the origin if we don't have timing information
      if (!firstRecordOfOrigin.timing) return;

      const securityOrigin = firstRecordOfOrigin.parsedURL.securityOrigin;

      // Approximate the connection time with the duration of TCP (+potentially SSL) handshake
      // DNS time can be large but can also be 0 if a commonly used origin that's cached, so make
      // no assumption about DNS.
      const additionalRtt = additionalRttByOrigin.get(securityOrigin) || 0;
      let connectionTime = rtt + additionalRtt;
      // TCP Handshake will be at least 2 RTTs for TLS connections
      if (firstRecordOfOrigin.parsedURL.scheme === 'https') connectionTime = connectionTime * 2;

      const timeBetweenMainResourceAndDnsStart =
        firstRecordOfOrigin.startTime * 1000 -
        mainResource.endTime * 1000 +
        firstRecordOfOrigin.timing.dnsStart;

      const wastedMs = Math.min(connectionTime, timeBetweenMainResourceAndDnsStart);
      if (wastedMs < IGNORE_THRESHOLD_IN_MS) return;

      if (preconnectOrigins.has(securityOrigin)) {
        // Add a warning for any origin the user tried to preconnect to but failed
        warnings.push(str_(UIStrings.crossoriginWarning, {securityOrigin}));
        return;
      }

      maxWasted = Math.max(wastedMs, maxWasted);
      results.push({
        url: securityOrigin,
        wastedMs: wastedMs,
      });
    });

    results = results
      .sort((a, b) => b.wastedMs - a.wastedMs);

    // Add warnings for any preconnect origins that aren't being used.
    for (const origin of preconnectOrigins) {
      if (!origin) continue;
      if (networkRecords.some(record => origin === record.parsedURL.securityOrigin)) continue;
      warnings.push(str_(UIStrings.unusedWarning, {securityOrigin: origin}));
    }

    // Shortcut early with a pass when the user has already configured preconnect.
    // https://twitter.com/_tbansal/status/1197771385172480001
    if (preconnectLinks.length >= 2) {
      return {
        score: 1,
        warnings: preconnectLinks.length >= 3 ?
          [...warnings, str_(UIStrings.tooManyPreconnectLinksWarning)] : warnings,
      };
    }

    /** @type {LH.Audit.Details.Opportunity['headings']} */
    const headings = [
      {key: 'url', valueType: 'url', label: str_(i18n.UIStrings.columnURL)},
      {key: 'wastedMs', valueType: 'timespanMs', label: str_(i18n.UIStrings.columnWastedMs)},
    ];

    const details = Audit.makeOpportunityDetails(headings, results, maxWasted);

    return {
      score: UnusedBytes.scoreForWastedMs(maxWasted),
      numericValue: maxWasted,
      numericUnit: 'millisecond',
      displayValue: maxWasted ?
        str_(i18n.UIStrings.displayValueMsSavings, {wastedMs: maxWasted}) :
        '',
      warnings,
      details,
    };
  }
}

module.exports = UsesRelPreconnectAudit;
module.exports.UIStrings = UIStrings;

}).call(this)}).call(this,"/lighthouse-core/audits/uses-rel-preconnect.js")
},{"../computed/load-simulator.js":13,"../computed/main-resource.js":14,"../computed/metrics/lantern-largest-contentful-paint.js":25,"../computed/network-records.js":40,"../computed/page-dependency-graph.js":41,"../computed/processed-navigation.js":42,"../computed/processed-trace.js":43,"../lib/i18n/i18n.js":96,"../lib/url-shim.js":"url","./audit.js":3,"./byte-efficiency/byte-efficiency-audit.js":4}],"../audits/uses-rel-preload":[function(require,module,exports){
(function (__filename){(function (){
/**
 * @license Copyright 2017 The Lighthouse Authors. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.
 */
'use strict';

const URL = require('../lib/url-shim.js');
const NetworkRequest = require('../lib/network-request.js');
const Audit = require('./audit.js');
const UnusedBytes = require('./byte-efficiency/byte-efficiency-audit.js');
const CriticalRequestChains = require('../computed/critical-request-chains.js');
const i18n = require('../lib/i18n/i18n.js');
const MainResource = require('../computed/main-resource.js');
const PageDependencyGraph = require('../computed/page-dependency-graph.js');
const LoadSimulator = require('../computed/load-simulator.js');

const UIStrings = {
  /** Imperative title of a Lighthouse audit that tells the user to use <link rel=preload> to initiate important network requests earlier during page load. This is displayed in a list of audit titles that Lighthouse generates. */
  title: 'Preload key requests',
  /** Description of a Lighthouse audit that tells the user *why* they should preload important network requests. The associated network requests are started halfway through pageload (or later) but should be started at the beginning. This is displayed after a user expands the section to see more. No character length limits. '<link rel=preload>' is the html code the user would include in their page and shouldn't be translated. 'Learn More' becomes link text to additional documentation. */
  description: 'Consider using `<link rel=preload>` to prioritize fetching resources that are ' +
    'currently requested later in page load. [Learn more](https://web.dev/uses-rel-preload/).',
  /**
   * @description A warning message that is shown when the user tried to follow the advice of the audit, but it's not working as expected. Forgetting to set the `crossorigin` HTML attribute, or setting it to an incorrect value, on the link is a common mistake when adding preload links.
   * @example {https://example.com} preloadURL
   * */
  crossoriginWarning: 'A preload `<link>` was found for "{preloadURL}" but was not used ' +
    'by the browser. Check that you are using the `crossorigin` attribute properly.',
};

const str_ = i18n.createMessageInstanceIdFn(__filename, UIStrings);

const THRESHOLD_IN_MS = 100;

class UsesRelPreloadAudit extends Audit {
  /**
   * @return {LH.Audit.Meta}
   */
  static get meta() {
    return {
      id: 'uses-rel-preload',
      title: str_(UIStrings.title),
      description: str_(UIStrings.description),
      supportedModes: ['navigation'],
      requiredArtifacts: ['devtoolsLogs', 'traces', 'URL'],
      scoreDisplayMode: Audit.SCORING_MODES.NUMERIC,
    };
  }

  /**
   * @param {LH.Artifacts.NetworkRequest} mainResource
   * @param {LH.Gatherer.Simulation.GraphNode} graph
   * @return {Set<string>}
   */
  static getURLsToPreload(mainResource, graph) {
    /** @type {Set<string>} */
    const urls = new Set();

    graph.traverse((node, traversalPath) => {
      if (node.type !== 'network') return;
      // Don't include the node itself or any CPU nodes in the initiatorPath
      const path = traversalPath.slice(1).filter(initiator => initiator.type === 'network');
      if (!UsesRelPreloadAudit.shouldPreloadRequest(node.record, mainResource, path)) return;
      urls.add(node.record.url);
    });

    return urls;
  }

  /**
   * Finds which URLs were attempted to be preloaded, but failed to be reused and were requested again.
   *
   * @param {LH.Gatherer.Simulation.GraphNode} graph
   * @return {Set<string>}
   */
  static getURLsFailedToPreload(graph) {
    /** @type {Array<LH.Artifacts.NetworkRequest>} */
    const requests = [];
    graph.traverse(node => node.type === 'network' && requests.push(node.record));

    const preloadRequests = requests.filter(req => req.isLinkPreload);
    const preloadURLsByFrame = new Map();
    for (const request of preloadRequests) {
      const preloadURLs = preloadURLsByFrame.get(request.frameId) || new Set();
      preloadURLs.add(request.url);
      preloadURLsByFrame.set(request.frameId, preloadURLs);
    }

    // A failed preload attempt will manifest as a URL that was requested twice within the same frame.
    // Once with `isLinkPreload` AND again without `isLinkPreload` but not hitting the cache.
    const duplicateRequestsAfterPreload = requests.filter(request => {
      const preloadURLsForFrame = preloadURLsByFrame.get(request.frameId);
      if (!preloadURLsForFrame) return false;
      if (!preloadURLsForFrame.has(request.url)) return false;
      const fromCache = request.fromDiskCache ||
        request.fromMemoryCache ||
        request.fromPrefetchCache;
      return !fromCache && !request.isLinkPreload;
    });

    return new Set(duplicateRequestsAfterPreload.map(req => req.url));
  }

  /**
   * We want to preload all first party critical requests at depth 2.
   * Third party requests can be tricky to know the URL ahead of time.
   * Critical requests at depth 1 would already be identified by the browser for preloading.
   * Critical requests deeper than depth 2 are more likely to be a case-by-case basis such that it
   * would be a little risky to recommend blindly.
   *
   * @param {LH.Artifacts.NetworkRequest} request
   * @param {LH.Artifacts.NetworkRequest} mainResource
   * @param {Array<LH.Gatherer.Simulation.GraphNode>} initiatorPath
   * @return {boolean}
   */
  static shouldPreloadRequest(request, mainResource, initiatorPath) {
    const mainResourceDepth = mainResource.redirects ? mainResource.redirects.length : 0;

    // If it's already preloaded, no need to recommend it.
    if (request.isLinkPreload) return false;
    // It's not critical, don't recommend it.
    if (!CriticalRequestChains.isCritical(request, mainResource)) return false;
    // It's not a request loaded over the network, don't recommend it.
    if (NetworkRequest.isNonNetworkRequest(request)) return false;
    // It's not at the right depth, don't recommend it.
    if (initiatorPath.length !== mainResourceDepth + 2) return false;
    // It's not a request for the main frame, it wouldn't get reused even if you did preload it.
    if (request.frameId !== mainResource.frameId) return false;
    // We survived everything else, just check that it's a first party request.
    return URL.rootDomainsMatch(request.url, mainResource.url);
  }

  /**
   * Computes the estimated effect of preloading all the resources.
   * @param {Set<string>} urls The array of byte savings results per resource
   * @param {LH.Gatherer.Simulation.GraphNode} graph
   * @param {LH.Gatherer.Simulation.Simulator} simulator
   * @return {{wastedMs: number, results: Array<{url: string, wastedMs: number}>}}
   */
  static computeWasteWithGraph(urls, graph, simulator) {
    if (!urls.size) {
      return {wastedMs: 0, results: []};
    }

    // Preload changes the ordering of requests, simulate the original graph with flexible ordering
    // to have a reasonable baseline for comparison.
    const simulationBeforeChanges = simulator.simulate(graph, {flexibleOrdering: true});
    const modifiedGraph = graph.cloneWithRelationships();

    /** @type {Array<LH.Gatherer.Simulation.GraphNetworkNode>} */
    const nodesToPreload = [];
    /** @type {LH.Gatherer.Simulation.GraphNode|null} */
    let mainDocumentNode = null;
    modifiedGraph.traverse(node => {
      if (node.type !== 'network') return;

      if (node.isMainDocument()) {
        mainDocumentNode = node;
      } else if (node.record && urls.has(node.record.url)) {
        nodesToPreload.push(node);
      }
    });

    if (!mainDocumentNode) {
      // Should always find the main document node
      throw new Error('Could not find main document node');
    }

    // Preload has the effect of moving the resource's only dependency to the main HTML document
    // Remove all dependencies of the nodes
    for (const node of nodesToPreload) {
      node.removeAllDependencies();
      node.addDependency(mainDocumentNode);
    }

    // Once we've modified the dependencies, simulate the new graph with flexible ordering.
    const simulationAfterChanges = simulator.simulate(modifiedGraph, {flexibleOrdering: true});
    const originalNodesByRecord = Array.from(simulationBeforeChanges.nodeTimings.keys())
        // @ts-expect-error we don't care if all nodes without a record collect on `undefined`
        .reduce((map, node) => map.set(node.record, node), new Map());

    const results = [];
    for (const node of nodesToPreload) {
      const originalNode = originalNodesByRecord.get(node.record);
      const timingAfter = simulationAfterChanges.nodeTimings.get(node);
      const timingBefore = simulationBeforeChanges.nodeTimings.get(originalNode);
      if (!timingBefore || !timingAfter) throw new Error('Missing preload node');

      const wastedMs = Math.round(timingBefore.endTime - timingAfter.endTime);
      if (wastedMs < THRESHOLD_IN_MS) continue;
      results.push({url: node.record.url, wastedMs});
    }

    if (!results.length) {
      return {wastedMs: 0, results};
    }

    return {
      // Preload won't necessarily impact the deepest chain/overall time
      // We'll use the maximum endTime improvement for now
      wastedMs: Math.max(...results.map(item => item.wastedMs)),
      results,
    };
  }

  /**
   * @param {LH.Artifacts} artifacts
   * @param {LH.Audit.Context} context
   * @return {Promise<LH.Audit.Product>}
   */
  static async audit_(artifacts, context) {
    const trace = artifacts.traces[UsesRelPreloadAudit.DEFAULT_PASS];
    const devtoolsLog = artifacts.devtoolsLogs[UsesRelPreloadAudit.DEFAULT_PASS];
    const URL = artifacts.URL;
    const simulatorOptions = {devtoolsLog, settings: context.settings};

    const [mainResource, graph, simulator] = await Promise.all([
      MainResource.request({devtoolsLog, URL}, context),
      PageDependencyGraph.request({trace, devtoolsLog}, context),
      LoadSimulator.request(simulatorOptions, context),
    ]);

    const urls = UsesRelPreloadAudit.getURLsToPreload(mainResource, graph);
    const {results, wastedMs} = UsesRelPreloadAudit.computeWasteWithGraph(urls, graph, simulator);
    // sort results by wastedTime DESC
    results.sort((a, b) => b.wastedMs - a.wastedMs);

    /** @type {Array<LH.IcuMessage>|undefined} */
    let warnings;
    const failedURLs = UsesRelPreloadAudit.getURLsFailedToPreload(graph);
    if (failedURLs.size) {
      warnings = Array.from(failedURLs)
        .map(preloadURL => str_(UIStrings.crossoriginWarning, {preloadURL}));
    }

    /** @type {LH.Audit.Details.Opportunity['headings']} */
    const headings = [
      {key: 'url', valueType: 'url', label: str_(i18n.UIStrings.columnURL)},
      {key: 'wastedMs', valueType: 'timespanMs', label: str_(i18n.UIStrings.columnWastedMs)},
    ];
    const details = Audit.makeOpportunityDetails(headings, results, wastedMs);

    return {
      score: UnusedBytes.scoreForWastedMs(wastedMs),
      numericValue: wastedMs,
      numericUnit: 'millisecond',
      displayValue: wastedMs ?
        str_(i18n.UIStrings.displayValueMsSavings, {wastedMs}) :
        '',
      details,
      warnings,
    };
  }

  /**
   * @return {Promise<LH.Audit.Product>}
   */
  static async audit() {
    // Preload advice is dangerous until https://bugs.chromium.org/p/chromium/issues/detail?id=788757
    // has been fixed and validated. All preload audits are on hold until then.
    // See https://github.com/GoogleChrome/lighthouse/issues/11960 for more discussion.
    return {score: 1, notApplicable: true, details: Audit.makeOpportunityDetails([], [], 0)};
  }
}

module.exports = UsesRelPreloadAudit;
module.exports.UIStrings = UIStrings;

}).call(this)}).call(this,"/lighthouse-core/audits/uses-rel-preload.js")
},{"../computed/critical-request-chains.js":10,"../computed/load-simulator.js":13,"../computed/main-resource.js":14,"../computed/page-dependency-graph.js":41,"../lib/i18n/i18n.js":96,"../lib/network-request.js":109,"../lib/url-shim.js":"url","./audit.js":3,"./byte-efficiency/byte-efficiency-audit.js":4}],"../audits/valid-source-maps":[function(require,module,exports){
(function (__filename){(function (){
/**
 * @license Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.
 */
'use strict';

const thirdPartyWeb = require('../lib/third-party-web.js');
const Audit = require('./audit.js');
const i18n = require('../lib/i18n/i18n.js');

const UIStrings = {
  /** Title of a Lighthouse audit that provides detail on HTTP to HTTPS redirects. This descriptive title is shown to users when HTTP traffic is redirected to HTTPS. */
  title: 'Page has valid source maps',
  /** Title of a Lighthouse audit that provides detail on HTTP to HTTPS redirects. This descriptive title is shown to users when HTTP traffic is not redirected to HTTPS. */
  failureTitle: 'Missing source maps for large first-party JavaScript',
  /** Description of a Lighthouse audit that tells the user that their JavaScript source maps are invalid or missing. This is displayed after a user expands the section to see more. No character length limits. 'Learn More' becomes link text to additional documentation. */
  description: 'Source maps translate minified code to the original source code. This helps ' +
    'developers debug in production. In addition, Lighthouse is able to provide further ' +
    'insights. Consider deploying source maps to take advantage of these benefits. ' +
    '[Learn more](https://developers.google.com/web/tools/chrome-devtools/javascript/source-maps).',
  /** Label for a column in a data table. Entries will be URLs to JavaScript source maps. */
  columnMapURL: 'Map URL',
  /** Label for a possible error message indicating that a source map for a large, first-party JavaScript script is missing. */
  missingSourceMapErrorMessage: 'Large JavaScript file is missing a source map',
  /** Label for a possible error message indicating that the content of a source map is invalid because it is missing items in the sourcesContent attribute. */
  missingSourceMapItemsWarningMesssage: `{missingItems, plural,
    =1 {Warning: missing 1 item in \`.sourcesContent\`}
    other {Warning: missing # items in \`.sourcesContent\`}
    }`,
};

const str_ = i18n.createMessageInstanceIdFn(__filename, UIStrings);

const LARGE_JS_BYTE_THRESHOLD = 500 * 1024;

class ValidSourceMaps extends Audit {
  /**
   * @return {LH.Audit.Meta}
   */
  static get meta() {
    return {
      id: 'valid-source-maps',
      title: str_(UIStrings.title),
      failureTitle: str_(UIStrings.failureTitle),
      description: str_(UIStrings.description),
      requiredArtifacts: ['ScriptElements', 'SourceMaps', 'URL'],
    };
  }

  /**
   * Returns true if the size of the script exceeds a static threshold.
   * @param {LH.Artifacts.ScriptElement} scriptElement
   * @param {string} finalURL
   * @return {boolean}
   */
  static isLargeFirstPartyJS(scriptElement, finalURL) {
    if (scriptElement.content === null) return false;

    const isLargeJS = scriptElement.content.length >= LARGE_JS_BYTE_THRESHOLD;
    const isFirstPartyJS = scriptElement.src ?
      thirdPartyWeb.isFirstParty(scriptElement.src, thirdPartyWeb.getEntity(finalURL)) : false;

    return isLargeJS && isFirstPartyJS;
  }

  /**
   * @param {LH.Artifacts} artifacts
   */
  static async audit(artifacts) {
    const {SourceMaps} = artifacts;

    /** @type {Set<string>} */
    const isMissingMapForLargeFirstPartyScriptUrl = new Set();

    let missingMapsForLargeFirstPartyFile = false;
    const results = [];
    for (const scriptElement of artifacts.ScriptElements) {
      if (!scriptElement.src) continue; // TODO: inline scripts, how do they work?

      const sourceMap = SourceMaps.find(m => m.scriptUrl === scriptElement.src);
      const errors = [];
      const isLargeFirstParty = this.isLargeFirstPartyJS(scriptElement, artifacts.URL.finalUrl);

      if (isLargeFirstParty && (!sourceMap || !sourceMap.map)) {
        missingMapsForLargeFirstPartyFile = true;
        isMissingMapForLargeFirstPartyScriptUrl.add(scriptElement.src);
        errors.push({error: str_(UIStrings.missingSourceMapErrorMessage)});
      }

      if (sourceMap && !sourceMap.map) {
        errors.push({error: sourceMap.errorMessage});
      }

      // Sources content errors.
      if (sourceMap && sourceMap.map) {
        const sourcesContent = sourceMap.map.sourcesContent || [];
        let missingSourcesContentCount = 0;
        for (let i = 0; i < sourceMap.map.sources.length; i++) {
          if (sourcesContent.length < i || !sourcesContent[i]) missingSourcesContentCount += 1;
        }
        if (missingSourcesContentCount > 0) {
          errors.push({error: str_(UIStrings.missingSourceMapItemsWarningMesssage,
              {missingItems: missingSourcesContentCount})});
        }
      }

      if (sourceMap || errors.length) {
        results.push({
          scriptUrl: scriptElement.src,
          sourceMapUrl: sourceMap && sourceMap.sourceMapUrl,
          subItems: {
            type: /** @type {'subitems'} */ ('subitems'),
            items: errors,
          },
        });
      }
    }

    /** @type {LH.Audit.Details.TableColumnHeading[]} */
    const headings = [
      /* eslint-disable max-len */
      {
        key: 'scriptUrl',
        itemType: 'url',
        subItemsHeading: {key: 'error'},
        text: str_(i18n.UIStrings.columnURL),
      },
      {key: 'sourceMapUrl', itemType: 'url', text: str_(UIStrings.columnMapURL)},
      /* eslint-enable max-len */
    ];

    results.sort((a, b) => {
      // Show the items that can fail the audit first.
      const missingMapA = isMissingMapForLargeFirstPartyScriptUrl.has(a.scriptUrl);
      const missingMapB = isMissingMapForLargeFirstPartyScriptUrl.has(b.scriptUrl);
      if (missingMapA && !missingMapB) return -1;
      if (!missingMapA && missingMapB) return 1;

      // Then sort by whether one has errors and the other doesn't.
      if (a.subItems.items.length && !b.subItems.items.length) return -1;
      if (!a.subItems.items.length && b.subItems.items.length) return 1;

      // Then sort by script url.
      return b.scriptUrl.localeCompare(a.scriptUrl);
    });

    // Only fails if `missingMapsForLargeFirstPartyFile` is true. All other errors are diagnostical.
    return {
      score: missingMapsForLargeFirstPartyFile ? 0 : 1,
      details: Audit.makeTableDetails(headings, results),
    };
  }
}

module.exports = ValidSourceMaps;
module.exports.UIStrings = UIStrings;

}).call(this)}).call(this,"/lighthouse-core/audits/valid-source-maps.js")
},{"../lib/i18n/i18n.js":96,"../lib/third-party-web.js":116,"./audit.js":3}],"../audits/viewport":[function(require,module,exports){
(function (__filename){(function (){
/**
 * @license Copyright 2016 The Lighthouse Authors. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.
 */
'use strict';

const Audit = require('./audit.js');
const ComputedViewportMeta = require('../computed/viewport-meta.js');
const i18n = require('../lib/i18n/i18n.js');

const UIStrings = {
  /** Title of a Lighthouse audit that provides detail on the viewport meta tag in a web page's html. This descriptive title is shown to users when a viewport tag is set and configured. */
  title: 'Has a `<meta name="viewport">` tag with `width` or `initial-scale`',
  /** Title of a Lighthouse audit that provides detail on the viewport meta tag in a web page's html. This descriptive title is shown to users when a viewport tag is not set or configured. */
  failureTitle: 'Does not have a `<meta name="viewport">` tag with `width` ' +
    'or `initial-scale`',
  /** Description of a Lighthouse audit that tells the user why they should have a viewport meta tag in their html. This is displayed after a user expands the section to see more. No character length limits. 'Learn More' becomes link text to additional documentation. */
  description: 'Add a `<meta name="viewport">` tag to optimize your app for mobile screens. ' +
    '[Learn more](https://web.dev/viewport/).',
  /** Explanatory message stating that no viewport meta tag exists on the page. */
  explanationNoTag: 'No `<meta name="viewport">` tag found',
};

const str_ = i18n.createMessageInstanceIdFn(__filename, UIStrings);

class Viewport extends Audit {
  /**
   * @return {LH.Audit.Meta}
   */
  static get meta() {
    return {
      id: 'viewport',
      title: str_(UIStrings.title),
      failureTitle: str_(UIStrings.failureTitle),
      description: str_(UIStrings.description),
      requiredArtifacts: ['MetaElements'],
    };
  }

  /**
   * @param {LH.Artifacts} artifacts
   * @param {LH.Audit.Context} context
   * @return {Promise<LH.Audit.Product>}
   */
  static async audit(artifacts, context) {
    const viewportMeta = await ComputedViewportMeta.request(artifacts.MetaElements, context);

    if (!viewportMeta.hasViewportTag) {
      return {
        score: 0,
        explanation: str_(UIStrings.explanationNoTag),
      };
    }

    return {
      score: Number(viewportMeta.isMobileOptimized),
      warnings: viewportMeta.parserWarnings,
    };
  }
}

module.exports = Viewport;
module.exports.UIStrings = UIStrings;

}).call(this)}).call(this,"/lighthouse-core/audits/viewport.js")
},{"../computed/viewport-meta.js":51,"../lib/i18n/i18n.js":96,"./audit.js":3}],"../gather/gatherers/accessibility":[function(require,module,exports){
/**
 * @license Copyright 2016 The Lighthouse Authors. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.
 */
'use strict';

/* global window, document, getNodeDetails */

const FRGatherer = require('../../fraggle-rock/gather/base-gatherer.js');
const axeLibSource = require('../../lib/axe.js').source;
const pageFunctions = require('../../lib/page-functions.js');

/**
 * This is run in the page, not Lighthouse itself.
 * axe.run returns a promise which fulfills with a results object
 * containing any violations.
 * @return {Promise<LH.Artifacts.Accessibility>}
 */
/* c8 ignore start */
async function runA11yChecks() {
  /** @type {import('axe-core/axe')} */
  // @ts-expect-error - axe defined by axeLibSource
  const axe = window.axe;
  const application = `lighthouse-${Math.random()}`;
  axe.configure({
    branding: {
      application,
    },
    noHtml: true,
  });
  const axeResults = await axe.run(document, {
    elementRef: true,
    runOnly: {
      type: 'tag',
      values: [
        'wcag2a',
        'wcag2aa',
      ],
    },
    resultTypes: ['violations', 'inapplicable'],
    rules: {
      'tabindex': {enabled: true},
      'accesskeys': {enabled: true},
      'heading-order': {enabled: true},
      'meta-viewport': {enabled: true},
      'duplicate-id': {enabled: false},
      'table-fake-caption': {enabled: false},
      'td-has-header': {enabled: false},
      'marquee': {enabled: false},
      'area-alt': {enabled: false},
      'html-xml-lang-mismatch': {enabled: false},
      'blink': {enabled: false},
      'server-side-image-map': {enabled: false},
      'identical-links-same-purpose': {enabled: false},
      'no-autoplay-audio': {enabled: false},
      'svg-img-alt': {enabled: false},
      'audio-caption': {enabled: false},
      'aria-treeitem-name': {enabled: true},
      // https://github.com/dequelabs/axe-core/issues/2958
      'nested-interactive': {enabled: false},
      'frame-focusable-content': {enabled: false},
    },
  });

  // axe just scrolled the page, scroll back to the top of the page so that element positions
  // are relative to the top of the page
  document.documentElement.scrollTop = 0;

  return {
    violations: axeResults.violations.map(createAxeRuleResultArtifact),
    incomplete: axeResults.incomplete.map(createAxeRuleResultArtifact),
    notApplicable: axeResults.inapplicable.map(result => ({id: result.id})),
    version: axeResults.testEngine.version,
  };
}

/**
 * @param {import('axe-core/axe').Result} result
 * @return {LH.Artifacts.AxeRuleResult}
 */
function createAxeRuleResultArtifact(result) {
  // Simplify `nodes` and collect nodeDetails for each.
  const nodes = result.nodes.map(node => {
    const {target, failureSummary, element} = node;
    // TODO: with `elementRef: true`, `element` _should_ always be defined, but need to verify.
    // @ts-expect-error - getNodeDetails put into scope via stringification
    const nodeDetails = getNodeDetails(/** @type {HTMLElement} */ (element));

    return {
      target,
      failureSummary,
      node: nodeDetails,
    };
  });

  // Ensure errors can be serialized over the protocol.
  /** @type {Error | undefined} */
  // @ts-expect-error - when rules throw an error, axe saves it here.
  // see https://github.com/dequelabs/axe-core/blob/eeff122c2de11dd690fbad0e50ba2fdb244b50e8/lib/core/base/audit.js#L684-L693
  const resultError = result.error;
  let error;
  if (resultError instanceof Error) {
    error = {
      name: resultError.name,
      message: resultError.message,
    };
  }

  return {
    id: result.id,
    impact: result.impact || undefined,
    tags: result.tags,
    nodes,
    error,
  };
}
/* c8 ignore stop */

class Accessibility extends FRGatherer {
  /** @type {LH.Gatherer.GathererMeta} */
  meta = {
    supportedModes: ['snapshot', 'navigation'],
  }

  /**
   * @param {LH.Gatherer.FRTransitionalContext} passContext
   * @return {Promise<LH.Artifacts.Accessibility>}
   */
  getArtifact(passContext) {
    const driver = passContext.driver;

    return driver.executionContext.evaluate(runA11yChecks, {
      args: [],
      useIsolation: true,
      deps: [
        axeLibSource,
        pageFunctions.getNodeDetailsString,
        createAxeRuleResultArtifact,
      ],
    });
  }
}

module.exports = Accessibility;

},{"../../fraggle-rock/gather/base-gatherer.js":60,"../../lib/axe.js":81,"../../lib/page-functions.js":110}],"../gather/gatherers/anchor-elements":[function(require,module,exports){
/**
 * @license Copyright 2019 The Lighthouse Authors. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.
 */
'use strict';

/* global getNodeDetails */

const FRGatherer = require('../../fraggle-rock/gather/base-gatherer.js');
const dom = require('../driver/dom.js');
const pageFunctions = require('../../lib/page-functions.js');

/* eslint-env browser, node */

/**
 * Function that is stringified and run in the page to collect anchor elements.
 * Additional complexity is introduced because anchors can be HTML or SVG elements.
 *
 * We use this evaluateAsync method because the `node.getAttribute` method doesn't actually normalize
 * the values like access from JavaScript in-page does.
 *
 * @return {LH.Artifacts['AnchorElements']}
 */
/* c8 ignore start */
function collectAnchorElements() {
  /** @param {string} url */
  const resolveURLOrEmpty = url => {
    try {
      return new URL(url, window.location.href).href;
    } catch (_) {
      return '';
    }
  };

  /** @param {HTMLAnchorElement|SVGAElement} node */
  function getTruncatedOnclick(node) {
    const onclick = node.getAttribute('onclick') || '';
    return onclick.slice(0, 1024);
  }

  /** @type {Array<HTMLAnchorElement|SVGAElement>} */
  // @ts-expect-error - put into scope via stringification
  const anchorElements = getElementsInDocument('a'); // eslint-disable-line no-undef

  return anchorElements.map(node => {
    if (node instanceof HTMLAnchorElement) {
      return {
        href: node.href,
        rawHref: node.getAttribute('href') || '',
        onclick: getTruncatedOnclick(node),
        role: node.getAttribute('role') || '',
        name: node.name,
        text: node.innerText, // we don't want to return hidden text, so use innerText
        rel: node.rel,
        target: node.target,
        // @ts-expect-error - getNodeDetails put into scope via stringification
        node: getNodeDetails(node),
      };
    }

    return {
      href: resolveURLOrEmpty(node.href.baseVal),
      rawHref: node.getAttribute('href') || '',
      onclick: getTruncatedOnclick(node),
      role: node.getAttribute('role') || '',
      text: node.textContent || '',
      rel: '',
      target: node.target.baseVal || '',
      // @ts-expect-error - getNodeDetails put into scope via stringification
      node: getNodeDetails(node),
    };
  });
}
/* c8 ignore stop */

/**
 * @param {LH.Gatherer.FRProtocolSession} session
 * @param {string} devtoolsNodePath
 * @return {Promise<Array<{type: string}>>}
 */
async function getEventListeners(session, devtoolsNodePath) {
  const objectId = await dom.resolveDevtoolsNodePathToObjectId(session, devtoolsNodePath);
  if (!objectId) return [];

  const response = await session.sendCommand('DOMDebugger.getEventListeners', {
    objectId,
  });

  return response.listeners.map(({type}) => ({type}));
}

class AnchorElements extends FRGatherer {
  /** @type {LH.Gatherer.GathererMeta} */
  meta = {
    supportedModes: ['snapshot', 'navigation'],
  }

  /**
   * @param {LH.Gatherer.FRTransitionalContext} passContext
   * @return {Promise<LH.Artifacts['AnchorElements']>}
   */
  async getArtifact(passContext) {
    const session = passContext.driver.defaultSession;

    const anchors = await passContext.driver.executionContext.evaluate(collectAnchorElements, {
      args: [],
      useIsolation: true,
      deps: [
        pageFunctions.getElementsInDocumentString,
        pageFunctions.getNodeDetailsString,
      ],
    });
    await session.sendCommand('DOM.enable');

    // DOM.getDocument is necessary for pushNodesByBackendIdsToFrontend to properly retrieve nodeIds if the `DOM` domain was enabled before this gatherer, invoke it to be safe.
    await session.sendCommand('DOM.getDocument', {depth: -1, pierce: true});
    const anchorsWithEventListeners = anchors.map(async anchor => {
      const listeners = await getEventListeners(session, anchor.node.devtoolsNodePath);

      return {
        ...anchor,
        listeners,
      };
    });

    const result = await Promise.all(anchorsWithEventListeners);
    await session.sendCommand('DOM.disable');
    return result;
  }
}

module.exports = AnchorElements;

},{"../../fraggle-rock/gather/base-gatherer.js":60,"../../lib/page-functions.js":110,"../driver/dom.js":65}],"../gather/gatherers/cache-contents":[function(require,module,exports){
/**
 * @license Copyright 2016 The Lighthouse Authors. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.
 */
'use strict';

/* global caches */

const FRGatherer = require('../../fraggle-rock/gather/base-gatherer.js');

/**
 * @return {Promise<Array<string>>}
 */
/* c8 ignore start */
function getCacheContents() {
  // Get every cache by name.
  return caches.keys()

      // Open each one.
      .then(cacheNames => Promise.all(cacheNames.map(cacheName => caches.open(cacheName))))

      .then(caches => {
        /** @type {Array<string>} */
        const requests = [];

        // Take each cache and get any requests is contains, and bounce each one down to its URL.
        return Promise.all(caches.map(cache => {
          return cache.keys()
              .then(reqs => {
                requests.push(...reqs.map(r => r.url));
              });
        })).then(_ => {
          return requests;
        });
      });
}
/* c8 ignore stop */

class CacheContents extends FRGatherer {
  /** @type {LH.Gatherer.GathererMeta} */
  meta = {
    supportedModes: ['snapshot', 'navigation'],
  }

  /**
   * Creates an array of cached URLs.
   * @param {LH.Gatherer.FRTransitionalContext} passContext
   * @return {Promise<LH.Artifacts['CacheContents']>}
   */
  async getArtifact(passContext) {
    const driver = passContext.driver;

    const cacheUrls = await driver.executionContext.evaluate(getCacheContents, {args: []});
    return cacheUrls;
  }
}

module.exports = CacheContents;

},{"../../fraggle-rock/gather/base-gatherer.js":60}],"../gather/gatherers/console-messages":[function(require,module,exports){
/**
 * @license Copyright 2020 The Lighthouse Authors. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.
 */

/**
 * @fileoverview Gathers all entries logged to the console, including console API calls,
 * exceptions, and browser reports (on violations, interventions, deprecations, etc.).
 */

'use strict';

const FRGatherer = require('../../fraggle-rock/gather/base-gatherer.js');

/**
 * @param {LH.Crdp.Runtime.RemoteObject} obj
 * @return {string}
 */
function remoteObjectToString(obj) {
  if (typeof obj.value !== 'undefined' || obj.type === 'undefined') {
    return String(obj.value);
  }
  if (typeof obj.description === 'string' && obj.description !== obj.className) {
    return obj.description;
  }
  const type = obj.subtype || obj.type;
  const className = obj.className || 'Object';
  // Simulate calling String() on the object.
  return `[${type} ${className}]`;
}

class ConsoleMessages extends FRGatherer {
  /** @type {LH.Gatherer.GathererMeta} */
  meta = {
    supportedModes: ['timespan', 'navigation'],
  }

  constructor() {
    super();
    /** @type {LH.Artifacts.ConsoleMessage[]} */
    this._logEntries = [];

    this._onConsoleAPICalled = this.onConsoleAPICalled.bind(this);
    this._onExceptionThrown = this.onExceptionThrown.bind(this);
    this._onLogEntryAdded = this.onLogEntry.bind(this);
  }

  /**
   * Handles events for when a script invokes a console API.
   * @param {LH.Crdp.Runtime.ConsoleAPICalledEvent} event
   */
  onConsoleAPICalled(event) {
    const {type} = event;
    if (type !== 'warning' && type !== 'error') {
      // Only gather warnings and errors for brevity.
      return;
    }

    /** @type {LH.Crdp.Runtime.RemoteObject[]} */
    const args = event.args || [];
    const text = args.map(remoteObjectToString).join(' ');
    if (!text && !event.stackTrace) {
      // No useful information from Chrome. Skip.
      return;
    }

    const {url, lineNumber, columnNumber} =
      event.stackTrace && event.stackTrace.callFrames[0] || {};
    /** @type {LH.Artifacts.ConsoleMessage} */
    const consoleMessage = {
      eventType: 'consoleAPI',
      source: type === 'warning' ? 'console.warn' : 'console.error',
      level: type,
      text,
      stackTrace: event.stackTrace,
      timestamp: event.timestamp,
      url,
      lineNumber,
      columnNumber,
    };
    this._logEntries.push(consoleMessage);
  }

  /**
   * Handles exception thrown events.
   * @param {LH.Crdp.Runtime.ExceptionThrownEvent} event
   */
  onExceptionThrown(event) {
    const text = event.exceptionDetails.exception ?
          event.exceptionDetails.exception.description : event.exceptionDetails.text;
    if (!text) {
      return;
    }
    /** @type {LH.Artifacts.ConsoleMessage} */
    const consoleMessage = {
      eventType: 'exception',
      source: 'exception',
      level: 'error',
      text,
      stackTrace: event.exceptionDetails.stackTrace,
      timestamp: event.timestamp,
      url: event.exceptionDetails.url,
      lineNumber: event.exceptionDetails.lineNumber,
      columnNumber: event.exceptionDetails.columnNumber,
    };
    this._logEntries.push(consoleMessage);
  }

  /**
   * Handles browser reports logged to the console, including interventions,
   * deprecations, violations, and more.
   * @param {LH.Crdp.Log.EntryAddedEvent} event
   */
  onLogEntry(event) {
    const {source, level, text, stackTrace, timestamp, url, lineNumber} = event.entry;

    // JS events have a stack trace, which we use to get the column.
    // CSS/HTML events only expose a line number.
    const {columnNumber} = event.entry.stackTrace && event.entry.stackTrace.callFrames[0] || {};

    this._logEntries.push({
      eventType: 'protocolLog',
      source,
      level,
      text,
      stackTrace,
      timestamp,
      url,
      lineNumber,
      columnNumber,
    });
  }

  /**
   * @param {LH.Gatherer.FRTransitionalContext} passContext
   */
  async startInstrumentation(passContext) {
    const session = passContext.driver.defaultSession;

    session.on('Log.entryAdded', this._onLogEntryAdded);
    await session.sendCommand('Log.enable');
    await session.sendCommand('Log.startViolationsReport', {
      config: [{name: 'discouragedAPIUse', threshold: -1}],
    });

    session.on('Runtime.consoleAPICalled', this._onConsoleAPICalled);
    session.on('Runtime.exceptionThrown', this._onExceptionThrown);
    await session.sendCommand('Runtime.enable');
  }

  /**
   * @param {LH.Gatherer.FRTransitionalContext} passContext
   * @return {Promise<void>}
   */
  async stopInstrumentation({driver}) {
    await driver.defaultSession.sendCommand('Log.stopViolationsReport');
    await driver.defaultSession.off('Log.entryAdded', this._onLogEntryAdded);
    await driver.defaultSession.sendCommand('Log.disable');
    await driver.defaultSession.off('Runtime.consoleAPICalled', this._onConsoleAPICalled);
    await driver.defaultSession.off('Runtime.exceptionThrown', this._onExceptionThrown);
    await driver.defaultSession.sendCommand('Runtime.disable');
  }

  /**
   * @return {Promise<LH.Artifacts['ConsoleMessages']>}
   */
  async getArtifact() {
    return this._logEntries;
  }
}

module.exports = ConsoleMessages;

},{"../../fraggle-rock/gather/base-gatherer.js":60}],"../gather/gatherers/css-usage":[function(require,module,exports){
/**
 * @license Copyright 2017 The Lighthouse Authors. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.
 */
'use strict';

const FRGatherer = require('../../fraggle-rock/gather/base-gatherer.js');

/**
 * @fileoverview Tracks unused CSS rules.
 */
class CSSUsage extends FRGatherer {
  /** @type {LH.Gatherer.GathererMeta} */
  meta = {
    // TODO(FR-COMPAT): Add support for timespan.
    supportedModes: ['snapshot', 'navigation'],
  };

  /**
   * @param {LH.Gatherer.FRTransitionalContext} context
   * @return {Promise<LH.Artifacts['CSSUsage']>}
   */
  async getArtifact(context) {
    const session = context.driver.defaultSession;
    const executionContext = context.driver.executionContext;

    /** @type {Array<LH.Crdp.CSS.StyleSheetAddedEvent>} */
    const stylesheets = [];
    /** @param {LH.Crdp.CSS.StyleSheetAddedEvent} sheet */
    const onStylesheetAdded = sheet => stylesheets.push(sheet);
    session.on('CSS.styleSheetAdded', onStylesheetAdded);

    await session.sendCommand('DOM.enable');
    await session.sendCommand('CSS.enable');
    await session.sendCommand('CSS.startRuleUsageTracking');

    // Force style to recompute.
    // Doesn't appear to be necessary in newer versions of Chrome.
    await executionContext.evaluateAsync('getComputedStyle(document.body)');

    session.off('CSS.styleSheetAdded', onStylesheetAdded);

    // Fetch style sheet content in parallel.
    const promises = stylesheets.map(sheet => {
      const styleSheetId = sheet.header.styleSheetId;
      return session.sendCommand('CSS.getStyleSheetText', {styleSheetId}).then(content => {
        return {
          header: sheet.header,
          content: content.text,
        };
      });
    });
    const styleSheetInfo = await Promise.all(promises);

    const ruleUsageResponse = await session.sendCommand('CSS.stopRuleUsageTracking');
    await session.sendCommand('CSS.disable');
    await session.sendCommand('DOM.disable');

    const dedupedStylesheets = new Map(styleSheetInfo.map(sheet => {
      return [sheet.content, sheet];
    }));
    return {
      rules: ruleUsageResponse.ruleUsage,
      stylesheets: Array.from(dedupedStylesheets.values()),
    };
  }
}

module.exports = CSSUsage;

},{"../../fraggle-rock/gather/base-gatherer.js":60}],"../gather/gatherers/devtools-log-compat":[function(require,module,exports){
/**
 * @license Copyright 2021 The Lighthouse Authors. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.
 */
'use strict';

/**
 * @fileoverview
 * This gatherer remaps the result of the DevtoolsLog gatherer for compatibility with legacy Lighthouse
 * when devtools logs and traces were special-cased.
 */

const DevtoolsLogGatherer = require('./devtools-log.js');
const FRGatherer = require('../../fraggle-rock/gather/base-gatherer.js');

/** @implements {LH.Gatherer.FRGathererInstance<'DevtoolsLog'>} */
class DevtoolsLogCompat extends FRGatherer {
  /** @type {LH.Gatherer.GathererMeta<'DevtoolsLog'>} */
  meta = {
    supportedModes: ['timespan', 'navigation'],
    dependencies: {DevtoolsLog: DevtoolsLogGatherer.symbol},
  };

  /**
   * @param {LH.Gatherer.FRTransitionalContext<'DevtoolsLog'>} passContext
   * @return {Promise<LH.Artifacts['devtoolsLogs']>}
   */
  async getArtifact(passContext) {
    return {
      defaultPass: passContext.dependencies.DevtoolsLog,
    };
  }
}

module.exports = DevtoolsLogCompat;

},{"../../fraggle-rock/gather/base-gatherer.js":60,"./devtools-log.js":"../gather/gatherers/devtools-log"}],"../gather/gatherers/devtools-log":[function(require,module,exports){
/**
 * @license Copyright 2021 The Lighthouse Authors. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.
 */
'use strict';

/**
 * @fileoverview
 * This gatherer collects all network and page devtools protocol traffic during the timespan/navigation.
 * This protocol log can be used to recreate the network records using lib/network-recorder.js.
 */

const MessageLog = require('../devtools-log.js');
const FRGatherer = require('../../fraggle-rock/gather/base-gatherer.js');

class DevtoolsLog extends FRGatherer {
  static symbol = Symbol('DevtoolsLog');

  /** @type {LH.Gatherer.GathererMeta} */
  meta = {
    symbol: DevtoolsLog.symbol,
    supportedModes: ['timespan', 'navigation'],
  };

  constructor() {
    super();

    this._messageLog = new MessageLog(/^(Page|Network)\./);

    /** @param {LH.Protocol.RawEventMessage} e */
    this._onProtocolMessage = e => this._messageLog.record(e);
  }

  /**
   * @param {LH.Gatherer.FRTransitionalContext} passContext
   */
  async startSensitiveInstrumentation({driver}) {
    this._messageLog.reset();
    this._messageLog.beginRecording();
    driver.defaultSession.addProtocolMessageListener(this._onProtocolMessage);

    // TODO(FR-COMPAT): use a dedicated session for these
    await driver.defaultSession.sendCommand('Page.enable');
    await driver.defaultSession.sendCommand('Network.enable');
  }

  /**
   * @param {LH.Gatherer.FRTransitionalContext} passContext
   */
  async stopSensitiveInstrumentation({driver}) {
    this._messageLog.endRecording();
    driver.defaultSession.removeProtocolMessageListener(this._onProtocolMessage);
  }

  /**
   * @return {Promise<LH.Artifacts['DevtoolsLog']>}
   */
  async getArtifact() {
    return this._messageLog.messages;
  }
}

module.exports = DevtoolsLog;

},{"../../fraggle-rock/gather/base-gatherer.js":60,"../devtools-log.js":63}],"../gather/gatherers/dobetterweb/appcache":[function(require,module,exports){
/**
 * @license Copyright 2016 The Lighthouse Authors. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.
 */
'use strict';

const FRGatherer = require('../../../fraggle-rock/gather/base-gatherer.js');

/* global document */

class AppCacheManifest extends FRGatherer {
  /** @type {LH.Gatherer.GathererMeta} */
  meta = {
    supportedModes: ['snapshot', 'navigation'],
  }

  /**
   * @param {LH.Gatherer.FRTransitionalContext} passContext
   * @return {Promise<LH.Artifacts['AppCacheManifest']>}
   */
  getArtifact(passContext) {
    const driver = passContext.driver;

    return driver.executionContext.evaluate(() => {
      return document.documentElement && document.documentElement.getAttribute('manifest');
    }, {
      args: [],
      useIsolation: true,
    });
  }
}

module.exports = AppCacheManifest;

},{"../../../fraggle-rock/gather/base-gatherer.js":60}],"../gather/gatherers/dobetterweb/doctype":[function(require,module,exports){
/**
 * @license Copyright 2018 The Lighthouse Authors. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.
 */
'use strict';

const FRGatherer = require('../../../fraggle-rock/gather/base-gatherer.js');

/* global document */

/**
 * Get and return `name`, `publicId`, `systemId` from
 * `document.doctype`
 * @return {{name: string, publicId: string, systemId: string} | null}
 */
function getDoctype() {
  // An example of this is warnerbros.com/archive/spacejam/movie/jam.htm
  if (!document.doctype) {
    return null;
  }

  const {name, publicId, systemId} = document.doctype;
  return {name, publicId, systemId};
}

class Doctype extends FRGatherer {
  /** @type {LH.Gatherer.GathererMeta} */
  meta = {
    supportedModes: ['snapshot', 'navigation'],
  }

  /**
   * @param {LH.Gatherer.FRTransitionalContext} passContext
   * @return {Promise<LH.Artifacts['Doctype']>}
   */
  getArtifact(passContext) {
    const driver = passContext.driver;
    return driver.executionContext.evaluate(getDoctype, {
      args: [],
      useIsolation: true,
    });
  }
}

module.exports = Doctype;

},{"../../../fraggle-rock/gather/base-gatherer.js":60}],"../gather/gatherers/dobetterweb/domstats":[function(require,module,exports){
/**
 * @license Copyright 2017 The Lighthouse Authors. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.
 */

/**
 * @fileoverview Gathers stats about the max height and width of the DOM tree
 * and total number of elements used on the page.
 */

/* global getNodeDetails document */

'use strict';

const FRGatherer = require('../../../fraggle-rock/gather/base-gatherer.js');
const pageFunctions = require('../../../lib/page-functions.js');

/**
 * Calculates the maximum tree depth of the DOM.
 * @param {HTMLElement} element Root of the tree to look in.
 * @param {boolean=} deep True to include shadow roots. Defaults to true.
 * @return {LH.Artifacts.DOMStats}
 */
/* c8 ignore start */
function getDOMStats(element = document.body, deep = true) {
  let deepestElement = null;
  let maxDepth = -1;
  let maxWidth = -1;
  let numElements = 0;
  let parentWithMostChildren = null;

  /**
   * @param {Element|ShadowRoot} element
   * @param {number} depth
   */
  const _calcDOMWidthAndHeight = function(element, depth = 1) {
    if (depth > maxDepth) {
      deepestElement = element;
      maxDepth = depth;
    }
    if (element.children.length > maxWidth) {
      parentWithMostChildren = element;
      maxWidth = element.children.length;
    }

    let child = element.firstElementChild;
    while (child) {
      _calcDOMWidthAndHeight(child, depth + 1);
      // If element has shadow dom, traverse into that tree.
      if (deep && child.shadowRoot) {
        _calcDOMWidthAndHeight(child.shadowRoot, depth + 1);
      }
      child = child.nextElementSibling;
      numElements++;
    }

    return {maxDepth, maxWidth, numElements};
  };

  const result = _calcDOMWidthAndHeight(element);

  return {
    depth: {
      max: result.maxDepth,
      // @ts-expect-error - getNodeDetails put into scope via stringification
      ...getNodeDetails(deepestElement),
    },
    width: {
      max: result.maxWidth,
      // @ts-expect-error - getNodeDetails put into scope via stringification
      ...getNodeDetails(parentWithMostChildren),
    },
    totalBodyElements: result.numElements,
  };
}
/* c8 ignore stop */

class DOMStats extends FRGatherer {
  /** @type {LH.Gatherer.GathererMeta} */
  meta = {
    supportedModes: ['snapshot', 'navigation'],
  }

  /**
   * @param {LH.Gatherer.FRTransitionalContext} passContext
   * @return {Promise<LH.Artifacts['DOMStats']>}
   */
  async getArtifact(passContext) {
    const driver = passContext.driver;

    await driver.defaultSession.sendCommand('DOM.enable');
    const results = await driver.executionContext.evaluate(getDOMStats, {
      args: [],
      useIsolation: true,
      deps: [pageFunctions.getNodeDetailsString],
    });
    await driver.defaultSession.sendCommand('DOM.disable');
    return results;
  }
}

module.exports = DOMStats;

},{"../../../fraggle-rock/gather/base-gatherer.js":60,"../../../lib/page-functions.js":110}],"../gather/gatherers/dobetterweb/optimized-images":[function(require,module,exports){
/**
 * @license Copyright 2017 The Lighthouse Authors. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.
 */

/**
  * @fileoverview Determines optimized jpeg/webp filesizes for all same-origin and dataURI images by
  *   running the images through canvas in the browser context.
  */
'use strict';

const log = require('lighthouse-logger');
const FRGatherer = require('../../../fraggle-rock/gather/base-gatherer.js');
const URL = require('../../../lib/url-shim.js');
const NetworkRequest = require('../../../lib/network-request.js');
const Sentry = require('../../../lib/sentry.js');
const NetworkRecords = require('../../../computed/network-records.js');
const DevtoolsLog = require('../devtools-log.js');

// Image encoding can be slow and we don't want to spend forever on it.
// Cap our encoding to 5 seconds, anything after that will be estimated.
const MAX_TIME_TO_SPEND_ENCODING = 5000;
// Cap our image file size at 2MB, anything bigger than that will be estimated.
const MAX_RESOURCE_SIZE_TO_ENCODE = 2000 * 1024;

const JPEG_QUALITY = 0.92;
const WEBP_QUALITY = 0.85;

const MINIMUM_IMAGE_SIZE = 4096; // savings of <4 KiB will be ignored in the audit anyway

const IMAGE_REGEX = /^image\/((x|ms|x-ms)-)?(png|bmp|jpeg)$/;

/** @typedef {{requestId: string, url: string, mimeType: string, resourceSize: number}} SimplifiedNetworkRecord */

class OptimizedImages extends FRGatherer {
  /** @type {LH.Gatherer.GathererMeta<'DevtoolsLog'>} */
  meta = {
    supportedModes: ['timespan', 'navigation'],
    dependencies: {DevtoolsLog: DevtoolsLog.symbol},
  }

  constructor() {
    super();
    this._encodingStartAt = 0;
  }

  /**
   * @param {Array<LH.Artifacts.NetworkRequest>} networkRecords
   * @return {Array<SimplifiedNetworkRecord>}
   */
  static filterImageRequests(networkRecords) {
    /** @type {Set<string>} */
    const seenUrls = new Set();
    return networkRecords.reduce((prev, record) => {
      // Skip records that we've seen before, never finished, or came from child targets (OOPIFS).
      if (seenUrls.has(record.url) || !record.finished || record.sessionId) {
        return prev;
      }

      seenUrls.add(record.url);
      const isOptimizableImage = record.resourceType === NetworkRequest.TYPES.Image &&
        IMAGE_REGEX.test(record.mimeType);

      const actualResourceSize = Math.min(record.resourceSize || 0, record.transferSize || 0);
      if (isOptimizableImage && actualResourceSize > MINIMUM_IMAGE_SIZE) {
        prev.push({
          requestId: record.requestId,
          url: record.url,
          mimeType: record.mimeType,
          resourceSize: actualResourceSize,
        });
      }

      return prev;
    }, /** @type {Array<SimplifiedNetworkRecord>} */ ([]));
  }

  /**
   * @param {LH.Gatherer.FRProtocolSession} session
   * @param {string} requestId
   * @param {'jpeg'|'webp'} encoding Either webp or jpeg.
   * @return {Promise<LH.Crdp.Audits.GetEncodedResponseResponse>}
   */
  _getEncodedResponse(session, requestId, encoding) {
    requestId = NetworkRequest.getRequestIdForBackend(requestId);

    const quality = encoding === 'jpeg' ? JPEG_QUALITY : WEBP_QUALITY;
    const params = {requestId, encoding, quality, sizeOnly: true};
    return session.sendCommand('Audits.getEncodedResponse', params);
  }

  /**
   * @param {LH.Gatherer.FRProtocolSession} session
   * @param {SimplifiedNetworkRecord} networkRecord
   * @return {Promise<{originalSize: number, jpegSize?: number, webpSize?: number}>}
   */
  async calculateImageStats(session, networkRecord) {
    const originalSize = networkRecord.resourceSize;
    // Once we've hit our execution time limit or when the image is too big, don't try to re-encode it.
    // Images in this execution path will fallback to byte-per-pixel heuristics on the audit side.
    if (Date.now() - this._encodingStartAt > MAX_TIME_TO_SPEND_ENCODING ||
        originalSize > MAX_RESOURCE_SIZE_TO_ENCODE) {
      return {originalSize, jpegSize: undefined, webpSize: undefined};
    }

    const jpegData = await this._getEncodedResponse(session, networkRecord.requestId, 'jpeg');
    const webpData = await this._getEncodedResponse(session, networkRecord.requestId, 'webp');

    return {
      originalSize,
      jpegSize: jpegData.encodedSize,
      webpSize: webpData.encodedSize,
    };
  }

  /**
   * @param {LH.Gatherer.FRProtocolSession} session
   * @param {Array<SimplifiedNetworkRecord>} imageRecords
   * @return {Promise<LH.Artifacts['OptimizedImages']>}
   */
  async computeOptimizedImages(session, imageRecords) {
    this._encodingStartAt = Date.now();

    /** @type {LH.Artifacts['OptimizedImages']} */
    const results = [];

    for (const record of imageRecords) {
      try {
        const stats = await this.calculateImageStats(session, record);
        /** @type {LH.Artifacts.OptimizedImage} */
        const image = {failed: false, ...stats, ...record};
        results.push(image);
      } catch (err) {
        log.warn('optimized-images', err.message);

        // Track this with Sentry since these errors aren't surfaced anywhere else, but we don't
        // want to tank the entire run due to a single image.
        Sentry.captureException(err, {
          tags: {gatherer: 'OptimizedImages'},
          extra: {imageUrl: URL.elideDataURI(record.url)},
          level: 'warning',
        });

        /** @type {LH.Artifacts.OptimizedImageError} */
        const imageError = {failed: true, errMsg: err.message, ...record};
        results.push(imageError);
      }
    }

    return results;
  }

  /**
   * @param {LH.Gatherer.FRTransitionalContext} context
   * @param {LH.Artifacts.NetworkRequest[]} networkRecords
   * @return {Promise<LH.Artifacts['OptimizedImages']>}
   */
  async _getArtifact(context, networkRecords) {
    const imageRecords = OptimizedImages
      .filterImageRequests(networkRecords)
      .sort((a, b) => b.resourceSize - a.resourceSize);

    const results = await this.computeOptimizedImages(context.driver.defaultSession, imageRecords);
    const successfulResults = results.filter(result => !result.failed);
    if (results.length && !successfulResults.length) {
      throw new Error('All image optimizations failed');
    }
    return results;
  }

  /**
   * @param {LH.Gatherer.FRTransitionalContext<'DevtoolsLog'>} context
   * @return {Promise<LH.Artifacts['OptimizedImages']>}
   */
  async getArtifact(context) {
    const devtoolsLog = context.dependencies.DevtoolsLog;
    const networkRecords = await NetworkRecords.request(devtoolsLog, context);
    return this._getArtifact(context, networkRecords);
  }

  /**
   * @param {LH.Gatherer.PassContext} passContext
   * @param {LH.Gatherer.LoadData} loadData
   * @return {Promise<LH.Artifacts['OptimizedImages']>}
   */
  async afterPass(passContext, loadData) {
    return this._getArtifact({...passContext, dependencies: {}}, loadData.networkRecords);
  }
}

module.exports = OptimizedImages;

},{"../../../computed/network-records.js":40,"../../../fraggle-rock/gather/base-gatherer.js":60,"../../../lib/network-request.js":109,"../../../lib/sentry.js":112,"../../../lib/url-shim.js":"url","../devtools-log.js":"../gather/gatherers/devtools-log","lighthouse-logger":188}],"../gather/gatherers/dobetterweb/password-inputs-with-prevented-paste":[function(require,module,exports){
/**
 * @license Copyright 2017 The Lighthouse Authors. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.
 */
'use strict';

/* global document ClipboardEvent getNodeDetails */

const FRGatherer = require('../../../fraggle-rock/gather/base-gatherer.js');
const pageFunctions = require('../../../lib/page-functions.js');

/**
 * @return {LH.Artifacts['PasswordInputsWithPreventedPaste']}
 */
/* c8 ignore start */
function findPasswordInputsWithPreventedPaste() {
  return Array.from(document.querySelectorAll('input[type="password"]'))
    .filter(passwordInput =>
      !passwordInput.dispatchEvent(
        new ClipboardEvent('paste', {cancelable: true})
      )
    )
    .map(passwordInput => ({
      // @ts-expect-error - getNodeDetails put into scope via stringification
      node: getNodeDetails(passwordInput),
    }));
}
/* c8 ignore stop */

class PasswordInputsWithPreventedPaste extends FRGatherer {
  /** @type {LH.Gatherer.GathererMeta} */
  meta = {
    supportedModes: ['snapshot', 'navigation'],
  }

  /**
   * @param {LH.Gatherer.FRTransitionalContext} passContext
   * @return {Promise<LH.Artifacts['PasswordInputsWithPreventedPaste']>}
   */
  getArtifact(passContext) {
    return passContext.driver.executionContext.evaluate(findPasswordInputsWithPreventedPaste, {
      args: [],
      deps: [pageFunctions.getNodeDetailsString],
    });
  }
}


module.exports = PasswordInputsWithPreventedPaste;

},{"../../../fraggle-rock/gather/base-gatherer.js":60,"../../../lib/page-functions.js":110}],"../gather/gatherers/dobetterweb/response-compression":[function(require,module,exports){
(function (Buffer){(function (){
/**
 * @license Copyright 2017 The Lighthouse Authors. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.
 */

/**
  * @fileoverview Determines optimized gzip/br/deflate filesizes for all responses by
  *   checking the content-encoding header.
  */
'use strict';

const FRGatherer = require('../../../fraggle-rock/gather/base-gatherer.js');
const URL = require('../../../lib/url-shim.js');
const Sentry = require('../../../lib/sentry.js');
const NetworkRequest = require('../../../lib/network-request.js');
const gzip = require('zlib').gzip;
const DevtoolsLog = require('../devtools-log.js');
const {fetchResponseBodyFromCache} = require('../../driver/network.js');
const NetworkRecords = require('../../../computed/network-records.js');

const CHROME_EXTENSION_PROTOCOL = 'chrome-extension:';
const compressionHeaders = ['content-encoding', 'x-original-content-encoding'];
const compressionTypes = ['gzip', 'br', 'deflate'];
const binaryMimeTypes = ['image', 'audio', 'video'];
/** @type {LH.Crdp.Network.ResourceType[]} */
const textResourceTypes = [
  NetworkRequest.TYPES.Document,
  NetworkRequest.TYPES.Script,
  NetworkRequest.TYPES.Stylesheet,
  NetworkRequest.TYPES.XHR,
  NetworkRequest.TYPES.Fetch,
  NetworkRequest.TYPES.EventSource,
];

class ResponseCompression extends FRGatherer {
  /** @type {LH.Gatherer.GathererMeta<'DevtoolsLog'>} */
  meta = {
    supportedModes: ['timespan', 'navigation'],
    dependencies: {DevtoolsLog: DevtoolsLog.symbol},
  }

  /**
   * @param {LH.Artifacts.NetworkRequest[]} networkRecords
   * @return {LH.Artifacts['ResponseCompression']}
   */
  static filterUnoptimizedResponses(networkRecords) {
    /** @type {LH.Artifacts['ResponseCompression']} */
    const unoptimizedResponses = [];

    networkRecords.forEach(record => {
      // Ignore records from child targets (OOPIFS).
      if (record.sessionId) return;

      const mimeType = record.mimeType;
      const resourceType = record.resourceType || NetworkRequest.TYPES.Other;
      const resourceSize = record.resourceSize;

      const isBinaryResource = mimeType && binaryMimeTypes.some(type => mimeType.startsWith(type));
      const isTextResource = !isBinaryResource && textResourceTypes.includes(resourceType);
      const isChromeExtensionResource = record.url.startsWith(CHROME_EXTENSION_PROTOCOL);

      if (!isTextResource || !resourceSize || !record.finished ||
        isChromeExtensionResource || !record.transferSize || record.statusCode === 304) {
        return;
      }

      const isContentEncoded = (record.responseHeaders || []).find(header =>
        compressionHeaders.includes(header.name.toLowerCase()) &&
        compressionTypes.includes(header.value)
      );

      if (!isContentEncoded) {
        unoptimizedResponses.push({
          requestId: record.requestId,
          url: record.url,
          mimeType: mimeType,
          transferSize: record.transferSize,
          resourceSize: resourceSize,
          gzipSize: 0,
        });
      }
    });

    return unoptimizedResponses;
  }

  /**
   * @param {LH.Gatherer.FRTransitionalContext} context
   * @param {LH.Artifacts.NetworkRequest[]} networkRecords
   * @return {Promise<LH.Artifacts['ResponseCompression']>}
   */
  async _getArtifact(context, networkRecords) {
    const session = context.driver.defaultSession;
    const textRecords = ResponseCompression.filterUnoptimizedResponses(networkRecords);

    return Promise.all(textRecords.map(record => {
      return fetchResponseBodyFromCache(session, record.requestId).then(content => {
        // if we don't have any content, gzipSize is already set to 0
        if (!content) {
          return record;
        }

        return new Promise((resolve, reject) => {
          return gzip(content, (err, res) => {
            if (err) {
              return reject(err);
            }

            // get gzip size
            record.gzipSize = Buffer.byteLength(res, 'utf8');

            resolve(record);
          });
        });
      }).catch(err => {
        Sentry.captureException(err, {
          tags: {gatherer: 'ResponseCompression'},
          extra: {url: URL.elideDataURI(record.url)},
          level: 'warning',
        });

        record.gzipSize = undefined;
        return record;
      });
    }));
  }

  /**
   * @param {LH.Gatherer.FRTransitionalContext<'DevtoolsLog'>} context
   * @return {Promise<LH.Artifacts['ResponseCompression']>}
   */
  async getArtifact(context) {
    const devtoolsLog = context.dependencies.DevtoolsLog;
    const networkRecords = await NetworkRecords.request(devtoolsLog, context);
    return this._getArtifact(context, networkRecords);
  }

  /**
   * @param {LH.Gatherer.PassContext} passContext
   * @param {LH.Gatherer.LoadData} loadData
   * @return {Promise<LH.Artifacts['ResponseCompression']>}
   */
  async afterPass(passContext, loadData) {
    return this._getArtifact({...passContext, dependencies: {}}, loadData.networkRecords);
  }
}

module.exports = ResponseCompression;

}).call(this)}).call(this,require("buffer").Buffer)
},{"../../../computed/network-records.js":40,"../../../fraggle-rock/gather/base-gatherer.js":60,"../../../lib/network-request.js":109,"../../../lib/sentry.js":112,"../../../lib/url-shim.js":"url","../../driver/network.js":70,"../devtools-log.js":"../gather/gatherers/devtools-log","buffer":145,"zlib":135}],"../gather/gatherers/dobetterweb/tags-blocking-first-paint":[function(require,module,exports){
/**
 * @license Copyright 2016 The Lighthouse Authors. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.
 */
/**
 * @fileoverview
 *   Identifies stylesheets, HTML Imports, and scripts that potentially block
 *   the first paint of the page by running several scripts in the page context.
 *   Candidate blocking tags are collected by querying for all script tags in
 *   the head of the page and all link tags that are either matching media
 *   stylesheets or non-async HTML imports. These are then compared to the
 *   network requests to ensure they were initiated by the parser and not
 *   injected with script. To avoid false positives from strategies like
 *   (http://filamentgroup.github.io/loadCSS/test/preload.html), a separate
 *   script is run to flag all links that at one point were rel=preload.
 */

'use strict';

const NetworkRecords = require('../../../computed/network-records.js');
const DevtoolsLog = require('../devtools-log.js');
const FRGatherer = require('../../../fraggle-rock/gather/base-gatherer.js');

/* global document, window, performance, HTMLLinkElement, SVGScriptElement */

/** @typedef {{href: string, media: string, msSinceHTMLEnd: number, matches: boolean}} MediaChange */
/** @typedef {{tagName: 'LINK', url: string, href: string, rel: string, media: string, disabled: boolean, mediaChanges: Array<MediaChange>}} LinkTag */
/** @typedef {{tagName: 'SCRIPT', url: string, src: string}} ScriptTag */

/* c8 ignore start */
function installMediaListener() {
  // @ts-expect-error - inserted in page to track media changes.
  window.___linkMediaChanges = [];
  Object.defineProperty(HTMLLinkElement.prototype, 'media', {
    set: function(val) {
      /** @type {MediaChange} */
      const mediaChange = {
        href: this.href,
        media: val,
        msSinceHTMLEnd: Date.now() - performance.timing.responseEnd,
        matches: window.matchMedia(val).matches,
      };
      // @ts-expect-error - `___linkMediaChanges` created above.
      window.___linkMediaChanges.push(mediaChange);

      this.setAttribute('media', val);
    },
  });
}
/* c8 ignore stop */

/**
 * @return {Promise<Array<LinkTag | ScriptTag>>}
 */
/* c8 ignore start */
async function collectTagsThatBlockFirstPaint() {
  /** @type {Array<MediaChange>} */
  // @ts-expect-error - `___linkMediaChanges` created in `installMediaListener`.
  const linkMediaChanges = window.___linkMediaChanges;

  try {
    /** @type {Array<LinkTag>} */
    const linkTags = [...document.querySelectorAll('link')]
      .filter(linkTag => {
        // Filter stylesheet/HTML imports that block rendering.
        // https://www.igvita.com/2012/06/14/debunking-responsive-css-performance-myths/
        // https://www.w3.org/TR/html-imports/#dfn-import-async-attribute
        const blockingStylesheet = linkTag.rel === 'stylesheet' &&
          window.matchMedia(linkTag.media).matches && !linkTag.disabled;
        const blockingImport = linkTag.rel === 'import' && !linkTag.hasAttribute('async');
        return blockingStylesheet || blockingImport;
      })
      .map(tag => {
        return {
          tagName: 'LINK',
          url: tag.href,
          href: tag.href,
          rel: tag.rel,
          media: tag.media,
          disabled: tag.disabled,
          mediaChanges: linkMediaChanges.filter(item => item.href === tag.href),
        };
      });

    /** @type {Array<ScriptTag>} */
    const scriptTags = [...document.querySelectorAll('head script[src]')]
      .filter(/** @return {scriptTag is HTMLScriptElement} */ scriptTag => {
        // SVGScriptElement can't appear in <head> (it'll be kicked to <body>), but keep tsc happy.
        // https://html.spec.whatwg.org/multipage/semantics.html#the-head-element
        if (scriptTag instanceof SVGScriptElement) return false;

        return (
          !scriptTag.hasAttribute('async') &&
          !scriptTag.hasAttribute('defer') &&
          !/^data:/.test(scriptTag.src) &&
          !/^blob:/.test(scriptTag.src) &&
          scriptTag.getAttribute('type') !== 'module'
        );
      })
      .map(tag => {
        return {
          tagName: 'SCRIPT',
          url: tag.src,
          src: tag.src,
        };
      });

    return [...linkTags, ...scriptTags];
  } catch (e) {
    const friendly = 'Unable to gather Scripts/Stylesheets/HTML Imports on the page';
    throw new Error(`${friendly}: ${e.message}`);
  }
}
/* c8 ignore stop */

class TagsBlockingFirstPaint extends FRGatherer {
  /** @type {LH.Gatherer.GathererMeta<'DevtoolsLog'>} */
  meta = {
    supportedModes: ['navigation'],
    dependencies: {DevtoolsLog: DevtoolsLog.symbol},
  }

  /**
   * @param {Array<LH.Artifacts.NetworkRequest>} networkRecords
   * @return {Map<string, LH.Artifacts.NetworkRequest>}
   */
  static _filteredAndIndexedByUrl(networkRecords) {
    /** @type {Map<string, LH.Artifacts.NetworkRequest>} */
    const result = new Map();

    for (const record of networkRecords) {
      if (!record.finished) continue;

      const isParserGenerated = record.initiator.type === 'parser';
      // A stylesheet only blocks script if it was initiated by the parser
      // https://html.spec.whatwg.org/multipage/semantics.html#interactions-of-styling-and-scripting
      const isParserScriptOrStyle = /(css|script)/.test(record.mimeType) && isParserGenerated;
      const isFailedRequest = record.failed;
      const isHtml = record.mimeType && record.mimeType.includes('html');

      // Filter stylesheet, javascript, and html import mimetypes.
      // Include 404 scripts/links generated by the parser because they are likely blocking.
      if (isHtml || isParserScriptOrStyle || (isFailedRequest && isParserGenerated)) {
        result.set(record.url, record);
      }
    }

    return result;
  }

  /**
   * @param {LH.Gatherer.FRTransitionalDriver} driver
   * @param {Array<LH.Artifacts.NetworkRequest>} networkRecords
   * @return {Promise<Array<LH.Artifacts.TagBlockingFirstPaint>>}
   */
  static async findBlockingTags(driver, networkRecords) {
    const firstRequestEndTime = networkRecords.reduce(
      (min, record) => Math.min(min, record.endTime),
      Infinity
    );
    const tags = await driver.executionContext.evaluate(collectTagsThatBlockFirstPaint, {args: []});
    const requests = TagsBlockingFirstPaint._filteredAndIndexedByUrl(networkRecords);

    /** @type {Array<LH.Artifacts.TagBlockingFirstPaint>} */
    const result = [];
    for (const tag of tags) {
      const request = requests.get(tag.url);
      if (!request || request.isLinkPreload) continue;

      let endTime = request.endTime;
      let mediaChanges;

      if (tag.tagName === 'LINK') {
        // Even if the request was initially blocking or appeared to be blocking once the
        // page was loaded, the media attribute could have been changed during load, capping the
        // amount of time it was render blocking. See https://github.com/GoogleChrome/lighthouse/issues/2832.
        const timesResourceBecameNonBlocking = tag.mediaChanges
          .filter(change => !change.matches)
          .map(change => change.msSinceHTMLEnd);
        if (timesResourceBecameNonBlocking.length > 0) {
          const earliestNonBlockingTime = Math.min(...timesResourceBecameNonBlocking);
          const lastTimeResourceWasBlocking = Math.max(
            request.startTime,
            firstRequestEndTime + earliestNonBlockingTime / 1000
          );
          endTime = Math.min(endTime, lastTimeResourceWasBlocking);
        }

        mediaChanges = tag.mediaChanges;
      }

      const {tagName, url} = tag;

      result.push({
        tag: {tagName, url, mediaChanges},
        transferSize: request.transferSize,
        startTime: request.startTime,
        endTime,
      });

      // Prevent duplicates from showing up again
      requests.delete(tag.url);
    }

    return result;
  }

  /**
   * @param {LH.Gatherer.FRTransitionalContext} context
   */
  async startSensitiveInstrumentation(context) {
    const {executionContext} = context.driver;
    // Don't return return value of `evaluateOnNewDocument`.
    await executionContext.evaluateOnNewDocument(installMediaListener, {args: []});
  }

  /**
   * @param {LH.Gatherer.FRTransitionalContext<'DevtoolsLog'>} context
   * @return {Promise<LH.Artifacts['TagsBlockingFirstPaint']>}
   */
  async getArtifact(context) {
    const devtoolsLog = context.dependencies.DevtoolsLog;
    const networkRecords = await NetworkRecords.request(devtoolsLog, context);
    return TagsBlockingFirstPaint.findBlockingTags(context.driver, networkRecords);
  }

  /**
   * @param {LH.Gatherer.PassContext} passContext
   * @param {LH.Gatherer.LoadData} loadData
   * @return {Promise<LH.Artifacts['TagsBlockingFirstPaint']>}
   */
  afterPass(passContext, loadData) {
    return TagsBlockingFirstPaint.findBlockingTags(passContext.driver, loadData.networkRecords);
  }
}

module.exports = TagsBlockingFirstPaint;

},{"../../../computed/network-records.js":40,"../../../fraggle-rock/gather/base-gatherer.js":60,"../devtools-log.js":"../gather/gatherers/devtools-log"}],"../gather/gatherers/form-elements":[function(require,module,exports){
/**
 * @license Copyright 2020 The Lighthouse Authors. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.
 */
'use strict';

/* global getNodeDetails */

const FRGatherer = require('../../fraggle-rock/gather/base-gatherer.js');
const pageFunctions = require('../../lib/page-functions.js');

/* eslint-env browser, node */

/**
 * @return {LH.Artifacts['FormElements']}
 */
/* c8 ignore start */
function collectFormElements() {
  // @ts-expect-error - put into scope via stringification
  const formChildren = getElementsInDocument('textarea, input, label, select'); // eslint-disable-line no-undef
  /** @type {Map<HTMLFormElement|string, LH.Artifacts.Form>} */
  const forms = new Map();
  /** @type {LH.Artifacts.Form} */
  const formlessObj = {
    node: null,
    inputs: [],
    labels: [],
  };
  for (const child of formChildren) {
    const isButton = child instanceof HTMLInputElement &&
      (child.type === 'submit' || child.type === 'button');
    if (isButton) continue;

    const parentFormElement = child.form;
    const hasForm = !!parentFormElement;
    if (hasForm && !forms.has(parentFormElement)) {
      const newFormObj = {
        attributes: {
          id: parentFormElement.id,
          name: parentFormElement.name,
          autocomplete: parentFormElement.autocomplete,
        },
        // @ts-expect-error - getNodeDetails put into scope via stringification
        node: getNodeDetails(parentFormElement),
        inputs: [],
        labels: [],
      };
      forms.set(parentFormElement, newFormObj);
    }
    const formObj = forms.get(parentFormElement) || formlessObj;
    if (child instanceof HTMLInputElement || child instanceof HTMLTextAreaElement
      || child instanceof HTMLSelectElement) {
      formObj.inputs.push({
        id: child.id,
        name: child.name,
        placeholder: child instanceof HTMLSelectElement ? undefined : child.placeholder,
        autocomplete: {
          property: child.autocomplete,
          // Requires `--enable-features=AutofillShowTypePredictions`.
          attribute: child.getAttribute('autocomplete'),
          prediction: child.getAttribute('autofill-prediction'),
        },
        // @ts-expect-error - getNodeDetails put into scope via stringification
        node: getNodeDetails(child),
      });
    }
    if (child instanceof HTMLLabelElement) {
      formObj.labels.push({
        for: child.htmlFor,
        // @ts-expect-error - getNodeDetails put into scope via stringification
        node: getNodeDetails(child),
      });
    }
  }

  if (formlessObj.inputs.length > 0 || formlessObj.labels.length > 0) {
    forms.set('formless', {
      node: formlessObj.node,
      inputs: formlessObj.inputs,
      labels: formlessObj.labels,
    });
  }
  return [...forms.values()];
}
/* c8 ignore stop */

class FormElements extends FRGatherer {
  /** @type {LH.Gatherer.GathererMeta} */
  meta = {
    supportedModes: ['snapshot', 'navigation'],
  }

  /**
   * @param {LH.Gatherer.FRTransitionalContext} passContext
   * @return {Promise<LH.Artifacts['FormElements']>}
   */
  async getArtifact(passContext) {
    const driver = passContext.driver;

    const formElements = await driver.executionContext.evaluate(collectFormElements, {
      args: [],
      useIsolation: true,
      deps: [
        pageFunctions.getElementsInDocumentString,
        pageFunctions.getNodeDetailsString,
      ],
    });
    return formElements;
  }
}

module.exports = FormElements;

},{"../../fraggle-rock/gather/base-gatherer.js":60,"../../lib/page-functions.js":110}],"../gather/gatherers/full-page-screenshot":[function(require,module,exports){
/**
 * @license Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.
 */
'use strict';

/* globals window document getBoundingClientRect */

const FRGatherer = require('../../fraggle-rock/gather/base-gatherer.js');
const emulation = require('../../lib/emulation.js');
const pageFunctions = require('../../lib/page-functions.js');

// JPEG quality setting
// Exploration and examples of reports using different quality settings: https://docs.google.com/document/d/1ZSffucIca9XDW2eEwfoevrk-OTl7WQFeMf0CgeJAA8M/edit#
const FULL_PAGE_SCREENSHOT_QUALITY = 30;

/**
 * @param {string} str
 */
function snakeCaseToCamelCase(str) {
  return str.replace(/(-\w)/g, m => m[1].toUpperCase());
}

class FullPageScreenshot extends FRGatherer {
  /** @type {LH.Gatherer.GathererMeta} */
  meta = {
    supportedModes: ['snapshot', 'timespan', 'navigation'],
  }

  /**
   * @param {LH.Gatherer.FRTransitionalContext} context
   * @return {Promise<number>}
   * @see https://bugs.chromium.org/p/chromium/issues/detail?id=770769
   */
  async getMaxScreenshotHeight(context) {
    return await context.driver.executionContext.evaluate(pageFunctions.getMaxTextureSize, {
      args: [],
      useIsolation: true,
      deps: [],
    });
  }

  /**
   * @param {LH.Gatherer.FRTransitionalContext} context
   * @return {Promise<LH.Artifacts.FullPageScreenshot['screenshot']>}
   */
  async _takeScreenshot(context) {
    const session = context.driver.defaultSession;
    const maxScreenshotHeight = await this.getMaxScreenshotHeight(context);
    const metrics = await session.sendCommand('Page.getLayoutMetrics');

    // Width should match emulated width, without considering content overhang.
    // Both layoutViewport and visualViewport capture this. visualViewport accounts
    // for page zoom/scale, which we currently don't account for (or expect). So we use layoutViewport.width.
    // Note: If the page is zoomed, many assumptions fail.
    //
    // Height should be as tall as the content. So we use contentSize.height
    const width = Math.min(metrics.layoutViewport.clientWidth, maxScreenshotHeight);
    const height = Math.min(metrics.contentSize.height, maxScreenshotHeight);

    await session.sendCommand('Emulation.setDeviceMetricsOverride', {
      // If we're gathering with mobile screenEmulation on (overlay scrollbars, etc), continue to use that for this screenshot.
      mobile: context.settings.screenEmulation.mobile,
      height,
      width,
      deviceScaleFactor: 1,
      scale: 1,
      screenOrientation: {angle: 0, type: 'portraitPrimary'},
    });

    // TODO: elements collected earlier in gathering are likely to have been shifted by now.
    // The lower in the page, the more likely (footer elements especially).
    // https://github.com/GoogleChrome/lighthouse/issues/11118

    const result = await session.sendCommand('Page.captureScreenshot', {
      format: 'jpeg',
      quality: FULL_PAGE_SCREENSHOT_QUALITY,
    });
    const data = 'data:image/jpeg;base64,' + result.data;

    return {
      data,
      width,
      height,
    };
  }

  /**
   * Gatherers can collect details about DOM nodes, including their position on the page.
   * Layout shifts occuring after a gatherer runs can cause these positions to be incorrect,
   * resulting in a poor experience for element screenshots.
   * `getNodeDetails` maintains a collection of DOM objects in the page, which we can iterate
   * to re-collect the bounding client rectangle.
   * @see pageFunctions.getNodeDetails
   * @param {LH.Gatherer.FRTransitionalContext} context
   * @return {Promise<LH.Artifacts.FullPageScreenshot['nodes']>}
   */
  async _resolveNodes(context) {
    function resolveNodes() {
      /** @type {LH.Artifacts.FullPageScreenshot['nodes']} */
      const nodes = {};
      if (!window.__lighthouseNodesDontTouchOrAllVarianceGoesAway) return nodes;

      const lhIdToElements = window.__lighthouseNodesDontTouchOrAllVarianceGoesAway;
      for (const [node, id] of lhIdToElements.entries()) {
        // @ts-expect-error - getBoundingClientRect put into scope via stringification
        const rect = getBoundingClientRect(node);
        nodes[id] = rect;
      }

      return nodes;
    }

    /**
     * @param {{useIsolation: boolean}} _
     */
    function resolveNodesInPage({useIsolation}) {
      return context.driver.executionContext.evaluate(resolveNodes, {
        args: [],
        useIsolation,
        deps: [pageFunctions.getBoundingClientRectString],
      });
    }

    // Collect nodes with the page context (`useIsolation: false`) and with our own, reused
    // context (`useIsolation: true`). Gatherers use both modes when collecting node details,
    // so we must do the same here too.
    const pageContextResult = await resolveNodesInPage({useIsolation: false});
    const isolatedContextResult = await resolveNodesInPage({useIsolation: true});
    return {...pageContextResult, ...isolatedContextResult};
  }

  /**
   * @param {LH.Gatherer.FRTransitionalContext} context
   * @return {Promise<LH.Artifacts['FullPageScreenshot']>}
   */
  async getArtifact(context) {
    const session = context.driver.defaultSession;
    const executionContext = context.driver.executionContext;
    const settings = context.settings;

    // In case some other program is controlling emulation, try to remember what the device looks
    // like now and reset after gatherer is done.
    const lighthouseControlsEmulation = !settings.screenEmulation.disabled;

    try {
      return {
        screenshot: await this._takeScreenshot(context),
        nodes: await this._resolveNodes(context),
      };
    } finally {
      // Revert resized page.
      if (lighthouseControlsEmulation) {
        await emulation.emulate(session, settings);
      } else {
        // Best effort to reset emulation to what it was.
        // https://github.com/GoogleChrome/lighthouse/pull/10716#discussion_r428970681
        // TODO: seems like this would be brittle. Should at least work for devtools, but what
        // about scripted puppeteer usages? Better to introduce a "setEmulation" callback
        // in the LH runner api, which for ex. puppeteer consumers would setup puppeteer emulation,
        // and then just call that to reset?
        // https://github.com/GoogleChrome/lighthouse/issues/11122

        // eslint-disable-next-line no-inner-declarations
        function getObservedDeviceMetrics() {
          // Convert the Web API's snake case (landscape-primary) to camel case (landscapePrimary).
          const screenOrientationType = /** @type {LH.Crdp.Emulation.ScreenOrientationType} */ (
            snakeCaseToCamelCase(window.screen.orientation.type));
          return {
            width: document.documentElement.clientWidth,
            height: document.documentElement.clientHeight,
            screenOrientation: {
              type: screenOrientationType,
              angle: window.screen.orientation.angle,
            },
            deviceScaleFactor: window.devicePixelRatio,
          };
        }

        const observedDeviceMetrics = await executionContext.evaluate(getObservedDeviceMetrics, {
          args: [],
          useIsolation: true,
          deps: [snakeCaseToCamelCase],
        });
        await session.sendCommand('Emulation.setDeviceMetricsOverride', {
          mobile: settings.formFactor === 'mobile',
          ...observedDeviceMetrics,
        });
      }
    }
  }
}

module.exports = FullPageScreenshot;

},{"../../fraggle-rock/gather/base-gatherer.js":60,"../../lib/emulation.js":95,"../../lib/page-functions.js":110}],"../gather/gatherers/gather-context":[function(require,module,exports){
/**
 * @license Copyright 2021 The Lighthouse Authors. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.
 */
'use strict';

const FRGatherer = require('../../fraggle-rock/gather/base-gatherer.js');

class GatherContext extends FRGatherer {
   /** @type {LH.Gatherer.GathererMeta} */
   meta = {
     supportedModes: ['snapshot', 'timespan', 'navigation'],
   }

   /**
    * @param {LH.Gatherer.FRTransitionalContext} phaseContext
    * @return {Promise<LH.Artifacts['GatherContext']>}
    */
   async getArtifact(phaseContext) {
     return {gatherMode: phaseContext.gatherMode};
   }
}

module.exports = GatherContext;

},{"../../fraggle-rock/gather/base-gatherer.js":60}],"../gather/gatherers/global-listeners":[function(require,module,exports){
/**
 * @license Copyright 2020 The Lighthouse Authors. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.
 */
'use strict';

/**
 * @fileoverview
 * A gatherer to collect information about the event listeners registered on the
 * global object. For now, the scope is narrowed to events that occur on and
 * around page unload, but this can be expanded in the future.
 */

const FRGatherer = require('../../fraggle-rock/gather/base-gatherer.js');

class GlobalListeners extends FRGatherer {
  /** @type {LH.Gatherer.GathererMeta} */
  meta = {
    supportedModes: ['snapshot', 'navigation'],
  }

  /**
   * @param {LH.Crdp.DOMDebugger.EventListener} listener
   * @return {listener is {type: 'pagehide'|'unload'|'visibilitychange'} & LH.Crdp.DOMDebugger.EventListener}
   */
  static _filterForAllowlistedTypes(listener) {
    return listener.type === 'pagehide' ||
      listener.type === 'unload' ||
      listener.type === 'visibilitychange';
  }

  /**
   * @param { LH.Artifacts.GlobalListener } listener
   * @return { string }
   */
  getListenerIndentifier(listener) {
    return `${listener.type}:${listener.scriptId}:${listener.columnNumber}:${listener.lineNumber}`;
  }

  /**
   * @param { LH.Artifacts['GlobalListeners'] } listeners
   * @return { LH.Artifacts['GlobalListeners'] }
   */
  dedupeListeners(listeners) {
    const seenListeners = new Set();
    return listeners.filter(listener => {
      const id = this.getListenerIndentifier(listener);
      if (!seenListeners.has(id)) {
        seenListeners.add(id);
        return true;
      } else {
        return false;
      }
    });
  }

  /**
   * @param {LH.Gatherer.FRTransitionalContext} passContext
   * @return {Promise<LH.Artifacts['GlobalListeners']>}
   */
  async getArtifact(passContext) {
    const session = passContext.driver.defaultSession;

    // Get a RemoteObject handle to `window`.
    const {result: {objectId}} = await session.sendCommand('Runtime.evaluate', {
      expression: 'window',
      returnByValue: false,
    });
    if (!objectId) {
      throw new Error('Error fetching information about the global object');
    }

    // And get all its listeners of interest.
    const {listeners} = await session.sendCommand('DOMDebugger.getEventListeners', {objectId});
    const filteredListeners = listeners.filter(GlobalListeners._filterForAllowlistedTypes)
    .map(listener => {
      const {type, scriptId, lineNumber, columnNumber} = listener;
      return {
        type,
        scriptId,
        lineNumber,
        columnNumber,
      };
    });

    // Dedupe listeners with same underlying data.
    return this.dedupeListeners(filteredListeners);
  }
}

module.exports = GlobalListeners;

},{"../../fraggle-rock/gather/base-gatherer.js":60}],"../gather/gatherers/host-form-factor":[function(require,module,exports){
/**
 * @license Copyright 2021 The Lighthouse Authors. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.
 */
'use strict';

const FRGatherer = require('../../fraggle-rock/gather/base-gatherer.js');
const HostUserAgent = require('./host-user-agent.js');

class HostFormFactor extends FRGatherer {
  static symbol = Symbol('HostFormFactor');

  /** @type {LH.Gatherer.GathererMeta<'HostUserAgent'>} */
  meta = {
    symbol: HostFormFactor.symbol,
    supportedModes: ['snapshot', 'timespan', 'navigation'],
    dependencies: {HostUserAgent: HostUserAgent.symbol},
  };

  /**
   * @param {LH.Gatherer.FRTransitionalContext<'HostUserAgent'>} context
   * @return {Promise<LH.Artifacts['HostFormFactor']>}
   */
  async getArtifact(context) {
    const userAgent = context.dependencies.HostUserAgent;
    return userAgent.includes('Android') || userAgent.includes('Mobile') ? 'mobile' : 'desktop';
  }
}

module.exports = HostFormFactor;

},{"../../fraggle-rock/gather/base-gatherer.js":60,"./host-user-agent.js":"../gather/gatherers/host-user-agent"}],"../gather/gatherers/host-user-agent":[function(require,module,exports){
/**
 * @license Copyright 2021 The Lighthouse Authors. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.
 */
'use strict';

const FRGatherer = require('../../fraggle-rock/gather/base-gatherer.js');
const {getBrowserVersion} = require('../driver/environment.js');

class HostUserAgent extends FRGatherer {
  static symbol = Symbol('HostUserAgent');

  /** @type {LH.Gatherer.GathererMeta} */
  meta = {
    symbol: HostUserAgent.symbol,
    supportedModes: ['snapshot', 'timespan', 'navigation'],
  };

  /**
   * @param {LH.Gatherer.FRTransitionalContext} context
   * @return {Promise<LH.Artifacts['HostUserAgent']>}
   */
  getArtifact(context) {
    return getBrowserVersion(context.driver.defaultSession).then(v => v.userAgent);
  }
}

module.exports = HostUserAgent;

},{"../../fraggle-rock/gather/base-gatherer.js":60,"../driver/environment.js":66}],"../gather/gatherers/http-redirect":[function(require,module,exports){
/**
 * @license Copyright 2016 The Lighthouse Authors. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.
 */
'use strict';

const Gatherer = require('./gatherer.js');

/**
 * This gatherer changes the options.url so that its pass loads the http page.
 * After load it detects if its on a crypographic scheme.
 * TODO: Instead of abusing a loadPage pass for this test, it could likely just do an XHR instead
 */
class HTTPRedirect extends Gatherer {
  constructor() {
    super();
    this._preRedirectURL = '';
  }

  /**
   * @param {LH.Gatherer.PassContext} passContext
   */
  beforePass(passContext) {
    this._preRedirectURL = passContext.url;
    passContext.url = this._preRedirectURL.replace(/^https/, 'http');
  }

  /**
   * @param {LH.Gatherer.PassContext} passContext
   * @return {Promise<LH.Artifacts['HTTPRedirect']>}
   */
  async afterPass(passContext) {
    // Reset the options.
    passContext.url = this._preRedirectURL;

    const executionContext = passContext.driver.executionContext;
    const expression = `new URL(window.location).protocol === 'https:'`;
    const isHttps = await executionContext.evaluateAsync(expression, {useIsolation: true});
    return {
      value: isHttps,
    };
  }
}

module.exports = HTTPRedirect;

},{"./gatherer.js":77}],"../gather/gatherers/iframe-elements":[function(require,module,exports){
/**
 * @license Copyright 2019 The Lighthouse Authors. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.
 */
'use strict';

/* global getNodeDetails */

const FRGatherer = require('../../fraggle-rock/gather/base-gatherer.js');
const pageFunctions = require('../../lib/page-functions.js');

/* eslint-env browser, node */

/**
 * @return {LH.Artifacts['IFrameElements']}
 */
/* c8 ignore start */
function collectIFrameElements() {
  // @ts-expect-error - put into scope via stringification
  const iFrameElements = getElementsInDocument('iframe'); // eslint-disable-line no-undef
  return iFrameElements.map(/** @param {HTMLIFrameElement} node */ (node) => {
    const clientRect = node.getBoundingClientRect();
    const {top, bottom, left, right, width, height} = clientRect;
    return {
      id: node.id,
      src: node.src,
      clientRect: {top, bottom, left, right, width, height},
      // @ts-expect-error - put into scope via stringification
      isPositionFixed: isPositionFixed(node), // eslint-disable-line no-undef
      // @ts-expect-error - getNodeDetails put into scope via stringification
      node: getNodeDetails(node),
    };
  });
}
/* c8 ignore stop */

class IFrameElements extends FRGatherer {
  /** @type {LH.Gatherer.GathererMeta} */
  meta = {
    supportedModes: ['snapshot', 'navigation'],
  }

  /**
   * @param {LH.Gatherer.FRTransitionalContext} passContext
   * @return {Promise<LH.Artifacts['IFrameElements']>}
   * @override
   */
  async getArtifact(passContext) {
    const driver = passContext.driver;

    const iframeElements = await driver.executionContext.evaluate(collectIFrameElements, {
      args: [],
      useIsolation: true,
      deps: [
        pageFunctions.getElementsInDocumentString,
        pageFunctions.isPositionFixedString,
        pageFunctions.getNodeDetailsString,
      ],
    });
    return iframeElements;
  }
}

module.exports = IFrameElements;

},{"../../fraggle-rock/gather/base-gatherer.js":60,"../../lib/page-functions.js":110}],"../gather/gatherers/image-elements":[function(require,module,exports){
/**
 * @license Copyright 2017 The Lighthouse Authors. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.
 */
/**
  * @fileoverview Gathers all images used on the page with their src, size,
  *   and attribute information. Executes script in the context of the page.
  */
'use strict';

const log = require('lighthouse-logger');
const FRGatherer = require('../../fraggle-rock/gather/base-gatherer.js');
const pageFunctions = require('../../lib/page-functions.js');
const URL = require('../../lib/url-shim.js');
const FontSize = require('./seo/font-size.js');

/* global window, getElementsInDocument, Image, getNodeDetails, ShadowRoot */

/** @param {Element} element */
/* c8 ignore start */
function getClientRect(element) {
  const clientRect = element.getBoundingClientRect();
  return {
    // Just grab the DOMRect properties we want, excluding x/y/width/height
    top: clientRect.top,
    bottom: clientRect.bottom,
    left: clientRect.left,
    right: clientRect.right,
  };
}
/* c8 ignore stop */

/**
 * If an image is within `picture`, the `picture` element's css position
 * is what we want to collect, since that position is relevant to CLS.
 * @param {Element} element
 * @param {CSSStyleDeclaration} computedStyle
 */
/* c8 ignore start */
function getPosition(element, computedStyle) {
  if (element.parentElement && element.parentElement.tagName === 'PICTURE') {
    const parentStyle = window.getComputedStyle(element.parentElement);
    return parentStyle.getPropertyValue('position');
  }
  return computedStyle.getPropertyValue('position');
}
/* c8 ignore stop */

/**
 * @param {Array<Element>} allElements
 * @return {Array<LH.Artifacts.ImageElement>}
 */
/* c8 ignore start */
function getHTMLImages(allElements) {
  const allImageElements = /** @type {Array<HTMLImageElement>} */ (allElements.filter(element => {
    return element.localName === 'img';
  }));

  return allImageElements.map(element => {
    const computedStyle = window.getComputedStyle(element);
    const isPicture = !!element.parentElement && element.parentElement.tagName === 'PICTURE';
    const canTrustNaturalDimensions = !isPicture && !element.srcset;
    return {
      // currentSrc used over src to get the url as determined by the browser
      // after taking into account srcset/media/sizes/etc.
      src: element.currentSrc,
      srcset: element.srcset,
      displayedWidth: element.width,
      displayedHeight: element.height,
      clientRect: getClientRect(element),
      attributeWidth: element.getAttribute('width'),
      attributeHeight: element.getAttribute('height'),
      naturalDimensions: canTrustNaturalDimensions ?
        {width: element.naturalWidth, height: element.naturalHeight} :
        undefined,
      cssRules: undefined, // this will get overwritten below
      computedStyles: {
        position: getPosition(element, computedStyle),
        objectFit: computedStyle.getPropertyValue('object-fit'),
        imageRendering: computedStyle.getPropertyValue('image-rendering'),
      },
      isCss: false,
      isPicture,
      loading: element.loading,
      isInShadowDOM: element.getRootNode() instanceof ShadowRoot,
      // @ts-expect-error - getNodeDetails put into scope via stringification
      node: getNodeDetails(element),
    };
  });
}
/* c8 ignore stop */

/**
 * @param {Array<Element>} allElements
 * @return {Array<LH.Artifacts.ImageElement>}
 */
/* c8 ignore start */
function getCSSImages(allElements) {
  // Chrome normalizes background image style from getComputedStyle to be an absolute URL in quotes.
  // Only match basic background-image: url("http://host/image.jpeg") declarations
  const CSS_URL_REGEX = /^url\("([^"]+)"\)$/;

  /** @type {Array<LH.Artifacts.ImageElement>} */
  const images = [];

  for (const element of allElements) {
    const style = window.getComputedStyle(element);
    // If the element didn't have a CSS background image, we're not interested.
    if (!style.backgroundImage || !CSS_URL_REGEX.test(style.backgroundImage)) continue;

    const imageMatch = style.backgroundImage.match(CSS_URL_REGEX);
    // @ts-expect-error test() above ensures that there is a match.
    const url = imageMatch[1];

    images.push({
      src: url,
      srcset: '',
      displayedWidth: element.clientWidth,
      displayedHeight: element.clientHeight,
      clientRect: getClientRect(element),
      attributeWidth: null,
      attributeHeight: null,
      naturalDimensions: undefined,
      cssEffectiveRules: undefined,
      computedStyles: {
        position: getPosition(element, style),
        objectFit: '',
        imageRendering: style.getPropertyValue('image-rendering'),
      },
      isCss: true,
      isPicture: false,
      isInShadowDOM: element.getRootNode() instanceof ShadowRoot,
      // @ts-expect-error - getNodeDetails put into scope via stringification
      node: getNodeDetails(element),
    });
  }

  return images;
}
/* c8 ignore stop */

/** @return {Array<LH.Artifacts.ImageElement>} */
/* c8 ignore start */
function collectImageElementInfo() {
  /** @type {Array<Element>} */
  // @ts-expect-error - added by getElementsInDocumentFnString
  const allElements = getElementsInDocument();
  return getHTMLImages(allElements).concat(getCSSImages(allElements));
}
/* c8 ignore stop */

/**
 * @param {string} url
 * @return {Promise<{naturalWidth: number, naturalHeight: number}>}
 */
/* c8 ignore start */
function determineNaturalSize(url) {
  return new Promise((resolve, reject) => {
    const img = new Image();
    img.addEventListener('error', _ => reject(new Error('determineNaturalSize failed img load')));
    img.addEventListener('load', () => {
      resolve({
        naturalWidth: img.naturalWidth,
        naturalHeight: img.naturalHeight,
      });
    });

    img.src = url;
  });
}
/* c8 ignore stop */

/**
 * @param {Partial<Pick<LH.Crdp.CSS.CSSStyle, 'cssProperties'>>|undefined} rule
 * @param {string} property
 * @return {string | undefined}
 */
function findSizeDeclaration(rule, property) {
  if (!rule || !rule.cssProperties) return;

  const definedProp = rule.cssProperties.find(({name}) => name === property);
  if (!definedProp) return;

  return definedProp.value;
}

/**
 * Finds the most specific directly matched CSS font-size rule from the list.
 *
 * @param {Array<LH.Crdp.CSS.RuleMatch>|undefined} matchedCSSRules
 * @param {string} property
 * @return {string | undefined}
 */
function findMostSpecificCSSRule(matchedCSSRules, property) {
  /** @param {LH.Crdp.CSS.CSSStyle} declaration */
  const isDeclarationofInterest = (declaration) => findSizeDeclaration(declaration, property);
  const rule = FontSize.findMostSpecificMatchedCSSRule(matchedCSSRules, isDeclarationofInterest);
  if (!rule) return;

  return findSizeDeclaration(rule, property);
}

/**
 * @param {LH.Crdp.CSS.GetMatchedStylesForNodeResponse} matched CSS rules}
 * @param {string} property
 * @return {string | null}
 */
function getEffectiveSizingRule({attributesStyle, inlineStyle, matchedCSSRules}, property) {
  // CSS sizing can't be inherited.
  // We only need to check inline & matched styles.
  // Inline styles have highest priority.
  const inlineRule = findSizeDeclaration(inlineStyle, property);
  if (inlineRule) return inlineRule;

  const attributeRule = findSizeDeclaration(attributesStyle, property);
  if (attributeRule) return attributeRule;

  // Rules directly referencing the node come next.
  const matchedRule = findMostSpecificCSSRule(matchedCSSRules, property);
  if (matchedRule) return matchedRule;

  return null;
}

/**
 * @param {LH.Artifacts.ImageElement} element
 * @return {number}
 */
function getPixelArea(element) {
  if (element.naturalDimensions) {
    return element.naturalDimensions.height * element.naturalDimensions.width;
  }
  return element.displayedHeight * element.displayedWidth;
}

class ImageElements extends FRGatherer {
  /** @type {LH.Gatherer.GathererMeta} */
  meta = {
    supportedModes: ['snapshot', 'timespan', 'navigation'],
  };

  constructor() {
    super();
    /** @type {Map<string, {naturalWidth: number, naturalHeight: number}>} */
    this._naturalSizeCache = new Map();
  }

  /**
   * @param {LH.Gatherer.FRTransitionalDriver} driver
   * @param {LH.Artifacts.ImageElement} element
   */
  async fetchElementWithSizeInformation(driver, element) {
    const url = element.src;
    let size = this._naturalSizeCache.get(url);
    if (!size) {
      try {
        // We don't want this to take forever, 250ms should be enough for images that are cached
        driver.defaultSession.setNextProtocolTimeout(250);
        size = await driver.executionContext.evaluate(determineNaturalSize, {
          args: [url],
        });
        this._naturalSizeCache.set(url, size);
      } catch (_) {
        // determineNaturalSize fails on invalid images, which we treat as non-visible
      }
    }

    if (!size) return;
    element.naturalDimensions = {width: size.naturalWidth, height: size.naturalHeight};
  }

  /**
   * Images might be sized via CSS. In order to compute unsized-images failures, we need to collect
   * matched CSS rules to see if this is the case.
   * @url http://go/dwoqq (googlers only)
   * @param {LH.Gatherer.FRProtocolSession} session
   * @param {string} devtoolsNodePath
   * @param {LH.Artifacts.ImageElement} element
   */
  async fetchSourceRules(session, devtoolsNodePath, element) {
    try {
      const {nodeId} = await session.sendCommand('DOM.pushNodeByPathToFrontend', {
        path: devtoolsNodePath,
      });
      if (!nodeId) return;

      const matchedRules = await session.sendCommand('CSS.getMatchedStylesForNode', {
        nodeId: nodeId,
      });
      const width = getEffectiveSizingRule(matchedRules, 'width');
      const height = getEffectiveSizingRule(matchedRules, 'height');
      const aspectRatio = getEffectiveSizingRule(matchedRules, 'aspect-ratio');
      element.cssEffectiveRules = {width, height, aspectRatio};
    } catch (err) {
      if (/No node.*found/.test(err.message)) return;
      throw err;
    }
  }

  /**
   *
   * @param {LH.Gatherer.FRTransitionalDriver} driver
   * @param {LH.Artifacts.ImageElement[]} elements
   */
  async collectExtraDetails(driver, elements) {
    // Don't do more than 5s of this expensive devtools protocol work. See #11289
    let reachedGatheringBudget = false;
    setTimeout(_ => (reachedGatheringBudget = true), 5000);
    let skippedCount = 0;

    for (const element of elements) {
      element.mimeType = URL.guessMimeType(element.src);

      if (reachedGatheringBudget) {
        skippedCount++;
        continue;
      }

      // Need source rules to determine if sized via CSS (for unsized-images).
      if (!element.isInShadowDOM && !element.isCss) {
        await this.fetchSourceRules(driver.defaultSession, element.node.devtoolsNodePath, element);
      }
      // Images within `picture` behave strangely and natural size information isn't accurate,
      // CSS images have no natural size information at all. Try to get the actual size if we can.
      if (element.isPicture || element.isCss || element.srcset) {
        await this.fetchElementWithSizeInformation(driver, element);
      }
    }

    if (reachedGatheringBudget) {
      log.warn('ImageElements', `Reached gathering budget of 5s. Skipped extra details for ${skippedCount}/${elements.length}`); // eslint-disable-line max-len
    }
  }

  /**
   * @param {LH.Gatherer.FRTransitionalContext} context
   * @return {Promise<LH.Artifacts['ImageElements']>}
   */
  async getArtifact(context) {
    const session = context.driver.defaultSession;
    const executionContext = context.driver.executionContext;

    const elements = await executionContext.evaluate(collectImageElementInfo, {
      args: [],
      deps: [
        pageFunctions.getElementsInDocumentString,
        pageFunctions.getBoundingClientRectString,
        pageFunctions.getNodeDetailsString,
        getClientRect,
        getPosition,
        getHTMLImages,
        getCSSImages,
      ],
    });

    await Promise.all([
      session.sendCommand('DOM.enable'),
      session.sendCommand('CSS.enable'),
      session.sendCommand('DOM.getDocument', {depth: -1, pierce: true}),
    ]);

    // Spend our extra details budget on highest impact images.
    // Our best approximation of impact without network records is to use pixel area.
    elements.sort((a, b) => getPixelArea(b) - getPixelArea(a));

    await this.collectExtraDetails(context.driver, elements);

    await Promise.all([
      session.sendCommand('DOM.disable'),
      session.sendCommand('CSS.disable'),
    ]);

    return elements;
  }
}

module.exports = ImageElements;

},{"../../fraggle-rock/gather/base-gatherer.js":60,"../../lib/page-functions.js":110,"../../lib/url-shim.js":"url","./seo/font-size.js":"../gather/gatherers/seo/font-size","lighthouse-logger":188}],"../gather/gatherers/inspector-issues":[function(require,module,exports){
/**
 * @license Copyright 2020 The Lighthouse Authors. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.
 */

/**
 * @fileoverview Capture IssueAdded events
 */

'use strict';

const FRGatherer = require('../../fraggle-rock/gather/base-gatherer.js');
const NetworkRecords = require('../../computed/network-records.js');
const DevtoolsLog = require('./devtools-log.js');

class InspectorIssues extends FRGatherer {
  /** @type {LH.Gatherer.GathererMeta<'DevtoolsLog'>} */
  meta = {
    supportedModes: ['timespan', 'navigation'],
    dependencies: {DevtoolsLog: DevtoolsLog.symbol},
  }

  constructor() {
    super();
    /** @type {Array<LH.Crdp.Audits.InspectorIssue>} */
    this._issues = [];
    this._onIssueAdded = this.onIssueAdded.bind(this);
  }

  /**
   * @param {LH.Crdp.Audits.IssueAddedEvent} entry
   */
  onIssueAdded(entry) {
    this._issues.push(entry.issue);
  }

  /**
   * @param {LH.Gatherer.FRTransitionalContext} context
   */
  async startInstrumentation(context) {
    const session = context.driver.defaultSession;
    session.on('Audits.issueAdded', this._onIssueAdded);
    await session.sendCommand('Audits.enable');
  }

  /**
   * @param {LH.Gatherer.FRTransitionalContext} context
   */
  async stopInstrumentation(context) {
    const session = context.driver.defaultSession;
    session.off('Audits.issueAdded', this._onIssueAdded);
    await session.sendCommand('Audits.disable');
  }

  /**
   * @param {Array<LH.Artifacts.NetworkRequest>} networkRecords
   * @return {Promise<LH.Artifacts['InspectorIssues']>}
   */
  async _getArtifact(networkRecords) {
    const artifact = {
      /** @type {Array<LH.Crdp.Audits.MixedContentIssueDetails>} */
      mixedContent: [],
      /** @type {Array<LH.Crdp.Audits.SameSiteCookieIssueDetails>} */
      sameSiteCookies: [],
      /** @type {Array<LH.Crdp.Audits.BlockedByResponseIssueDetails>} */
      blockedByResponse: [],
      /** @type {Array<LH.Crdp.Audits.HeavyAdIssueDetails>} */
      heavyAds: [],
      /** @type {Array<LH.Crdp.Audits.ContentSecurityPolicyIssueDetails>} */
      contentSecurityPolicy: [],
    };

    for (const issue of this._issues) {
      if (issue.details.mixedContentIssueDetails) {
        const issueDetails = issue.details.mixedContentIssueDetails;
        const issueReqId = issueDetails.request && issueDetails.request.requestId;
        // Duplicate issues can occur for the same request; only use the one with a matching networkRequest.
        if (issueReqId &&
          networkRecords.find(req => req.requestId === issueReqId)) {
          artifact.mixedContent.push(issueDetails);
        }
      }
      if (issue.details.sameSiteCookieIssueDetails) {
        const issueDetails = issue.details.sameSiteCookieIssueDetails;
        const issueReqId = issueDetails.request && issueDetails.request.requestId;
        // Duplicate issues can occur for the same request; only use the one with a matching networkRequest.
        if (issueReqId &&
          networkRecords.find(req => req.requestId === issueReqId)) {
          artifact.sameSiteCookies.push(issueDetails);
        }
      }
      if (issue.details.blockedByResponseIssueDetails) {
        const issueDetails = issue.details.blockedByResponseIssueDetails;
        const issueReqId = issueDetails.request && issueDetails.request.requestId;
        // Duplicate issues can occur for the same request; only use the one with a matching networkRequest.
        if (issueReqId &&
          networkRecords.find(req => req.requestId === issueReqId)) {
          artifact.blockedByResponse.push(issueDetails);
        }
      }
      if (issue.details.heavyAdIssueDetails) {
        artifact.heavyAds.push(issue.details.heavyAdIssueDetails);
      }
      if (issue.details.contentSecurityPolicyIssueDetails) {
        artifact.contentSecurityPolicy.push(issue.details.contentSecurityPolicyIssueDetails);
      }
    }

    return artifact;
  }

  /**
   * @param {LH.Gatherer.FRTransitionalContext<'DevtoolsLog'>} context
   * @return {Promise<LH.Artifacts['InspectorIssues']>}
   */
  async getArtifact(context) {
    const devtoolsLog = context.dependencies.DevtoolsLog;
    const networkRecords = await NetworkRecords.request(devtoolsLog, context);
    return this._getArtifact(networkRecords);
  }

  /**
   * @param {LH.Gatherer.PassContext} passContext
   * @param {LH.Gatherer.LoadData} loadData
   * @return {Promise<LH.Artifacts['InspectorIssues']>}
   */
  async afterPass(passContext, loadData) {
    await this.stopInstrumentation({...passContext, dependencies: {}});
    return this._getArtifact(loadData.networkRecords);
  }
}

module.exports = InspectorIssues;

},{"../../computed/network-records.js":40,"../../fraggle-rock/gather/base-gatherer.js":60,"./devtools-log.js":"../gather/gatherers/devtools-log"}],"../gather/gatherers/installability-errors":[function(require,module,exports){
/**
 * @license Copyright 2021 The Lighthouse Authors. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.
 */
'use strict';

const log = require('lighthouse-logger');
const FRGatherer = require('../../fraggle-rock/gather/base-gatherer.js');

class InstallabilityErrors extends FRGatherer {
  /** @type {LH.Gatherer.GathererMeta} */
  meta = {
    supportedModes: ['snapshot', 'navigation'],
  };

  /**
   * Creates an Artifacts.InstallabilityErrors, tranforming data from the protocol
   * for old versions of Chrome.
   * @param {LH.Gatherer.FRProtocolSession} session
   * @return {Promise<LH.Artifacts['InstallabilityErrors']>}
   */
  static async getInstallabilityErrors(session) {
    const status = {
      msg: 'Get webapp installability errors',
      id: 'lh:gather:getInstallabilityErrors',
    };
    log.time(status);
    const response = await session.sendCommand('Page.getInstallabilityErrors');

    const errors = response.installabilityErrors;

    log.timeEnd(status);
    return {errors};
  }

  /**
   * @param {LH.Gatherer.FRTransitionalContext} context
   * @return {Promise<LH.Artifacts['InstallabilityErrors']>}
   */
  getArtifact(context) {
    const driver = context.driver;

    return InstallabilityErrors.getInstallabilityErrors(driver.defaultSession);
  }
}

module.exports = InstallabilityErrors;

},{"../../fraggle-rock/gather/base-gatherer.js":60,"lighthouse-logger":188}],"../gather/gatherers/js-usage":[function(require,module,exports){
/**
 * @license Copyright 2017 The Lighthouse Authors. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.
 */
'use strict';

const FRGatherer = require('../../fraggle-rock/gather/base-gatherer.js');

/**
 * @fileoverview Tracks unused JavaScript
 */
class JsUsage extends FRGatherer {
  /** @type {LH.Gatherer.GathererMeta} */
  meta = {
    // TODO(FR-COMPAT): special snapshot case for scriptId -> URL mappings.
    supportedModes: ['timespan', 'navigation'],
  }

  constructor() {
    super();
    /** @type {LH.Crdp.Debugger.ScriptParsedEvent[]} */
    this._scriptParsedEvents = [];
    /** @type {LH.Crdp.Profiler.ScriptCoverage[]} */
    this._scriptUsages = [];
    this.onScriptParsed = this.onScriptParsed.bind(this);
  }

  /**
   * @param {LH.Crdp.Debugger.ScriptParsedEvent} event
   */
  onScriptParsed(event) {
    if (event.embedderName) {
      this._scriptParsedEvents.push(event);
    }
  }

  /**
   * @param {LH.Gatherer.FRTransitionalContext} context
   */
  async startInstrumentation(context) {
    const session = context.driver.defaultSession;
    await session.sendCommand('Profiler.enable');
    await session.sendCommand('Profiler.startPreciseCoverage', {detailed: false});
  }

  /**
   * @param {LH.Gatherer.FRTransitionalContext} context
   */
  async stopInstrumentation(context) {
    const session = context.driver.defaultSession;
    const coverageResponse = await session.sendCommand('Profiler.takePreciseCoverage');
    this._scriptUsages = coverageResponse.result;
    await session.sendCommand('Profiler.stopPreciseCoverage');
    await session.sendCommand('Profiler.disable');
  }

  /**
   * @param {LH.Gatherer.FRTransitionalContext} context
   */
  async startSensitiveInstrumentation(context) {
    const session = context.driver.defaultSession;
    await session.sendCommand('Debugger.enable');
    await session.on('Debugger.scriptParsed', this.onScriptParsed);
  }

  /**
   * @param {LH.Gatherer.FRTransitionalContext} context
   */
  async stopSensitiveInstrumentation(context) {
    const session = context.driver.defaultSession;
    await session.off('Debugger.scriptParsed', this.onScriptParsed);
    await session.sendCommand('Debugger.disable');
  }

  /**
   * @return {Promise<LH.Artifacts['JsUsage']>}
   */
  async getArtifact() {
    /** @type {Record<string, Array<LH.Crdp.Profiler.ScriptCoverage>>} */
    const usageByUrl = {};
    for (const scriptUsage of this._scriptUsages) {
      // `ScriptCoverage.url` can be overridden by a magic sourceURL comment.
      // Get the associated ScriptParsedEvent and use embedderName, which is the original url.
      // See https://chromium-review.googlesource.com/c/v8/v8/+/2317310
      let url = scriptUsage.url;
      const scriptParsedEvent =
        this._scriptParsedEvents.find(e => e.scriptId === scriptUsage.scriptId);
      if (scriptParsedEvent && scriptParsedEvent.embedderName) {
        url = scriptParsedEvent.embedderName;
      }

      // If `url` is blank, that means the script was anonymous (eval, new Function, onload, ...).
      // Or, it's because it was code Lighthouse over the protocol via `Runtime.evaluate`.
      // We currently don't consider coverage of anonymous scripts, and we definitely don't want
      // coverage of code Lighthouse ran to inspect the page, so we ignore this ScriptCoverage if
      // url is blank.
      if (scriptUsage.url === '' || (scriptParsedEvent && scriptParsedEvent.embedderName === '')) {
        continue;
      }

      const scripts = usageByUrl[url] || [];
      scripts.push(scriptUsage);
      usageByUrl[url] = scripts;
    }

    return usageByUrl;
  }
}

module.exports = JsUsage;

},{"../../fraggle-rock/gather/base-gatherer.js":60}],"../gather/gatherers/link-elements":[function(require,module,exports){
/**
 * @license Copyright 2018 The Lighthouse Authors. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.
 */
'use strict';

const LinkHeader = require('http-link-header');
const FRGatherer = require('../../fraggle-rock/gather/base-gatherer.js');
const {URL} = require('../../lib/url-shim.js');
const NetworkRecords = require('../../computed/network-records.js');
const NetworkAnalyzer = require('../../lib/dependency-graph/simulator/network-analyzer.js');
const pageFunctions = require('../../lib/page-functions.js');
const DevtoolsLog = require('./devtools-log.js');

/* globals HTMLLinkElement getNodeDetails */

/**
 * @fileoverview
 * This gatherer collects all the effect `link` elements, both in the page and declared in the
 * headers of the main resource.
 */

/**
 *
 * @param {string} url
 * @param {string} finalUrl
 * @return {string|null}
 */
function normalizeUrlOrNull(url, finalUrl) {
  try {
    return new URL(url, finalUrl).href;
  } catch (_) {
    return null;
  }
}

/**
 * @param {string|undefined} value
 * @return {LH.Artifacts.LinkElement['crossOrigin']}
 */
function getCrossoriginFromHeader(value) {
  if (value === 'anonymous') return 'anonymous';
  if (value === 'use-credentials') return 'use-credentials';
  return null;
}

/**
 * @return {LH.Artifacts['LinkElements']}
 */
/* c8 ignore start */
function getLinkElementsInDOM() {
  /** @type {Array<HTMLOrSVGElement>} */
  // @ts-expect-error - getElementsInDocument put into scope via stringification
  const browserElements = getElementsInDocument('link'); // eslint-disable-line no-undef
  /** @type {LH.Artifacts['LinkElements']} */
  const linkElements = [];

  for (const link of browserElements) {
    // We're only interested in actual LinkElements, not `<link>` tagName elements inside SVGs.
    // https://github.com/GoogleChrome/lighthouse/issues/9764
    if (!(link instanceof HTMLLinkElement)) continue;

    const hrefRaw = link.getAttribute('href') || '';
    const source = link.closest('head') ? 'head' : 'body';

    linkElements.push({
      rel: link.rel,
      href: link.href,
      hreflang: link.hreflang,
      as: link.as,
      crossOrigin: link.crossOrigin,
      hrefRaw,
      source,
      // @ts-expect-error - put into scope via stringification
      node: getNodeDetails(link),
    });
  }

  return linkElements;
}
/* c8 ignore stop */

class LinkElements extends FRGatherer {
  constructor() {
    super();
    /**
     * This needs to be in the constructor.
     * https://github.com/GoogleChrome/lighthouse/issues/12134
     * @type {LH.Gatherer.GathererMeta<'DevtoolsLog'>}
     */
    this.meta = {
      supportedModes: ['timespan', 'navigation'],
      dependencies: {DevtoolsLog: DevtoolsLog.symbol},
    };
  }

  /**
   * @param {LH.Gatherer.FRTransitionalContext} context
   * @return {Promise<LH.Artifacts['LinkElements']>}
   */
  static getLinkElementsInDOM(context) {
    // We'll use evaluateAsync because the `node.getAttribute` method doesn't actually normalize
    // the values like access from JavaScript does.
    return context.driver.executionContext.evaluate(getLinkElementsInDOM, {
      args: [],
      useIsolation: true,
      deps: [
        pageFunctions.getNodeDetailsString,
        pageFunctions.getElementsInDocument,
      ],
    });
  }

  /**
   * @param {LH.Gatherer.FRTransitionalContext} context
   * @param {LH.Artifacts.NetworkRequest[]} networkRecords
   * @return {LH.Artifacts['LinkElements']}
   */
  static getLinkElementsInHeaders(context, networkRecords) {
    const finalUrl = context.url;
    const mainDocument = NetworkAnalyzer.findMainDocument(networkRecords, finalUrl);

    /** @type {LH.Artifacts['LinkElements']} */
    const linkElements = [];

    for (const header of mainDocument.responseHeaders) {
      if (header.name.toLowerCase() !== 'link') continue;

      for (const link of LinkHeader.parse(header.value).refs) {
        linkElements.push({
          rel: link.rel || '',
          href: normalizeUrlOrNull(link.uri, finalUrl),
          hrefRaw: link.uri || '',
          hreflang: link.hreflang || '',
          as: link.as || '',
          crossOrigin: getCrossoriginFromHeader(link.crossorigin),
          source: 'headers',
          node: null,
        });
      }
    }

    return linkElements;
  }

  /**
   * @param {LH.Gatherer.FRTransitionalContext} context
   * @param {LH.Artifacts.NetworkRequest[]} networkRecords
   * @return {Promise<LH.Artifacts['LinkElements']>}
   */
  async _getArtifact(context, networkRecords) {
    const fromDOM = await LinkElements.getLinkElementsInDOM(context);
    const fromHeaders = LinkElements.getLinkElementsInHeaders(context, networkRecords);
    const linkElements = fromDOM.concat(fromHeaders);

    for (const link of linkElements) {
      // Normalize the rel for easy consumption/filtering
      link.rel = link.rel.toLowerCase();
    }

    return linkElements;
  }

  /**
   * @param {LH.Gatherer.PassContext} context
   * @param {LH.Gatherer.LoadData} loadData
   * @return {Promise<LH.Artifacts['LinkElements']>}
   */
  async afterPass(context, loadData) {
    return this._getArtifact({...context, dependencies: {}}, loadData.networkRecords);
  }

  /**
   * @param {LH.Gatherer.FRTransitionalContext<'DevtoolsLog'>} context
   * @return {Promise<LH.Artifacts['LinkElements']>}
   */
  async getArtifact(context) {
    const records = await NetworkRecords.request(context.dependencies.DevtoolsLog, context);
    return this._getArtifact(context, records);
  }
}

module.exports = LinkElements;

},{"../../computed/network-records.js":40,"../../fraggle-rock/gather/base-gatherer.js":60,"../../lib/dependency-graph/simulator/network-analyzer.js":91,"../../lib/page-functions.js":110,"../../lib/url-shim.js":"url","./devtools-log.js":"../gather/gatherers/devtools-log","http-link-header":170}],"../gather/gatherers/main-document-content":[function(require,module,exports){
/**
 * @license Copyright 2019 The Lighthouse Authors. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.
 */
'use strict';

const FRGatherer = require('../../fraggle-rock/gather/base-gatherer.js');
const NetworkAnalyzer = require('../../lib/dependency-graph/simulator/network-analyzer.js');
const NetworkRecords = require('../../computed/network-records.js');
const DevtoolsLog = require('./devtools-log.js');
const {fetchResponseBodyFromCache} = require('../driver/network.js');

/**
 * Collects the content of the main html document.
 */
class MainDocumentContent extends FRGatherer {
  /** @type {LH.Gatherer.GathererMeta<'DevtoolsLog'>} */
  meta = {
    supportedModes: ['navigation'],
    dependencies: {DevtoolsLog: DevtoolsLog.symbol},
  }

  /**
   *
   * @param {LH.Gatherer.FRTransitionalContext} context
   * @param {LH.Artifacts.NetworkRequest[]} networkRecords
   * @return {Promise<LH.Artifacts['MainDocumentContent']>}
   */
  async _getArtifact(context, networkRecords) {
    const mainResource = NetworkAnalyzer.findMainDocument(networkRecords, context.url);
    const session = context.driver.defaultSession;
    return fetchResponseBodyFromCache(session, mainResource.requestId);
  }
  /**
   *
   * @param {LH.Gatherer.FRTransitionalContext<'DevtoolsLog'>} context
   * @return {Promise<LH.Artifacts['MainDocumentContent']>}
   */
  async getArtifact(context) {
    const devtoolsLog = context.dependencies.DevtoolsLog;
    const networkRecords = await NetworkRecords.request(devtoolsLog, context);
    return this._getArtifact(context, networkRecords);
  }

  /**
   * @param {LH.Gatherer.PassContext} passContext
   * @param {LH.Gatherer.LoadData} loadData
   * @return {Promise<LH.Artifacts['MainDocumentContent']>}
   */
  async afterPass(passContext, loadData) {
    return this._getArtifact({...passContext, dependencies: {}}, loadData.networkRecords);
  }
}

module.exports = MainDocumentContent;

},{"../../computed/network-records.js":40,"../../fraggle-rock/gather/base-gatherer.js":60,"../../lib/dependency-graph/simulator/network-analyzer.js":91,"../driver/network.js":70,"./devtools-log.js":"../gather/gatherers/devtools-log"}],"../gather/gatherers/meta-elements":[function(require,module,exports){
/**
 * @license Copyright 2019 The Lighthouse Authors. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.
 */
'use strict';

const FRGatherer = require('../../fraggle-rock/gather/base-gatherer.js');
const pageFunctions = require('../../lib/page-functions.js');

/* globals getElementsInDocument getNodeDetails */

/* c8 ignore start */
function collectMetaElements() {
  const functions = /** @type {typeof pageFunctions} */({
    // @ts-expect-error - getElementsInDocument put into scope via stringification
    getElementsInDocument,
    // @ts-expect-error - getNodeDetails put into scope via stringification
    getNodeDetails,
  });

  const metas = functions.getElementsInDocument('head meta');
  return metas.map(meta => {
    /** @param {string} name */
    const getAttribute = name => {
      const attr = meta.attributes.getNamedItem(name);
      if (!attr) return;
      return attr.value;
    };
    return {
      name: meta.name.toLowerCase(),
      content: meta.content,
      property: getAttribute('property'),
      httpEquiv: meta.httpEquiv ? meta.httpEquiv.toLowerCase() : undefined,
      charset: getAttribute('charset'),
      node: functions.getNodeDetails(meta),
    };
  });
}
/* c8 ignore stop */

class MetaElements extends FRGatherer {
  /** @type {LH.Gatherer.GathererMeta} */
  meta = {
    supportedModes: ['snapshot', 'navigation'],
  }

  /**
   * @param {LH.Gatherer.FRTransitionalContext} passContext
   * @return {Promise<LH.Artifacts['MetaElements']>}
   */
  getArtifact(passContext) {
    const driver = passContext.driver;

    // We'll use evaluateAsync because the `node.getAttribute` method doesn't actually normalize
    // the values like access from JavaScript does.
    return driver.executionContext.evaluate(collectMetaElements, {
      args: [],
      useIsolation: true,
      deps: [
        pageFunctions.getElementsInDocument,
        pageFunctions.getNodeDetailsString,
      ],
    });
  }
}

module.exports = MetaElements;

},{"../../fraggle-rock/gather/base-gatherer.js":60,"../../lib/page-functions.js":110}],"../gather/gatherers/network-user-agent":[function(require,module,exports){
/**
 * @license Copyright 2021 The Lighthouse Authors. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.
 */
'use strict';

const FRGatherer = require('../../fraggle-rock/gather/base-gatherer.js');
const DevtoolsLogGatherer = require('./devtools-log.js');

/** @implements {LH.Gatherer.FRGathererInstance<'DevtoolsLog'>} */
class NetworkUserAgent extends FRGatherer {
  /** @type {LH.Gatherer.GathererMeta<'DevtoolsLog'>} */
  meta = {
    supportedModes: ['timespan', 'navigation'],
    dependencies: {DevtoolsLog: DevtoolsLogGatherer.symbol},
  };

  /**
   * @param {LH.Artifacts['DevtoolsLog']} devtoolsLog
   * @return {string}
   */
  static getNetworkUserAgent(devtoolsLog) {
    for (const entry of devtoolsLog) {
      if (entry.method !== 'Network.requestWillBeSent') continue;
      const userAgent = entry.params.request.headers['User-Agent'];
      if (userAgent) return userAgent;
    }

    return '';
  }

  /**
   * @param {LH.Gatherer.FRTransitionalContext<'DevtoolsLog'>} context
   * @return {Promise<LH.Artifacts['NetworkUserAgent']>}
   */
  async getArtifact(context) {
    return NetworkUserAgent.getNetworkUserAgent(context.dependencies.DevtoolsLog);
  }
}

module.exports = NetworkUserAgent;

},{"../../fraggle-rock/gather/base-gatherer.js":60,"./devtools-log.js":"../gather/gatherers/devtools-log"}],"../gather/gatherers/script-elements":[function(require,module,exports){
/**
 * @license Copyright 2017 The Lighthouse Authors. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.
 */
'use strict';

const FRGatherer = require('../../fraggle-rock/gather/base-gatherer.js');
const NetworkRecords = require('../../computed/network-records.js');
const NetworkAnalyzer = require('../../lib/dependency-graph/simulator/network-analyzer.js');
const NetworkRequest = require('../../lib/network-request.js');
const pageFunctions = require('../../lib/page-functions.js');
const {fetchResponseBodyFromCache} = require('../driver/network.js');
const DevtoolsLog = require('./devtools-log.js');
const HostFormFactor = require('./host-form-factor.js');

/* global getNodeDetails */

/**
 * @return {LH.Artifacts['ScriptElements']}
 */
/* c8 ignore start */
function collectAllScriptElements() {
  /** @type {HTMLScriptElement[]} */
  // @ts-expect-error - getElementsInDocument put into scope via stringification
  const scripts = getElementsInDocument('script'); // eslint-disable-line no-undef

  return scripts.map(script => {
    return {
      type: script.type || null,
      src: script.src || null,
      id: script.id || null,
      async: script.async,
      defer: script.defer,
      source: script.closest('head') ? 'head' : 'body',
      content: script.src ? null : script.text,
      requestId: null,
      // @ts-expect-error - getNodeDetails put into scope via stringification
      node: getNodeDetails(script),
    };
  });
}
/* c8 ignore stop */

/**
 * @template T, U
 * @param {Array<T>} values
 * @param {(value: T) => Promise<U>} promiseMapper
 * @param {boolean} runInSeries
 * @return {Promise<Array<U>>}
 */
async function runInSeriesOrParallel(values, promiseMapper, runInSeries) {
  if (runInSeries) {
    const results = [];
    for (const value of values) {
      const result = await promiseMapper(value);
      results.push(result);
    }
    return results;
  } else {
    const promises = values.map(promiseMapper);
    return await Promise.all(promises);
  }
}

/**
 * @fileoverview Gets JavaScript file contents.
 */
class ScriptElements extends FRGatherer {
  /** @type {LH.Gatherer.GathererMeta<'DevtoolsLog'|'HostFormFactor'>} */
  meta = {
    supportedModes: ['timespan', 'navigation'],
    dependencies: {DevtoolsLog: DevtoolsLog.symbol, HostFormFactor: HostFormFactor.symbol},
  }

  /**
   * @param {LH.Gatherer.FRTransitionalContext} context
   * @param {LH.Artifacts.NetworkRequest[]} networkRecords
   * @param {LH.Artifacts['HostFormFactor']} formFactor
   * @return {Promise<LH.Artifacts['ScriptElements']>}
   */
  async _getArtifact(context, networkRecords, formFactor) {
    const session = context.driver.defaultSession;
    const executionContext = context.driver.executionContext;
    const mainResource = NetworkAnalyzer.findOptionalMainDocument(networkRecords, context.url);

    const scripts = await executionContext.evaluate(collectAllScriptElements, {
      args: [],
      useIsolation: true,
      deps: [
        pageFunctions.getNodeDetailsString,
        pageFunctions.getElementsInDocument,
      ],
    });

    for (const script of scripts) {
      if (mainResource && script.content) script.requestId = mainResource.requestId;
    }

    const scriptRecords = networkRecords
      // Ignore records from OOPIFs
      .filter(record => !record.sessionId)
      // Only get the content of script requests
      .filter(record => record.resourceType === NetworkRequest.TYPES.Script);

    // If run on a mobile device, be sensitive to memory limitations and only request one
    // record at a time.
    const scriptRecordContents = await runInSeriesOrParallel(
      scriptRecords,
      record => fetchResponseBodyFromCache(session, record.requestId).catch(() => ''),
      formFactor === 'mobile' /* runInSeries */
    );

    for (let i = 0; i < scriptRecords.length; i++) {
      const record = scriptRecords[i];
      const content = scriptRecordContents[i];
      if (!content) continue;

      const matchedScriptElement = scripts.find(script => script.src === record.url);
      if (matchedScriptElement) {
        matchedScriptElement.requestId = record.requestId;
        matchedScriptElement.content = content;
      } else {
        scripts.push({
          type: null,
          src: record.url,
          id: null,
          async: false,
          defer: false,
          source: 'network',
          requestId: record.requestId,
          content,
          node: null,
        });
      }
    }
    return scripts;
  }

  /**
   * @param {LH.Gatherer.FRTransitionalContext<'DevtoolsLog'|'HostFormFactor'>} context
   */
  async getArtifact(context) {
    const devtoolsLog = context.dependencies.DevtoolsLog;
    const formFactor = context.dependencies.HostFormFactor;
    const networkRecords = await NetworkRecords.request(devtoolsLog, context);
    return this._getArtifact(context, networkRecords, formFactor);
  }

  /**
   * @param {LH.Gatherer.PassContext} passContext
   * @param {LH.Gatherer.LoadData} loadData
   */
  async afterPass(passContext, loadData) {
    const networkRecords = loadData.networkRecords;
    const formFactor = passContext.baseArtifacts.HostFormFactor;
    return this._getArtifact({...passContext, dependencies: {}}, networkRecords, formFactor);
  }
}

module.exports = ScriptElements;

},{"../../computed/network-records.js":40,"../../fraggle-rock/gather/base-gatherer.js":60,"../../lib/dependency-graph/simulator/network-analyzer.js":91,"../../lib/network-request.js":109,"../../lib/page-functions.js":110,"../driver/network.js":70,"./devtools-log.js":"../gather/gatherers/devtools-log","./host-form-factor.js":"../gather/gatherers/host-form-factor"}],"../gather/gatherers/seo/embedded-content":[function(require,module,exports){
/**
 * @license Copyright 2018 The Lighthouse Authors. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.
 */
'use strict';

/* globals getElementsInDocument getNodeDetails */

const FRGatherer = require('../../../fraggle-rock/gather/base-gatherer.js');
const pageFunctions = require('../../../lib/page-functions.js');

/**
 * @return {LH.Artifacts.EmbeddedContentInfo[]}
 */
function getEmbeddedContent() {
  const functions = /** @type {typeof pageFunctions} */ ({
    // @ts-expect-error - getElementsInDocument put into scope via stringification
    getElementsInDocument,
    // @ts-expect-error - getNodeDetails put into scope via stringification
    getNodeDetails,
  });

  const selector = 'object, embed, applet';
  const elements = functions.getElementsInDocument(selector);
  return elements
    .map(node => ({
      tagName: node.tagName,
      type: node.getAttribute('type'),
      src: node.getAttribute('src'),
      data: node.getAttribute('data'),
      code: node.getAttribute('code'),
      params: Array.from(node.children)
        .filter(el => el.tagName === 'PARAM')
        .map(el => ({
          name: el.getAttribute('name') || '',
          value: el.getAttribute('value') || '',
        })),
      node: functions.getNodeDetails(node),
    }));
}

class EmbeddedContent extends FRGatherer {
  /** @type {LH.Gatherer.GathererMeta} */
  meta = {
    supportedModes: ['snapshot', 'navigation'],
  }

  /**
   * @param {LH.Gatherer.FRTransitionalContext} passContext
   * @return {Promise<LH.Artifacts['EmbeddedContent']>}
   */
  getArtifact(passContext) {
    return passContext.driver.executionContext.evaluate(getEmbeddedContent, {
      args: [],
      deps: [
        pageFunctions.getElementsInDocument,
        pageFunctions.getNodeDetailsString,
      ],
    });
  }
}

module.exports = EmbeddedContent;

},{"../../../fraggle-rock/gather/base-gatherer.js":60,"../../../lib/page-functions.js":110}],"../gather/gatherers/seo/font-size":[function(require,module,exports){
/**
 * @license Copyright 2017 The Lighthouse Authors. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.
 */
'use strict';

/**
 * @fileoverview Extracts information about illegible text from the page.
 *
 * In effort to keep this audit's execution time around 1s, maximum number of protocol calls was limited.
 * Firstly, number of visited nodes (text nodes for which font size was checked) is capped.
 * Secondly, number of failing nodes that are analyzed (for which detailed CSS information is extracted) is also limited.
 *
 * The applicable CSS rule is also determined by the code here with some simplifications (namely !important is ignored).
 * This gatherer collects stylesheet metadata by itself, instead of relying on the styles gatherer which is slow (because it parses the stylesheet content).
 */

const FRGatherer = require('../../../fraggle-rock/gather/base-gatherer.js');
const FONT_SIZE_PROPERTY_NAME = 'font-size';
const MINIMAL_LEGIBLE_FONT_SIZE_PX = 12;
// limit number of protocol calls to make sure that gatherer doesn't take more than 1-2s
const MAX_NODES_SOURCE_RULE_FETCHED = 50; // number of nodes to fetch the source font-size rule

/** @typedef {import('../../driver.js')} Driver */
/** @typedef {LH.Artifacts.FontSize['analyzedFailingNodesData'][0]} NodeFontData */
/** @typedef {Map<number, {fontSize: number, textLength: number}>} BackendIdsToFontData */

/**
 * @param {LH.Crdp.CSS.CSSStyle} [style]
 * @return {boolean}
 */
function hasFontSizeDeclaration(style) {
  return !!style && !!style.cssProperties.find(({name}) => name === FONT_SIZE_PROPERTY_NAME);
}

/**
 * Computes the CSS specificity of a given selector, i.e. #id > .class > div
 * LIMITATION: !important is not respected
 *
 * @see https://developer.mozilla.org/en-US/docs/Web/CSS/Specificity
 * @see https://www.smashingmagazine.com/2010/04/css-specificity-and-inheritance/
 *
 * @param {string} selector
 * @return {number}
 */
function computeSelectorSpecificity(selector) {
  const tokens = selector.split(' ');

  let numIDs = 0;
  let numClasses = 0;
  let numTypes = 0;

  for (const token of tokens) {
    const ids = token.match(/\b#[a-z0-9]+/g) || [];
    const classes = token.match(/\b\.[a-z0-9]+/g) || [];
    const types = token.match(/^[a-z]+/) ? [1] : [];
    numIDs += ids.length;
    numClasses += classes.length;
    numTypes += types.length;
  }

  return Math.min(9, numIDs) * 100 + Math.min(9, numClasses) * 10 + Math.min(9, numTypes);
}

/**
 * Finds the most specific directly matched CSS font-size rule from the list.
 *
 * @param {Array<LH.Crdp.CSS.RuleMatch>} matchedCSSRules
 * @param {function(LH.Crdp.CSS.CSSStyle):boolean|string|undefined} isDeclarationOfInterest
 * @return {NodeFontData['cssRule']|undefined}
 */
function findMostSpecificMatchedCSSRule(matchedCSSRules = [], isDeclarationOfInterest) {
  let maxSpecificity = -Infinity;
  /** @type {LH.Crdp.CSS.CSSRule|undefined} */
  let maxSpecificityRule;

  for (const {rule, matchingSelectors} of matchedCSSRules) {
    if (isDeclarationOfInterest(rule.style)) {
      const specificities = matchingSelectors.map(idx =>
        computeSelectorSpecificity(rule.selectorList.selectors[idx].text)
      );
      const specificity = Math.max(...specificities);
      // Use greater OR EQUAL so that the last rule wins in the event of a tie
      if (specificity >= maxSpecificity) {
        maxSpecificity = specificity;
        maxSpecificityRule = rule;
      }
    }
  }

  if (maxSpecificityRule) {
    return {
      type: 'Regular',
      ...maxSpecificityRule.style,
      parentRule: {
        origin: maxSpecificityRule.origin,
        selectors: maxSpecificityRule.selectorList.selectors,
      },
    };
  }
}

/**
 * Finds the most specific directly matched CSS font-size rule from the list.
 *
 * @param {Array<LH.Crdp.CSS.InheritedStyleEntry>} [inheritedEntries]
 * @return {NodeFontData['cssRule']|undefined}
 */
function findInheritedCSSRule(inheritedEntries = []) {
  // The inherited array contains the array of matched rules for all parents in ascending tree order.
  // i.e. for an element whose path is `html > body > #main > #nav > p`
  // `inherited` will be an array of styles like `[#nav, #main, body, html]`
  // The closest parent with font-size will win
  for (const {inlineStyle, matchedCSSRules} of inheritedEntries) {
    if (hasFontSizeDeclaration(inlineStyle)) return {type: 'Inline', ...inlineStyle};

    const directRule = findMostSpecificMatchedCSSRule(matchedCSSRules, hasFontSizeDeclaration);
    if (directRule) return directRule;
  }
}

/**
 * Returns the governing/winning CSS font-size rule for the set of styles given.
 * This is roughly a stripped down version of the CSSMatchedStyle class in DevTools.
 *
 * @see https://cs.chromium.org/chromium/src/third_party/blink/renderer/devtools/front_end/sdk/CSSMatchedStyles.js?q=CSSMatchedStyles+f:devtools+-f:out&sq=package:chromium&dr=C&l=59-134
 * @param {LH.Crdp.CSS.GetMatchedStylesForNodeResponse} matched CSS rules
 * @return {NodeFontData['cssRule']|undefined}
 */
function getEffectiveFontRule({attributesStyle, inlineStyle, matchedCSSRules, inherited}) {
  // Inline styles have highest priority
  if (hasFontSizeDeclaration(inlineStyle)) return {type: 'Inline', ...inlineStyle};

  // Rules directly referencing the node come next
  const matchedRule = findMostSpecificMatchedCSSRule(matchedCSSRules, hasFontSizeDeclaration);
  if (matchedRule) return matchedRule;

  // Then comes attributes styles (<font size="1">)
  if (hasFontSizeDeclaration(attributesStyle)) return {type: 'Attributes', ...attributesStyle};

  // Finally, find an inherited property if there is one
  const inheritedRule = findInheritedCSSRule(inherited);
  if (inheritedRule) return inheritedRule;

  return undefined;
}

/**
 * @param {string} text
 * @return {number}
 */
function getTextLength(text) {
  // Array.from to count symbols not unicode code points. See: #6973
  return !text ? 0 : Array.from(text.trim()).length;
}

/**
 * @param {LH.Gatherer.FRProtocolSession} session
 * @param {number} nodeId text node
 * @return {Promise<NodeFontData['cssRule']|undefined>}
 */
async function fetchSourceRule(session, nodeId) {
  const matchedRules = await session.sendCommand('CSS.getMatchedStylesForNode', {
    nodeId,
  });
  const sourceRule = getEffectiveFontRule(matchedRules);
  if (!sourceRule) return undefined;

  return {
    type: sourceRule.type,
    range: sourceRule.range,
    styleSheetId: sourceRule.styleSheetId,
    parentRule: sourceRule.parentRule && {
      origin: sourceRule.parentRule.origin,
      selectors: sourceRule.parentRule.selectors,
    },
  };
}

class FontSize extends FRGatherer {
  /** @type {LH.Gatherer.GathererMeta} */
  meta = {
    supportedModes: ['snapshot', 'navigation'],
  }

  /**
   * @param {LH.Gatherer.FRProtocolSession} session
   * @param {Array<NodeFontData>} failingNodes
   */
  static async fetchFailingNodeSourceRules(session, failingNodes) {
    const nodesToAnalyze = failingNodes
      .sort((a, b) => b.textLength - a.textLength)
      .slice(0, MAX_NODES_SOURCE_RULE_FETCHED);

    // DOM.getDocument is necessary for pushNodesByBackendIdsToFrontend to properly retrieve nodeIds if the `DOM` domain was enabled before this gatherer, invoke it to be safe.
    await session.sendCommand('DOM.getDocument', {depth: -1, pierce: true});

    const {nodeIds} = await session.sendCommand('DOM.pushNodesByBackendIdsToFrontend', {
      backendNodeIds: nodesToAnalyze.map(node => node.parentNode.backendNodeId),
    });

    const analysisPromises = nodesToAnalyze
      .map(async (failingNode, i) => {
        failingNode.nodeId = nodeIds[i];
        try {
          const cssRule = await fetchSourceRule(session, nodeIds[i]);
          failingNode.cssRule = cssRule;
        } catch (err) {
          // The node was deleted. We don't need to distinguish between lack-of-rule
          // due to a deleted node vs due to failed attribution, so just set to undefined.
          failingNode.cssRule = undefined;
        }
        return failingNode;
      });

    const analyzedFailingNodesData = await Promise.all(analysisPromises);

    const analyzedFailingTextLength = analyzedFailingNodesData.reduce(
      (sum, {textLength}) => (sum += textLength),
      0
    );

    return {analyzedFailingNodesData, analyzedFailingTextLength};
  }

  /**
   * Returns the TextNodes in a DOM Snapshot.
   * Every entry is associated with a TextNode in the layout tree (not display: none).
   * @param {LH.Crdp.DOMSnapshot.CaptureSnapshotResponse} snapshot
   */
  getTextNodesInLayoutFromSnapshot(snapshot) {
    const strings = snapshot.strings;
    /** @param {number} index */
    const getString = (index) => strings[index];
    /** @param {number} index */
    const getFloat = (index) => parseFloat(strings[index]);

    const textNodesData = [];
    for (let j = 0; j < snapshot.documents.length; j++) {
      // `doc` is a flattened property list describing all the Nodes in a document, with all string
      // values deduped in the `strings` array.
      const doc = snapshot.documents[j];

      if (!doc.nodes.backendNodeId || !doc.nodes.parentIndex ||
          !doc.nodes.attributes || !doc.nodes.nodeName) {
        throw new Error('Unexpected response from DOMSnapshot.captureSnapshot.');
      }
      const nodes = /** @type {Required<typeof doc['nodes']>} */ (doc.nodes);

      /** @param {number} parentIndex */
      const getParentData = (parentIndex) => ({
        backendNodeId: nodes.backendNodeId[parentIndex],
        attributes: nodes.attributes[parentIndex].map(getString),
        nodeName: getString(nodes.nodeName[parentIndex]),
      });

      for (const layoutIndex of doc.textBoxes.layoutIndex) {
        const text = strings[doc.layout.text[layoutIndex]];
        if (!text) continue;

        const nodeIndex = doc.layout.nodeIndex[layoutIndex];
        const styles = doc.layout.styles[layoutIndex];
        const [fontSizeStringId] = styles;
        const fontSize = getFloat(fontSizeStringId);

        const parentIndex = nodes.parentIndex[nodeIndex];
        const grandParentIndex = nodes.parentIndex[parentIndex];
        const parentNode = getParentData(parentIndex);
        const grandParentNode =
          grandParentIndex !== undefined ? getParentData(grandParentIndex) : undefined;

        textNodesData.push({
          nodeIndex,
          backendNodeId: nodes.backendNodeId[nodeIndex],
          fontSize,
          textLength: getTextLength(text),
          parentNode: {
            ...parentNode,
            parentNode: grandParentNode,
          },
        });
      }
    }

    return textNodesData;
  }

  /**
   * Get all the failing text nodes that don't meet the legible text threshold.
   * @param {LH.Crdp.DOMSnapshot.CaptureSnapshotResponse} snapshot
   */
  findFailingNodes(snapshot) {
    /** @type {NodeFontData[]} */
    const failingNodes = [];
    let totalTextLength = 0;
    let failingTextLength = 0;

    for (const textNodeData of this.getTextNodesInLayoutFromSnapshot(snapshot)) {
      totalTextLength += textNodeData.textLength;
      if (textNodeData.fontSize < MINIMAL_LEGIBLE_FONT_SIZE_PX) {
        // Once a bad TextNode is identified, its parent Node is needed.
        failingTextLength += textNodeData.textLength;
        failingNodes.push({
          nodeId: 0, // Set later in fetchFailingNodeSourceRules.
          parentNode: textNodeData.parentNode,
          textLength: textNodeData.textLength,
          fontSize: textNodeData.fontSize,
        });
      }
    }

    return {totalTextLength, failingTextLength, failingNodes};
  }

  /**
   * @param {LH.Gatherer.FRTransitionalContext} passContext
   * @return {Promise<LH.Artifacts.FontSize>} font-size analysis
   */
  async getArtifact(passContext) {
    const session = passContext.driver.defaultSession;

    /** @type {Map<string, LH.Crdp.CSS.CSSStyleSheetHeader>} */
    const stylesheets = new Map();
    /** @param {LH.Crdp.CSS.StyleSheetAddedEvent} sheet */
    const onStylesheetAdded = sheet => stylesheets.set(sheet.header.styleSheetId, sheet.header);
    session.on('CSS.styleSheetAdded', onStylesheetAdded);

    await Promise.all([
      session.sendCommand('DOMSnapshot.enable'),
      session.sendCommand('DOM.enable'),
      session.sendCommand('CSS.enable'),
    ]);

    // Get the computed font-size style of every node.
    const snapshot = await session.sendCommand('DOMSnapshot.captureSnapshot', {
      computedStyles: ['font-size'],
    });

    const {
      totalTextLength,
      failingTextLength,
      failingNodes,
    } = this.findFailingNodes(snapshot);
    const {
      analyzedFailingNodesData,
      analyzedFailingTextLength,
    } = await FontSize.fetchFailingNodeSourceRules(session, failingNodes);

    session.off('CSS.styleSheetAdded', onStylesheetAdded);

    // For the nodes whose computed style we could attribute to a stylesheet, assign
    // the stylsheet to the data.
    analyzedFailingNodesData
      .filter(data => data.cssRule && data.cssRule.styleSheetId)
      // @ts-expect-error - guaranteed to exist from the filter immediately above
      .forEach(data => (data.cssRule.stylesheet = stylesheets.get(data.cssRule.styleSheetId)));

    await Promise.all([
      session.sendCommand('DOMSnapshot.disable'),
      session.sendCommand('DOM.disable'),
      session.sendCommand('CSS.disable'),
    ]);

    return {
      analyzedFailingNodesData,
      analyzedFailingTextLength,
      failingTextLength,
      totalTextLength,
    };
  }
}

module.exports = FontSize;
module.exports.computeSelectorSpecificity = computeSelectorSpecificity;
module.exports.getEffectiveFontRule = getEffectiveFontRule;
module.exports.findMostSpecificMatchedCSSRule = findMostSpecificMatchedCSSRule;

},{"../../../fraggle-rock/gather/base-gatherer.js":60}],"../gather/gatherers/seo/robots-txt":[function(require,module,exports){
/**
 * @license Copyright 2018 The Lighthouse Authors. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.
 */
'use strict';

const FRGatherer = require('../../../fraggle-rock/gather/base-gatherer.js');
const {getBrowserVersion} = require('../../driver/environment.js');

/* global fetch, location */

/** @return {Promise<LH.Artifacts['RobotsTxt']>} */
/* c8 ignore start */
async function getRobotsTxtContent() {
  try {
    const response = await fetch(new URL('/robots.txt', location.href).href);
    if (!response.ok) {
      return {status: response.status, content: null};
    }

    const content = await response.text();
    return {status: response.status, content};
  } catch (_) {
    return {status: null, content: null};
  }
}
/* c8 ignore stop */

class RobotsTxt extends FRGatherer {
  /** @type {LH.Gatherer.GathererMeta} */
  meta = {
    supportedModes: ['snapshot', 'navigation'],
  }

  /**
   * @param {LH.Gatherer.FRTransitionalContext} passContext
   * @return {Promise<LH.Artifacts['RobotsTxt']>}
   */
  async getArtifact(passContext) {
    const {milestone} = await getBrowserVersion(passContext.driver.defaultSession);

    // TODO: Remove when 92 hits stable.
    // Iframe fetcher still has issues with CSPs.
    // Only use the fetcher if we are fetching over the CDP.
    if (milestone < 92) {
      return passContext.driver.executionContext.evaluate(getRobotsTxtContent, {
        args: [],
        useIsolation: true,
      });
    }

    const robotsUrl = new URL('/robots.txt', passContext.url).href;
    await passContext.driver.fetcher.enable();
    return passContext.driver.fetcher.fetchResource(robotsUrl)
      .catch(() => ({status: null, content: null}));
  }
}

module.exports = RobotsTxt;

},{"../../../fraggle-rock/gather/base-gatherer.js":60,"../../driver/environment.js":66}],"../gather/gatherers/seo/tap-targets":[function(require,module,exports){
/**
 * @license Copyright 2018 The Lighthouse Authors. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.
 */
'use strict';

/* global document, window, getComputedStyle, getElementsInDocument, Node, getNodeDetails, getRectCenterPoint */

const FRGatherer = require('../../../fraggle-rock/gather/base-gatherer.js');
const pageFunctions = require('../../../lib/page-functions.js');
const RectHelpers = require('../../../lib/rect-helpers.js');

const TARGET_SELECTORS = [
  'button',
  'a',
  'input',
  'textarea',
  'select',
  'option',
  '[role=button]',
  '[role=checkbox]',
  '[role=link]',
  '[role=menuitem]',
  '[role=menuitemcheckbox]',
  '[role=menuitemradio]',
  '[role=option]',
  '[role=scrollbar]',
  '[role=slider]',
  '[role=spinbutton]',
];
const tapTargetsSelector = TARGET_SELECTORS.join(',');

/**
 * @param {HTMLElement} element
 * @return {boolean}
 */
/* c8 ignore start */
function elementIsVisible(element) {
  return !!(element.offsetWidth || element.offsetHeight || element.getClientRects().length);
}
/* c8 ignore stop */

/**
 * @param {Element} element
 * @return {LH.Artifacts.Rect[]}
 */
/* c8 ignore start */
function getClientRects(element) {
  const clientRects = Array.from(
    element.getClientRects()
  ).map(clientRect => {
    // Contents of DOMRect get lost when returned from Runtime.evaluate call,
    // so we convert them to plain objects.
    const {width, height, left, top, right, bottom} = clientRect;
    return {width, height, left, top, right, bottom};
  });

  for (const child of element.children) {
    clientRects.push(...getClientRects(child));
  }

  return clientRects;
}
/* c8 ignore stop */

/**
 * @param {Element} element
 * @param {string} tapTargetsSelector
 * @return {boolean}
 */
/* c8 ignore start */
function elementHasAncestorTapTarget(element, tapTargetsSelector) {
  if (!element.parentElement) {
    return false;
  }
  if (element.parentElement.matches(tapTargetsSelector)) {
    return true;
  }
  return elementHasAncestorTapTarget(element.parentElement, tapTargetsSelector);
}
/* c8 ignore stop */

/**
 * @param {Element} element
 */
/* c8 ignore start */
function hasTextNodeSiblingsFormingTextBlock(element) {
  if (!element.parentElement) {
    return false;
  }

  const parentElement = element.parentElement;

  const nodeText = element.textContent || '';
  const parentText = parentElement.textContent || '';
  if (parentText.length - nodeText.length < 5) {
    // Parent text mostly consists of this node, so the parent
    // is not a text block container
    return false;
  }

  for (const sibling of element.parentElement.childNodes) {
    if (sibling === element) {
      continue;
    }
    const siblingTextContent = (sibling.textContent || '').trim();
    // Only count text in text nodes so that a series of e.g. buttons isn't counted
    // as a text block.
    // This works reasonably well, but means we miss text blocks where all text is e.g.
    // wrapped in spans
    if (sibling.nodeType === Node.TEXT_NODE && siblingTextContent.length > 0) {
      return true;
    }
  }

  return false;
}
/* c8 ignore stop */

/**
 * Check if element is in a block of text, such as paragraph with a bunch of links in it.
 * Makes a reasonable guess, but for example gets it wrong if the element is surrounded by other
 * HTML elements instead of direct text nodes.
 * @param {Element} element
 * @return {boolean}
 */
/* c8 ignore start */
function elementIsInTextBlock(element) {
  const {display} = getComputedStyle(element);
  if (display !== 'inline' && display !== 'inline-block') {
    return false;
  }

  if (hasTextNodeSiblingsFormingTextBlock(element)) {
    return true;
  } else if (element.parentElement) {
    return elementIsInTextBlock(element.parentElement);
  } else {
    return false;
  }
}
/* c8 ignore stop */

/**
 * @param {Element} el
 * @param {{x: number, y: number}} elCenterPoint
 */
/* c8 ignore start */
function elementCenterIsAtZAxisTop(el, elCenterPoint) {
  const viewportHeight = window.innerHeight;
  const targetScrollY = Math.floor(elCenterPoint.y / viewportHeight) * viewportHeight;
  if (window.scrollY !== targetScrollY) {
    window.scrollTo(0, targetScrollY);
  }

  const topEl = document.elementFromPoint(
    elCenterPoint.x,
    elCenterPoint.y - window.scrollY
  );

  return topEl === el || el.contains(topEl);
}
/* c8 ignore stop */

/**
 * Finds all position sticky/absolute elements on the page and adds a class
 * that disables pointer events on them.
 * @param {string} className
 * @return {() => void} - undo function to re-enable pointer events
 */
/* c8 ignore start */
function disableFixedAndStickyElementPointerEvents(className) {
  document.querySelectorAll('*').forEach(el => {
    const position = getComputedStyle(el).position;
    if (position === 'fixed' || position === 'sticky') {
      el.classList.add(className);
    }
  });

  return function undo() {
    Array.from(document.getElementsByClassName(className)).forEach(el => {
      el.classList.remove(className);
    });
  };
}
/* c8 ignore stop */

/**
 * @param {string} tapTargetsSelector
 * @param {string} className
 * @return {LH.Artifacts.TapTarget[]}
 */
/* c8 ignore start */
function gatherTapTargets(tapTargetsSelector, className) {
  /** @type {LH.Artifacts.TapTarget[]} */
  const targets = [];

  // Capture element positions relative to the top of the page
  window.scrollTo(0, 0);

  /** @type {HTMLElement[]} */
  // @ts-expect-error - getElementsInDocument put into scope via stringification
  const tapTargetElements = getElementsInDocument(tapTargetsSelector);

  /** @type {{
    tapTargetElement: Element,
    clientRects: ClientRect[]
  }[]} */
  const tapTargetsWithClientRects = [];
  tapTargetElements.forEach(tapTargetElement => {
    // Filter out tap targets that are likely to cause false failures:
    if (elementHasAncestorTapTarget(tapTargetElement, tapTargetsSelector)) {
      // This is usually intentional, either the tap targets trigger the same action
      // or there's a child with a related action (like a delete button for an item)
      return;
    }
    if (elementIsInTextBlock(tapTargetElement)) {
      // Links inside text blocks cause a lot of failures, and there's also an exception for them
      // in the Web Content Accessibility Guidelines https://www.w3.org/TR/WCAG21/#target-size
      return;
    }
    if (!elementIsVisible(tapTargetElement)) {
      return;
    }

    tapTargetsWithClientRects.push({
      tapTargetElement,
      clientRects: getClientRects(tapTargetElement),
    });
  });

  // Disable pointer events so that tap targets below them don't get
  // detected as non-tappable (they are tappable, just not while the viewport
  // is at the current scroll position)
  const reenableFixedAndStickyElementPointerEvents =
    disableFixedAndStickyElementPointerEvents(className);

  /** @type {{
    tapTargetElement: Element,
    visibleClientRects: ClientRect[]
  }[]} */
  const tapTargetsWithVisibleClientRects = [];
  // We use separate loop here to get visible client rects because that involves
  // scrolling around the page for elementCenterIsAtZAxisTop, which would affect the
  // client rect positions.
  tapTargetsWithClientRects.forEach(({tapTargetElement, clientRects}) => {
    // Filter out empty client rects
    let visibleClientRects = clientRects.filter(cr => cr.width !== 0 && cr.height !== 0);

    // Filter out client rects that are invisible, e.g because they are in a position absolute element
    // with a lower z-index than the main content.
    // This will also filter out all position fixed or sticky tap targets elements because we disable pointer
    // events on them before running this. That's the correct behavior because whether a position fixed/stick
    // element overlaps with another tap target depends on the scroll position.
    visibleClientRects = visibleClientRects.filter(rect => {
      // Just checking the center can cause false failures for large partially hidden tap targets,
      // but that should be a rare edge case
      // @ts-expect-error - put into scope via stringification
      const rectCenterPoint = getRectCenterPoint(rect);
      return elementCenterIsAtZAxisTop(tapTargetElement, rectCenterPoint);
    });

    if (visibleClientRects.length > 0) {
      tapTargetsWithVisibleClientRects.push({
        tapTargetElement,
        visibleClientRects,
      });
    }
  });

  for (const {tapTargetElement, visibleClientRects} of tapTargetsWithVisibleClientRects) {
    targets.push({
      clientRects: visibleClientRects,
      href: /** @type {HTMLAnchorElement} */(tapTargetElement)['href'] || '',
      // @ts-expect-error - getNodeDetails put into scope via stringification
      node: getNodeDetails(tapTargetElement),
    });
  }

  reenableFixedAndStickyElementPointerEvents();

  return targets;
}
/* c8 ignore stop */

class TapTargets extends FRGatherer {
  constructor() {
    super();
    /**
     * This needs to be in the constructor.
     * https://github.com/GoogleChrome/lighthouse/issues/12134
     * @type {LH.Gatherer.GathererMeta}
     */
    this.meta = {
      supportedModes: ['snapshot', 'navigation'],
    };
  }

  /**
   * @param {LH.Gatherer.FRProtocolSession} session
   * @param {string} className
   * @return {Promise<string>}
   */
  async addStyleRule(session, className) {
    const frameTreeResponse = await session.sendCommand('Page.getFrameTree');
    const {styleSheetId} = await session.sendCommand('CSS.createStyleSheet', {
      frameId: frameTreeResponse.frameTree.frame.id,
    });
    const ruleText = `.${className} { pointer-events: none !important }`;
    await session.sendCommand('CSS.setStyleSheetText', {
      styleSheetId,
      text: ruleText,
    });
    return styleSheetId;
  }

  /**
   * @param {LH.Gatherer.FRProtocolSession} session
   * @param {string} styleSheetId
   */
  async removeStyleRule(session, styleSheetId) {
    await session.sendCommand('CSS.setStyleSheetText', {
      styleSheetId,
      text: '',
    });
  }

  /**
   * @param {LH.Gatherer.FRTransitionalContext} passContext
   * @return {Promise<LH.Artifacts.TapTarget[]>} All visible tap targets with their positions and sizes
   */
  async getArtifact(passContext) {
    const session = passContext.driver.defaultSession;
    await session.sendCommand('DOM.enable');
    await session.sendCommand('CSS.enable');

    const className = 'lighthouse-disable-pointer-events';
    const styleSheetId = await this.addStyleRule(session, className);

    const tapTargets = await passContext.driver.executionContext.evaluate(gatherTapTargets, {
      args: [tapTargetsSelector, className],
      useIsolation: true,
      deps: [
        pageFunctions.getNodeDetailsString,
        pageFunctions.getElementsInDocument,
        disableFixedAndStickyElementPointerEvents,
        elementIsVisible,
        elementHasAncestorTapTarget,
        elementCenterIsAtZAxisTop,
        getClientRects,
        hasTextNodeSiblingsFormingTextBlock,
        elementIsInTextBlock,
        RectHelpers.getRectCenterPoint,
        pageFunctions.getNodePath,
        pageFunctions.getNodeSelector,
        pageFunctions.getNodeLabel,
      ],
    });

    await this.removeStyleRule(session, styleSheetId);

    await session.sendCommand('CSS.disable');
    await session.sendCommand('DOM.disable');

    return tapTargets;
  }
}

module.exports = TapTargets;

},{"../../../fraggle-rock/gather/base-gatherer.js":60,"../../../lib/page-functions.js":110,"../../../lib/rect-helpers.js":111}],"../gather/gatherers/service-worker":[function(require,module,exports){
/**
 * @license Copyright 2016 The Lighthouse Authors. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.
 */
'use strict';

const FRGatherer = require('../../fraggle-rock/gather/base-gatherer.js');
const serviceWorkers = require('../driver/service-workers.js');

class ServiceWorker extends FRGatherer {
  /** @type {LH.Gatherer.GathererMeta} */
  meta = {
    supportedModes: ['navigation'],
  }

  /**
   * @param {LH.Gatherer.PassContext} passContext
   * @return {Promise<LH.Artifacts['ServiceWorker']>}
   */
  async beforePass(passContext) {
    return this.getArtifact({...passContext, dependencies: {}});
  }

  // This gatherer is run in a separate pass for legacy mode.
  // Legacy compat code is in `beforePass`.
  async afterPass() { }

  /**
   * @param {LH.Gatherer.FRTransitionalContext} context
   * @return {Promise<LH.Artifacts['ServiceWorker']>}
   */
  async getArtifact(context) {
    const session = context.driver.defaultSession;
    const {versions} = await serviceWorkers.getServiceWorkerVersions(session);
    const {registrations} = await serviceWorkers.getServiceWorkerRegistrations(session);

    return {
      versions,
      registrations,
    };
  }
}

module.exports = ServiceWorker;

},{"../../fraggle-rock/gather/base-gatherer.js":60,"../driver/service-workers.js":72}],"../gather/gatherers/source-maps":[function(require,module,exports){
(function (Buffer){(function (){
/**
 * @license Copyright 2019 The Lighthouse Authors. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.
 */
'use strict';

const FRGatherer = require('../../fraggle-rock/gather/base-gatherer.js');
const URL = require('../../lib/url-shim.js');

/**
 * @fileoverview Gets JavaScript source maps.
 */
class SourceMaps extends FRGatherer {
  /** @type {LH.Gatherer.GathererMeta} */
  meta = {
    supportedModes: ['timespan', 'navigation'],
  }

  constructor() {
    super();
    /** @type {LH.Crdp.Debugger.ScriptParsedEvent[]} */
    this._scriptParsedEvents = [];
    this.onScriptParsed = this.onScriptParsed.bind(this);
  }

  /**
   * @param {LH.Gatherer.FRTransitionalDriver} driver
   * @param {string} sourceMapUrl
   * @return {Promise<LH.Artifacts.RawSourceMap>}
   */
  async fetchSourceMap(driver, sourceMapUrl) {
    const response = await driver.fetcher.fetchResource(sourceMapUrl, {timeout: 1500});
    if (response.content === null) {
      throw new Error(`Failed fetching source map (${response.status})`);
    }
    return JSON.parse(response.content);
  }

  /**
   * @param {string} sourceMapURL
   * @return {LH.Artifacts.RawSourceMap}
   */
  parseSourceMapFromDataUrl(sourceMapURL) {
    const buffer = Buffer.from(sourceMapURL.split(',')[1], 'base64');
    return JSON.parse(buffer.toString());
  }

  /**
   * @param {LH.Crdp.Debugger.ScriptParsedEvent} event
   */
  onScriptParsed(event) {
    if (event.sourceMapURL) {
      this._scriptParsedEvents.push(event);
    }
  }

  /**
   * @param {string} url
   * @param {string} base
   * @return {string|undefined}
   */
  _resolveUrl(url, base) {
    try {
      return new URL(url, base).href;
    } catch (e) {
      return;
    }
  }

  /**
   * @param {LH.Gatherer.FRTransitionalDriver} driver
   * @param {LH.Crdp.Debugger.ScriptParsedEvent} event
   * @return {Promise<LH.Artifacts.SourceMap>}
   */
  async _retrieveMapFromScriptParsedEvent(driver, event) {
    if (!event.sourceMapURL) {
      throw new Error('precondition failed: event.sourceMapURL should exist');
    }

    // `sourceMapURL` is simply the URL found in either a magic comment or an x-sourcemap header.
    // It has not been resolved to a base url.
    const isSourceMapADataUri = event.sourceMapURL.startsWith('data:');
    const scriptUrl = event.url;
    const rawSourceMapUrl = isSourceMapADataUri ?
        event.sourceMapURL :
        this._resolveUrl(event.sourceMapURL, event.url);

    if (!rawSourceMapUrl) {
      return {
        scriptUrl,
        errorMessage: `Could not resolve map url: ${event.sourceMapURL}`,
      };
    }

    // sourceMapUrl isn't included in the the artifact if it was a data URL.
    const sourceMapUrl = isSourceMapADataUri ? undefined : rawSourceMapUrl;

    try {
      const map = isSourceMapADataUri ?
          this.parseSourceMapFromDataUrl(rawSourceMapUrl) :
          await this.fetchSourceMap(driver, rawSourceMapUrl);
      if (map.sections) {
        map.sections = map.sections.filter(section => section.map);
      }
      return {
        scriptUrl,
        sourceMapUrl,
        map,
      };
    } catch (err) {
      return {
        scriptUrl,
        sourceMapUrl,
        errorMessage: err.toString(),
      };
    }
  }

  /**
   * @param {LH.Gatherer.FRTransitionalContext} context
   */
  async startSensitiveInstrumentation(context) {
    const session = context.driver.defaultSession;
    session.on('Debugger.scriptParsed', this.onScriptParsed);
    await session.sendCommand('Debugger.enable');
  }

  /**
   * @param {LH.Gatherer.FRTransitionalContext} context
   */
  async stopSensitiveInstrumentation(context) {
    const session = context.driver.defaultSession;
    await session.sendCommand('Debugger.disable');
    session.off('Debugger.scriptParsed', this.onScriptParsed);
  }

  /**
   * @param {LH.Gatherer.FRTransitionalContext} context
   * @return {Promise<LH.Artifacts['SourceMaps']>}
   */
  async getArtifact(context) {
    await context.driver.fetcher.enable();
    const eventProcessPromises = this._scriptParsedEvents
      .map((event) => this._retrieveMapFromScriptParsedEvent(context.driver, event));
    return Promise.all(eventProcessPromises);
  }
}

module.exports = SourceMaps;

}).call(this)}).call(this,require("buffer").Buffer)
},{"../../fraggle-rock/gather/base-gatherer.js":60,"../../lib/url-shim.js":"url","buffer":145}],"../gather/gatherers/stacks":[function(require,module,exports){
/**
 * @license Copyright 2019 The Lighthouse Authors. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.
 */
'use strict';

/**
 * @fileoverview Gathers a list of detected JS libraries and their versions.
 */

/* global window */
/* global d41d8cd98f00b204e9800998ecf8427e_LibraryDetectorTests */


const log = require('lighthouse-logger');
const FRGatherer = require('../../fraggle-rock/gather/base-gatherer.js');
const libDetectorSource = "function _createTimeoutHelper() {\n    let timeout;\n    const timeoutPromise = new Promise((_, reject) => {\n        timeout = setTimeout(() => reject(new Error('Timed out')), 5000);\n    });\n\n    return {timeoutPromise, clearTimeout: () => clearTimeout(timeout)};\n}\n\nvar UNKNOWN_VERSION = null;\nvar d41d8cd98f00b204e9800998ecf8427e_LibraryDetectorTests = {\n\n    'GWT': {\n        id: 'gwt',\n        icon: 'gwt',\n        url: 'http://www.gwtproject.org/',\n        test: function(win) {\n            // pretty complicated, many possible tell tales\n            var doc = win.document,\n                hasHistFrame = doc.getElementById('__gwt_historyFrame'),\n                hasGwtUid = doc.gwt_uid,\n                hasBodyListener = doc.body.__listener,\n                hasBodyEventBits = doc.body.__eventBits,\n                hasModules = win.__gwt_activeModules,\n                hasJsonP = win.__gwt_jsonp__,\n                hasRootWinApp = win.__gwt_scriptsLoaded || win.__gwt_stylesLoaded || win.__gwt_activeModules;\n\n            // use the many possible indicators\n            if(hasHistFrame || hasGwtUid || hasBodyListener || hasBodyEventBits || hasModules || hasJsonP || hasRootWinApp) {\n\n                // carefully look at frames, but only if certain is GWT frame\n                var frames = doc.getElementsByTagName('iframe'),\n                    gwtVersion = UNKNOWN_VERSION;\n                for(var n=0; n<frames.length; n++) {\n                    // catch security access errors\n                    try {\n                        var hasNegativeTabIndex = frames[n].tabIndex < 0; // on for GWT\n                        if(hasNegativeTabIndex && frames[n].contentWindow && frames[n].contentWindow.$gwt_version) {\n                            gwtVersion = frames[n].contentWindow.$gwt_version;\n                            break;\n                        }\n                    }\n                    catch(e) {}\n                }\n\n                if(gwtVersion=='0.0.999') {\n                  gwtVersion = 'Google Internal';\n                }\n\n                return { version: gwtVersion };\n            }\n            return false;\n        }\n    },\n\n    'Ink': {\n        id: 'ink',\n        icon: 'ink',\n        url: 'http://ink.sapo.pt/',\n        test: function(win) {\n            if (win.Ink && win.Ink.createModule) {\n                return { version: UNKNOWN_VERSION };\n            }\n            return false;\n        }\n    },\n\n    'Vaadin': {\n        id: 'vaadin',\n        icon: 'vaadin',\n        url: 'https://vaadin.com/',\n        test: function(win) {\n            if (win.vaadin && win.vaadin.registerWidgetset) {\n                return { version: UNKNOWN_VERSION };\n            }\n            return false;\n        }\n    },\n\n    'Bootstrap': {\n        id: 'bootstrap',\n        icon: 'bootstrap',\n        url: 'http://getbootstrap.com/',\n        npm: 'bootstrap',\n        // look for a function Boostrap has added to jQuery - regex for BS 2 & 3\n        test: function(win) {\n            var jQueryAvailable = win.$ && win.$.fn,\n                RE_PREFIX_V2 = '\\\\$this\\\\.data\\\\((?:\\'|\")',\n                RE_PREFIX_V3 = '\\\\$this\\\\.data\\\\((?:\\'|\")(?:bs\\\\.){1}',\n                bootstrapComponents = [\n                    'affix', 'alert', 'button', 'carousel', 'collapse', 'dropdown',\n                    'modal', 'popover', 'scrollspy', 'tab', 'tooltip'\n                ];\n\n            if(jQueryAvailable) {\n                var bootstrapVersion;\n\n                bootstrapComponents.some(function(component) {\n                    if(win.$.fn[component]) {\n                        // Bootstrap >= 3.2.0 detection\n                        if(win.$.fn[component].Constructor && win.$.fn[component].Constructor.VERSION) {\n                            bootstrapVersion = win.$.fn[component].Constructor.VERSION;\n                            return true;\n                        // Bootstrap >= 2.0.0 and <= 3.1.0 detection\n                        } else if(new RegExp(RE_PREFIX_V3 + component).test(win.$.fn[component].toString())) {\n                            bootstrapVersion = '>= 3.0.0 & <= 3.1.1';\n                            return true;\n                        // Bootstrap < 3.1.0 detection\n                        } else if(new RegExp(RE_PREFIX_V2 + component).test(win.$.fn[component].toString())) {\n                            bootstrapVersion = '>= 2.0.0 & <= 2.3.2';\n                            return true;\n                        }\n                    }\n\n                    return false;\n                });\n\n                if (bootstrapVersion) {\n                    return { version: bootstrapVersion };\n                }\n            }\n\n            return false;\n        }\n    },\n\n    'Zurb': {\n        id: 'zurb',\n        icon: 'zurb',\n        url: 'https://foundation.zurb.com/',\n        npm: 'foundation-sites',\n        test: function(win) {\n            if(win.Foundation && win.Foundation.Toggler) {\n                return { version: win.Foundation.version || UNKNOWN_VERSION };\n            }\n            return false;\n        }\n    },\n\n    'Polymer': {\n        id: 'polymer',\n        icon: 'polymer',\n        url: 'https://www.polymer-project.org/',\n        npm: '@polymer/polymer',\n        test: function(win) {\n            if(win.Polymer && win.Polymer.dom) {\n                return { version: win.Polymer.version || UNKNOWN_VERSION };\n            }\n            return false;\n        }\n    },\n\n    'LitElement': {\n        id: 'litelement',\n        icon: 'polymer',\n        url: 'https://lit-element.polymer-project.org/',\n        npm: 'lit-element',\n        test: function(win) {\n            if(win.litElementVersions && win.litElementVersions.length) {\n                // Get latest version if multiple versions are used\n                var versions = [...win.litElementVersions].sort( (a, b) => a.localeCompare(b, undefined, { numeric:true }) );\n                return { version: versions[versions.length - 1] };\n            }\n            return false;\n        }\n    },\n\n    'Highcharts': {\n        id: 'highcharts',\n        icon: 'highcharts',\n        url: 'http://www.highcharts.com',\n        npm: 'highcharts',\n        test: function(win) {\n            if(win.Highcharts && win.Highcharts.Point) {\n                return { version: win.Highcharts.version || UNKNOWN_VERSION };\n            }\n            return false;\n        }\n    },\n\n    'InfoVis': {\n        id: 'jit',\n        icon: 'jit',\n        url: 'http://philogb.github.com/jit/',\n        test: function test(win) {\n            if(win.$jit && win.$jit.PieChart) {\n                return { version: win.$jit.version || UNKNOWN_VERSION };\n            }\n            return false;\n        }\n    },\n\n    'FlotCharts': {\n        id: 'flotcharts',\n        icon: 'flotcharts',\n        url: 'http://www.flotcharts.org/',\n        npm: 'flot',\n        test: function(win) {\n            if(win.$ && win.$.plot) {\n                return { version: win.$.plot.version || UNKNOWN_VERSION};\n            }\n            return false;\n        }\n    },\n\n    'CreateJS': {\n        id: 'createjs',\n        icon: 'createjs',\n        url: 'https://createjs.com/',\n        npm: 'createjs',\n        test: function(win) {\n            if(win.createjs && win.createjs.promote) {\n                return { version: UNKNOWN_VERSION}; // no version info available\n            }\n            return false;\n        }\n    },\n\n    'Google Maps': {\n        id: 'gmaps',\n        icon: 'gmaps',\n        url: 'https://developers.google.com/maps/',\n        test: function(win) {\n            if (win.google && win.google.maps) {\n                return { version: win.google.maps.version || UNKNOWN_VERSION };\n            }\n            return false;\n        }\n    },\n\n    'jQuery': {\n        id: 'jquery',\n        icon: 'jquery',\n        url: 'http://jquery.com',\n        npm: 'jquery',\n        test: function(win) {\n            var jq = win.jQuery || win.$;\n            if (jq && jq.fn && jq.fn.jquery) {\n                return { version: jq.fn.jquery.replace(/[^\\d+\\.+]/g, '') || UNKNOWN_VERSION};\n            }\n            return false;\n        }\n    },\n\n    'jQuery (Fast path)': {\n        id: 'jquery-fast',\n        icon: 'jquery',\n        url: 'http://jquery.com',\n        npm: 'jquery',\n        test: function (win) {\n            var jq = win.jQuery || win.$;\n            if (jq && jq.fn) {\n                return { version: UNKNOWN_VERSION };\n            }\n            return false;\n        }\n    },\n\n    'jQuery UI': {\n        id: 'jquery_ui',\n        icon: 'jquery_ui',\n        url: 'http://jqueryui.com',\n        npm: 'jquery-ui',\n        test: function(win) {\n            var jq = win.jQuery || win.$ || win.$jq || win.$j;\n            if(jq && jq.fn && jq.fn.jquery && jq.ui) {\n                var plugins = 'accordion,datepicker,dialog,draggable,droppable,progressbar,resizable,selectable,slider,menu,grid,tabs'.split(','), concat = [];\n                for (var i=0; i < plugins.length; i++) { if(jq.ui[plugins[i]]) concat.push(plugins[i].substr(0,1).toUpperCase() + plugins[i].substr(1)); }\n                return { version: jq.ui.version || UNKNOWN_VERSION, details: concat.length ? 'Plugins used: '+concat.join(',') : '' };\n            }\n            return false;\n        }\n    },\n\n    'Dojo': {\n        id: 'dojo',\n        icon: 'dojo',\n        url: 'http://dojotoolkit.org',\n        npm: 'dojo',\n        test: function(win) {\n            if(win.dojo && win.dojo.delegate) {\n                var version = win.dojo.version ? win.dojo.version.toString() : UNKNOWN_VERSION;\n                return { version: version, details: 'Details: '+(win.dijit ? 'Uses Dijit' : 'none') };\n            }\n            return false;\n        }\n    },\n\n    'Prototype': {\n        id: 'prototype',\n        icon: 'prototype',\n        url: 'http://prototypejs.org',\n        test: function(win) {\n            if(win.Prototype && win.Prototype.BrowserFeatures) {\n                return { version: win.Prototype.Version || UNKNOWN_VERSION };\n            }\n            return false;\n        }\n    },\n\n    'Scriptaculous': {\n        id: 'scriptaculous',\n        icon: 'scriptaculous',\n        url: 'http://script.aculo.us',\n        test: function(win) {\n            if(win.Scriptaculous && win.Scriptaculous.load) {\n                return { version: win.Scriptaculous.Version || UNKNOWN_VERSION };\n            }\n            return false;\n        }\n    },\n\n    'MooTools': {\n        id: 'mootools',\n        icon: 'mootools',\n        url: 'https://mootools.net/',\n        test: function(win) {\n            if(win.MooTools && win.MooTools.build) {\n                return { version: win.MooTools.version || UNKNOWN_VERSION };\n            }\n            return false;\n        }\n    },\n\n    'Spry': {\n        id: 'spry',\n        icon: 'spry',\n        url: 'http://labs.adobe.com/technologies/spry',\n        test: function(win) {\n            if (win.Spry && win.Spry.Data) {\n                return { version: UNKNOWN_VERSION };\n            }\n            return false;\n        }\n    },\n\n    'YUI 2': {\n        id: 'yui',\n        icon: 'yui',\n        url: 'http://developer.yahoo.com/yui/2/',\n        test: function(win) {\n            if (win.YAHOO && win.YAHOO.util) {\n                return { version: win.YAHOO.VERSION || UNKNOWN_VERSION };\n            }\n            return false;\n        }\n    },\n\n    'YUI 3': {\n        id: 'yui3',\n        icon: 'yui3',\n        url: 'https://yuilibrary.com/',\n        npm: 'yui',\n        test: function(win) {\n            if (win.YUI && win.YUI.Env) {\n                return { version: win.YUI.version || UNKNOWN_VERSION };\n            }\n            return false;\n        }\n    },\n\n    'Qooxdoo': {\n        id: 'qooxdoo',\n        icon: 'qooxdoo',\n        url: 'http://www.qooxdoo.org/',\n        npm: 'qooxdoo',\n        test: function(win) {\n            if(win.qx && win.qx.Bootstrap) {\n                return { version: UNKNOWN_VERSION };\n            }\n            return false;\n        }\n    },\n\n    'Ext JS': {\n        id: 'extjs',\n        icon: 'extjs',\n        url: 'https://www.sencha.com/products/extjs/',\n        test: function(win) {\n            if (win.Ext && win.Ext.versions) {\n                return { version: win.Ext.versions.core.version };\n            }\n            else if(win.Ext) {\n                return { version: win.Ext.version || UNKNOWN_VERSION };\n            }\n            return false;\n        }\n    },\n\n    'base2': {\n        id: 'base2',\n        icon: 'base2',\n        url: 'http://code.google.com/p/base2',\n        test: function(win) {\n            if(win.base2 && win.base2.dom) {\n                return { version: win.base2.version || UNKNOWN_VERSION };\n            }\n            return false;\n        }\n    },\n\n    'Closure Library': {\n        id: 'closure',\n        icon: 'closure',\n        url: 'https://developers.google.com/closure/library/',\n        npm: 'google-closure-library',\n        test: function(win) {\n            if(win.goog && win.goog.provide) {\n                return { version: UNKNOWN_VERSION };\n            }\n            return false;\n        }\n    },\n\n    'Rapha&euml;l': {\n        id: 'raphael',\n        icon: 'raphael',\n        url: 'http://dmitrybaranovskiy.github.io/raphael/',\n        test: function(win) {\n            if (win.Raphael && win.Raphael.circle) {\n                return { version: win.Raphael.version || UNKNOWN_VERSION };\n            }\n            return false;\n        }\n    },\n\n    'React': {\n        id: 'react',\n        icon: 'react',\n        url: 'https://reactjs.org/',\n        npm: 'react',\n        test: function(win) {\n            function isMatch(node) {\n                return node!=null && node._reactRootContainer!=null;\n            }\n            function nodeFilter(node) {\n                return isMatch(node) ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;\n            }\n            var reactRoot = document.getElementById('react-root');\n            var altHasReact = document.querySelector('*[data-reactroot]');\n            var bodyReactRoot = isMatch(document.body) || isMatch(document.body.firstElementChild);\n            var hasReactRoot = bodyReactRoot|| document.createTreeWalker(document.body, NodeFilter.SHOW_ELEMENT, nodeFilter).nextNode() != null;\n            if (hasReactRoot || reactRoot && reactRoot.innerText.length > 0 || altHasReact || win.React && win.React.Component) {\n                return { version: win.React && win.React.version || UNKNOWN_VERSION };\n            }\n            return false;\n        }\n    },\n\n    'React (Fast path)': {\n        id: 'react-fast',\n        icon: 'react',\n        url: 'https://reactjs.org/',\n        npm: 'react',\n        test: function (win) {\n            function isMatch(node) {\n                return node != null && node._reactRootContainer != null;\n            }\n            var reactRoot = document.getElementById('react-root');\n            var altHasReact = document.querySelector('*[data-reactroot]');\n            var hasReactRoot = isMatch(document.body) || isMatch(document.body.firstElementChild);\n            if (hasReactRoot || reactRoot || altHasReact || win.React) {\n                return { version: win.React && win.React.version || UNKNOWN_VERSION };\n            }\n            return false;\n        }\n    },\n\n    'Next.js': {\n        id: 'next',\n        icon: 'next',\n        url: 'https://nextjs.org/',\n        npm: 'next',\n        test: function(win) {\n            if (win.__NEXT_DATA__ && win.__NEXT_DATA__.buildId) {\n                return { version: window.next && window.next.version || UNKNOWN_VERSION };\n            }\n            return false;\n        }\n    },\n\n    'Next.js (Fast path)': {\n        id: 'next-fast',\n        icon: 'next',\n        url: 'https://nextjs.org/',\n        npm: 'next',\n        test: function (win) {\n            if (win.__NEXT_DATA__) {\n                return { version: UNKNOWN_VERSION };\n            }\n            return false;\n        }\n    },\n\n    'Preact': {\n        id: 'preact',\n        icon: 'preact',\n        url: 'https://preactjs.com/',\n        npm: 'preact',\n        test: function(win) {\n            var expando = typeof Symbol!='undefined' && Symbol.for && Symbol.for('preactattr');\n            function isMatch(node) {\n                if ('__k' in node && 'props' in node.__k && 'type' in node.__k) {\n                    return true;\n                }\n                return '_component' in node || '__preactattr_' in node || expando && node[expando]!=null;\n            }\n            function getMatch(node) {\n                return node!=null && isMatch(node) && node;\n            }\n            function nodeFilter(node) {\n                return isMatch(node) ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;\n            }\n            var preactRoot = getMatch(document.body) || getMatch(document.body.firstElementChild);\n            if (!preactRoot) {\n                preactRoot = document.createTreeWalker(document.body, NodeFilter.SHOW_ELEMENT, nodeFilter).nextNode();\n            }\n            if (preactRoot || win.preact) {\n                var version = UNKNOWN_VERSION;\n                if (preactRoot) {\n                    if ('__k' in preactRoot) {\n                        version = '10';\n                    }\n                    if ('__preactattr_' in preactRoot) {\n                        version = '8';\n                    }\n                    if (expando && preactRoot[expando]!=null) {\n                        version = '7';\n                    }\n                }\n                return { version: version };\n            }\n            return false;\n        }\n    },\n\n    'Preact (Fast path)': {\n        id: 'preact-fast',\n        icon: 'preact',\n        url: 'https://preactjs.com/',\n        npm: 'preact',\n        test: function (win) {\n            var version = UNKNOWN_VERSION;\n            function isMatch(node) {\n                if (node.__k != null) { version = '10'; return true; }\n                return node._component != null || node.__preactattr_ != null;\n            }\n            function getMatch(node) {\n                return node != null && isMatch(node);\n            }\n            var preactRoot = getMatch(document.body) || getMatch(document.body.firstElementChild);\n            if (preactRoot || win.preact) {\n                return { version: version };\n            }\n            return false;\n        }\n    },\n\n    'Modernizr': {\n        id: 'modernizr',\n        icon: 'modernizr',\n        url: 'https://modernizr.com/',\n        npm: 'modernizr',\n        test: function(win) {\n            if (win.Modernizr && win.Modernizr.addTest) {\n                return { version: win.Modernizr._version || UNKNOWN_VERSION };\n            }\n            return false;\n        }\n    },\n\n    'Processing.js': {\n        id: 'processingjs',\n        icon: 'processingjs',\n        url: 'http://processingjs.org',\n        npm: 'processing-js',\n        test: function(win) {\n            if(win.Processing && win.Processing.box) {\n                return { version: Processing.version || UNKNOWN_VERSION };\n            }\n            return false;\n        }\n    },\n\n    'Backbone': {\n        id: 'backbone',\n        icon: 'backbone',\n        url: 'http://backbonejs.org/',\n        npm: 'backbone',\n        test: function(win) {\n            if (win.Backbone && win.Backbone.Model.extend) {\n                return {version: win.Backbone.VERSION || UNKNOWN_VERSION};\n            }\n            return false;\n        }\n    },\n\n    'Leaflet': {\n        id: 'leaflet',\n        icon: 'leaflet',\n        url: 'http://leafletjs.com',\n        npm: 'leaflet',\n        test: function(win) {\n            // Leaflet 3.1 uses L.Marker and L.VERSION; later versions use L.marker and L.version\n            if (win.L && win.L.GeoJSON && (win.L.marker || win.L.Marker)) {\n                return { version: win.L.version || win.L.VERSION || UNKNOWN_VERSION };\n            }\n            return false;\n        }\n    },\n\n    'Mapbox': {\n        id: 'mapbox',\n        icon: 'mapbox',\n        url: 'https://www.mapbox.com/',\n        npm: 'mapbox-gl',\n        test: function(win) {\n            if (win.L && win.L.mapbox && win.L.mapbox.geocoder) {\n                return { version: win.L.mapbox.VERSION || UNKNOWN_VERSION };\n            }\n            return false;\n        }\n    },\n\n    'Lo-Dash': {\n        id: 'lodash',\n        icon: 'lodash',\n        url: 'https://lodash.com/',\n        npm: 'lodash',\n        test: function(win) {\n            var _ = typeof (_ = win._) == 'function' && _,\n                chain = typeof (chain = _ && _.chain) == 'function' && chain,\n                wrapper = (chain || _ || function() { return {}; })(1);\n\n            if (_ && wrapper.__wrapped__) {\n                return { version: _.VERSION || UNKNOWN_VERSION };\n            }\n            return false;\n        }\n    },\n\n    'Underscore': {\n        id: 'underscore',\n        icon: 'underscore',\n        url: 'http://underscorejs.org/',\n        npm: 'underscore',\n        test: function(win) {\n            if (win._ && typeof win._.tap === 'function' &&\n                !d41d8cd98f00b204e9800998ecf8427e_LibraryDetectorTests['Lo-Dash'].test(win)) {\n                return {version: win._.VERSION || UNKNOWN_VERSION};\n            }\n            return false;\n        }\n    },\n\n    'Sammy': {\n        id: 'sammy',\n        icon: 'sammy',\n        url: 'http://sammyjs.org',\n        test: function(win) {\n            if (win.Sammy && win.Sammy.Application.curry) {\n                return {version: win.Sammy.VERSION || UNKNOWN_VERSION};\n            }\n            return false;\n        }\n    },\n\n    'Rico': {\n        id: 'rico',\n        icon: 'rico',\n        url: 'http://openrico.sourceforge.net/examples/index.html',\n        test:  function(win) {\n            if (win.Rico && window.Rico.checkIfComplete) {\n                return {version: win.Rico.Version || UNKNOWN_VERSION};\n            }\n            return false;\n        }\n    },\n\n    'MochiKit': {\n        id: 'mochikit',\n        icon: 'mochikit',\n        url: 'https://mochi.github.io/mochikit/',\n        test: function(win) {\n            if (win.MochiKit && win.MochiKit.Base.module) {\n                return {version: MochiKit.VERSION || UNKNOWN_VERSION};\n            }\n            return false;\n        }\n    },\n\n    'gRapha&euml;l': {\n        id: 'graphael',\n        icon: 'graphael',\n        url: 'https://github.com/DmitryBaranovskiy/g.raphael',\n        test: function(win) {\n            if (win.Raphael && win.Raphael.fn.g) {\n                return {version: UNKNOWN_VERSION};\n            }\n            return false;\n        }\n    },\n\n    'Glow': {\n        id: 'glow',\n        icon: 'glow',\n        url: 'http://www.bbc.co.uk/glow/',\n        test: function(win) {\n            if (win.gloader && win.gloader.getRequests) {\n                return {version: UNKNOWN_VERSION};\n            }\n            else if (win.glow && win.glow.dom) {\n                return {version: win.glow.VERSION || UNKNOWN_VERSION};\n            }\n            else if (win.Glow) {\n                return {version: win.Glow.version || UNKNOWN_VERSION};\n            }\n            return false;\n        }\n    },\n\n    'Socket.IO': {\n        id: 'socketio',\n        icon: 'socketio', // currently has no icon\n        url: 'https://socket.io/',\n        npm: 'socket.io',\n        test: function(win) {\n            // version 0.6.2 uses only io.Socket; more recent versions also have io.sockets\n            if (win.io && (win.io.sockets || win.io.Socket)) {\n                return {version: win.io.version || UNKNOWN_VERSION};\n            }\n            return false;\n        }\n    },\n\n    'Mustache': {\n        id: 'mustache',\n        icon: 'mustache',\n        url: 'http://mustache.github.io/',\n        npm: 'mustache',\n        test: function(win) {\n            if (win.Mustache && win.Mustache.to_html) {\n                return {version: win.Mustache.version || UNKNOWN_VERSION};\n            }\n            return false;\n        }\n    },\n\n    'Fabric.js': {\n        id: 'fabricjs',\n        icon: 'icon38', // currently has no icon\n        url: 'http://fabricjs.com/',\n        npm: 'fabric',\n        test: function(win) {\n            if (win.fabric && win.fabric.util) {\n                return {version: win.fabric.version || UNKNOWN_VERSION};\n            }\n            return false;\n        }\n    },\n\n    'FuseJS': {\n        id: 'fusejs',\n        icon: 'fusejs',\n        url: 'http://fusejs.io/',\n        npm: 'fuse.js',\n        test: function(win) {\n            if (win.Fuse) {\n                return {version: UNKNOWN_VERSION};\n            }\n            return false;\n        }\n    },\n\n    'Tween.js': {\n        id: 'tweenjs',\n        icon: 'icon38', // currently has no icon\n        url: 'https://github.com/tweenjs/tween.js',\n        npm: 'tween.js',\n        test: function(win) {\n            if (win.TWEEN && win.TWEEN.Easing) {\n                return {version: UNKNOWN_VERSION};\n            }\n            return false;\n        }\n    },\n\n    'SproutCore': {\n       id: 'sproutcore',\n       icon: 'sproutcore',\n       url: 'http://sproutcore.com/',\n       test: function(win) {\n           if (win.SC && win.SC.Application) {\n               return {version: UNKNOWN_VERSION};\n           }\n           return false;\n       }\n    },\n\n    'Zepto.js': {\n       id: 'zepto',\n       icon: 'zepto',\n       url: 'http://zeptojs.com',\n       npm: 'zepto',\n       test: function(win) {\n           if (win.Zepto && win.Zepto.fn) {\n               return {version: UNKNOWN_VERSION};\n           }\n           return false;\n       }\n    },\n\n    'three.js': {\n       id: 'threejs',\n       icon: 'icon38', // currently has no icon\n       url: 'https://threejs.org/',\n       npm: 'three',\n       test: function(win) {\n           if (win.THREE && win.THREE.REVISION) {\n               return {version: 'r' + win.THREE.REVISION};\n           }\n           else if (win.THREE) {\n               return {version: UNKNOWN_VERSION};\n           }\n           return false;\n       }\n    },\n\n    'PhiloGL': {\n       id: 'philogl',\n       icon: 'philogl',\n       url: 'http://www.senchalabs.org/philogl/',\n       npm: 'philogl',\n       test: function(win) {\n           if (win.PhiloGL && win.PhiloGL.Camera) {\n               return {version: win.PhiloGL.version || UNKNOWN_VERSION};\n           }\n           return false;\n       }\n    },\n\n    'CamanJS': {\n        id: 'camanjs',\n        icon: 'camanjs',\n        url: 'http://camanjs.com/',\n        npm: 'caman',\n        test: function(win) {\n            if (win.Caman && win.Caman.version) {\n                return {version: win.Caman.version.release};\n            }\n            else if (win.Caman) {\n                return {version: UNKNOWN_VERSION};\n            }\n            return false;\n        }\n    },\n\n    'yepnope': {\n        id: 'yepnope',\n        icon: 'yepnope',\n        url: 'http://yepnopejs.com/',\n        test: function(win) {\n            if (win.yepnope && win.yepnope.injectJs) {\n                return {version: UNKNOWN_VERSION};\n            }\n            return false;\n        }\n    },\n\n    'LABjs': {\n        id: 'labjs',\n        icon: 'icon38',\n        url: 'https://github.com/getify/LABjs',\n        test: function(win) {\n            if (win.$LAB && win.$LAB.setOptions) {\n                return {version: UNKNOWN_VERSION};\n            }\n            return false;\n        }\n    },\n\n    'Head JS': {\n        id: 'headjs',\n        icon: 'headjs',\n        url: 'http://headjs.com/',\n        npm: 'headjs',\n        test: function(win) {\n            if (win.head && win.head.js) {\n                return {version: UNKNOWN_VERSION};\n            }\n            return false;\n        }\n    },\n\n    'ControlJS': {\n        id: 'controljs',\n        icon: 'icon38',\n        url: 'http://stevesouders.com/controljs/',\n        test: function(win) {\n            if (win.CJS && win.CJS.start) {\n                return {version: UNKNOWN_VERSION};\n            }\n            return false;\n        }\n    },\n\n    'RequireJS': {\n        id: 'requirejs',\n        icon: 'requirejs',\n        url: 'http://requirejs.org/',\n        npm: 'requirejs',\n        test: function(win) {\n            var req = win.require || win.requirejs;\n            if (req && (req.load || (req.s && req.s.contexts && req.s.contexts._ && (req.s.contexts._.loaded || req.s.contexts._.load)))) {\n                return { version: req.version || UNKNOWN_VERSION };\n            }\n            return false;\n        }\n    },\n\n    'RightJS': {\n        id: 'rightjs',\n        icon: 'rightjs',\n        url: 'http://rightjs.org/',\n        test: function(win) {\n            if (win.RightJS && win.RightJS.isNode) {\n                return { version: win.RightJS.version || UNKNOWN_VERSION };\n            }\n            return false;\n        }\n    },\n\n    'jQuery Tools': {\n       id: 'jquerytools',\n       icon: 'jquerytools',\n       url: 'http://jquerytools.github.io/',\n       test: function(win) {\n            var jq = win.jQuery || win.$;\n            if(jq && jq.tools) {\n               return { version: jq.tools.version || UNKNOWN_VERSION };\n           }\n           return false;\n       }\n    },\n\n    'Pusher': {\n       id: 'pusher',\n       icon: 'pusher',\n       url: 'https://pusher.com/docs/',\n       npm: 'pusher-js',\n       test: function(win) {\n            if(win.Pusher && win.Pusher.Channel) {\n               return { version: win.Pusher.VERSION || UNKNOWN_VERSION };\n           }\n           return false;\n       }\n    },\n\n    'Paper.js': {\n       id: 'paperjs',\n       icon: 'paperjs',\n       url: 'http://paperjs.org/',\n       npm: 'paper',\n       test: function(win) {\n            if(win.paper && win.paper.Point) {\n               return { version: win.paper.version || UNKNOWN_VERSION };\n           }\n           return false;\n       }\n    },\n\n    'Swiffy': {\n       id: 'swiffy',\n       icon: 'icon38',\n       url: 'https://developers.google.com/swiffy/',\n       test: function(win) {\n            if(win.swiffy && win.swiffy.Stage) {\n               return { version: UNKNOWN_VERSION };\n           }\n           return false;\n       }\n    },\n\n    'Move': {\n       id: 'move',\n       icon: 'move',\n       url: 'https://github.com/rsms/move',\n       npm: 'move',\n       test: function(win) {\n            if(win.move && win.move.compile) {\n               return { version: win.move.version() || UNKNOWN_VERSION };\n           }\n           return false;\n       }\n    },\n\n    'AmplifyJS': {\n       id: 'amplifyjs',\n       icon: 'amplifyjs',\n       url: 'http://amplifyjs.com/',\n       npm: 'amplifyjs',\n       test: function(win) {\n            if(win.amplify && win.amplify.publish) {\n               return { version: UNKNOWN_VERSION };\n           }\n           return false;\n       }\n    },\n\n    'Popcorn.js': {\n       id: 'popcornjs',\n       icon: 'popcornjs',\n       url: 'https://github.com/mozilla/popcorn-js/',\n       test: function(win) {\n            if (win.Popcorn && win.Popcorn.Events) {\n               return { version: win.Popcorn.version || UNKNOWN_VERSION };\n           }\n           return false;\n       }\n    },\n\n    'D3': {\n        id: 'd3',\n        icon: 'd3',\n        url: 'https://d3js.org/',\n        npm: 'd3',\n        test: function(win) {\n            if (win.d3 && win.d3.select) {\n                return { version: win.d3.version || UNKNOWN_VERSION };\n            }\n            return false;\n        }\n    },\n\n    'Handlebars': {\n        id: 'handlebars',\n        icon: 'handlebars',\n        url: 'http://handlebarsjs.com/',\n        npm: 'handlebars',\n        test: function(win) {\n            if(win.Handlebars && win.Handlebars.compile) {\n                return { version: win.Handlebars.VERSION || UNKNOWN_VERSION };\n            }\n            return false;\n        }\n    },\n\n    'Knockout': {\n        id: 'knockout',\n        icon: 'knockout',\n        url: 'http://knockoutjs.com/',\n        npm: 'knockout',\n        test: function(win) {\n            if (win.ko && win.ko.applyBindings) {\n                return { version: win.ko.version || UNKNOWN_VERSION };\n            }\n            return false;\n        }\n    },\n\n    'Spine': {\n        id: 'spine',\n        icon: 'icon38',\n        url: 'http://spine.github.io/',\n        test: function(win) {\n            if (win.Spine && win.Spine.Controller) {\n                return {version: win.Spine.version || UNKNOWN_VERSION};\n            }\n            return false;\n        }\n    },\n\n    'jQuery Mobile': {\n        id: 'jquery-mobile',\n        icon: 'jquery_mobile',\n        url: 'http://jquerymobile.com/',\n        npm: 'jquery-mobile',\n        test: function(win) {\n            var jq = win.jQuery || win.$ || win.$jq || win.$j;\n            if(jq && jq.fn && jq.fn.jquery && jq.mobile) {\n                return { version: jq.mobile.version || UNKNOWN_VERSION };\n            }\n            return false;\n        }\n    },\n\n    'WebFont Loader': {\n        id: 'webfontloader',\n        icon: 'icon38',\n        url: 'https://github.com/typekit/webfontloader',\n        npm: 'webfontloader',\n        test: function(win) {\n            if(win.WebFont && win.WebFont.load) {\n                return { version: UNKNOWN_VERSION };\n            }\n            return false;\n        }\n    },\n\n    'Angular': {\n        id: 'angular',\n        icon: 'angular',\n        url: 'https://angular.io/',\n        npm: '@angular/core',\n        test: function(win) {\n            var ngVersion = win.document.querySelector('[ng-version]');\n            if (ngVersion) {\n                return { version: ngVersion.getAttribute('ng-version') || UNKNOWN_VERSION };\n            }\n            else if (win.ng && win.ng.probe instanceof Function) {\n                return { version: UNKNOWN_VERSION };\n            }\n            return false;\n        }\n    },\n\n    'AngularJS': {\n        id: 'angularjs',\n        icon: 'angularjs',\n        url: 'https://angularjs.org/',\n        npm: 'angular',\n        test: function(win) {\n            var ng = win.angular;\n            if(ng && ng.version && ng.version.full) {\n                return { version: ng.version.full };\n            }\n            else if (ng) {\n                return { version: UNKNOWN_VERSION };\n            }\n            return false;\n        }\n    },\n\n    'Ember.js': {\n        id: 'emberjs',\n        icon: 'emberjs',\n        url: 'https://emberjs.com/',\n        npm: 'ember-source',\n        test: function(win) {\n            var ember = win.Ember || win.Em;\n            if (ember && ember.GUID_KEY) {\n                return { version: ember.VERSION || UNKNOWN_VERSION };\n            }\n            return false;\n        }\n    },\n\n    'Hammer.js': {\n        id: 'hammerjs',\n        icon: 'hammerjs',\n        url: 'http://eightmedia.github.io/hammer.js/',\n        npm: 'hammerjs',\n        test: function(win) {\n            if(win.Hammer && win.Hammer.Pinch) {\n                // Hammer.VERSION available in 1.0.10+\n                return { version: win.Hammer.VERSION || \"&lt; 1.0.10\" };\n            }\n            return false;\n        }\n    },\n\n    'Visibility.js': {\n        id: 'visibilityjs',\n        icon: 'icon38',\n        url: 'https://github.com/ai/visibilityjs',\n        npm: 'visibilityjs',\n        test: function(win) {\n            if(win.Visibility && win.Visibility.every) {\n                return { version: UNKNOWN_VERSION };\n            }\n            return false;\n        }\n    },\n\n    'Velocity.js': {\n        id: 'velocityjs',\n        icon: 'icon38',\n        url: 'http://velocityjs.org/',\n        npm: 'velocity-animate',\n        test: function(win) {\n            var jq = win.jQuery || win.$,\n                velocity = jq ? jq.Velocity : win.Velocity;\n\n            if(velocity && velocity.RegisterEffect && velocity.version) {\n                return {\n                    version:\n                        velocity.version.major + \".\" +\n                        velocity.version.minor + \".\" +\n                        velocity.version.patch\n                };\n            }\n            else if (velocity && velocity.RegisterEffect) {\n                return { version: UNKNOWN_VERSION };\n            }\n            return false;\n        }\n    },\n\n    'IfVisible.js': {\n        id: 'ifvisiblejs',\n        icon: 'icon38',\n        url: 'http://serkanyersen.github.io/ifvisible.js/',\n        npm: 'ifvisible.js',\n        test: function(win) {\n            var iv = win.ifvisible;\n            if(iv && iv.__ceGUID === \"ifvisible.object.event.identifier\") {\n                return { version: UNKNOWN_VERSION };\n            }\n            return false;\n        }\n    },\n    'Pixi.js': {\n        id: 'pixi',\n        icon: 'pixi',\n        url: 'http://www.pixijs.com/',\n        npm: 'pixi.js',\n        test: function(win) {\n            var px = win.PIXI;\n            if(px && px.WebGLRenderer && px.VERSION) {\n                // version 4.4.3 returns simply \"4.4.3\"; version 1.5.2 returns \"v1.5.2\"\n                return { version: px.VERSION.replace('v', '') || UNKNOWN_VERSION };\n            }\n            return false;\n        }\n    },\n    'DC.js': {\n        id: 'dcjs',\n        icon: 'dcjs',\n        url: 'http://dc-js.github.io/dc.js/',\n        npm: 'dc',\n        test: function(win) {\n            var dc = win.dc;\n            if(dc && dc.registerChart) {\n                return { version: dc.version || UNKNOWN_VERSION };\n            }\n            return false;\n        }\n    },\n    'GreenSock JS': {\n        id: 'greensock',\n        icon: 'greensock',\n        url: 'https://greensock.com/gsap',\n        npm: 'gsap',\n        test: function(win) {\n            if (win.TweenMax && win.TweenMax.pauseAll) {\n                return { version: win.TweenMax.version || UNKNOWN_VERSION };\n            }\n            return false;\n        }\n    },\n    'FastClick': {\n        id: 'fastclick',\n        icon: 'fastclick',\n        url: 'https://github.com/ftlabs/fastclick',\n        npm: 'fastclick',\n        test: function(win) {\n            if(win.FastClick && win.FastClick.notNeeded) {\n                return { version: UNKNOWN_VERSION };\n            }\n            return false;\n        }\n    },\n    'Isotope': {\n        id: 'isotope',\n        icon: 'isotope',\n        url: 'https://isotope.metafizzy.co/',\n        npm: 'isotope-layout',\n        test: function(win) {\n            if(win.Isotope || (win.$ != null && win.$.Isotope)) {\n                return { version: UNKNOWN_VERSION };\n            }\n            return false;\n        }\n    },\n    'Marionette': {\n        id: 'marionette',\n        icon: 'marionette',\n        url: 'https://marionettejs.com/',\n        npm: 'backbone.marionette',\n        test: function(win) {\n            if(win.Marionette && win.Marionette.Application) {\n                return { version: win.Marionette.VERSION || UNKNOWN_VERSION };\n            }\n            return false;\n        }\n    },\n    'Can': {\n        id: 'canjs',\n        icon: 'canjs',\n        url: 'https://canjs.com/',\n        npm: 'can',\n        test: function (win) {\n            if (win.can && win.can.Construct) {\n                return { version: win.can.VERSION || UNKNOWN_VERSION };\n            }\n            return false;\n        }\n    },\n    'Vue': {\n        id: 'vue',\n        icon: 'vue',\n        url: 'https://vuejs.org/',\n        npm: 'vue',\n        test: function(win) {\n            function isVueNode(node) {\n                return node.__vue__ != null ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;\n            }\n            var hasVueNode = document.createTreeWalker(document.body, NodeFilter.SHOW_ELEMENT, isVueNode).nextNode() !== null;\n            if (hasVueNode || win.Vue) {\n                return { version: win.Vue && win.Vue.version || UNKNOWN_VERSION };\n            }\n            return false;\n        }\n    },\n    'Vue (Fast path)': {\n        id: 'vue-fast',\n        icon: 'vue',\n        url: 'https://vuejs.org/',\n        npm: 'vue',\n        test: function (win) {\n            if (win.Vue) {\n                return { version: win.Vue && win.Vue.version || UNKNOWN_VERSION };\n            }\n            return false;\n        }\n    },\n    'Nuxt.js': {\n        id: 'nuxt',\n        icon: 'nuxt',\n        url: 'https://nuxtjs.org/',\n        npm: 'nuxt',\n        test: function(win) {\n            if ((win.__NUXT__ && win.__NUXT__.data != null) || win.$nuxt) {\n                return { version: UNKNOWN_VERSION };\n            }\n            return false;\n        }\n    },\n    'Nuxt.js (Fast path)': {\n        id: 'nuxt-fast',\n        icon: 'nuxt',\n        url: 'https://nuxtjs.org/',\n        npm: 'nuxt',\n        test: function (win) {\n            if (win.__NUXT__  || win.$nuxt) {\n                return { version: UNKNOWN_VERSION };\n            }\n            return false;\n        }\n    },\n    'Two': {\n        id: 'two',\n        icon: 'two',\n        url: 'https://two.js.org/',\n        npm: 'two.js',\n        test: function(win) {\n            if (win.Two && win.Two.Utils) {\n                return { version: win.Two.Version || UNKNOWN_VERSION };\n            }\n            return false;\n        }\n    },\n    'Brewser': {\n        id: 'brewser',\n        icon: 'brewser',\n        url: 'https://robertpataki.github.io/brewser/',\n        npm: 'brewser',\n        test: function(win) {\n            if(win.BREWSER && win.BREWSER.ua) {\n                return { version: BREWSER.VERSION || UNKNOWN_VERSION };\n            }\n            return false;\n        }\n    },\n    'Material Design Lite': {\n        id: 'materialdesignlite',\n        icon: 'mdl',\n        url: 'https://getmdl.io/',\n        npm: 'material-design-lite',\n        test: function(win) {\n            if(win.componentHandler && win.componentHandler.upgradeElement) {\n                return { version: UNKNOWN_VERSION};\n            }\n            return false;\n        }\n    },\n    'Kendo UI': {\n        id: 'kendoui',\n        icon: 'kendoui',\n        url: 'https://github.com/telerik/kendo-ui-core',\n        npm: 'kendo-ui-core',\n        test: function(win) {\n            if (win.kendo && win.kendo.View && win.kendo.View.extend) {\n                return {version: win.kendo.version || UNKNOWN_VERSION};\n            }\n            return false;\n        }\n    },\n    'Matter.js': {\n        id: 'matterjs',\n        icon: 'matter-js',\n        url: 'http://brm.io/matter-js/',\n        npm: 'matter-js',\n        test: function(win) {\n            if (win.Matter && win.Matter.Engine) {\n                return {version: UNKNOWN_VERSION};\n            }\n            return false;\n        }\n    },\n    'Riot': {\n        id: 'riot',\n        icon: 'riot',\n        url: 'http://riotjs.com/',\n        npm: 'riot',\n        test: function(win) {\n            if (win.riot && win.riot.mixin) {\n                return { version: win.riot.version || UNKNOWN_VERSION };\n            }\n            return false;\n        }\n    },\n    'Sea.js': {\n        id: 'seajs',\n        icon: 'icon38',\n        url: 'https://seajs.github.io/seajs/docs/',\n        npm: 'seajs',\n        test: function(win) {\n            if(win.seajs && win.seajs.use) {\n                return { version: win.seajs.version || UNKNOWN_VERSION };\n            }\n            return false;\n        }\n    },\n    'Moment.js': {\n        id: 'momentjs',\n        icon: 'momentjs',\n        url: 'http://momentjs.com/',\n        npm: 'moment',\n        test: function(win) {\n            if(win.moment && (win.moment.isMoment || win.moment.lang)) {\n                // version 1.0.0 has neither \"isMoment\" nor \"version\"\n                return { version: win.moment.version || UNKNOWN_VERSION };\n            }\n            return false;\n        }\n    },\n    'Moment Timezone': {\n        id: 'moment-timezone',\n        icon: 'momentjs',\n        url: 'http://momentjs.com/timezone/',\n        npm: 'moment-timezone',\n        test: function(win) {\n            if (win.moment && win.moment.tz) {\n                return { version: win.moment.tz.version || UNKNOWN_VERSION };\n            }\n            return false;\n        }\n    },\n    'ScrollMagic': {\n        id: 'scrollmagic',\n        icon: 'scrollmagic',\n        url: 'http://scrollmagic.io/',\n        npm: 'scrollmagic',\n        test: function(win) {\n            if (win.ScrollMagic && win.ScrollMagic.Controller) {\n                return {version: ScrollMagic.version || UNKNOWN_VERSION};\n            }\n            return false;\n        }\n    },\n    'SWFObject': {\n        id: 'swfobject',\n        icon: 'icon38', // currently has no icon\n        url: 'https://github.com/swfobject/swfobject',\n        test: function(win) {\n            if (win.swfobject && win.swfobject.embedSWF) {\n                // 2.x - exact version only for 2.3\n                return { version: win.swfobject.version || UNKNOWN_VERSION };\n            } else if(win.deconcept && win.deconcept.SWFObject) {\n                // 1.x\n                return { version: UNKNOWN_VERSION };\n            }\n            return false;\n        }\n    },\n    'FlexSlider': {\n        id: 'flexslider',\n        icon: 'icon38', // currently has no icon\n        url: 'https://woocommerce.com/flexslider/',\n        npm: 'flexslider',\n        test: function(win) {\n            var jq = win.jQuery || win.$ || win.$jq || win.$j;\n            if (jq && jq.fn && jq.fn.jquery && jq.flexslider){\n                return { version: UNKNOWN_VERSION };\n            }\n            return false;\n        }\n    },\n    'SPF': {\n        id: 'spf',\n        icon: 'icon38', // currently has no icon\n        url: 'https://youtube.github.io/spfjs/',\n        npm: 'spf',\n        test: function(win) {\n            if (win.spf && win.spf.init) {\n                return { version: UNKNOWN_VERSION };\n            }\n            return false;\n        }\n    },\n    'Numeral.js': {\n        id: 'numeraljs',\n        icon: 'icon38', // currently has no icon\n        url: 'http://numeraljs.com/',\n        npm: 'numeraljs',\n        test: function(win) {\n            if (win.numeral && win.isNumeral) {\n                return { version: win.numeral.version || UNKNOWN_VERSION };\n            }\n            return false;\n        }\n    },\n    'boomerang.js': {\n        id: 'boomerangjs',\n        icon: 'icon38', // currently has no icon\n        url: 'https://soasta.github.io/boomerang/',\n        npm: 'boomerangjs',\n        test: function(win) {\n            if (win.BOOMR && win.BOOMR.utils && win.BOOMR.init) {\n                return { version: win.BOOMR.version || UNKNOWN_VERSION };\n            }\n            return false;\n        }\n    },\n    'Framer': {\n        id: 'framer',\n        icon: 'framer',\n        url: 'https://framer.com/',\n        npm: 'framerjs',\n        test: function(win) {\n            if (win.Framer && win.Framer.Layer) {\n                return { version: win.Framer.Version.build || UNKNOWN_VERSION };\n            }\n            return false;\n        }\n    },\n    'Marko': {\n        id: 'marko',\n        icon: 'marko',\n        url: 'https://markojs.com/',\n        npm: 'marko',\n        test: function (win) {\n            var selector = '[data-marko-key], [data-marko]';\n            var markoElement = document.querySelector(selector);\n            if (markoElement) {\n                return { version: UNKNOWN_VERSION };\n            }\n            return false;\n        }\n    },\n    'AMP': {\n        id: 'amp',\n        icon: 'amp',\n        url: 'https://amp.dev/',\n        npm: 'https://www.npmjs.com/org/ampproject',\n        test: function (win) {\n            var version = win.document.documentElement.getAttribute(\"amp-version\");\n            return version ? { version: version } : false;\n        }\n    },\n    'Gatsby': {\n        id: 'gatsby',\n        icon: 'gatsby',\n        url: 'https://www.gatsbyjs.org/',\n        npm: 'gatsby',\n        test: function (win) {\n            if (document.getElementById('___gatsby')) {\n                return { version: UNKNOWN_VERSION };\n            }\n            return false;\n        }\n    },\n    'Shopify': {\n        id: 'shopify',\n        icon: 'shopify',\n        url: 'https://www.shopify.com/',\n        npm: null,\n        test: function (win) {\n            if (win.Shopify && win.Shopify.shop) {\n                return { version: UNKNOWN_VERSION };\n            }\n            return false;\n        }\n    },\n    'Magento': {\n        id: 'magento',\n        icon: 'magento',\n        url: 'https://magento.com/',\n        npm: null,\n        test: function (win) {\n            // Same detecton used in Magento 2 DevTools: https://github.com/magento/m2-devtools\n            const reRequireScript = /\\/static(?:\\/version\\d+)?\\/frontend\\/.+\\/.+\\/requirejs\\/require(?:\\.min)?\\.js/;\n            const scripts = Array.from(document.querySelectorAll('script[src]') || []);\n            if (scripts.some(s => reRequireScript.test(s.src))) {\n                return { version: 2 }; // Magento 1 is no longer supported and this only verifies version 2\n            }\n            \n            return false;\n        }\n    },\n    'WordPress': {\n        id: 'wordpress',\n        icon: 'wordpress',\n        url: 'https://wordpress.org/',\n        npm: null,\n        test: function (win) {\n            const hasAPILinkElem = !!document.querySelector('link[rel=\"https://api.w.org/\"]');\n            const hasWPIncludes = !!document.querySelectorAll('link[href*=\"wp-includes\"], script[src*=\"wp-includes\"]').length;\n\n            if (!hasAPILinkElem && !hasWPIncludes) return false;\n\n            const generatorMeta = document.querySelector('meta[name=generator][content^=\"WordPress\"]');\n            const version = generatorMeta ? generatorMeta.getAttribute(\"content\").replace(/^\\w+\\s/,'') : UNKNOWN_VERSION;\n            return { version };\n        }\n    },\n    'Wix': {\n        id: 'wix',\n        icon: 'wix',\n        url: 'https://www.wix.com/',\n        npm: null,\n        test: function (win) {\n            if (win.wixBiSession) {\n                return { version: UNKNOWN_VERSION };\n            }\n            return false;\n        }\n    },\n    'Workbox': {\n      id: 'workbox',\n      icon: 'workbox',\n      url: 'https://developers.google.com/web/tools/workbox/',\n      npm: 'workbox-sw',\n      test: async function (win) {\n        var nav = win.navigator;\n        // Service Workers not supported\n        if (!('serviceWorker' in nav)) {\n          return false;\n        }\n\n        const {timeoutPromise, clearTimeout} = _createTimeoutHelper();\n\n        const workerPromise = nav.serviceWorker.getRegistration()\n        .then(function(registration) {\n          var scriptURL = nav.serviceWorker.controller ? nav.serviceWorker.controller.scriptURL :\n            registration.active.scriptURL;\n          return fetch(scriptURL, { credentials: 'include',\n            headers: { 'service-worker': 'script' }\n          })\n          .then(function(response) {\n            return response.text();\n          })\n          .then(function(scriptContent) {\n            var workboxRegExp = /new Workbox|new workbox|workbox\\.precaching\\.|workbox\\.strategies/gm;\n            if (workboxRegExp.test(scriptContent)) {\n              // Adapted from\n              // https://github.com/semver/semver/issues/232#issue-48635632\n              var semVerRegExp = /workbox.*?\\b((0|[1-9]\\d*)\\.(0|[1-9]\\d*)\\.(0|[1-9]\\d*)(-(0|[1-9]\\d*|\\d*[a-zA-Z-][0-9a-zA-Z-]*)(\\.(0|[1-9]\\d*|\\d*[a-zA-Z-][0-9a-zA-Z-]*))*)?(\\+[0-9a-zA-Z-]+(\\.[0-9a-zA-Z-]+)*)?)\\b/gim;\n              var matches = semVerRegExp.exec(scriptContent);\n              var version = UNKNOWN_VERSION;\n              if (Array.isArray(matches) && matches.length > 1 && matches[1]) {\n                version = matches[1];\n              }\n              return { version: version };\n            }\n            return false;\n          });\n        });\n        \n        return Promise.race([workerPromise, timeoutPromise]).catch(function(exception) {\n          return false;\n        }).finally(result => {\n          clearTimeout();\n          return result;\n        });\n      }\n    },\n    'Boq': {\n        id: 'boq',\n        icon: 'icon38',\n        url: 'https://github.com/johnmichel/Library-Detector-for-Chrome/pull/143',\n        npm: null,\n        test: function (win) {\n            if (win.WIZ_global_data) {\n                return { version: UNKNOWN_VERSION };\n            }\n            return false;\n        }\n    },\n    'Wiz': {\n        id: 'wiz',\n        icon: 'icon38',\n        url: 'https://github.com/johnmichel/Library-Detector-for-Chrome/pull/147',\n        npm: null,\n        test: function (win) {\n            if (document.__wizdispatcher) {\n                return { version: UNKNOWN_VERSION };\n            }\n            return false;\n        }\n    },\n    'core-js': {\n        id: 'corejs',\n        icon: 'icon38',\n        url: 'https://github.com/zloirock/core-js',\n        npm: 'core-js',\n        test: function (win) {\n            const shared = win['__core-js_shared__'];\n            const core = win.core;\n            if (shared) {\n                const versions = shared.versions;\n                return { version: Array.isArray(versions) ? versions.map(it => `core-js-${ it.mode }@${ it.version }`).join('; ') : UNKNOWN_VERSION };\n            } else if (core) {\n                return { version: core.version || UNKNOWN_VERSION };\n            }\n            return false;\n        }\n    },\n    'Drupal': {\n        id: 'drupal',\n        icon: 'drupal',\n        url: 'https://www.drupal.org/',\n        npm: null,\n        test: function (win) {\n            const generatorMeta = document.querySelector('meta[name=\"generator\"][content^=\"Drupal\"]');\n            const version = generatorMeta ? generatorMeta.getAttribute(\"content\").replace(/\\D+/gi,'') : UNKNOWN_VERSION;\n\n            // Detect Drupal resources patterns\n            const resDrupal = /\\/sites\\/(?:default|all)\\/(?:themes|modules|files)/;\n            const res = Array.from(document.querySelectorAll('link,style,script') || []);\n\n            if (res.some(s => resDrupal.test(s.src)) || res.some(s => resDrupal.test(s.href)) ||\n                generatorMeta || (win.Drupal && win.Drupal.behaviors)) {\n                return { version };\n            }\n\n            return false;\n        }\n    },\n    'TYPO3': {\n        id: 'typo3',\n        icon: 'typo3',\n        url: 'https://typo3.org/',\n        npm: null,\n        test: function (win) {\n            const generatorMeta = document.querySelector('meta[name=\"generator\"][content^=\"TYPO3\"]');\n\n            // TYPO3 resource patterns / paths - search in link, style or script tags\n            const resourcesTYPO3 = /\\/(typo3conf|typo3temp|fileadmin)/;\n            const res = Array.from(document.querySelectorAll('link,style,script') || []);\n\n            if (generatorMeta || res.some(s => resourcesTYPO3.test(s.src)) || res.some(s => resourcesTYPO3.test(s.href))) {\n\t\t        // No version exposure available in TYPO3 due to information disclosure\n                return { version: UNKNOWN_VERSION };\n            }\n\n            return false;\n        }\n    },\n    'Create React App': {\n        id: 'create-react-app',\n        icon: 'cra',\n        url: 'https://create-react-app.dev/',\n        npm: 'react-scripts',\n        test: function (win) {\n            let child = win.document.body.firstElementChild;\n            let noscript, root;\n            \n            do {\n                if (child.localName === 'noscript') noscript = child;\n                else if (child.id === 'root') root = child;\n            } while (child = child.nextElementSibling);\n            \n            if (root && noscript && /You need to enable JavaScript to run this app/.test(noscript.textContent)) {\n                return { version: UNKNOWN_VERSION };\n            }\n\n            return false;\n        }\n    },\n    'Guess.js': {\n        id: 'guessjs',\n        icon: 'guessjs',\n        url: 'https://guess-js.github.io/',\n        test: function (win) {\n            if (win.__GUESS__ && win.__GUESS__.guess) {\n                return { version: UNKNOWN_VERSION };\n            }\n            return false;\n        }\n    },\n    'October CMS': {\n        id: 'octobercms',\n        icon: 'octobercms',\n        url: 'https://octobercms.com/',\n        npm: null,\n        test: function (win) {\n            const generatorMeta1 = document.querySelector('meta[name=\"generator\"][content^=\"OctoberCMS\"]');\n            const generatorMeta2 = document.querySelector('meta[name=\"generator\"][content^=\"October CMS\"]');\n            \n            // October CMS resource patterns / paths - search in link, style or script tags\n            const resourcesOctober = /\\/modules\\/system\\/assets\\/(css|js)\\/framework(\\.extras|\\.combined)?(-min)?/;\n            const res = Array.from(document.querySelectorAll('link,style,script') || []);\n\n            if (generatorMeta1 || generatorMeta2 || res.some(s => resourcesOctober.test(s.src || s.href))) {\n                // No version exposure available in October CMS due to information disclosure\n                return { version: UNKNOWN_VERSION };\n            }\n\n            return false;\n        }\n    },\n    'Joomla': {\n        id: 'joomla',\n        icon: 'joomla',\n        url: 'https://www.joomla.org/',\n        npm: null,\n        test: function (win) {\n            // You can disable the generator tag as well as the version from the backend\n            const generatorMeta = document.querySelector('meta[name=generator][content^=\"Joomla\"]');\n            // This is the path to the joomla core bootstrap but sites are not required to load that file but could also load a different version\n            const hasJoomlaBootstrap = !!document.querySelectorAll('script[src*=\"/media/jui/js/bootstrap.min.js\"]').length;\n            \n            if (generatorMeta) {\n                return { version: generatorMeta.getAttribute(\"content\").replace(/^\\w+\\s/,'') };\n            } else if (win.Joomla || hasJoomlaBootstrap) {\n                return { version: UNKNOWN_VERSION };\n            }\n            \n            return false;\n        }\n    }\n};\n";

/** @typedef {false | {version: string|number|null}} JSLibraryDetectorTestResult */
/**
 * @typedef JSLibraryDetectorTest
 * @property {string} id
 * @property {string} icon
 * @property {string} url
 * @property {string|null} npm npm module name, if applicable to library.
 * @property {function(Window): JSLibraryDetectorTestResult | Promise<JSLibraryDetectorTestResult>} test Returns false if library is not present, otherwise returns an object that contains the library version (set to null if the version is not detected).
 */

/**
 * @typedef JSLibrary
 * @property {string} id
 * @property {string} name
 * @property {string|number|null} version
 * @property {string|null} npm
 */

/**
 * Obtains a list of detected JS libraries and their versions.
 */
/* c8 ignore start */
async function detectLibraries() {
  /** @type {JSLibrary[]} */
  const libraries = [];

  // d41d8cd98f00b204e9800998ecf8427e_ is a consistent prefix used by the detect libraries
  // see https://github.com/HTTPArchive/httparchive/issues/77#issuecomment-291320900
  /** @type {Record<string, JSLibraryDetectorTest>} */
  // @ts-expect-error - injected libDetectorSource var
  const libraryDetectorTests = d41d8cd98f00b204e9800998ecf8427e_LibraryDetectorTests; // eslint-disable-line

  for (const [name, lib] of Object.entries(libraryDetectorTests)) {
    try {
      /** @type {NodeJS.Timeout|undefined} */
      let timeout;
      // Some library detections are async that can never return.
      // Guard ourselves from PROTOCL_TIMEOUT by limiting each detection to a max of 1s.
      // See https://github.com/GoogleChrome/lighthouse/issues/11124.
      const timeoutPromise = new Promise(r => timeout = setTimeout(() => r(false), 1000));

      const result = await Promise.race([lib.test(window), timeoutPromise]);
      if (timeout) clearTimeout(timeout);
      if (result) {
        libraries.push({
          id: lib.id,
          name: name,
          version: result.version,
          npm: lib.npm,
        });
      }
    } catch (e) {}
  }

  return libraries;
}
/* c8 ignore stop */


/** @implements {LH.Gatherer.FRGathererInstance} */
class Stacks extends FRGatherer {
  constructor() {
    super();

    // Because this file uses `fs.readFile` it gets parsed by a different branch of the browserify internals
    // that cannot handle the latest ECMAScript features.
    // See https://github.com/GoogleChrome/lighthouse/issues/12134
    /** @type {LH.Gatherer.GathererMeta} */
    this.meta = {
      supportedModes: ['snapshot', 'navigation'],
    };
  }

  /**
   * @param {LH.Gatherer.FRTransitionalDriver['executionContext']} executionContext
   * @return {Promise<LH.Artifacts['Stacks']>}
   */
  static async collectStacks(executionContext) {
    const status = {msg: 'Collect stacks', id: 'lh:gather:collectStacks'};
    log.time(status);

    const jsLibraries = await executionContext.evaluate(detectLibraries, {
      args: [],
      deps: [libDetectorSource],
    });

    /** @type {LH.Artifacts['Stacks']} */
    const stacks = jsLibraries.map(lib => ({
      detector: 'js',
      id: lib.id,
      name: lib.name,
      version: typeof lib.version === 'number' ? String(lib.version) : (lib.version || undefined),
      npm: lib.npm || undefined,
    }));
    log.timeEnd(status);
    return stacks;
  }

  /**
   * @param {LH.Gatherer.FRTransitionalContext} context
   * @return {Promise<LH.Artifacts['Stacks']>}
   */
  async snapshot(context) {
    return Stacks.collectStacks(context.driver.executionContext);
  }
}

module.exports = Stacks;

},{"../../fraggle-rock/gather/base-gatherer.js":60,"lighthouse-logger":188}],"../gather/gatherers/trace-compat":[function(require,module,exports){
/**
 * @license Copyright 2021 The Lighthouse Authors. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.
 */
'use strict';

/**
 * @fileoverview
 * This gatherer remaps the result of the Trace gatherer for compatibility with legacy Lighthouse
 * when devtools logs and traces were special-cased.
 */

const TraceGatherer = require('./trace.js');
const FRGatherer = require('../../fraggle-rock/gather/base-gatherer.js');

/** @implements {LH.Gatherer.FRGathererInstance<'Trace'>} */
class TraceCompat extends FRGatherer {
  /** @type {LH.Gatherer.GathererMeta<'Trace'>} */
  meta = {
    supportedModes: ['timespan', 'navigation'],
    dependencies: {Trace: TraceGatherer.symbol},
  };

  /**
   * @param {LH.Gatherer.FRTransitionalContext<'Trace'>} passContext
   * @return {Promise<LH.Artifacts['traces']>}
   */
  async getArtifact(passContext) {
    return {
      defaultPass: passContext.dependencies.Trace,
    };
  }
}

module.exports = TraceCompat;

},{"../../fraggle-rock/gather/base-gatherer.js":60,"./trace.js":"../gather/gatherers/trace"}],"../gather/gatherers/trace-elements":[function(require,module,exports){
/**
 * @license Copyright 2020 The Lighthouse Authors. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.
 */
'use strict';

/* global getNodeDetails */

/**
 * @fileoverview
 * This gatherer identifies elements that contribrute to metrics in the trace (LCP, CLS, etc.).
 * We take the backend nodeId from the trace and use it to find the corresponding element in the DOM.
 */

const FRGatherer = require('../../fraggle-rock/gather/base-gatherer.js');
const {resolveNodeIdToObjectId} = require('../driver/dom.js');
const pageFunctions = require('../../lib/page-functions.js');
const RectHelpers = require('../../lib/rect-helpers.js');
const Sentry = require('../../lib/sentry.js');
const Trace = require('./trace.js');
const ProcessedTrace = require('../../computed/processed-trace.js');
const ProcessedNavigation = require('../../computed/processed-navigation.js');
const LighthouseError = require('../../lib/lh-error.js');

/** @typedef {{nodeId: number, score?: number, animations?: {name?: string, failureReasonsMask?: number, unsupportedProperties?: string[]}[]}} TraceElementData */

/**
 * @this {HTMLElement}
 */
/* c8 ignore start */
function getNodeDetailsData() {
  const elem = this.nodeType === document.ELEMENT_NODE ? this : this.parentElement; // eslint-disable-line no-undef
  let traceElement;
  if (elem) {
    // @ts-expect-error - getNodeDetails put into scope via stringification
    traceElement = {node: getNodeDetails(elem)};
  }
  return traceElement;
}
/* c8 ignore stop */

class TraceElements extends FRGatherer {
  /** @type {LH.Gatherer.GathererMeta<'Trace'>} */
  meta = {
    supportedModes: ['timespan', 'navigation'],
    dependencies: {Trace: Trace.symbol},
  }

  /** @type {Map<string, string>} */
  animationIdToName = new Map();

  constructor() {
    super();
    this._onAnimationStarted = this._onAnimationStarted.bind(this);
  }

  /** @param {LH.Crdp.Animation.AnimationStartedEvent} args */
  _onAnimationStarted({animation: {id, name}}) {
    if (name) this.animationIdToName.set(id, name);
  }

  /**
   * @param {LH.TraceEvent | undefined} event
   * @return {number | undefined}
   */
  static getNodeIDFromTraceEvent(event) {
    return event && event.args &&
      event.args.data && event.args.data.nodeId;
  }

  /**
   * @param {LH.TraceEvent | undefined} event
   * @return {string | undefined}
   */
  static getAnimationIDFromTraceEvent(event) {
    return event && event.args &&
      event.args.data && event.args.data.id;
  }

  /**
   * @param {LH.TraceEvent | undefined} event
   * @return {number | undefined}
   */
  static getFailureReasonsFromTraceEvent(event) {
    return event && event.args &&
      event.args.data && event.args.data.compositeFailed;
  }

  /**
   * @param {LH.TraceEvent | undefined} event
   * @return {string[] | undefined}
   */
  static getUnsupportedPropertiesFromTraceEvent(event) {
    return event && event.args &&
      event.args.data && event.args.data.unsupportedProperties;
  }

  /**
   * @param {Array<number>} rect
   * @return {LH.Artifacts.Rect}
   */
  static traceRectToLHRect(rect) {
    const rectArgs = {
      x: rect[0],
      y: rect[1],
      width: rect[2],
      height: rect[3],
    };
    return RectHelpers.addRectTopAndBottom(rectArgs);
  }

  /**
   * This function finds the top (up to 5) elements that contribute to the CLS score of the page.
   * Each layout shift event has a 'score' which is the amount added to the CLS as a result of the given shift(s).
   * We calculate the score per element by taking the 'score' of each layout shift event and
   * distributing it between all the nodes that were shifted, proportianal to the impact region of
   * each shifted element.
   * @param {Array<LH.TraceEvent>} mainThreadEvents
   * @return {Array<TraceElementData>}
   */
  static getTopLayoutShiftElements(mainThreadEvents) {
    /** @type {Map<number, number>} */
    const clsPerNode = new Map();
    const shiftEvents = mainThreadEvents
      .filter(e => e.name === 'LayoutShift')
      .map(e => e.args && e.args.data);
    const indexFirstEventWithoutInput =
      shiftEvents.findIndex(event => event && !event.had_recent_input);

    shiftEvents.forEach((event, index) => {
      if (!event || !event.impacted_nodes || !event.score) {
        return;
      }

      // Ignore events with input, unless it's one of the initial events.
      // See comment in computed/metrics/cumulative-layout-shift.js.
      if (indexFirstEventWithoutInput !== -1 && index >= indexFirstEventWithoutInput) {
        if (event.had_recent_input) return;
      }

      let totalAreaOfImpact = 0;
      /** @type {Map<number, number>} */
      const pixelsMovedPerNode = new Map();

      event.impacted_nodes.forEach(node => {
        if (!node.node_id || !node.old_rect || !node.new_rect) {
          return;
        }

        const oldRect = TraceElements.traceRectToLHRect(node.old_rect);
        const newRect = TraceElements.traceRectToLHRect(node.new_rect);
        const areaOfImpact = RectHelpers.getRectArea(oldRect) +
          RectHelpers.getRectArea(newRect) -
          RectHelpers.getRectOverlapArea(oldRect, newRect);

        pixelsMovedPerNode.set(node.node_id, areaOfImpact);
        totalAreaOfImpact += areaOfImpact;
      });

      for (const [nodeId, pixelsMoved] of pixelsMovedPerNode.entries()) {
        let clsContribution = clsPerNode.get(nodeId) || 0;
        clsContribution += (pixelsMoved / totalAreaOfImpact) * event.score;
        clsPerNode.set(nodeId, clsContribution);
      }
    });

    const topFive = [...clsPerNode.entries()]
    .sort((a, b) => b[1] - a[1])
    .slice(0, 5)
    .map(([nodeId, clsContribution]) => {
      return {
        nodeId: nodeId,
        score: clsContribution,
      };
    });

    return topFive;
  }

  /**
   * Find the node ids of elements which are animated using the Animation trace events.
   * @param {Array<LH.TraceEvent>} mainThreadEvents
   * @return {Promise<Array<TraceElementData>>}
   */
  async getAnimatedElements(mainThreadEvents) {
    /** @type {Map<string, {begin: LH.TraceEvent | undefined, status: LH.TraceEvent | undefined}>} */
    const animationPairs = new Map();
    for (const event of mainThreadEvents) {
      if (event.name !== 'Animation') continue;

      if (!event.id2 || !event.id2.local) continue;
      const local = event.id2.local;

      const pair = animationPairs.get(local) || {begin: undefined, status: undefined};
      if (event.ph === 'b') {
        pair.begin = event;
      } else if (
        event.ph === 'n' &&
          event.args.data &&
          event.args.data.compositeFailed !== undefined) {
        pair.status = event;
      }
      animationPairs.set(local, pair);
    }

    /** @type {Map<number, Set<{animationId: string, failureReasonsMask?: number, unsupportedProperties?: string[]}>>} */
    const elementAnimations = new Map();
    for (const {begin, status} of animationPairs.values()) {
      const nodeId = TraceElements.getNodeIDFromTraceEvent(begin);
      const animationId = TraceElements.getAnimationIDFromTraceEvent(begin);
      const failureReasonsMask = TraceElements.getFailureReasonsFromTraceEvent(status);
      const unsupportedProperties = TraceElements.getUnsupportedPropertiesFromTraceEvent(status);
      if (!nodeId || !animationId) continue;
      const animationIds = elementAnimations.get(nodeId) || new Set();
      animationIds.add({animationId, failureReasonsMask, unsupportedProperties});
      elementAnimations.set(nodeId, animationIds);
    }

    /** @type {Array<TraceElementData>} */
    const animatedElementData = [];
    for (const [nodeId, animationIds] of elementAnimations) {
      const animations = [];
      for (const {animationId, failureReasonsMask, unsupportedProperties} of animationIds) {
        const animationName = this.animationIdToName.get(animationId);
        animations.push({name: animationName, failureReasonsMask, unsupportedProperties});
      }
      animatedElementData.push({nodeId, animations});
    }
    return animatedElementData;
  }

  /**
   * @param {LH.Gatherer.FRTransitionalContext} context
   */
  async startInstrumentation(context) {
    await context.driver.defaultSession.sendCommand('Animation.enable');
    context.driver.defaultSession.on('Animation.animationStarted', this._onAnimationStarted);
  }

  /**
   * @param {LH.Gatherer.FRTransitionalContext} context
   */
  async stopInstrumentation(context) {
    context.driver.defaultSession.off('Animation.animationStarted', this._onAnimationStarted);
    await context.driver.defaultSession.sendCommand('Animation.disable');
  }

  /**
   * @param {LH.Gatherer.FRTransitionalContext} context
   * @param {LH.Trace|undefined} trace
   * @return {Promise<LH.Artifacts['TraceElements']>}
   */
  async _getArtifact(context, trace) {
    const session = context.driver.defaultSession;
    if (!trace) {
      throw new Error('Trace is missing!');
    }

    const processedTrace = await ProcessedTrace.request(trace, context);
    const {largestContentfulPaintEvt} = await ProcessedNavigation
      .request(processedTrace, context)
      .catch(err => {
        // If we were running in timespan mode and there was no paint, treat LCP as missing.
        if (context.gatherMode === 'timespan' && err.code === LighthouseError.errors.NO_FCP.code) {
          return {largestContentfulPaintEvt: undefined};
        }

        throw err;
      });
    const {mainThreadEvents} = processedTrace;

    const lcpNodeId = TraceElements.getNodeIDFromTraceEvent(largestContentfulPaintEvt);
    const clsNodeData = TraceElements.getTopLayoutShiftElements(mainThreadEvents);
    const animatedElementData =
      await this.getAnimatedElements(mainThreadEvents);

    /** @type {Map<string, TraceElementData[]>} */
    const backendNodeDataMap = new Map([
      ['largest-contentful-paint', lcpNodeId ? [{nodeId: lcpNodeId}] : []],
      ['layout-shift', clsNodeData],
      ['animation', animatedElementData],
    ]);

    const traceElements = [];
    for (const [traceEventType, backendNodeData] of backendNodeDataMap) {
      for (let i = 0; i < backendNodeData.length; i++) {
        const backendNodeId = backendNodeData[i].nodeId;
        let response;
        try {
          const objectId = await resolveNodeIdToObjectId(session, backendNodeId);
          if (!objectId) continue;
          response = await session.sendCommand('Runtime.callFunctionOn', {
            objectId,
            functionDeclaration: `function () {
              ${getNodeDetailsData.toString()};
              ${pageFunctions.getNodeDetailsString};
              return getNodeDetailsData.call(this);
            }`,
            returnByValue: true,
            awaitPromise: true,
          });
        } catch (err) {
          Sentry.captureException(err, {
            tags: {gatherer: this.name},
            level: 'error',
          });
          continue;
        }

        if (response && response.result && response.result.value) {
          traceElements.push({
            traceEventType,
            ...response.result.value,
            score: backendNodeData[i].score,
            animations: backendNodeData[i].animations,
            nodeId: backendNodeId,
          });
        }
      }
    }

    return traceElements;
  }

  /**
   * @param {LH.Gatherer.FRTransitionalContext<'Trace'>} context
   * @return {Promise<LH.Artifacts.TraceElement[]>}
   */
  async getArtifact(context) {
    return this._getArtifact(context, context.dependencies.Trace);
  }

  /**
   * @param {LH.Gatherer.PassContext} passContext
   * @param {LH.Gatherer.LoadData} loadData
   * @return {Promise<LH.Artifacts.TraceElement[]>}
   */
  async afterPass(passContext, loadData) {
    const context = {...passContext, dependencies: {}};
    await this.stopInstrumentation(context);
    return this._getArtifact(context, loadData.trace);
  }
}

module.exports = TraceElements;

},{"../../computed/processed-navigation.js":42,"../../computed/processed-trace.js":43,"../../fraggle-rock/gather/base-gatherer.js":60,"../../lib/lh-error.js":103,"../../lib/page-functions.js":110,"../../lib/rect-helpers.js":111,"../../lib/sentry.js":112,"../driver/dom.js":65,"./trace.js":"../gather/gatherers/trace"}],"../gather/gatherers/trace":[function(require,module,exports){
/**
 * @license Copyright 2021 The Lighthouse Authors. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.
 */
'use strict';

/**
 * @fileoverview
 * This gatherer collects all network and page devtools protocol traffic during the timespan/navigation.
 * This protocol log can be used to recreate the network records using lib/network-recorder.js.
 */

const FRGatherer = require('../../fraggle-rock/gather/base-gatherer.js');
const TraceProcessor = require('../../lib/tracehouse/trace-processor.js');

class Trace extends FRGatherer {
  /** @type {LH.Trace} */
  _trace = {traceEvents: []};

  static getDefaultTraceCategories() {
    return [
      // Exclude default categories. We'll be selective to minimize trace size
      '-*',

      // Used instead of 'toplevel' in Chrome 71+
      'disabled-by-default-lighthouse',

      // Used for Cumulative Layout Shift metric
      'loading',

      // All compile/execute events are captured by parent events in devtools.timeline..
      // But the v8 category provides some nice context for only <0.5% of the trace size
      'v8',
      // Same situation here. This category is there for RunMicrotasks only, but with other teams
      // accidentally excluding microtasks, we don't want to assume a parent event will always exist
      'v8.execute',

      // For extracting UserTiming marks/measures
      'blink.user_timing',

      // Not mandatory but not used much
      'blink.console',

      // Most of the events we need are from these two categories
      'devtools.timeline',
      'disabled-by-default-devtools.timeline',

      // Up to 450 (https://goo.gl/rBfhn4) JPGs added to the trace
      'disabled-by-default-devtools.screenshot',

      // This doesn't add its own events, but adds a `stackTrace` property to devtools.timeline events
      'disabled-by-default-devtools.timeline.stack',

      // Additional categories used by devtools. Not used by Lighthouse, but included to facilitate
      // loading traces from Lighthouse into the Performance panel.
      'disabled-by-default-devtools.timeline.frame',
      'disabled-by-default-v8.cpu_profiler',
      'disabled-by-default-v8.cpu_profiler.hires',
      'latencyInfo',
    ];
  }

  /**
   * @param {LH.Gatherer.FRProtocolSession} session
   * @return {Promise<LH.Trace>}
   */
  static async endTraceAndCollectEvents(session) {
    /** @type {Array<LH.TraceEvent>} */
    const traceEvents = [];

    /**
     * Listener for when dataCollected events fire for each trace chunk
     * @param {LH.Crdp.Tracing.DataCollectedEvent} data
     */
    const dataListener = function(data) {
      traceEvents.push(...data.value);
    };
    session.on('Tracing.dataCollected', dataListener);

    return new Promise((resolve, reject) => {
      session.once('Tracing.tracingComplete', _ => {
        session.off('Tracing.dataCollected', dataListener);
        resolve({traceEvents});
      });

      session.sendCommand('Tracing.end').catch(reject);
    });
  }

  static symbol = Symbol('Trace');

  /** @type {LH.Gatherer.GathererMeta} */
  meta = {
    symbol: Trace.symbol,
    supportedModes: ['timespan', 'navigation'],
  };

  /**
   * @param {LH.Gatherer.FRTransitionalContext} passContext
   */
  async startSensitiveInstrumentation({driver, gatherMode}) {
    // TODO(FR-COMPAT): read additional trace categories from overall settings?
    // TODO(FR-COMPAT): check if CSS/DOM domains have been enabled in another session and warn?
    await driver.defaultSession.sendCommand('Page.enable');
    await driver.defaultSession.sendCommand('Tracing.start', {
      categories: Trace.getDefaultTraceCategories().join(','),
      options: 'sampling-frequency=10000', // 1000 is default and too slow.
    });

    if (gatherMode === 'timespan') {
      await driver.defaultSession.sendCommand('Tracing.recordClockSyncMarker',
        {syncId: TraceProcessor.TIMESPAN_MARKER_ID});
    }
  }

  /**
   * @param {LH.Gatherer.FRTransitionalContext} passContext
   */
  async stopSensitiveInstrumentation({driver}) {
    this._trace = await Trace.endTraceAndCollectEvents(driver.defaultSession);
  }

  getArtifact() {
    return this._trace;
  }
}

module.exports = Trace;

},{"../../fraggle-rock/gather/base-gatherer.js":60,"../../lib/tracehouse/trace-processor.js":119}],"../gather/gatherers/viewport-dimensions":[function(require,module,exports){
/**
 * @license Copyright 2016 The Lighthouse Authors. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.
 */
'use strict';

const FRGatherer = require('../../fraggle-rock/gather/base-gatherer.js');

/* global window */

/**
 * @return {LH.Artifacts.ViewportDimensions}
 */
/* c8 ignore start */
function getViewportDimensions() {
  // window.innerWidth to get the scrollable size of the window (irrespective of zoom)
  // window.outerWidth to get the size of the visible area
  // window.devicePixelRatio to get ratio of logical pixels to physical pixels
  return {
    innerWidth: window.innerWidth,
    innerHeight: window.innerHeight,
    outerWidth: window.outerWidth,
    outerHeight: window.outerHeight,
    devicePixelRatio: window.devicePixelRatio,
  };
}
/* c8 ignore stop */

class ViewportDimensions extends FRGatherer {
  /** @type {LH.Gatherer.GathererMeta} */
  meta = {
    supportedModes: ['snapshot', 'timespan', 'navigation'],
  }

  /**
   * @param {LH.Gatherer.FRTransitionalContext} passContext
   * @return {Promise<LH.Artifacts.ViewportDimensions>}
   */
  async getArtifact(passContext) {
    const driver = passContext.driver;

    const dimensions = await driver.executionContext.evaluate(getViewportDimensions, {
      args: [],
      useIsolation: true,
    });

    const allNumeric = Object.values(dimensions).every(Number.isFinite);
    if (!allNumeric) {
      const results = JSON.stringify(dimensions);
      throw new Error(`ViewportDimensions results were not numeric: ${results}`);
    }

    return dimensions;
  }
}

module.exports = ViewportDimensions;

},{"../../fraggle-rock/gather/base-gatherer.js":60}],"../gather/gatherers/web-app-manifest":[function(require,module,exports){
(function (Buffer){(function (){
/**
 * @license Copyright 2021 The Lighthouse Authors. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.
 */
'use strict';

const log = require('lighthouse-logger');
const manifestParser = require('../../lib/manifest-parser.js');
const FRGatherer = require('../../fraggle-rock/gather/base-gatherer.js');

class WebAppManifest extends FRGatherer {
  /** @type {LH.Gatherer.GathererMeta} */
  meta = {
    supportedModes: ['snapshot', 'navigation'],
  };

  /**
   * @param {LH.Gatherer.FRProtocolSession} session
   * @return {Promise<{url: string, data: string}|null>}
   */
  static async fetchAppManifest(session) {
    // In all environments but LR, Page.getAppManifest finishes very quickly.
    // In LR, there is a bug that causes this command to hang until outgoing
    // requests finish. This has been seen in long polling (where it will never
    // return) and when other requests take a long time to finish. We allow 10 seconds
    // for outgoing requests to finish. Anything more, and we continue the run without
    // a manifest.
    // Googlers, see: http://b/124008171
    session.setNextProtocolTimeout(10000);
    let response;
    try {
      response = await session.sendCommand('Page.getAppManifest');
    } catch (err) {
      if (err.code === 'PROTOCOL_TIMEOUT') {
        // LR will timeout fetching the app manifest in some cases, move on without one.
        // https://github.com/GoogleChrome/lighthouse/issues/7147#issuecomment-461210921
        log.error('WebAppManifest', 'Failed fetching manifest', err);
        return null;
      }

      throw err;
    }

    let data = response.data;

    // We're not reading `response.errors` however it may contain critical and noncritical
    // errors from Blink's manifest parser:
    //   https://chromedevtools.github.io/debugger-protocol-viewer/tot/Page/#type-AppManifestError
    if (!data) {
      // If the data is empty, the page had no manifest.
      return null;
    }

    const BOM_LENGTH = 3;
    const BOM_FIRSTCHAR = 65279;
    const isBomEncoded = data.charCodeAt(0) === BOM_FIRSTCHAR;

    if (isBomEncoded) {
      data = Buffer.from(data)
        .slice(BOM_LENGTH)
        .toString();
    }

    return {...response, data};
  }

  /**
   * Uses the debugger protocol to fetch the manifest from within the context of
   * the target page, reusing any credentials, emulation, etc, already established
   * there.
   *
   * Returns the parsed manifest or null if the page had no manifest. If the manifest
   * was unparseable as JSON, manifest.value will be undefined and manifest.warning
   * will have the reason. See manifest-parser.js for more information.
   *
   * @param {LH.Gatherer.FRProtocolSession} session
   * @param {string} pageUrl
   * @return {Promise<LH.Artifacts.Manifest|null>}
   */
  static async getWebAppManifest(session, pageUrl) {
    const status = {msg: 'Get webapp manifest', id: 'lh:gather:getWebAppManifest'};
    log.time(status);
    const response = await WebAppManifest.fetchAppManifest(session);
    if (!response) return null;
    const manifest = manifestParser(response.data, response.url, pageUrl);
    log.timeEnd(status);
    return manifest;
  }

  /**
   * @param {LH.Gatherer.FRTransitionalContext} context
   * @return {Promise<LH.Artifacts['WebAppManifest']>}
   */
  getArtifact(context) {
    const driver = context.driver;

    return WebAppManifest.getWebAppManifest(driver.defaultSession, context.url);
  }
}

module.exports = WebAppManifest;

}).call(this)}).call(this,require("buffer").Buffer)
},{"../../fraggle-rock/gather/base-gatherer.js":60,"../../lib/manifest-parser.js":105,"buffer":145,"lighthouse-logger":188}],1:[function(require,module,exports){
(function (global){(function (){
/**
 * @license Copyright 2016 The Lighthouse Authors. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.
 */
'use strict';

const lighthouse = require('../lighthouse-core/index.js');
const RawProtocol = require('../lighthouse-core/gather/connections/raw.js');
const log = require('lighthouse-logger');
const {registerLocaleData, lookupLocale} = require('../lighthouse-core/lib/i18n/i18n.js');
const constants = require('../lighthouse-core/config/constants.js');

/** @typedef {import('../lighthouse-core/gather/connections/connection.js')} Connection */

/**
 * Returns a config, which runs only certain categories.
 * Varies the config to use based on device.
 * If `lighthouse-plugin-publisher-ads` is in the list of
 * `categoryIDs` the plugin will also be run.
 * Counterpart to the CDT code that sets flags.
 * @see https://cs.chromium.org/chromium/src/third_party/devtools-frontend/src/front_end/lighthouse/LighthouseController.js?type=cs&q=%22const+RuntimeSettings%22+f:lighthouse+-f:out&g=0&l=250
 * @param {Array<string>} categoryIDs
 * @param {string} device
 * @return {LH.Config.Json}
 */
function createConfig(categoryIDs, device) {
  /** @type {LH.SharedFlagsSettings} */
  const settings = {
    onlyCategories: categoryIDs,
    // In DevTools, emulation is applied _before_ Lighthouse starts (to deal with viewport emulation bugs). go/xcnjf
    // As a result, we don't double-apply viewport emulation.
    screenEmulation: {disabled: true},
  };
  if (device === 'desktop') {
    settings.throttling = constants.throttling.desktopDense4G;
    // UA emulation, however, is lost in the protocol handover from devtools frontend to the lighthouse_worker. So it's always applied.
    settings.emulatedUserAgent = constants.userAgents.desktop;
    settings.formFactor = 'desktop';
  }

  return {
    extends: 'lighthouse:default',
    plugins: ['lighthouse-plugin-publisher-ads'],
    settings,
  };
}

/**
 * @param {RawProtocol.Port} port
 * @return {RawProtocol}
 */
function setUpWorkerConnection(port) {
  return new RawProtocol(port);
}

/** @param {(status: [string, string, string]) => void} listenCallback */
function listenForStatus(listenCallback) {
  log.events.addListener('status', listenCallback);
}

// For the bundle smoke test.
if (typeof module !== 'undefined' && module.exports) {
  // Ideally this could be exposed via browserify's `standalone`, but it doesn't
  // work for LH because of https://github.com/browserify/browserify/issues/968
  // Instead, since this file is only ever run in node for testing, expose a
  // bundle entry point as global.
  // @ts-expect-error
  global.runBundledLighthouse = lighthouse;
}

// Expose only in DevTools' worker
if (typeof self !== 'undefined') {
  // TODO: refactor and delete `global.isDevtools`.
  global.isDevtools = true;

  // @ts-expect-error
  self.setUpWorkerConnection = setUpWorkerConnection;
  // @ts-expect-error
  self.runLighthouse = lighthouse;
  // @ts-expect-error
  self.createConfig = createConfig;
  // @ts-expect-error
  self.listenForStatus = listenForStatus;
  // @ts-expect-error
  self.registerLocaleData = registerLocaleData;
  // @ts-expect-error
  self.lookupLocale = lookupLocale;
}

}).call(this)}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../lighthouse-core/config/constants.js":56,"../lighthouse-core/gather/connections/raw.js":62,"../lighthouse-core/index.js":78,"../lighthouse-core/lib/i18n/i18n.js":96,"lighthouse-logger":188}],2:[function(require,module,exports){
(function (__filename){(function (){
/**
 * @license Copyright 2017 The Lighthouse Authors. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.
 */
'use strict';

/**
 * @fileoverview Base class for all aXe audits. Provides a consistent way to
 * generate audit results using aXe rule names.
 */

const Audit = require('../audit.js');
const i18n = require('../../lib/i18n/i18n.js');

const UIStrings = {
  /** Label of a table column that identifies HTML elements that have failed an audit. */
  failingElementsHeader: 'Failing Elements',
};

const str_ = i18n.createMessageInstanceIdFn(__filename, UIStrings);

class AxeAudit extends Audit {
  /**
   * Base class for audit rules which reflect assessment performed by the aXe accessibility library
   * See https://github.com/dequelabs/axe-core/blob/6b444546cff492a62a70a74a8fc3c62bd4729400/doc/API.md#results-object for result type and format details
   *
   * @param {LH.Artifacts} artifacts Accessibility gatherer artifacts. Note that AxeAudit
   * expects the meta name for the class to match the rule id from aXe.
   * @return {LH.Audit.Product}
   */
  static audit(artifacts) {
    // Indicate if a test is not applicable.
    // This means aXe did not find any nodes which matched these checks.
    // Note in Lighthouse we use the phrasing "Not Applicable" (aXe uses "inapplicable", which sounds weird).
    const notApplicables = artifacts.Accessibility.notApplicable || [];
    const isNotApplicable = notApplicables.find(result => result.id === this.meta.id);
    if (isNotApplicable) {
      return {
        score: null,
        notApplicable: true,
      };
    }

    // Detect errors reported within aXe 'incomplete' results
    // aXe uses this result type to indicate errors, or rules which require manual investigation
    // If aXe reports an error, then bubble it up to the caller
    const incomplete = artifacts.Accessibility.incomplete || [];
    const incompleteResult = incomplete.find(result => result.id === this.meta.id);
    if (incompleteResult && incompleteResult.error) {
      return {
        score: null,
        errorMessage: `axe-core Error: ${incompleteResult.error.message || 'Unknown error'}`,
      };
    }

    const isInformative = this.meta.scoreDisplayMode === Audit.SCORING_MODES.INFORMATIVE;
    const violations = artifacts.Accessibility.violations || [];
    const failureCases = isInformative ? violations.concat(incomplete) : violations;
    const rule = failureCases.find(result => result.id === this.meta.id);
    const impact = rule && rule.impact;
    const tags = rule && rule.tags;

    // Handle absence of aXe failure results for informative rules as 'not applicable'
    // This scenario indicates that no action is required by the web property owner
    // Since there is no score impact from informative rules, display the rule as not applicable
    if (isInformative && !rule) {
      return {
        score: null,
        notApplicable: true,
      };
    }

    /** @type {LH.Audit.Details.Table['items']}>} */
    let items = [];
    if (rule && rule.nodes) {
      items = rule.nodes.map(axeNode => ({
        node: {
          ...Audit.makeNodeItem(axeNode.node),
          explanation: axeNode.failureSummary,
        },
      }));
    }

    /** @type {LH.Audit.Details.Table['headings']} */
    const headings = [
      {key: 'node', itemType: 'node', text: str_(UIStrings.failingElementsHeader)},
    ];

    /** @type {LH.Audit.Details.DebugData|undefined} */
    let debugData;
    if (impact || tags) {
      debugData = {
        type: 'debugdata',
        impact,
        tags,
      };
    }

    return {
      score: Number(rule === undefined),
      details: {...Audit.makeTableDetails(headings, items), debugData},
    };
  }
}

module.exports = AxeAudit;
module.exports.UIStrings = UIStrings;

}).call(this)}).call(this,"/lighthouse-core/audits/accessibility/axe-audit.js")
},{"../../lib/i18n/i18n.js":96,"../audit.js":3}],3:[function(require,module,exports){
/**
 * @license Copyright 2016 The Lighthouse Authors. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.
 */
'use strict';

const {isUnderTest} = require('../lib/lh-env.js');
const statistics = require('../lib/statistics.js');
const Util = require('../util-commonjs.js');

const DEFAULT_PASS = 'defaultPass';

/**
 * Clamp figure to 2 decimal places
 * @param {number} val
 * @return {number}
 */
const clampTo2Decimals = val => Math.round(val * 100) / 100;

class Audit {
  /**
   * @return {string}
   */
  static get DEFAULT_PASS() {
    return DEFAULT_PASS;
  }

  /**
   * @return {LH.Audit.ScoreDisplayModes}
   */
  static get SCORING_MODES() {
    return {
      NUMERIC: 'numeric',
      BINARY: 'binary',
      MANUAL: 'manual',
      INFORMATIVE: 'informative',
      NOT_APPLICABLE: 'notApplicable',
      ERROR: 'error',
    };
  }

  /**
   * @return {LH.Audit.Meta}
   */
  static get meta() {
    throw new Error('Audit meta information must be overridden.');
  }

  /**
   * @return {Object}
   */
  static get defaultOptions() {
    return {};
  }

  /* eslint-disable no-unused-vars */

  /**
   *
   * @param {LH.Artifacts} artifacts
   * @param {LH.Audit.Context} context
   * @return {LH.Audit.Product|Promise<LH.Audit.Product>}
   */
  static audit(artifacts, context) {
    throw new Error('audit() method must be overriden');
  }

  /* eslint-enable no-unused-vars */

  /**
   * Computes a score between 0 and 1 based on the measured `value`. Score is determined by
   * considering a log-normal distribution governed by two control points (the 10th
   * percentile value and the median value) and represents the percentage of sites that are
   * greater than `value`.
   * @param {{median: number, p10: number}} controlPoints
   * @param {number} value
   * @return {number}
   */
  static computeLogNormalScore(controlPoints, value) {
    const percentile = statistics.getLogNormalScore(controlPoints, value);
    return clampTo2Decimals(percentile);
  }

  /**
   * This catches typos in the `key` property of a heading definition of table/opportunity details.
   * Throws an error if any of keys referenced by headings don't exist in at least one of the items.
   *
   * @param {LH.Audit.Details.Table['headings']|LH.Audit.Details.Opportunity['headings']} headings
   * @param {LH.Audit.Details.Opportunity['items']|LH.Audit.Details.Table['items']} items
   */
  static assertHeadingKeysExist(headings, items) {
    // If there are no items, there's nothing to check.
    if (!items.length) return;
    // Only do this in tests for now.
    if (!isUnderTest) return;

    for (const heading of headings) {
      // `null` heading key means it's a column for subrows only
      if (heading.key === null) continue;

      const key = heading.key;
      if (items.some(item => key in item)) continue;
      throw new Error(`"${heading.key}" is missing from items`);
    }
  }

  /**
   * @param {LH.Audit.Details.Table['headings']} headings
   * @param {LH.Audit.Details.Table['items']} results
   * @param {LH.Audit.Details.Table['summary']=} summary
   * @return {LH.Audit.Details.Table}
   */
  static makeTableDetails(headings, results, summary) {
    if (results.length === 0) {
      return {
        type: 'table',
        headings: [],
        items: [],
        summary,
      };
    }

    Audit.assertHeadingKeysExist(headings, results);

    return {
      type: 'table',
      headings: headings,
      items: results,
      summary,
    };
  }

  /**
   * @param {LH.Audit.Details.List['items']} items
   * @return {LH.Audit.Details.List}
   */
  static makeListDetails(items) {
    return {
      type: 'list',
      items: items,
    };
  }

  /** @typedef {{
   * content: string;
   * title: string;
   * lineMessages: LH.Audit.Details.SnippetValue['lineMessages'];
   * generalMessages: LH.Audit.Details.SnippetValue['generalMessages'];
   * node?: LH.Audit.Details.NodeValue;
   * maxLineLength?: number;
   * maxLinesAroundMessage?: number;
   * }} SnippetInfo */
  /**
   * @param {SnippetInfo} snippetInfo
   * @return {LH.Audit.Details.SnippetValue}
   */
  static makeSnippetDetails({
    content,
    title,
    lineMessages,
    generalMessages,
    node,
    maxLineLength = 200,
    maxLinesAroundMessage = 20,
  }) {
    const allLines = Audit._makeSnippetLinesArray(content, maxLineLength);
    const lines = Util.filterRelevantLines(allLines, lineMessages, maxLinesAroundMessage);
    return {
      type: 'snippet',
      lines,
      title,
      lineMessages,
      generalMessages,
      lineCount: allLines.length,
      node,
    };
  }

  /**
   * @param {string} content
   * @param {number} maxLineLength
   * @return {LH.Audit.Details.SnippetValue['lines']}
   */
  static _makeSnippetLinesArray(content, maxLineLength) {
    return content.split('\n').map((line, lineIndex) => {
      const lineNumber = lineIndex + 1;
      /** @type LH.Audit.Details.SnippetValue['lines'][0] */
      const lineDetail = {
        content: line.slice(0, maxLineLength),
        lineNumber,
      };
      if (line.length > maxLineLength) {
        lineDetail.truncated = true;
      }
      return lineDetail;
    });
  }

  /**
   * @param {LH.Audit.Details.Opportunity['headings']} headings
   * @param {LH.Audit.Details.Opportunity['items']} items
   * @param {number} overallSavingsMs
   * @param {number=} overallSavingsBytes
   * @return {LH.Audit.Details.Opportunity}
   */
  static makeOpportunityDetails(headings, items, overallSavingsMs, overallSavingsBytes) {
    Audit.assertHeadingKeysExist(headings, items);

    return {
      type: 'opportunity',
      headings: items.length === 0 ? [] : headings,
      items,
      overallSavingsMs,
      overallSavingsBytes,
    };
  }

  /**
   * @param {LH.Artifacts.NodeDetails} node
   * @return {LH.Audit.Details.NodeValue}
   */
  static makeNodeItem(node) {
    return {
      type: 'node',
      lhId: node.lhId,
      path: node.devtoolsNodePath,
      selector: node.selector,
      boundingRect: node.boundingRect,
      snippet: node.snippet,
      nodeLabel: node.nodeLabel,
    };
  }

  /**
   * @param {LH.Artifacts.ConsoleMessage} entry
   * @return {LH.Audit.Details.SourceLocationValue | undefined}
   */
  static makeSourceLocationFromConsoleMessage(entry) {
    if (!entry.url) return;

    return {
      type: 'source-location',
      url: entry.url,
      urlProvider: 'network',
      line: entry.lineNumber || 0,
      column: entry.columnNumber || 0,
    };
  }

  /**
   * @param {number|null} score
   * @param {LH.Audit.ScoreDisplayMode} scoreDisplayMode
   * @param {string} auditId
   * @return {number|null}
   */
  static _normalizeAuditScore(score, scoreDisplayMode, auditId) {
    if (scoreDisplayMode !== Audit.SCORING_MODES.BINARY &&
        scoreDisplayMode !== Audit.SCORING_MODES.NUMERIC) {
      return null;
    }

    // Otherwise, score must be a number in [0, 1].
    if (score === null || !Number.isFinite(score)) {
      throw new Error(`Invalid score for ${auditId}: ${score}`);
    }
    if (score > 1) throw new Error(`Audit score for ${auditId} is > 1`);
    if (score < 0) throw new Error(`Audit score for ${auditId} is < 0`);

    score = clampTo2Decimals(score);

    return score;
  }

  /**
   * @param {typeof Audit} audit
   * @param {string | LH.IcuMessage} errorMessage
   * @return {LH.RawIcu<LH.Audit.Result>}
   */
  static generateErrorAuditResult(audit, errorMessage) {
    return Audit.generateAuditResult(audit, {
      score: null,
      errorMessage,
    });
  }

  /**
   * @param {typeof Audit} audit
   * @param {LH.Audit.Product} product
   * @return {LH.RawIcu<LH.Audit.Result>}
   */
  static generateAuditResult(audit, product) {
    if (product.score === undefined) {
      throw new Error('generateAuditResult requires a score');
    }

    // Default to binary scoring.
    let scoreDisplayMode = audit.meta.scoreDisplayMode || Audit.SCORING_MODES.BINARY;

    // But override if product contents require it.
    if (product.errorMessage) {
      // Error result.
      scoreDisplayMode = Audit.SCORING_MODES.ERROR;
    } else if (product.notApplicable) {
      // Audit was determined to not apply to the page.
      scoreDisplayMode = Audit.SCORING_MODES.NOT_APPLICABLE;
    }

    const score = Audit._normalizeAuditScore(product.score, scoreDisplayMode, audit.meta.id);

    let auditTitle = audit.meta.title;
    if (audit.meta.failureTitle) {
      if (score !== null && score < Util.PASS_THRESHOLD) {
        auditTitle = audit.meta.failureTitle;
      }
    }

    // The Audit.Product type is bifurcated to enforce numericUnit accompanying numericValue;
    // the existence of `numericUnit` is our discriminant.
    // Make ts happy and enforce this contract programmatically by only pulling numericValue off of
    // a `NumericProduct` type.
    const numericProduct = 'numericUnit' in product ? product : undefined;

    return {
      id: audit.meta.id,
      title: auditTitle,
      description: audit.meta.description,

      score,
      scoreDisplayMode,
      numericValue: numericProduct && numericProduct.numericValue,
      numericUnit: numericProduct && numericProduct.numericUnit,

      displayValue: product.displayValue,
      explanation: product.explanation,
      errorMessage: product.errorMessage,
      warnings: product.warnings,

      details: product.details,
    };
  }
}

module.exports = Audit;

},{"../lib/lh-env.js":102,"../lib/statistics.js":114,"../util-commonjs.js":124}],4:[function(require,module,exports){
(function (__filename){(function (){
/**
 * @license Copyright 2017 The Lighthouse Authors. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.
 */
'use strict';

const Audit = require('../audit.js');
const linearInterpolation = require('../../lib/statistics.js').linearInterpolation;
const Interactive = require('../../computed/metrics/lantern-interactive.js');
const i18n = require('../../lib/i18n/i18n.js');
const NetworkRecords = require('../../computed/network-records.js');
const LoadSimulator = require('../../computed/load-simulator.js');
const PageDependencyGraph = require('../../computed/page-dependency-graph.js');

const str_ = i18n.createMessageInstanceIdFn(__filename, {});

/** @typedef {import('../../lib/dependency-graph/simulator/simulator')} Simulator */
/** @typedef {import('../../lib/dependency-graph/base-node.js').Node} Node */

const WASTED_MS_FOR_AVERAGE = 300;
const WASTED_MS_FOR_POOR = 750;
const WASTED_MS_FOR_SCORE_OF_ZERO = 5000;

/**
 * @typedef {object} ByteEfficiencyProduct
 * @property {Array<LH.Audit.ByteEfficiencyItem>} items
 * @property {Map<string, number>=} wastedBytesByUrl
 * @property {LH.Audit.Details.Opportunity['headings']} headings
 * @property {LH.IcuMessage} [displayValue]
 * @property {LH.IcuMessage} [explanation]
 * @property {Array<string | LH.IcuMessage>} [warnings]
 */

/**
 * @overview Used as the base for all byte efficiency audits. Computes total bytes
 *    and estimated time saved. Subclass and override `audit_` to return results.
 */
class UnusedBytes extends Audit {
  /**
   * Creates a score based on the wastedMs value using linear interpolation between control points.
   *
   * @param {number} wastedMs
   * @return {number}
   */
  static scoreForWastedMs(wastedMs) {
    if (wastedMs === 0) {
      return 1;
    } else if (wastedMs < WASTED_MS_FOR_AVERAGE) {
      return linearInterpolation(0, 1, WASTED_MS_FOR_AVERAGE, 0.75, wastedMs);
    } else if (wastedMs < WASTED_MS_FOR_POOR) {
      return linearInterpolation(WASTED_MS_FOR_AVERAGE, 0.75, WASTED_MS_FOR_POOR, 0.5, wastedMs);
    } else {
      return Math.max(
        0,
        linearInterpolation(WASTED_MS_FOR_POOR, 0.5, WASTED_MS_FOR_SCORE_OF_ZERO, 0, wastedMs)
      );
    }
  }

  /**
   * Estimates the number of bytes this network record would have consumed on the network based on the
   * uncompressed size (totalBytes). Uses the actual transfer size from the network record if applicable.
   *
   * @param {LH.Artifacts.NetworkRequest|undefined} networkRecord
   * @param {number} totalBytes Uncompressed size of the resource
   * @param {LH.Crdp.Network.ResourceType=} resourceType
   * @return {number}
   */
  static estimateTransferSize(networkRecord, totalBytes, resourceType) {
    if (!networkRecord) {
      // We don't know how many bytes this asset used on the network, but we can guess it was
      // roughly the size of the content gzipped.
      // See https://developers.google.com/web/fundamentals/performance/optimizing-content-efficiency/optimize-encoding-and-transfer for specific CSS/Script examples
      // See https://discuss.httparchive.org/t/file-size-and-compression-savings/145 for fallback multipliers
      switch (resourceType) {
        case 'Stylesheet':
          // Stylesheets tend to compress extremely well.
          return Math.round(totalBytes * 0.2);
        case 'Script':
        case 'Document':
          // Scripts and HTML compress fairly well too.
          return Math.round(totalBytes * 0.33);
        default:
          // Otherwise we'll just fallback to the average savings in HTTPArchive
          return Math.round(totalBytes * 0.5);
      }
    } else if (networkRecord.resourceType === resourceType) {
      // This was a regular standalone asset, just use the transfer size.
      return networkRecord.transferSize || 0;
    } else {
      // This was an asset that was inlined in a different resource type (e.g. HTML document).
      // Use the compression ratio of the resource to estimate the total transferred bytes.
      const transferSize = networkRecord.transferSize || 0;
      const resourceSize = networkRecord.resourceSize || 0;
      // Get the compression ratio, if it's an invalid number, assume no compression.
      const compressionRatio = Number.isFinite(resourceSize) && resourceSize > 0 ?
        (transferSize / resourceSize) : 1;
      return Math.round(totalBytes * compressionRatio);
    }
  }

  /**
   * @param {LH.Artifacts} artifacts
   * @param {LH.Audit.Context} context
   * @return {Promise<LH.Audit.Product>}
   */
  static async audit(artifacts, context) {
    const gatherContext = artifacts.GatherContext;
    const trace = artifacts.traces[Audit.DEFAULT_PASS];
    const devtoolsLog = artifacts.devtoolsLogs[Audit.DEFAULT_PASS];
    const settings = context && context.settings || {};
    const simulatorOptions = {
      devtoolsLog,
      settings,
    };

    const networkRecords = await NetworkRecords.request(devtoolsLog, context);
    const [result, graph, simulator] = await Promise.all([
      this.audit_(artifacts, networkRecords, context),
      PageDependencyGraph.request({trace, devtoolsLog}, context),
      LoadSimulator.request(simulatorOptions, context),
    ]);

    return this.createAuditProduct(result, graph, simulator, gatherContext);
  }

  /**
   * Computes the estimated effect of all the byte savings on the maximum of the following:
   *
   * - end time of the last long task in the provided graph
   * - (if includeLoad is true or not provided) end time of the last node in the graph
   *
   * @param {Array<LH.Audit.ByteEfficiencyItem>} results The array of byte savings results per resource
   * @param {Node} graph
   * @param {Simulator} simulator
   * @param {{includeLoad?: boolean, label?: string, providedWastedBytesByUrl?: Map<string, number>}=} options
   * @return {number}
   */
  static computeWasteWithTTIGraph(results, graph, simulator, options) {
    options = Object.assign({includeLoad: true, label: this.meta.id}, options);
    const beforeLabel = `${options.label}-before`;
    const afterLabel = `${options.label}-after`;

    const simulationBeforeChanges = simulator.simulate(graph, {label: beforeLabel});

    const wastedBytesByUrl = options.providedWastedBytesByUrl || new Map();
    if (!options.providedWastedBytesByUrl) {
      for (const {url, wastedBytes} of results) {
        wastedBytesByUrl.set(url, (wastedBytesByUrl.get(url) || 0) + wastedBytes);
      }
    }

    // Update all the transfer sizes to reflect implementing our recommendations
    /** @type {Map<string, number>} */
    const originalTransferSizes = new Map();
    graph.traverse(node => {
      if (node.type !== 'network') return;
      const wastedBytes = wastedBytesByUrl.get(node.record.url);
      if (!wastedBytes) return;

      const original = node.record.transferSize;
      originalTransferSizes.set(node.record.requestId, original);

      node.record.transferSize = Math.max(original - wastedBytes, 0);
    });

    const simulationAfterChanges = simulator.simulate(graph, {label: afterLabel});

    // Restore the original transfer size after we've done our simulation
    graph.traverse(node => {
      if (node.type !== 'network') return;
      const originalTransferSize = originalTransferSizes.get(node.record.requestId);
      if (originalTransferSize === undefined) return;
      node.record.transferSize = originalTransferSize;
    });

    const savingsOnOverallLoad = simulationBeforeChanges.timeInMs - simulationAfterChanges.timeInMs;
    const savingsOnTTI = Interactive.getLastLongTaskEndTime(simulationBeforeChanges.nodeTimings) -
      Interactive.getLastLongTaskEndTime(simulationAfterChanges.nodeTimings);

    let savings = savingsOnTTI;
    if (options.includeLoad) savings = Math.max(savings, savingsOnOverallLoad);

    // Round waste to nearest 10ms
    return Math.round(Math.max(savings, 0) / 10) * 10;
  }

  /**
   * TODO(FR-COMPAT): Rework opportunities to remove emphasis on `wastedMs`
   * @param {number} wastedBytes
   * @param {Simulator} simulator
   */
  static computeWastedMsWithThroughput(wastedBytes, simulator) {
    const bitsPerSecond = simulator.getOptions().throughput;
    const wastedBits = wastedBytes * 8;
    const wastedMs = wastedBits / bitsPerSecond * 1000;
    return wastedMs;
  }

  /**
   * @param {ByteEfficiencyProduct} result
   * @param {Node} graph
   * @param {Simulator} simulator
   * @param {LH.Artifacts['GatherContext']} gatherContext
   * @return {LH.Audit.Product}
   */
  static createAuditProduct(result, graph, simulator, gatherContext) {
    const results = result.items.sort((itemA, itemB) => itemB.wastedBytes - itemA.wastedBytes);

    const wastedBytes = results.reduce((sum, item) => sum + item.wastedBytes, 0);
    const wastedMs = gatherContext.gatherMode === 'navigation' ?
      this.computeWasteWithTTIGraph(results, graph, simulator, {
        providedWastedBytesByUrl: result.wastedBytesByUrl,
      }) :
      this.computeWastedMsWithThroughput(wastedBytes, simulator);

    let displayValue = result.displayValue || '';
    if (typeof result.displayValue === 'undefined' && wastedBytes) {
      displayValue = str_(i18n.UIStrings.displayValueByteSavings, {wastedBytes});
    }

    const details = Audit.makeOpportunityDetails(result.headings, results, wastedMs, wastedBytes);

    return {
      explanation: result.explanation,
      warnings: result.warnings,
      displayValue,
      numericValue: wastedMs,
      numericUnit: 'millisecond',
      score: UnusedBytes.scoreForWastedMs(wastedMs),
      details,
    };
  }

  /* eslint-disable no-unused-vars */

  /**
   * @param {LH.Artifacts} artifacts
   * @param {Array<LH.Artifacts.NetworkRequest>} networkRecords
   * @param {LH.Audit.Context} context
   * @return {ByteEfficiencyProduct|Promise<ByteEfficiencyProduct>}
   */
  static audit_(artifacts, networkRecords, context) {
    throw new Error('audit_ unimplemented');
  }

  /* eslint-enable no-unused-vars */
}

module.exports = UnusedBytes;

}).call(this)}).call(this,"/lighthouse-core/audits/byte-efficiency/byte-efficiency-audit.js")
},{"../../computed/load-simulator.js":13,"../../computed/metrics/lantern-interactive.js":24,"../../computed/network-records.js":40,"../../computed/page-dependency-graph.js":41,"../../lib/i18n/i18n.js":96,"../../lib/statistics.js":114,"../audit.js":3}],5:[function(require,module,exports){
module.exports={
  "moduleSizes": [498, 155, 242, 615, 220, 657, 651, 1664, 790, 1534, 558, 279, 868, 974, 618, 356, 720, 133, 826, 732, 235, 552, 170, 585, 1030, 210, 349, 179, 546, 167, 1634, 118, 199, 478, 849, 470, 452, 417, 147, 60, 180, 433, 360, 303, 1325, 1518, 397, 201, 550, 226, 132, 156, 198, 312, 544, 2125, 658, 778, 1084, 701, 401, 81, 716, 632, 321, 428, 648, 804, 718, 130, 1443, 142, 374, 259, 286, 403, 821, 938, 514, 654, 280, 328, 186, 233, 243, 553, 267, 187, 206, 879, 105, 343, 779, 833, 773, 275, 477, 696, 224, 759, 671, 772, 746, 716, 182, 304, 658, 473, 592, 235, 334, 277, 404, 420, 280, 675, 1034, 508, 725, 526, 498, 498, 499, 752, 661, 276, 275, 843, 1698, 962, 562, 609, 573, 1048, 205, 374, 226, 625, 632, 308, 772, 641, 233],
  "dependencies": {
    "Array.prototype.fill": [3, 5, 8, 17, 19, 21, 22, 29, 30, 35, 38, 39, 40, 42, 43, 45, 48, 51, 52, 53, 55, 56, 58, 60, 61, 63, 64, 65, 68, 69, 70, 71, 72, 73, 74, 75, 80, 81, 82, 83, 84, 87, 88, 89, 91],
    "Array.prototype.filter": [1, 8, 9, 10, 12, 14, 17, 19, 21, 22, 27, 28, 29, 30, 33, 35, 38, 39, 42, 43, 45, 47, 48, 51, 52, 53, 58, 60, 61, 63, 65, 68, 69, 70, 71, 72, 73, 74, 75, 80, 81, 82, 83, 84, 87, 88, 89, 92],
    "Array.prototype.find": [1, 3, 8, 9, 12, 14, 17, 19, 21, 22, 29, 30, 33, 35, 38, 39, 40, 42, 43, 45, 47, 48, 51, 52, 53, 55, 56, 58, 60, 61, 63, 64, 65, 68, 69, 70, 71, 72, 73, 74, 75, 80, 81, 82, 83, 84, 87, 88, 89, 94],
    "Array.prototype.findIndex": [1, 3, 8, 9, 12, 14, 17, 19, 21, 22, 29, 30, 33, 35, 38, 39, 40, 42, 43, 45, 47, 48, 51, 52, 53, 55, 56, 58, 60, 61, 63, 64, 65, 68, 69, 70, 71, 72, 73, 74, 75, 80, 81, 82, 83, 84, 87, 88, 89, 93],
    "Array.prototype.forEach": [1, 6, 8, 9, 11, 12, 14, 17, 19, 21, 22, 29, 30, 33, 35, 38, 39, 42, 43, 45, 47, 48, 51, 52, 53, 58, 60, 61, 63, 65, 68, 69, 70, 71, 72, 73, 74, 75, 80, 81, 82, 83, 84, 87, 88, 89, 95],
    "Array.from": [1, 7, 8, 15, 16, 17, 18, 19, 21, 22, 23, 29, 30, 33, 35, 36, 38, 39, 42, 43, 45, 46, 48, 51, 52, 53, 58, 60, 61, 63, 65, 68, 69, 70, 71, 72, 73, 74, 75, 80, 81, 82, 83, 84, 86, 87, 88, 89, 96],
    "Array.isArray": [8, 17, 19, 21, 22, 29, 30, 35, 38, 39, 42, 43, 45, 47, 48, 51, 53, 58, 60, 61, 63, 65, 68, 69, 70, 71, 72, 73, 74, 75, 80, 81, 82, 83, 87, 98],
    "Array.prototype.map": [1, 8, 9, 10, 12, 14, 17, 19, 21, 22, 27, 28, 29, 30, 33, 35, 38, 39, 42, 43, 45, 47, 48, 51, 52, 53, 58, 60, 61, 63, 65, 68, 69, 70, 71, 72, 73, 74, 75, 80, 81, 82, 83, 84, 87, 88, 89, 99],
    "Array.of": [8, 17, 19, 21, 22, 23, 29, 30, 35, 38, 39, 42, 43, 45, 48, 51, 53, 58, 60, 61, 63, 65, 68, 69, 70, 71, 72, 73, 74, 75, 80, 81, 82, 83, 87, 100],
    "Array.prototype.reduce": [1, 8, 11, 12, 13, 17, 19, 21, 22, 29, 30, 35, 38, 39, 42, 43, 45, 48, 51, 53, 58, 60, 61, 63, 65, 68, 69, 70, 71, 72, 73, 74, 75, 80, 81, 82, 83, 84, 87, 102],
    "Array.prototype.reduceRight": [1, 8, 11, 12, 13, 17, 19, 21, 22, 29, 30, 35, 38, 39, 42, 43, 45, 48, 51, 53, 58, 60, 61, 63, 65, 68, 69, 70, 71, 72, 73, 74, 75, 80, 81, 82, 83, 84, 87, 101],
    "Array.prototype.some": [1, 8, 9, 11, 12, 14, 17, 19, 21, 22, 29, 30, 33, 35, 38, 39, 42, 43, 45, 47, 48, 51, 52, 53, 58, 60, 61, 63, 65, 68, 69, 70, 71, 72, 73, 74, 75, 80, 81, 82, 83, 84, 87, 88, 89, 103],
    "Date.now": [8, 17, 19, 21, 22, 29, 30, 35, 38, 39, 42, 43, 45, 48, 51, 53, 58, 60, 61, 63, 65, 68, 69, 70, 71, 72, 73, 74, 75, 80, 81, 82, 83, 87, 104],
    "Date.prototype.toISOString": [8, 17, 19, 21, 22, 24, 29, 30, 35, 38, 39, 42, 43, 45, 48, 51, 53, 58, 60, 61, 63, 65, 68, 69, 70, 71, 72, 73, 74, 75, 77, 78, 80, 81, 82, 83, 87, 105],
    "Date.prototype.toJSON": [8, 17, 19, 21, 22, 29, 30, 35, 38, 39, 42, 43, 45, 48, 51, 53, 58, 60, 61, 63, 65, 68, 69, 70, 71, 72, 73, 74, 75, 80, 81, 82, 83, 84, 87, 106],
    "Date.prototype.toString": [21, 22, 38, 39, 43, 45, 51, 53, 70, 72, 73, 74, 75, 87, 107],
    "Function.prototype.name": [108],
    "Number.isInteger": [8, 17, 19, 21, 22, 29, 30, 35, 38, 39, 42, 43, 45, 48, 49, 51, 53, 58, 60, 61, 63, 65, 68, 69, 70, 71, 72, 73, 74, 75, 80, 81, 82, 83, 87, 109],
    "Number.isSafeInteger": [8, 17, 19, 21, 22, 29, 30, 35, 38, 39, 42, 43, 45, 48, 49, 51, 53, 58, 60, 61, 63, 65, 68, 69, 70, 71, 72, 73, 74, 75, 80, 81, 82, 83, 87, 110],
    "Number.parseInt": [8, 17, 19, 21, 22, 29, 30, 35, 38, 39, 42, 43, 45, 48, 51, 53, 54, 58, 60, 61, 63, 65, 68, 69, 70, 71, 72, 73, 74, 75, 79, 80, 81, 82, 83, 87, 90, 111],
    "Object.defineProperties": [8, 17, 19, 21, 22, 29, 30, 35, 38, 39, 42, 43, 45, 48, 51, 53, 56, 58, 60, 61, 63, 64, 65, 68, 69, 70, 71, 72, 73, 74, 75, 80, 81, 82, 83, 87, 112],
    "Object.defineProperty": [8, 17, 19, 21, 22, 29, 30, 35, 38, 39, 42, 43, 45, 48, 51, 53, 58, 60, 61, 63, 65, 68, 69, 70, 71, 72, 73, 74, 75, 80, 81, 82, 83, 87, 113],
    "Object.freeze": [8, 17, 19, 21, 22, 29, 30, 32, 35, 38, 39, 42, 43, 44, 45, 48, 51, 53, 58, 60, 61, 63, 65, 68, 69, 70, 71, 72, 73, 74, 75, 80, 81, 82, 83, 87, 115],
    "Object.getOwnPropertyNames": [8, 17, 19, 21, 22, 29, 30, 35, 38, 39, 42, 43, 45, 48, 51, 53, 58, 59, 60, 61, 63, 65, 68, 69, 70, 71, 72, 73, 74, 75, 80, 81, 82, 83, 87, 117],
    "Object.getPrototypeOf": [8, 17, 19, 20, 21, 22, 29, 30, 35, 38, 39, 42, 43, 45, 48, 51, 53, 58, 60, 61, 62, 63, 65, 68, 69, 70, 71, 72, 73, 74, 75, 80, 81, 82, 83, 84, 87, 118],
    "Object.isExtensible": [8, 17, 19, 21, 22, 29, 30, 35, 38, 39, 42, 43, 45, 48, 51, 53, 58, 60, 61, 63, 65, 68, 69, 70, 71, 72, 73, 74, 75, 80, 81, 82, 83, 87, 119],
    "Object.isFrozen": [8, 17, 19, 21, 22, 29, 30, 35, 38, 39, 42, 43, 45, 48, 51, 53, 58, 60, 61, 63, 65, 68, 69, 70, 71, 72, 73, 74, 75, 80, 81, 82, 83, 87, 120],
    "Object.isSealed": [8, 17, 19, 21, 22, 29, 30, 35, 38, 39, 42, 43, 45, 48, 51, 53, 58, 60, 61, 63, 65, 68, 69, 70, 71, 72, 73, 74, 75, 80, 81, 82, 83, 87, 121],
    "Object.keys": [8, 17, 19, 21, 22, 29, 30, 35, 38, 39, 42, 43, 45, 48, 51, 53, 58, 60, 61, 63, 64, 65, 68, 69, 70, 71, 72, 73, 74, 75, 80, 81, 82, 83, 84, 87, 122],
    "Object.preventExtensions": [8, 17, 19, 21, 22, 29, 30, 32, 35, 38, 39, 42, 43, 44, 45, 48, 51, 53, 58, 60, 61, 63, 65, 68, 69, 70, 71, 72, 73, 74, 75, 80, 81, 82, 83, 87, 123],
    "Object.seal": [8, 17, 19, 21, 22, 29, 30, 32, 35, 38, 39, 42, 43, 44, 45, 48, 51, 53, 58, 60, 61, 63, 65, 68, 69, 70, 71, 72, 73, 74, 75, 80, 81, 82, 83, 87, 124],
    "Object.setPrototypeOf": [2, 8, 17, 19, 21, 22, 29, 30, 35, 38, 39, 42, 43, 45, 48, 51, 53, 58, 60, 61, 63, 65, 66, 68, 69, 70, 71, 72, 73, 74, 75, 80, 81, 82, 83, 87, 125],
    "Reflect.apply": [1, 8, 17, 19, 21, 22, 29, 30, 35, 38, 39, 42, 43, 45, 48, 51, 53, 58, 60, 61, 63, 65, 68, 69, 70, 71, 72, 73, 74, 75, 80, 81, 82, 83, 87, 127],
    "Reflect.construct": [1, 8, 17, 19, 21, 22, 29, 30, 34, 35, 38, 39, 40, 42, 43, 45, 48, 51, 53, 55, 56, 58, 60, 61, 63, 64, 65, 68, 69, 70, 71, 72, 73, 74, 75, 80, 81, 82, 83, 87, 128],
    "Reflect.defineProperty": [8, 17, 19, 21, 22, 29, 30, 35, 38, 39, 42, 43, 45, 48, 51, 53, 58, 60, 61, 63, 65, 68, 69, 70, 71, 72, 73, 74, 75, 80, 81, 82, 83, 87, 129],
    "Reflect.deleteProperty": [8, 17, 19, 21, 22, 29, 30, 35, 38, 39, 42, 43, 45, 48, 51, 53, 58, 60, 61, 63, 65, 68, 69, 70, 71, 72, 73, 74, 75, 80, 81, 82, 83, 87, 130],
    "Reflect.get": [8, 17, 19, 20, 21, 22, 29, 30, 35, 38, 39, 42, 43, 45, 48, 51, 53, 58, 60, 61, 62, 63, 65, 68, 69, 70, 71, 72, 73, 74, 75, 80, 81, 82, 83, 84, 87, 133],
    "Reflect.getOwnPropertyDescriptor": [8, 17, 19, 21, 22, 29, 30, 35, 38, 39, 42, 43, 45, 48, 51, 53, 58, 60, 61, 63, 65, 68, 69, 70, 71, 72, 73, 74, 75, 80, 81, 82, 83, 87, 131],
    "Reflect.getPrototypeOf": [8, 17, 19, 20, 21, 22, 29, 30, 35, 38, 39, 42, 43, 45, 48, 51, 53, 58, 60, 61, 62, 63, 65, 68, 69, 70, 71, 72, 73, 74, 75, 80, 81, 82, 83, 84, 87, 132],
    "Reflect.has": [8, 17, 19, 21, 22, 29, 30, 35, 38, 39, 42, 43, 45, 48, 51, 53, 58, 60, 61, 63, 65, 68, 69, 70, 71, 72, 73, 74, 75, 80, 81, 82, 83, 87, 134],
    "Reflect.isExtensible": [8, 17, 19, 21, 22, 29, 30, 35, 38, 39, 42, 43, 45, 48, 51, 53, 58, 60, 61, 63, 65, 68, 69, 70, 71, 72, 73, 74, 75, 80, 81, 82, 83, 87, 135],
    "Reflect.ownKeys": [8, 17, 19, 21, 22, 29, 30, 35, 38, 39, 42, 43, 45, 48, 51, 53, 58, 60, 61, 63, 65, 68, 69, 70, 71, 72, 73, 74, 75, 80, 81, 82, 83, 87, 136],
    "Reflect.preventExtensions": [8, 17, 19, 21, 22, 29, 30, 32, 35, 38, 39, 42, 43, 45, 48, 51, 53, 58, 60, 61, 63, 65, 68, 69, 70, 71, 72, 73, 74, 75, 80, 81, 82, 83, 87, 137],
    "Reflect.setPrototypeOf": [2, 8, 17, 19, 21, 22, 29, 30, 35, 38, 39, 42, 43, 45, 48, 51, 53, 58, 60, 61, 63, 65, 66, 68, 69, 70, 71, 72, 73, 74, 75, 80, 81, 82, 83, 87, 138],
    "String.prototype.codePointAt": [8, 17, 19, 21, 22, 29, 30, 35, 38, 39, 42, 43, 45, 48, 51, 53, 58, 60, 61, 63, 65, 68, 69, 70, 71, 72, 73, 74, 75, 76, 80, 81, 82, 83, 87, 139],
    "String.fromCodePoint": [8, 17, 19, 21, 22, 29, 30, 35, 38, 39, 42, 43, 45, 48, 51, 53, 58, 60, 61, 63, 65, 68, 69, 70, 71, 72, 73, 74, 75, 80, 81, 82, 83, 87, 140],
    "String.raw": [8, 17, 19, 21, 22, 29, 30, 35, 38, 39, 42, 43, 45, 48, 51, 53, 58, 60, 61, 63, 65, 68, 69, 70, 71, 72, 73, 74, 75, 80, 81, 82, 83, 87, 141],
    "String.prototype.repeat": [8, 17, 19, 21, 22, 29, 30, 35, 38, 39, 42, 43, 45, 48, 51, 53, 58, 60, 61, 63, 65, 68, 69, 70, 71, 72, 73, 74, 75, 78, 80, 81, 82, 83, 87, 142],
    "Array.prototype.includes": [3, 8, 12, 17, 19, 21, 22, 29, 30, 35, 38, 39, 40, 42, 43, 45, 48, 51, 52, 53, 55, 56, 58, 60, 61, 63, 64, 65, 68, 69, 70, 71, 72, 73, 74, 75, 80, 81, 82, 83, 87, 88, 89, 97],
    "Object.entries": [8, 17, 19, 21, 22, 29, 30, 35, 38, 39, 42, 43, 45, 48, 51, 53, 58, 60, 61, 63, 64, 65, 67, 68, 69, 70, 71, 72, 73, 74, 75, 80, 81, 82, 83, 87, 114],
    "Object.getOwnPropertyDescriptors": [8, 17, 19, 21, 22, 23, 29, 30, 35, 38, 39, 42, 43, 45, 48, 51, 53, 58, 60, 61, 63, 65, 68, 69, 70, 71, 72, 73, 74, 75, 80, 81, 82, 83, 87, 116],
    "Object.values": [8, 17, 19, 21, 22, 29, 30, 35, 38, 39, 42, 43, 45, 48, 51, 53, 58, 60, 61, 63, 64, 65, 67, 68, 69, 70, 71, 72, 73, 74, 75, 80, 81, 82, 83, 87, 126]
  },
  "maxSize": 77759,
  "baseSize": 3708
}

},{}],6:[function(require,module,exports){
/**
 * @license Copyright 2017 The Lighthouse Authors. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.
 */
'use strict';

/**
 * @fileoverview Base class for audits that the user should verify manually on
 * their site.
 */

const Audit = require('../audit.js');

class ManualAudit extends Audit {
  /**
   * @return {Pick<LH.Audit.Meta, 'scoreDisplayMode'|'requiredArtifacts'>}
   */
  static get partialMeta() {
    return {
      scoreDisplayMode: Audit.SCORING_MODES.MANUAL,
      requiredArtifacts: [],
    };
  }

  /**
   * @return {LH.Audit.Product}
   */
  static audit() {
    return {
      score: 0,
      // displayValue: '(needs manual verification)'
    };
  }
}

module.exports = ManualAudit;

},{"../audit.js":3}],7:[function(require,module,exports){
/**
 * @license Copyright 2017 The Lighthouse Authors. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.
 */
'use strict';

/**
 * @fileoverview Base class for boolean audits that can have multiple reasons for failure
 */

const Audit = require('./audit.js');

class MultiCheckAudit extends Audit {
  /**
   * @param {LH.Artifacts} artifacts
   * @param {LH.Audit.Context} context
   * @return {Promise<LH.Audit.Product>}
   */
  static async audit(artifacts, context) {
    const multiProduct = await this.audit_(artifacts, context);
    return this.createAuditProduct(multiProduct);
  }

  /**
   * @param {{failures: Array<string>, manifestValues?: LH.Artifacts.ManifestValues}} result
   * @return {LH.Audit.Product}
   */
  static createAuditProduct(result) {
    /** @type {LH.Audit.MultiCheckAuditDetails} */
    const detailsItem = {
      ...result,
      ...result.manifestValues,
      manifestValues: undefined,
      allChecks: undefined,
    };

    if (result.manifestValues && result.manifestValues.allChecks) {
      result.manifestValues.allChecks.forEach(check => {
        detailsItem[check.id] = check.passing;
      });
    }

    // Include the detailed pass/fail checklist as a diagnostic.
    /** @type {LH.Audit.Details.DebugData} */
    const details = {
      type: 'debugdata',
      // TODO: Consider not nesting detailsItem under `items`.
      items: [detailsItem],
    };

    // If we fail, share the failures
    if (result.failures.length > 0) {
      return {
        score: 0,
        // TODO(#11495): make this i18n-able.
        explanation: `Failures: ${result.failures.join(',\n')}.`,
        details,
      };
    }

    // Otherwise, we pass
    return {
      score: 1,
      details,
    };
  }

  /* eslint-disable no-unused-vars */

  /**
   * @param {LH.Artifacts} artifacts
   * @param {LH.Audit.Context} context
   * @return {Promise<{failures: Array<string>, manifestValues?: LH.Artifacts.ManifestValues}>}
   */
  static audit_(artifacts, context) {
    throw new Error('audit_ unimplemented');
  }

  /* eslint-enable no-unused-vars */
}

module.exports = MultiCheckAudit;

},{"./audit.js":3}],8:[function(require,module,exports){
/**
 * @license Copyright 2017 The Lighthouse Authors. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.
 */
'use strict';

const Audit = require('./audit.js');

class ViolationAudit extends Audit {
  /**
   * @param {LH.Artifacts} artifacts
   * @param {RegExp} pattern
   * @return {Array<{source: LH.Audit.Details.SourceLocationValue}>}
   */
  static getViolationResults(artifacts, pattern) {
    /**
     * @template T
     * @param {T} value
     * @return {value is Exclude<T, undefined>}
     */
    function filterUndefined(value) {
      return value !== undefined;
    }

    const seen = new Set();
    return artifacts.ConsoleMessages
        .filter(entry => entry.url && entry.source === 'violation' && pattern.test(entry.text))
        .map(Audit.makeSourceLocationFromConsoleMessage)
        .filter(filterUndefined)
        .filter(source => {
          // Filter out duplicate entries since they are not differentiable to the user
          // @see https://github.com/GoogleChrome/lighthouse/issues/5218
          const key = `${source.url}!${source.line}!${source.column}`;
          if (seen.has(key)) return false;
          seen.add(key);
          return true;
        })
        .map(source => ({source}));
  }
}

module.exports = ViolationAudit;

},{"./audit.js":3}],9:[function(require,module,exports){
/**
 * @license Copyright 2018 The Lighthouse Authors. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.
 */
'use strict';

const ArbitraryEqualityMap = require('../lib/arbitrary-equality-map.js');
const log = require('lighthouse-logger');

/**
 * Decorate computableArtifact with a caching `request()` method which will
 * automatically call `computableArtifact.compute_()` under the hood.
 * @template {{name: string, compute_(artifacts: unknown, context: LH.Artifacts.ComputedContext): Promise<unknown>}} C
 * @param {C} computableArtifact
 */
function makeComputedArtifact(computableArtifact) {
  // tsc (3.1) has more difficulty with template inter-references in jsdoc, so
  // give types to params and return value the long way, essentially recreating
  // polymorphic-this behavior for C.
  /**
   * Return an automatically cached result from the computed artifact.
   * @param {FirstParamType<C['compute_']>} artifacts
   * @param {LH.Artifacts.ComputedContext} context
   * @return {ReturnType<C['compute_']>}
   */
  const request = (artifacts, context) => {
    // NOTE: break immutability solely for this caching-controller function.
    const computedCache = /** @type {Map<string, ArbitraryEqualityMap>} */ (context.computedCache);
    const computedName = computableArtifact.name;

    const cache = computedCache.get(computedName) || new ArbitraryEqualityMap();
    computedCache.set(computedName, cache);

    const computed = /** @type {ReturnType<C['compute_']>|undefined} */ (cache.get(artifacts));
    if (computed) {
      return computed;
    }

    const status = {msg: `Computing artifact: ${computedName}`, id: `lh:computed:${computedName}`};
    log.time(status, 'verbose');

    const artifactPromise = /** @type {ReturnType<C['compute_']>} */
        (computableArtifact.compute_(artifacts, context));
    cache.set(artifacts, artifactPromise);

    artifactPromise.then(() => log.timeEnd(status)).catch(() => log.timeEnd(status));

    return artifactPromise;
  };

  return Object.assign(computableArtifact, {request});
}

module.exports = makeComputedArtifact;

},{"../lib/arbitrary-equality-map.js":79,"lighthouse-logger":188}],10:[function(require,module,exports){
/**
 * @license Copyright 2016 The Lighthouse Authors. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.
 */
'use strict';

const makeComputedArtifact = require('./computed-artifact.js');
const NetworkRequest = require('../lib/network-request.js');
const MainResource = require('./main-resource.js');
const PageDependencyGraph = require('./page-dependency-graph.js');

class CriticalRequestChains {
  /**
   * For now, we use network priorities as a proxy for "render-blocking"/critical-ness.
   * It's imperfect, but there is not a higher-fidelity signal available yet.
   * @see https://docs.google.com/document/d/1bCDuq9H1ih9iNjgzyAL0gpwNFiEP4TZS-YLRp_RuMlc
   * @param {LH.Artifacts.NetworkRequest} request
   * @param {LH.Artifacts.NetworkRequest} mainResource
   * @return {boolean}
   */
  static isCritical(request, mainResource) {
    if (!mainResource) {
      throw new Error('mainResource not provided');
    }

    // The main resource is always critical.
    if (request.requestId === mainResource.requestId) return true;

    // Treat any preloaded resource as non-critical
    if (request.isLinkPreload) {
      return false;
    }

    // Whenever a request is a redirect, we don't know if it's critical until we resolve the final
    // destination. At that point we can assign all the properties (priority, resourceType) of the
    // final request back to the redirect(s) that led to it.
    // See https://github.com/GoogleChrome/lighthouse/pull/6704
    while (request.redirectDestination) {
      request = request.redirectDestination;
    }

    // Iframes are considered High Priority but they are not render blocking
    const isIframe = request.resourceType === NetworkRequest.TYPES.Document
      && request.frameId !== mainResource.frameId;
    // XHRs are fetched at High priority, but we exclude them, as they are unlikely to be critical
    // Images are also non-critical.
    // Treat any missed images, primarily favicons, as non-critical resources
    /** @type {Array<LH.Crdp.Network.ResourceType>} */
    const nonCriticalResourceTypes = [
      NetworkRequest.TYPES.Image,
      NetworkRequest.TYPES.XHR,
      NetworkRequest.TYPES.Fetch,
      NetworkRequest.TYPES.EventSource,
    ];
    if (nonCriticalResourceTypes.includes(request.resourceType || 'Other') ||
        isIframe ||
        request.mimeType && request.mimeType.startsWith('image/')) {
      return false;
    }

    // Requests that have no initiatorRequest are typically ambiguous late-load assets.
    // Even on the off chance they were important, we don't have any parent to display for them.
    if (!request.initiatorRequest) return false;

    return ['VeryHigh', 'High', 'Medium'].includes(request.priority);
  }

  /**
   * Create a tree of critical requests.
   * @param {LH.Artifacts.NetworkRequest} mainResource
   * @param {LH.Gatherer.Simulation.GraphNode} graph
   * @return {LH.Artifacts.CriticalRequestNode}
   */
  static extractChainsFromGraph(mainResource, graph) {
    /** @type {LH.Artifacts.CriticalRequestNode} */
    const rootNode = {};

    /**
     * @param {LH.Artifacts.NetworkRequest[]} path
     */
    function addChain(path) {
      let currentNode = rootNode;

      for (const record of path) {
        if (!currentNode[record.requestId]) {
          currentNode[record.requestId] = {
            request: record,
            children: {},
          };
        }

        currentNode = currentNode[record.requestId].children;
      }
    }

    // By default `traverse` will discover nodes in BFS-order regardless of dependencies, but
    // here we need traversal in a topological sort order. We'll visit a node only when its
    // dependencies have been met.
    const seenNodes = new Set();
    /** @param {LH.Gatherer.Simulation.GraphNode} node */
    function getNextNodes(node) {
      return node.getDependents().filter(n => n.getDependencies().every(d => seenNodes.has(d)));
    }

    graph.traverse((node, traversalPath) => {
      seenNodes.add(node);
      if (node.type !== 'network') return;
      if (!CriticalRequestChains.isCritical(node.record, mainResource)) return;

      const networkPath = traversalPath
        .filter(/** @return {n is LH.Gatherer.Simulation.GraphNetworkNode} */
          n => n.type === 'network')
        .reverse()
        .map(node => node.record);

      // Ignore if some ancestor is not a critical request.
      if (networkPath.some(r => !CriticalRequestChains.isCritical(r, mainResource))) return;

      addChain(networkPath);
    }, getNextNodes);

    return rootNode;
  }

  /**
   * @param {{URL: LH.Artifacts['URL'], devtoolsLog: LH.DevtoolsLog, trace: LH.Trace}} data
   * @param {LH.Artifacts.ComputedContext} context
   * @return {Promise<LH.Artifacts.CriticalRequestNode>}
   */
  static async compute_(data, context) {
    const mainResource = await MainResource.request({
      URL: data.URL,
      devtoolsLog: data.devtoolsLog,
    }, context);

    const graph = await PageDependencyGraph.request({
      trace: data.trace,
      devtoolsLog: data.devtoolsLog,
    }, context);

    return CriticalRequestChains.extractChainsFromGraph(mainResource, graph);
  }
}

module.exports = makeComputedArtifact(CriticalRequestChains);

},{"../lib/network-request.js":109,"./computed-artifact.js":9,"./main-resource.js":14,"./page-dependency-graph.js":41}],11:[function(require,module,exports){
/**
 * @license Copyright 2021 The Lighthouse Authors. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.
 */
'use strict';

const makeComputedArtifact = require('./computed-artifact.js');

class ImageRecords {
  /**
   * @param {LH.Artifacts.NetworkRequest[]} networkRecords
   */
  static indexNetworkRecords(networkRecords) {
    return networkRecords.reduce((map, record) => {
      // An image response in newer formats is sometimes incorrectly marked as "application/octet-stream",
      // so respect the extension too.
      const isImage = /^image/.test(record.mimeType) || /\.(avif|webp)$/i.test(record.url);
      // The network record is only valid for size information if it finished with a successful status
      // code that indicates a complete image response.
      if (isImage && record.finished && record.statusCode === 200) {
        map[record.url] = record;
      }

      return map;
    }, /** @type {Record<string, LH.Artifacts.NetworkRequest>} */ ({}));
  }

  /**
   * @param {{ImageElements: LH.Artifacts['ImageElements'], networkRecords: LH.Artifacts.NetworkRequest[]}} data
   * @return {Promise<LH.Artifacts.ImageElement[]>}
   */
  static async compute_(data) {
    const indexedNetworkRecords = ImageRecords.indexNetworkRecords(data.networkRecords);

    /** @type {LH.Artifacts.ImageElement[]} */
    const imageRecords = [];

    for (const element of data.ImageElements) {
      const networkRecord = indexedNetworkRecords[element.src];
      const mimeType = networkRecord && networkRecord.mimeType;

      // Don't change the guessed mime type if no mime type was found.
      imageRecords.push({
        ...element,
        mimeType: mimeType ? mimeType : element.mimeType,
      });
    }

    // Sort (in-place) as largest images descending.
    imageRecords.sort((a, b) => {
      const aRecord = indexedNetworkRecords[a.src] || {};
      const bRecord = indexedNetworkRecords[b.src] || {};
      return bRecord.resourceSize - aRecord.resourceSize;
    });

    return imageRecords;
  }
}

module.exports = makeComputedArtifact(ImageRecords);


},{"./computed-artifact.js":9}],12:[function(require,module,exports){
/**
 * @license Copyright 2020 The Lighthouse Authors. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.
 */
'use strict';

const log = require('lighthouse-logger');
const makeComputedArtifact = require('./computed-artifact.js');
const SDK = require('../lib/cdt/SDK.js');

/**
 * Calculate the number of bytes contributed by each source file
 * @param {LH.Artifacts.Bundle['map']} map
 * @param {string} content
 * @return {LH.Artifacts.Bundle['sizes']}
 */
function computeGeneratedFileSizes(map, content) {
  const lines = content.split('\n');
  /** @type {Record<string, number>} */
  const files = {};
  const totalBytes = content.length;
  let unmappedBytes = totalBytes;

  // @ts-expect-error: This function is added in SDK.js. This will eventually be added to CDT.
  map.computeLastGeneratedColumns();

  for (const mapping of map.mappings()) {
    const source = mapping.sourceURL;
    const lineNum = mapping.lineNumber;
    const colNum = mapping.columnNumber;
    // @ts-expect-error: `lastColumnNumber` is not on types yet. This will eventually be added to CDT.
    const lastColNum = /** @type {number=} */ (mapping.lastColumnNumber);

    // Webpack sometimes emits null mappings.
    // https://github.com/mozilla/source-map/pull/303
    if (!source) continue;

    // Lines and columns are zero-based indices. Visually, lines are shown as a 1-based index.

    const line = lines[lineNum];
    if (line === null || line === undefined) {
      const errorMessage = `${map.url()} mapping for line out of bounds: ${lineNum + 1}`;
      log.error('JSBundles', errorMessage);
      return {errorMessage};
    }

    if (colNum > line.length) {
      const errorMessage =
        `${map.url()} mapping for column out of bounds: ${lineNum + 1}:${colNum}`;
      log.error('JSBundles', errorMessage);
      return {errorMessage};
    }

    let mappingLength = 0;
    if (lastColNum !== undefined) {
      if (lastColNum > line.length) {
        // eslint-disable-next-line max-len
        const errorMessage =
          `${map.url()} mapping for last column out of bounds: ${lineNum + 1}:${lastColNum}`;
        log.error('JSBundles', errorMessage);
        return {errorMessage};
      }
      mappingLength = lastColNum - colNum;
    } else {
      // Add +1 to account for the newline.
      mappingLength = line.length - colNum + 1;
    }
    files[source] = (files[source] || 0) + mappingLength;
    unmappedBytes -= mappingLength;
  }

  return {
    files,
    unmappedBytes,
    totalBytes,
  };
}

class JSBundles {
  /**
   * @param {Pick<LH.Artifacts, 'SourceMaps'|'ScriptElements'>} artifacts
   */
  static async compute_(artifacts) {
    const {SourceMaps, ScriptElements} = artifacts;

    /** @type {LH.Artifacts.Bundle[]} */
    const bundles = [];

    // Collate map and script, compute file sizes.
    for (const SourceMap of SourceMaps) {
      if (!SourceMap.map) continue;
      const {scriptUrl, map: rawMap} = SourceMap;

      if (!rawMap.mappings) continue;

      const scriptElement = ScriptElements.find(s => s.src === scriptUrl);
      if (!scriptElement) continue;

      const compiledUrl = SourceMap.scriptUrl || 'compiled.js';
      const mapUrl = SourceMap.sourceMapUrl || 'compiled.js.map';
      // Hack: CDT expects undefined properties to be explicit.
      const rawMapForCdt = /** @type {any} */ (rawMap);
      const map = new SDK.TextSourceMap(compiledUrl, mapUrl, rawMapForCdt);

      const content = scriptElement && scriptElement.content ? scriptElement.content : '';
      const sizes = computeGeneratedFileSizes(map, content);

      const bundle = {
        rawMap,
        script: scriptElement,
        map,
        sizes,
      };
      bundles.push(bundle);
    }

    return bundles;
  }
}

module.exports = makeComputedArtifact(JSBundles);

},{"../lib/cdt/SDK.js":83,"./computed-artifact.js":9,"lighthouse-logger":188}],13:[function(require,module,exports){
/**
 * @license Copyright 2018 The Lighthouse Authors. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.
 */
'use strict';

const makeComputedArtifact = require('./computed-artifact.js');
const constants = require('../config/constants.js');
const Simulator = require('../lib/dependency-graph/simulator/simulator.js');
const NetworkAnalysis = require('./network-analysis.js');

class LoadSimulator {
  /**
   * @param {{devtoolsLog: LH.DevtoolsLog, settings: Immutable<LH.Config.Settings>}} data
   * @param {LH.Artifacts.ComputedContext} context
   * @return {Promise<Simulator>}
   */
  static async compute_(data, context) {
    const {throttlingMethod, throttling, precomputedLanternData} = data.settings;
    const networkAnalysis = await NetworkAnalysis.request(data.devtoolsLog, context);

    /** @type {LH.Gatherer.Simulation.Options} */
    const options = {
      additionalRttByOrigin: networkAnalysis.additionalRttByOrigin,
      serverResponseTimeByOrigin: networkAnalysis.serverResponseTimeByOrigin,
    };

    // If we have precomputed lantern data, overwrite our observed estimates and use precomputed instead
    // for increased stability.
    if (precomputedLanternData) {
      options.additionalRttByOrigin = new Map(Object.entries(
        precomputedLanternData.additionalRttByOrigin));
      options.serverResponseTimeByOrigin = new Map(Object.entries(
        precomputedLanternData.serverResponseTimeByOrigin));
    }

    switch (throttlingMethod) {
      case 'provided':
        options.rtt = networkAnalysis.rtt;
        options.throughput = networkAnalysis.throughput;
        options.cpuSlowdownMultiplier = 1;
        options.layoutTaskMultiplier = 1;
        break;
      case 'devtools':
        if (throttling) {
          options.rtt =
            throttling.requestLatencyMs / constants.throttling.DEVTOOLS_RTT_ADJUSTMENT_FACTOR;
          options.throughput =
            throttling.downloadThroughputKbps * 1024 /
            constants.throttling.DEVTOOLS_THROUGHPUT_ADJUSTMENT_FACTOR;
        }

        options.cpuSlowdownMultiplier = 1;
        options.layoutTaskMultiplier = 1;
        break;
      case 'simulate':
        if (throttling) {
          options.rtt = throttling.rttMs;
          options.throughput = throttling.throughputKbps * 1024;
          options.cpuSlowdownMultiplier = throttling.cpuSlowdownMultiplier;
        }
        break;
      default:
        // intentionally fallback to simulator defaults
        break;
    }

    return new Simulator(options);
  }

  /**
   * @param {LH.Artifacts.NetworkAnalysis} networkAnalysis
   * @return {LH.PrecomputedLanternData}
   */
  static convertAnalysisToSaveableLanternData(networkAnalysis) {
    /** @type {LH.PrecomputedLanternData} */
    const lanternData = {additionalRttByOrigin: {}, serverResponseTimeByOrigin: {}};
    for (const [origin, value] of networkAnalysis.additionalRttByOrigin.entries()) {
      if (origin.startsWith('http')) lanternData.additionalRttByOrigin[origin] = value;
    }

    for (const [origin, value] of networkAnalysis.serverResponseTimeByOrigin.entries()) {
      if (origin.startsWith('http')) lanternData.serverResponseTimeByOrigin[origin] = value;
    }

    return lanternData;
  }
}

module.exports = makeComputedArtifact(LoadSimulator);

},{"../config/constants.js":56,"../lib/dependency-graph/simulator/simulator.js":93,"./computed-artifact.js":9,"./network-analysis.js":39}],14:[function(require,module,exports){
/**
 * @license Copyright 2017 The Lighthouse Authors. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.
 */
'use strict';

const makeComputedArtifact = require('./computed-artifact.js');
const NetworkAnalyzer = require('../lib/dependency-graph/simulator/network-analyzer.js');
const NetworkRecords = require('./network-records.js');

/**
 * @fileoverview This artifact identifies the main resource on the page. Current solution assumes
 * that the main resource is the first non-rediected one.
 */
class MainResource {
  /**
   * @param {{URL: LH.Artifacts['URL'], devtoolsLog: LH.DevtoolsLog}} data
   * @param {LH.Artifacts.ComputedContext} context
   * @return {Promise<LH.Artifacts.NetworkRequest>}
   */
  static async compute_(data, context) {
    const finalUrl = data.URL.finalUrl;
    const requests = await NetworkRecords.request(data.devtoolsLog, context);
    const mainResource = NetworkAnalyzer.findMainDocument(requests, finalUrl);
    if (!mainResource) {
      throw new Error('Unable to identify the main resource');
    }

    return mainResource;
  }
}

module.exports = makeComputedArtifact(MainResource);

},{"../lib/dependency-graph/simulator/network-analyzer.js":91,"./computed-artifact.js":9,"./network-records.js":40}],15:[function(require,module,exports){
/**
 * @license Copyright 2019 The Lighthouse Authors. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.
 */
'use strict';

const makeComputedArtifact = require('./computed-artifact.js');
const MainThreadTasks_ = require('../lib/tracehouse/main-thread-tasks.js');
const ProcessedTrace = require('./processed-trace.js');

class MainThreadTasks {
  /**
   * @param {LH.Trace} trace
   * @param {LH.Artifacts.ComputedContext} context
   * @return {Promise<Array<LH.Artifacts.TaskNode>>}
   */
  static async compute_(trace, context) {
    const {mainThreadEvents, frames, timestamps} = await ProcessedTrace.request(trace, context);
    return MainThreadTasks_.getMainThreadTasks(mainThreadEvents, frames, timestamps.traceEnd);
  }
}

module.exports = makeComputedArtifact(MainThreadTasks);

},{"../lib/tracehouse/main-thread-tasks.js":117,"./computed-artifact.js":9,"./processed-trace.js":43}],16:[function(require,module,exports){
/**
 * @license Copyright 2016 The Lighthouse Authors. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.
 */
'use strict';

const makeComputedArtifact = require('./computed-artifact.js');
const icons = require('../lib/icons.js');

const PWA_DISPLAY_VALUES = ['minimal-ui', 'fullscreen', 'standalone'];

// Historically, Chrome recommended 12 chars as the maximum short_name length to prevent truncation.
// For more discussion, see https://github.com/GoogleChrome/lighthouse/issues/69 and https://developer.chrome.com/apps/manifest/name#short_name
const SUGGESTED_SHORTNAME_LENGTH = 12;

class ManifestValues {
  /** @typedef {(val: NonNullable<LH.Artifacts.Manifest['value']>, errors: LH.Artifacts.InstallabilityErrors['errors']) => boolean} Validator */

  /**
   * @return {Array<{id: LH.Artifacts.ManifestValueCheckID, failureText: string, validate: Validator}>}
   */
  static get manifestChecks() {
    return [
      {
        id: 'hasStartUrl',
        failureText: 'Manifest does not contain a `start_url`',
        validate: manifestValue => !!manifestValue.start_url.value,
      },
      {
        id: 'hasIconsAtLeast144px',
        failureText: 'Manifest does not have a PNG icon of at least 144px',
        validate: manifestValue => icons.doExist(manifestValue) &&
            icons.pngSizedAtLeast(144, manifestValue).length > 0,
      },
      {
        id: 'hasIconsAtLeast512px',
        failureText: 'Manifest does not have a PNG icon of at least 512px',
        validate: manifestValue => icons.doExist(manifestValue) &&
            icons.pngSizedAtLeast(512, manifestValue).length > 0,
      },
      {
        id: 'fetchesIcon',
        failureText: 'Manifest icon failed to be fetched',
        validate: (manifestValue, errors) => {
          const failedToFetchIconErrorIds = [
            'cannot-download-icon',
            'no-icon-available',
          ];
          return icons.doExist(manifestValue) &&
            !errors.some(error => failedToFetchIconErrorIds.includes(error.errorId));
        },
      },
      {
        id: 'hasPWADisplayValue',
        failureText: 'Manifest\'s `display` value is not one of: ' + PWA_DISPLAY_VALUES.join(' | '),
        validate: manifestValue => PWA_DISPLAY_VALUES.includes(manifestValue.display.value),
      },
      {
        id: 'hasBackgroundColor',
        failureText: 'Manifest does not have `background_color`',
        validate: manifestValue => !!manifestValue.background_color.value,
      },
      {
        id: 'hasThemeColor',
        failureText: 'Manifest does not have `theme_color`',
        validate: manifestValue => !!manifestValue.theme_color.value,
      },
      {
        id: 'hasShortName',
        failureText: 'Manifest does not have `short_name`',
        validate: manifestValue => !!manifestValue.short_name.value,
      },
      {
        id: 'shortNameLength',
        failureText: `Manifest's \`short_name\` is too long (>${SUGGESTED_SHORTNAME_LENGTH} ` +
          `characters) to be displayed on a homescreen without truncation`,
        // Pass if there's no short_name. Don't want to report a non-existent string is too long
        validate: manifestValue => !!manifestValue.short_name.value &&
            manifestValue.short_name.value.length <= SUGGESTED_SHORTNAME_LENGTH,
      },
      {
        id: 'hasName',
        failureText: 'Manifest does not have `name`',
        validate: manifestValue => !!manifestValue.name.value,
      },
      {
        id: 'hasMaskableIcon',
        failureText: 'Manifest does not have at least one icon that is maskable',
        validate: ManifestValue => icons.doExist(ManifestValue) &&
            icons.containsMaskableIcon(ManifestValue),
      },
    ];
  }

  /**
   * Returns results of all manifest checks
   * @param {Pick<LH.Artifacts, 'WebAppManifest'|'InstallabilityErrors'>} Manifest
   * @return {Promise<LH.Artifacts.ManifestValues>}
   */
  static async compute_({WebAppManifest, InstallabilityErrors}) {
    // if the manifest isn't there or is invalid json, we report that and bail
    if (WebAppManifest === null) {
      return {
        isParseFailure: true,
        parseFailureReason: 'No manifest was fetched',
        allChecks: [],
      };
    }
    const manifestValue = WebAppManifest.value;
    if (manifestValue === undefined) {
      return {
        isParseFailure: true,
        parseFailureReason: 'Manifest failed to parse as valid JSON',
        allChecks: [],
      };
    }

    // manifest is valid, so do the rest of the checks
    const remainingChecks = ManifestValues.manifestChecks.map(item => {
      return {
        id: item.id,
        failureText: item.failureText,
        passing: item.validate(manifestValue, InstallabilityErrors.errors),
      };
    });

    return {
      isParseFailure: false,
      allChecks: remainingChecks,
    };
  }
}

module.exports = makeComputedArtifact(ManifestValues);

},{"../lib/icons.js":98,"./computed-artifact.js":9}],17:[function(require,module,exports){
/**
 * @license Copyright 2019 The Lighthouse Authors. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.
 */
'use strict';

const makeComputedArtifact = require('../computed-artifact.js');
const ProcessedTrace = require('../processed-trace.js');
const LHError = require('../../lib/lh-error.js');

/** @typedef {{ts: number, isMainFrame: boolean, weightedScore: number}} LayoutShiftEvent */

class CumulativeLayoutShift {
  /**
   * Returns all LayoutShift events that had no recent input.
   * Only a `weightedScore` per event is returned. For non-main-frame events, this is
   * the only score that matters. For main-frame events, `weighted_score_delta === score`.
   * @see https://source.chromium.org/chromium/chromium/src/+/main:third_party/blink/renderer/core/layout/layout_shift_tracker.cc;l=492-495;drc=de3b3a8a8839269c6b44403fa38a13a1ed12fed5
   * @param {LH.TraceEvent[]} traceEvents
   * @return {Array<LayoutShiftEvent>}
   */
  static getLayoutShiftEvents(traceEvents) {
    const layoutShiftEvents = [];

    // Chromium will set `had_recent_input` if there was recent user input, which
    // skips shift events from contributing to CLS. This flag is also set when
    // Lighthouse changes the emulation size. This results in the first few shift
    // events having `had_recent_input` set, so ignore it for those events.
    // See https://bugs.chromium.org/p/chromium/issues/detail?id=1094974.
    let ignoreHadRecentInput = true;

    for (const event of traceEvents) {
      if (event.name !== 'LayoutShift' ||
          !event.args.data ||
          event.args.data.is_main_frame === undefined) {
        continue;
      }

      // For all-frames CLS calculation, we rely on `weighted_score_delta`, which
      // was added in Chrome 90: https://crbug.com/1173139
      if (event.args.data.weighted_score_delta === undefined) {
        throw new LHError(
          LHError.errors.UNSUPPORTED_OLD_CHROME,
          {featureName: 'Cumulative Layout Shift'}
        );
      }

      if (event.args.data.had_recent_input) {
        // `had_recent_input` events aren't used unless currently ignoring.
        if (!ignoreHadRecentInput) continue;
      } else {
        // After a false `had_recent_input`, stop ignoring property.
        ignoreHadRecentInput = false;
      }

      layoutShiftEvents.push({
        ts: event.ts,
        isMainFrame: event.args.data.is_main_frame,
        weightedScore: event.args.data.weighted_score_delta,
      });
    }

    return layoutShiftEvents;
  }

  /**
   * Calculates cumulative layout shifts per cluster (session) of LayoutShift
   * events -- where a new cluster is created when there's a gap of more than
   * 1000ms since the last LayoutShift event or the cluster is greater than
   * 5000ms long -- and returns the max LayoutShift score found.
   * @param {Array<LayoutShiftEvent>} layoutShiftEvents
   * @return {number}
   */
  static calculate(layoutShiftEvents) {
    const gapMicroseconds = 1_000_000;
    const limitMicroseconds = 5_000_000;
    let maxScore = 0;
    let currentClusterScore = 0;
    let firstTs = Number.NEGATIVE_INFINITY;
    let prevTs = Number.NEGATIVE_INFINITY;

    for (const event of layoutShiftEvents) {
      if (event.ts - firstTs > limitMicroseconds || event.ts - prevTs > gapMicroseconds) {
        firstTs = event.ts;
        currentClusterScore = 0;
      }
      prevTs = event.ts;
      currentClusterScore += event.weightedScore;
      maxScore = Math.max(maxScore, currentClusterScore);
    }

    return maxScore;
  }

  /**
   * Sum all layout shift events from the entire trace.
   * @param {Array<LayoutShiftEvent>} layoutShiftEvents
   * @return {number}
   */
  static calculateTotalCumulativeLayoutShift(layoutShiftEvents) {
    return layoutShiftEvents.reduce((sum, e) => sum += e.weightedScore, 0);
  }

  /**
   * @param {LH.Trace} trace
   * @param {LH.Artifacts.ComputedContext} context
   * @return {Promise<{cumulativeLayoutShift: number, cumulativeLayoutShiftMainFrame: number, totalCumulativeLayoutShift: number}>}
   */
  static async compute_(trace, context) {
    const processedTrace = await ProcessedTrace.request(trace, context);

    const allFrameShiftEvents =
        CumulativeLayoutShift.getLayoutShiftEvents(processedTrace.frameTreeEvents);
    const mainFrameShiftEvents = allFrameShiftEvents.filter(e => e.isMainFrame);

    // The original Cumulative Layout Shift metric, the sum of all main-frame shift events.
    const totalCumulativeLayoutShift =
        CumulativeLayoutShift.calculateTotalCumulativeLayoutShift(mainFrameShiftEvents);

    return {
      cumulativeLayoutShift: CumulativeLayoutShift.calculate(allFrameShiftEvents),
      cumulativeLayoutShiftMainFrame: CumulativeLayoutShift.calculate(mainFrameShiftEvents),
      totalCumulativeLayoutShift,
    };
  }
}

module.exports = makeComputedArtifact(CumulativeLayoutShift);

},{"../../lib/lh-error.js":103,"../computed-artifact.js":9,"../processed-trace.js":43}],18:[function(require,module,exports){
/**
 * @license Copyright 2021 The Lighthouse Authors. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.
 */
'use strict';

const makeComputedArtifact = require('../computed-artifact.js');
const NavigationMetric = require('./navigation-metric.js');

class FirstContentfulPaintAllFrames extends NavigationMetric {
  /**
   * @return {Promise<LH.Artifacts.LanternMetric>}
   */
  static computeSimulatedMetric() {
    // TODO: Add support for all frames in lantern.
    throw new Error('FCP All Frames not implemented in lantern');
  }

  /**
   * @param {LH.Artifacts.NavigationMetricComputationData} data
   * @return {Promise<LH.Artifacts.Metric>}
   */
  static async computeObservedMetric(data) {
    const {processedNavigation} = data;

    return {
      timing: processedNavigation.timings.firstContentfulPaintAllFrames,
      timestamp: processedNavigation.timestamps.firstContentfulPaintAllFrames,
    };
  }
}

module.exports = makeComputedArtifact(FirstContentfulPaintAllFrames);

},{"../computed-artifact.js":9,"./navigation-metric.js":34}],19:[function(require,module,exports){
/**
 * @license Copyright 2018 The Lighthouse Authors. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.
 */
'use strict';

const makeComputedArtifact = require('../computed-artifact.js');
const NavigationMetric = require('./navigation-metric.js');
const LanternFirstContentfulPaint = require('./lantern-first-contentful-paint.js');

class FirstContentfulPaint extends NavigationMetric {
  /**
   * @param {LH.Artifacts.NavigationMetricComputationData} data
   * @param {LH.Artifacts.ComputedContext} context
   * @return {Promise<LH.Artifacts.LanternMetric>}
   */
  static computeSimulatedMetric(data, context) {
    const metricData = NavigationMetric.getMetricComputationInput(data);
    return LanternFirstContentfulPaint.request(metricData, context);
  }

  /**
   * @param {LH.Artifacts.NavigationMetricComputationData} data
   * @return {Promise<LH.Artifacts.Metric>}
   */
  static async computeObservedMetric(data) {
    const {processedNavigation} = data;

    return {
      timing: processedNavigation.timings.firstContentfulPaint,
      timestamp: processedNavigation.timestamps.firstContentfulPaint,
    };
  }
}

module.exports = makeComputedArtifact(FirstContentfulPaint);

},{"../computed-artifact.js":9,"./lantern-first-contentful-paint.js":22,"./navigation-metric.js":34}],20:[function(require,module,exports){
/**
 * @license Copyright 2018 The Lighthouse Authors. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.
 */
'use strict';

const makeComputedArtifact = require('../computed-artifact.js');
const NavigationMetric = require('./navigation-metric.js');
const LHError = require('../../lib/lh-error.js');
const LanternFirstMeaningfulPaint = require('./lantern-first-meaningful-paint.js');

class FirstMeaningfulPaint extends NavigationMetric {
  /**
   * @param {LH.Artifacts.NavigationMetricComputationData} data
   * @param {LH.Artifacts.ComputedContext} context
   * @return {Promise<LH.Artifacts.LanternMetric>}
   */
  static computeSimulatedMetric(data, context) {
    const metricData = NavigationMetric.getMetricComputationInput(data);
    return LanternFirstMeaningfulPaint.request(metricData, context);
  }

  /**
   * @param {LH.Artifacts.NavigationMetricComputationData} data
   * @return {Promise<LH.Artifacts.Metric>}
   */
  static async computeObservedMetric(data) {
    const {processedNavigation} = data;
    if (processedNavigation.timings.firstMeaningfulPaint === undefined) {
      throw new LHError(LHError.errors.NO_FMP);
    }

    return {
      timing: processedNavigation.timings.firstMeaningfulPaint,
      timestamp: processedNavigation.timestamps.firstMeaningfulPaint,
    };
  }
}

module.exports = makeComputedArtifact(FirstMeaningfulPaint);

},{"../../lib/lh-error.js":103,"../computed-artifact.js":9,"./lantern-first-meaningful-paint.js":23,"./navigation-metric.js":34}],21:[function(require,module,exports){
/**
 * @license Copyright 2018 The Lighthouse Authors. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.
 */
'use strict';

const makeComputedArtifact = require('../computed-artifact.js');
const NavigationMetric = require('./navigation-metric.js');
const LanternInteractive = require('./lantern-interactive.js');

const NetworkMonitor = require('../../gather/driver/network-monitor.js');
const TracingProcessor = require('../../lib/tracehouse/trace-processor.js');
const LHError = require('../../lib/lh-error.js');

const REQUIRED_QUIET_WINDOW = 5000;
const ALLOWED_CONCURRENT_REQUESTS = 2;

/**
 * @fileoverview Computes "Time To Interactive", the time at which the page has loaded critical
 * resources and is mostly idle.
 * @see https://docs.google.com/document/d/1yE4YWsusi5wVXrnwhR61j-QyjK9tzENIzfxrCjA1NAk/edit#heading=h.yozfsuqcgpc4
 */
class Interactive extends NavigationMetric {
  /**
   * Finds all time periods where the number of inflight requests is less than or equal to the
   * number of allowed concurrent requests (2).
   * @param {Array<LH.Artifacts.NetworkRequest>} networkRecords
   * @param {{timestamps: {traceEnd: number}}} processedNavigation
   * @return {Array<TimePeriod>}
   */
  static _findNetworkQuietPeriods(networkRecords, processedNavigation) {
    const traceEndTsInMs = processedNavigation.timestamps.traceEnd / 1000;
    // Ignore records that failed, never finished, or were POST/PUT/etc.
    const filteredNetworkRecords = networkRecords.filter(record => {
      return record.finished && record.requestMethod === 'GET' && !record.failed &&
          // Consider network records that had 4xx/5xx status code as "failed"
          record.statusCode < 400;
    });
    return NetworkMonitor.findNetworkQuietPeriods(filteredNetworkRecords,
      ALLOWED_CONCURRENT_REQUESTS, traceEndTsInMs);
  }

  /**
   * Finds all time periods where there are no long tasks.
   * @param {Array<TimePeriod>} longTasks
   * @param {{timestamps: {timeOrigin: number, traceEnd: number}}} processedNavigation
   * @return {Array<TimePeriod>}
   */
  static _findCPUQuietPeriods(longTasks, processedNavigation) {
    const timeOriginTsInMs = processedNavigation.timestamps.timeOrigin / 1000;
    const traceEndTsInMs = processedNavigation.timestamps.traceEnd / 1000;
    if (longTasks.length === 0) {
      return [{start: 0, end: traceEndTsInMs}];
    }

    /** @type {Array<TimePeriod>} */
    const quietPeriods = [];
    longTasks.forEach((task, index) => {
      if (index === 0) {
        quietPeriods.push({
          start: 0,
          end: task.start + timeOriginTsInMs,
        });
      }

      if (index === longTasks.length - 1) {
        quietPeriods.push({
          start: task.end + timeOriginTsInMs,
          end: traceEndTsInMs,
        });
      } else {
        quietPeriods.push({
          start: task.end + timeOriginTsInMs,
          end: longTasks[index + 1].start + timeOriginTsInMs,
        });
      }
    });

    return quietPeriods;
  }

  /**
   * Finds the first time period where a network quiet period and a CPU quiet period overlap.
   * @param {Array<TimePeriod>} longTasks
   * @param {Array<LH.Artifacts.NetworkRequest>} networkRecords
   * @param {LH.Artifacts.ProcessedNavigation} processedNavigation
   * @return {{cpuQuietPeriod: TimePeriod, networkQuietPeriod: TimePeriod, cpuQuietPeriods: Array<TimePeriod>, networkQuietPeriods: Array<TimePeriod>}}
   */
  static findOverlappingQuietPeriods(longTasks, networkRecords, processedNavigation) {
    const FcpTsInMs = processedNavigation.timestamps.firstContentfulPaint / 1000;

    /** @type {function(TimePeriod):boolean} */
    const isLongEnoughQuietPeriod = period =>
        period.end > FcpTsInMs + REQUIRED_QUIET_WINDOW &&
        period.end - period.start >= REQUIRED_QUIET_WINDOW;
    const networkQuietPeriods = this._findNetworkQuietPeriods(networkRecords, processedNavigation)
        .filter(isLongEnoughQuietPeriod);
    const cpuQuietPeriods = this._findCPUQuietPeriods(longTasks, processedNavigation)
        .filter(isLongEnoughQuietPeriod);

    const cpuQueue = cpuQuietPeriods.slice();
    const networkQueue = networkQuietPeriods.slice();

    // We will check for a CPU quiet period contained within a Network quiet period or vice-versa
    let cpuCandidate = cpuQueue.shift();
    let networkCandidate = networkQueue.shift();
    while (cpuCandidate && networkCandidate) {
      if (cpuCandidate.start >= networkCandidate.start) {
        // CPU starts later than network, window must be contained by network or we check the next
        if (networkCandidate.end >= cpuCandidate.start + REQUIRED_QUIET_WINDOW) {
          return {
            cpuQuietPeriod: cpuCandidate,
            networkQuietPeriod: networkCandidate,
            cpuQuietPeriods,
            networkQuietPeriods,
          };
        } else {
          networkCandidate = networkQueue.shift();
        }
      } else {
        // Network starts later than CPU, window must be contained by CPU or we check the next
        if (cpuCandidate.end >= networkCandidate.start + REQUIRED_QUIET_WINDOW) {
          return {
            cpuQuietPeriod: cpuCandidate,
            networkQuietPeriod: networkCandidate,
            cpuQuietPeriods,
            networkQuietPeriods,
          };
        } else {
          cpuCandidate = cpuQueue.shift();
        }
      }
    }

    throw new LHError(
      cpuCandidate
        ? LHError.errors.NO_TTI_NETWORK_IDLE_PERIOD
        : LHError.errors.NO_TTI_CPU_IDLE_PERIOD
    );
  }

  /**
   * @param {LH.Artifacts.NavigationMetricComputationData} data
   * @param {LH.Artifacts.ComputedContext} context
   * @return {Promise<LH.Artifacts.LanternMetric>}
   */
  static computeSimulatedMetric(data, context) {
    const metricData = NavigationMetric.getMetricComputationInput(data);
    return LanternInteractive.request(metricData, context);
  }

  /**
   * @param {LH.Artifacts.NavigationMetricComputationData} data
   * @return {Promise<LH.Artifacts.Metric>}
   */
  static computeObservedMetric(data) {
    const {processedTrace, processedNavigation, networkRecords} = data;

    if (!processedNavigation.timestamps.domContentLoaded) {
      throw new LHError(LHError.errors.NO_DCL);
    }

    const longTasks = TracingProcessor.getMainThreadTopLevelEvents(processedTrace)
        .filter(event => event.duration >= 50);
    const quietPeriodInfo = Interactive.findOverlappingQuietPeriods(
      longTasks,
      networkRecords,
      processedNavigation
    );

    const cpuQuietPeriod = quietPeriodInfo.cpuQuietPeriod;

    const timestamp = Math.max(
      cpuQuietPeriod.start,
      processedNavigation.timestamps.firstContentfulPaint / 1000,
      processedNavigation.timestamps.domContentLoaded / 1000
    ) * 1000;
    const timing = (timestamp - processedNavigation.timestamps.timeOrigin) / 1000;
    return Promise.resolve({timing, timestamp});
  }
}

module.exports = makeComputedArtifact(Interactive);

/**
 * @typedef TimePeriod
 * @property {number} start
 * @property {number} end
 */

},{"../../gather/driver/network-monitor.js":69,"../../lib/lh-error.js":103,"../../lib/tracehouse/trace-processor.js":119,"../computed-artifact.js":9,"./lantern-interactive.js":24,"./navigation-metric.js":34}],22:[function(require,module,exports){
/**
 * @license Copyright 2018 The Lighthouse Authors. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.
 */
'use strict';

const makeComputedArtifact = require('../computed-artifact.js');
const LanternMetric = require('./lantern-metric.js');
const BaseNode = require('../../lib/dependency-graph/base-node.js');

/** @typedef {BaseNode.Node} Node */
/** @typedef {import('../../lib/dependency-graph/cpu-node')} CPUNode */
/** @typedef {import('../../lib/dependency-graph/network-node')} NetworkNode */

class LanternFirstContentfulPaint extends LanternMetric {
  /**
   * @return {LH.Gatherer.Simulation.MetricCoefficients}
   */
  static get COEFFICIENTS() {
    return {
      intercept: 0,
      optimistic: 0.5,
      pessimistic: 0.5,
    };
  }

  /**
   * This function computes the set of URLs that *appeared* to be render-blocking based on our filter,
   * *but definitely were not* render-blocking based on the timing of their EvaluateScript task.
   * It also computes the set of corresponding CPU node ids that were needed for the paint at the
   * given timestamp.
   *
   * @param {Node} graph
   * @param {number} filterTimestamp The timestamp used to filter out tasks that occured after our
   *    paint of interest. Typically this is First Contentful Paint or First Meaningful Paint.
   * @param {function(NetworkNode):boolean} blockingScriptFilter The function that determines which scripts
   *    should be considered *possibly* render-blocking.
   * @param {(function(CPUNode):boolean)=} extraBlockingCpuNodesToIncludeFilter The function that determines which CPU nodes
   *    should also be included in our blocking node IDs set.
   * @return {{definitelyNotRenderBlockingScriptUrls: Set<string>, blockingCpuNodeIds: Set<string>}}
   */
  static getBlockingNodeData(
      graph,
      filterTimestamp,
      blockingScriptFilter,
      extraBlockingCpuNodesToIncludeFilter
  ) {
    /** @type {Map<string, CPUNode>} A map of blocking script URLs to the earliest EvaluateScript task node that executed them. */
    const scriptUrlToNodeMap = new Map();

    /** @type {Array<CPUNode>} */
    const cpuNodes = [];
    graph.traverse(node => {
      if (node.type === BaseNode.TYPES.CPU) {
        // A task is *possibly* render blocking if it *started* before filterTimestamp.
        // We use startTime here because the paint event can be *inside* the task that was render blocking.
        if (node.startTime <= filterTimestamp) cpuNodes.push(node);

        // Build our script URL map to find the earliest EvaluateScript task node.
        const scriptUrls = node.getEvaluateScriptURLs();
        for (const url of scriptUrls) {
          // Use the earliest CPU node we find.
          const existing = scriptUrlToNodeMap.get(url) || node;
          scriptUrlToNodeMap.set(url, node.startTime < existing.startTime ? node : existing);
        }
      }
    });

    cpuNodes.sort((a, b) => a.startTime - b.startTime);

    // A script is *possibly* render blocking if it finished loading before filterTimestamp.
    const possiblyRenderBlockingScriptUrls = LanternMetric.getScriptUrls(graph, node => {
      return node.endTime <= filterTimestamp && blockingScriptFilter(node);
    });

    // A script is *definitely not* render blocking if its EvaluateScript task started after filterTimestamp.
    /** @type {Set<string>} */
    const definitelyNotRenderBlockingScriptUrls = new Set();
    /** @type {Set<string>} */
    const blockingCpuNodeIds = new Set();
    for (const url of possiblyRenderBlockingScriptUrls) {
      // Lookup the CPU node that had the earliest EvaluateScript for this URL.
      const cpuNodeForUrl = scriptUrlToNodeMap.get(url);

      // If we can't find it at all, we can't conclude anything, so just skip it.
      if (!cpuNodeForUrl) continue;

      // If we found it and it was in our `cpuNodes` set that means it finished before filterTimestamp, so it really is render-blocking.
      if (cpuNodes.includes(cpuNodeForUrl)) {
        blockingCpuNodeIds.add(cpuNodeForUrl.id);
        continue;
      }

      // We couldn't find the evaluate script in the set of CPU nodes that ran before our paint, so
      // it must not have been necessary for the paint.
      definitelyNotRenderBlockingScriptUrls.add(url);
    }

    // The first layout, first paint, and first ParseHTML are almost always necessary for first paint,
    // so we always include those CPU nodes.
    const firstLayout = cpuNodes.find(node => node.didPerformLayout());
    if (firstLayout) blockingCpuNodeIds.add(firstLayout.id);
    const firstPaint = cpuNodes.find(node => node.childEvents.some(e => e.name === 'Paint'));
    if (firstPaint) blockingCpuNodeIds.add(firstPaint.id);
    const firstParse = cpuNodes.find(node => node.childEvents.some(e => e.name === 'ParseHTML'));
    if (firstParse) blockingCpuNodeIds.add(firstParse.id);

    // If a CPU filter was passed in, we also want to include those extra nodes.
    if (extraBlockingCpuNodesToIncludeFilter) {
      cpuNodes
        .filter(extraBlockingCpuNodesToIncludeFilter)
        .forEach(node => blockingCpuNodeIds.add(node.id));
    }

    return {
      definitelyNotRenderBlockingScriptUrls,
      blockingCpuNodeIds,
    };
  }

  /**
   * This function computes the graph required for the first paint of interest.
   *
   * @param {Node} dependencyGraph
   * @param {number} paintTs The timestamp used to filter out tasks that occured after our
   *    paint of interest. Typically this is First Contentful Paint or First Meaningful Paint.
   * @param {function(NetworkNode):boolean} blockingResourcesFilter The function that determines which resources
   *    should be considered *possibly* render-blocking.
   * @param {(function(CPUNode):boolean)=} extraBlockingCpuNodesToIncludeFilter The function that determines which CPU nodes
   *    should also be included in our blocking node IDs set.
   * @return {Node}
   */
  static getFirstPaintBasedGraph(
      dependencyGraph,
      paintTs,
      blockingResourcesFilter,
      extraBlockingCpuNodesToIncludeFilter
  ) {
    const {
      definitelyNotRenderBlockingScriptUrls,
      blockingCpuNodeIds,
    } = this.getBlockingNodeData(
      dependencyGraph,
      paintTs,
      blockingResourcesFilter,
      extraBlockingCpuNodesToIncludeFilter
    );

    return dependencyGraph.cloneWithRelationships(node => {
      if (node.type === BaseNode.TYPES.NETWORK) {
        // Exclude all nodes that ended after paintTs (except for the main document which we always consider necessary)
        if (node.endTime > paintTs && !node.isMainDocument()) return false;

        const url = node.record.url;
        // If the URL definitely wasn't render-blocking then we filter it out.
        if (definitelyNotRenderBlockingScriptUrls.has(url)) {
          return false;
        }

        return blockingResourcesFilter(node);
      } else {
        // If it's a CPU node, just check if it was blocking.
        return blockingCpuNodeIds.has(node.id);
      }
    });
  }

  /**
   * @param {Node} dependencyGraph
   * @param {LH.Artifacts.ProcessedNavigation} processedNavigation
   * @return {Node}
   */
  static getOptimisticGraph(dependencyGraph, processedNavigation) {
    return this.getFirstPaintBasedGraph(
      dependencyGraph,
      processedNavigation.timestamps.firstContentfulPaint,
      // In the optimistic graph we exclude resources that appeared to be render blocking but were
      // initiated by a script. While they typically have a very high importance and tend to have a
      // significant impact on the page's content, these resources don't technically block rendering.
      node => node.hasRenderBlockingPriority() && node.initiatorType !== 'script'
    );
  }

  /**
   * @param {Node} dependencyGraph
   * @param {LH.Artifacts.ProcessedNavigation} processedNavigation
   * @return {Node}
   */
  static getPessimisticGraph(dependencyGraph, processedNavigation) {
    return this.getFirstPaintBasedGraph(
      dependencyGraph,
      processedNavigation.timestamps.firstContentfulPaint,
      node => node.hasRenderBlockingPriority()
    );
  }
}

module.exports = makeComputedArtifact(LanternFirstContentfulPaint);

},{"../../lib/dependency-graph/base-node.js":86,"../computed-artifact.js":9,"./lantern-metric.js":27}],23:[function(require,module,exports){
/**
 * @license Copyright 2018 The Lighthouse Authors. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.
 */
'use strict';

const makeComputedArtifact = require('../computed-artifact.js');
const LanternMetric = require('./lantern-metric.js');
const LHError = require('../../lib/lh-error.js');
const LanternFirstContentfulPaint = require('./lantern-first-contentful-paint.js');

/** @typedef {import('../../lib/dependency-graph/base-node.js').Node} Node */

class LanternFirstMeaningfulPaint extends LanternMetric {
  /**
   * @return {LH.Gatherer.Simulation.MetricCoefficients}
   */
  static get COEFFICIENTS() {
    return {
      intercept: 0,
      optimistic: 0.5,
      pessimistic: 0.5,
    };
  }

  /**
   * @param {Node} dependencyGraph
   * @param {LH.Artifacts.ProcessedNavigation} processedNavigation
   * @return {Node}
   */
  static getOptimisticGraph(dependencyGraph, processedNavigation) {
    const fmp = processedNavigation.timestamps.firstMeaningfulPaint;
    if (!fmp) {
      throw new LHError(LHError.errors.NO_FMP);
    }

    return LanternFirstContentfulPaint.getFirstPaintBasedGraph(
      dependencyGraph,
      fmp,
      // See LanternFirstContentfulPaint's getOptimisticGraph implementation for a longer description
      // of why we exclude script initiated resources here.
      node => node.hasRenderBlockingPriority() && node.initiatorType !== 'script'
    );
  }

  /**
   * @param {Node} dependencyGraph
   * @param {LH.Artifacts.ProcessedNavigation} processedNavigation
   * @return {Node}
   */
  static getPessimisticGraph(dependencyGraph, processedNavigation) {
    const fmp = processedNavigation.timestamps.firstMeaningfulPaint;
    if (!fmp) {
      throw new LHError(LHError.errors.NO_FMP);
    }

    return LanternFirstContentfulPaint.getFirstPaintBasedGraph(
      dependencyGraph,
      fmp,
      node => node.hasRenderBlockingPriority(),
      // For pessimistic FMP we'll include *all* layout nodes
      node => node.didPerformLayout()
    );
  }

  /**
   * @param {LH.Artifacts.MetricComputationDataInput} data
   * @param {LH.Artifacts.ComputedContext} context
   * @return {Promise<LH.Artifacts.LanternMetric>}
   */
  static async compute_(data, context) {
    const fcpResult = await LanternFirstContentfulPaint.request(data, context);
    const metricResult = await this.computeMetricWithGraphs(data, context);
    metricResult.timing = Math.max(metricResult.timing, fcpResult.timing);
    return metricResult;
  }
}

module.exports = makeComputedArtifact(LanternFirstMeaningfulPaint);

},{"../../lib/lh-error.js":103,"../computed-artifact.js":9,"./lantern-first-contentful-paint.js":22,"./lantern-metric.js":27}],24:[function(require,module,exports){
/**
 * @license Copyright 2018 The Lighthouse Authors. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.
 */
'use strict';

const makeComputedArtifact = require('../computed-artifact.js');
const LanternMetric = require('./lantern-metric.js');
const BaseNode = require('../../lib/dependency-graph/base-node.js');
const NetworkRequest = require('../../lib/network-request.js');
const LanternFirstMeaningfulPaint = require('./lantern-first-meaningful-paint.js');

/** @typedef {BaseNode.Node} Node */

// Any CPU task of 20 ms or more will end up being a critical long task on mobile
const CRITICAL_LONG_TASK_THRESHOLD = 20;

class LanternInteractive extends LanternMetric {
  /**
   * @return {LH.Gatherer.Simulation.MetricCoefficients}
   */
  static get COEFFICIENTS() {
    return {
      intercept: 0,
      optimistic: 0.5,
      pessimistic: 0.5,
    };
  }

  /**
   * @param {Node} dependencyGraph
   * @return {Node}
   */
  static getOptimisticGraph(dependencyGraph) {
    // Adjust the critical long task threshold for microseconds
    const minimumCpuTaskDuration = CRITICAL_LONG_TASK_THRESHOLD * 1000;

    return dependencyGraph.cloneWithRelationships(node => {
      // Include everything that might be a long task
      if (node.type === BaseNode.TYPES.CPU) {
        return node.event.dur > minimumCpuTaskDuration;
      }

      // Include all scripts and high priority requests, exclude all images
      const isImage = node.record.resourceType === NetworkRequest.TYPES.Image;
      const isScript = node.record.resourceType === NetworkRequest.TYPES.Script;
      return (
        !isImage &&
        (isScript ||
          node.record.priority === 'High' ||
          node.record.priority === 'VeryHigh')
      );
    });
  }

  /**
   * @param {Node} dependencyGraph
   * @return {Node}
   */
  static getPessimisticGraph(dependencyGraph) {
    return dependencyGraph;
  }

  /**
   * @param {LH.Gatherer.Simulation.Result} simulationResult
   * @param {import('./lantern-metric.js').Extras} extras
   * @return {LH.Gatherer.Simulation.Result}
   */
  static getEstimateFromSimulation(simulationResult, extras) {
    if (!extras.fmpResult) throw new Error('missing fmpResult');

    const lastTaskAt = LanternInteractive.getLastLongTaskEndTime(simulationResult.nodeTimings);
    const minimumTime = extras.optimistic
      ? extras.fmpResult.optimisticEstimate.timeInMs
      : extras.fmpResult.pessimisticEstimate.timeInMs;
    return {
      timeInMs: Math.max(minimumTime, lastTaskAt),
      nodeTimings: simulationResult.nodeTimings,
    };
  }

  /**
   * @param {LH.Artifacts.MetricComputationDataInput} data
   * @param {LH.Artifacts.ComputedContext} context
   * @return {Promise<LH.Artifacts.LanternMetric>}
   */
  static async compute_(data, context) {
    const fmpResult = await LanternFirstMeaningfulPaint.request(data, context);
    const metricResult = await this.computeMetricWithGraphs(data, context, {fmpResult});
    metricResult.timing = Math.max(metricResult.timing, fmpResult.timing);
    return metricResult;
  }

  /**
   * @param {LH.Gatherer.Simulation.Result['nodeTimings']} nodeTimings
   * @return {number}
   */
  static getLastLongTaskEndTime(nodeTimings, duration = 50) {
    return Array.from(nodeTimings.entries())
      .filter(([node, timing]) => {
        if (node.type !== BaseNode.TYPES.CPU) return false;
        return timing.duration > duration;
      })
      .map(([_, timing]) => timing.endTime)
      .reduce((max, x) => Math.max(max || 0, x || 0), 0);
  }
}

module.exports = makeComputedArtifact(LanternInteractive);

},{"../../lib/dependency-graph/base-node.js":86,"../../lib/network-request.js":109,"../computed-artifact.js":9,"./lantern-first-meaningful-paint.js":23,"./lantern-metric.js":27}],25:[function(require,module,exports){
/**
 * @license Copyright 2019 The Lighthouse Authors. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.
 */
'use strict';

const makeComputedArtifact = require('../computed-artifact.js');
const LanternMetric = require('./lantern-metric.js');
const LHError = require('../../lib/lh-error.js');
const LanternFirstContentfulPaint = require('./lantern-first-contentful-paint.js');

/** @typedef {import('../../lib/dependency-graph/base-node.js').Node} Node */

class LanternLargestContentfulPaint extends LanternMetric {
  /**
   * @return {LH.Gatherer.Simulation.MetricCoefficients}
   */
  static get COEFFICIENTS() {
    return {
      intercept: 0,
      optimistic: 0.5,
      pessimistic: 0.5,
    };
  }

  /**
   * Low priority image nodes are usually offscreen and very unlikely to be the
   * resource that is required for LCP. Our LCP graphs include everything except for these images.
   *
   * @param {Node} node
   * @return {boolean}
   */
  static isNotLowPriorityImageNode(node) {
    if (node.type !== 'network') return true;

    const isImage = node.record.resourceType === 'Image';
    const isLowPriority = node.record.priority === 'Low' || node.record.priority === 'VeryLow';
    return !isImage || !isLowPriority;
  }

  /**
   * @param {Node} dependencyGraph
   * @param {LH.Artifacts.ProcessedNavigation} processedNavigation
   * @return {Node}
   */
  static getOptimisticGraph(dependencyGraph, processedNavigation) {
    const lcp = processedNavigation.timestamps.largestContentfulPaint;
    if (!lcp) {
      throw new LHError(LHError.errors.NO_LCP);
    }

    return LanternFirstContentfulPaint.getFirstPaintBasedGraph(
      dependencyGraph,
      lcp,
      LanternLargestContentfulPaint.isNotLowPriorityImageNode
    );
  }

  /**
   * @param {Node} dependencyGraph
   * @param {LH.Artifacts.ProcessedNavigation} processedNavigation
   * @return {Node}
   */
  static getPessimisticGraph(dependencyGraph, processedNavigation) {
    const lcp = processedNavigation.timestamps.largestContentfulPaint;
    if (!lcp) {
      throw new LHError(LHError.errors.NO_LCP);
    }

    return LanternFirstContentfulPaint.getFirstPaintBasedGraph(
      dependencyGraph,
      lcp,
      _ => true,
      // For pessimistic LCP we'll include *all* layout nodes
      node => node.didPerformLayout()
    );
  }

  /**
   * @param {LH.Gatherer.Simulation.Result} simulationResult
   * @return {LH.Gatherer.Simulation.Result}
   */
  static getEstimateFromSimulation(simulationResult) {
    const nodeTimesNotOffscreenImages = Array.from(simulationResult.nodeTimings.entries())
      .filter(entry => LanternLargestContentfulPaint.isNotLowPriorityImageNode(entry[0]))
      .map(entry => entry[1].endTime);

    return {
      timeInMs: Math.max(...nodeTimesNotOffscreenImages),
      nodeTimings: simulationResult.nodeTimings,
    };
  }

  /**
   * @param {LH.Artifacts.MetricComputationDataInput} data
   * @param {LH.Artifacts.ComputedContext} context
   * @return {Promise<LH.Artifacts.LanternMetric>}
   */
  static async compute_(data, context) {
    const fcpResult = await LanternFirstContentfulPaint.request(data, context);
    const metricResult = await this.computeMetricWithGraphs(data, context);
    metricResult.timing = Math.max(metricResult.timing, fcpResult.timing);
    return metricResult;
  }
}

module.exports = makeComputedArtifact(LanternLargestContentfulPaint);

},{"../../lib/lh-error.js":103,"../computed-artifact.js":9,"./lantern-first-contentful-paint.js":22,"./lantern-metric.js":27}],26:[function(require,module,exports){
/**
 * @license Copyright 2018 The Lighthouse Authors. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.
 */
'use strict';

const makeComputedArtifact = require('../computed-artifact.js');
const LanternMetricArtifact = require('./lantern-metric.js');
const BaseNode = require('../../lib/dependency-graph/base-node.js');
const LanternFirstContentfulPaint = require('./lantern-first-contentful-paint.js');

/** @typedef {BaseNode.Node} Node */

class LanternMaxPotentialFID extends LanternMetricArtifact {
  /**
   * @return {LH.Gatherer.Simulation.MetricCoefficients}
   */
  static get COEFFICIENTS() {
    return {
      intercept: 0,
      optimistic: 0.5,
      pessimistic: 0.5,
    };
  }

  /**
   * @param {Node} dependencyGraph
   * @return {Node}
   */
  static getOptimisticGraph(dependencyGraph) {
    return dependencyGraph;
  }

  /**
   * @param {Node} dependencyGraph
   * @return {Node}
   */
  static getPessimisticGraph(dependencyGraph) {
    return dependencyGraph;
  }

  /**
   * @param {LH.Gatherer.Simulation.Result} simulation
   * @param {import('./lantern-metric.js').Extras} extras
   * @return {LH.Gatherer.Simulation.Result}
   */
  static getEstimateFromSimulation(simulation, extras) {
    if (!extras.fcpResult) throw new Error('missing fcpResult');

    // Intentionally use the opposite FCP estimate, a more pessimistic FCP means that more tasks
    // are excluded from the FID computation, so a higher FCP means lower FID for same work.
    const fcpTimeInMs = extras.optimistic
      ? extras.fcpResult.pessimisticEstimate.timeInMs
      : extras.fcpResult.optimisticEstimate.timeInMs;

    const timings = LanternMaxPotentialFID.getTimingsAfterFCP(
      simulation.nodeTimings,
      fcpTimeInMs
    );

    return {
      timeInMs: Math.max(...timings.map(timing => timing.duration), 16),
      nodeTimings: simulation.nodeTimings,
    };
  }

  /**
   * @param {LH.Artifacts.MetricComputationDataInput} data
   * @param {LH.Artifacts.ComputedContext} context
   * @return {Promise<LH.Artifacts.LanternMetric>}
   */
  static async compute_(data, context) {
    const fcpResult = await LanternFirstContentfulPaint.request(data, context);
    return super.computeMetricWithGraphs(data, context, {fcpResult});
  }

  /**
   * @param {LH.Gatherer.Simulation.Result['nodeTimings']} nodeTimings
   * @param {number} fcpTimeInMs
   * @return {Array<{duration: number}>}
   */
  static getTimingsAfterFCP(nodeTimings, fcpTimeInMs) {
    return Array.from(nodeTimings.entries())
      .filter(([node, timing]) => node.type === BaseNode.TYPES.CPU && timing.endTime > fcpTimeInMs)
      .map(([_, timing]) => timing);
  }
}

module.exports = makeComputedArtifact(LanternMaxPotentialFID);

},{"../../lib/dependency-graph/base-node.js":86,"../computed-artifact.js":9,"./lantern-first-contentful-paint.js":22,"./lantern-metric.js":27}],27:[function(require,module,exports){
/**
 * @license Copyright 2018 The Lighthouse Authors. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.
 */
'use strict';

const BaseNode = require('../../lib/dependency-graph/base-node.js');
const NetworkRequest = require('../../lib/network-request.js');
const ProcessedTrace = require('../processed-trace.js');
const ProcessedNavigation = require('../processed-navigation.js');
const PageDependencyGraph = require('../page-dependency-graph.js');
const LoadSimulator = require('../load-simulator.js');

/** @typedef {BaseNode.Node} Node */
/** @typedef {import('../../lib/dependency-graph/network-node')} NetworkNode */
/** @typedef {import('../../lib/dependency-graph/simulator/simulator')} Simulator */

/**
 * @typedef Extras
 * @property {boolean} optimistic
 * @property {LH.Artifacts.LanternMetric=} fcpResult
 * @property {LH.Artifacts.LanternMetric=} fmpResult
 * @property {LH.Artifacts.LanternMetric=} interactiveResult
 * @property {{speedIndex: number}=} speedline
 */

class LanternMetricArtifact {
  /**
   * @param {Node} dependencyGraph
   * @param {function(NetworkNode):boolean=} condition
   * @return {Set<string>}
   */
  static getScriptUrls(dependencyGraph, condition) {
    /** @type {Set<string>} */
    const scriptUrls = new Set();

    dependencyGraph.traverse(node => {
      if (node.type === BaseNode.TYPES.CPU) return;
      if (node.record.resourceType !== NetworkRequest.TYPES.Script) return;
      if (condition && !condition(node)) return;
      scriptUrls.add(node.record.url);
    });

    return scriptUrls;
  }

  /**
   * @return {LH.Gatherer.Simulation.MetricCoefficients}
   */
  static get COEFFICIENTS() {
    throw new Error('COEFFICIENTS unimplemented!');
  }

  /**
   * Returns the coefficients, scaled by the throttling settings if needed by the metric.
   * Some lantern metrics (speed-index) use components in their estimate that are not
   * from the simulator. In this case, we need to adjust the coefficients as the target throttling
   * settings change.
   *
   * @param {number} rttMs
   * @return {LH.Gatherer.Simulation.MetricCoefficients}
   */
  static getScaledCoefficients(rttMs) { // eslint-disable-line no-unused-vars
    return this.COEFFICIENTS;
  }

  /**
   * @param {Node} dependencyGraph
   * @param {LH.Artifacts.ProcessedNavigation} processedNavigation
   * @return {Node}
   */
  static getOptimisticGraph(dependencyGraph, processedNavigation) { // eslint-disable-line no-unused-vars
    throw new Error('Optimistic graph unimplemented!');
  }

  /**
   * @param {Node} dependencyGraph
   * @param {LH.Artifacts.ProcessedNavigation} processedNavigation
   * @return {Node}
   */
  static getPessimisticGraph(dependencyGraph, processedNavigation) { // eslint-disable-line no-unused-vars
    throw new Error('Pessmistic graph unimplemented!');
  }

  /**
   * @param {LH.Gatherer.Simulation.Result} simulationResult
   * @param {Extras} extras
   * @return {LH.Gatherer.Simulation.Result}
   */
  static getEstimateFromSimulation(simulationResult, extras) { // eslint-disable-line no-unused-vars
    return simulationResult;
  }

  /**
   * @param {LH.Artifacts.MetricComputationDataInput} data
   * @param {LH.Artifacts.ComputedContext} context
   * @param {Omit<Extras, 'optimistic'>=} extras
   * @return {Promise<LH.Artifacts.LanternMetric>}
   */
  static async computeMetricWithGraphs(data, context, extras) {
    // TODO: remove this fallback when lighthouse-pub-ads plugin can update.
    const gatherContext = data.gatherContext || {gatherMode: 'navigation'};
    const {trace, devtoolsLog, settings} = data;
    if (gatherContext.gatherMode !== 'navigation') {
      throw new Error(`Lantern metrics can only be computed on navigations`);
    }

    const metricName = this.name.replace('Lantern', '');
    const graph = await PageDependencyGraph.request({trace, devtoolsLog}, context);
    const processedTrace = await ProcessedTrace.request(trace, context);
    const processedNavigation = await ProcessedNavigation.request(processedTrace, context);
    const simulator = data.simulator ||
        await LoadSimulator.request({devtoolsLog, settings}, context);

    const optimisticGraph = this.getOptimisticGraph(graph, processedNavigation);
    const pessimisticGraph = this.getPessimisticGraph(graph, processedNavigation);

    /** @type {{flexibleOrdering?: boolean, label?: string}} */
    let simulateOptions = {label: `optimistic${metricName}`};
    const optimisticSimulation = simulator.simulate(optimisticGraph, simulateOptions);

    simulateOptions = {label: `optimisticFlex${metricName}`, flexibleOrdering: true};
    const optimisticFlexSimulation = simulator.simulate(optimisticGraph, simulateOptions);

    simulateOptions = {label: `pessimistic${metricName}`};
    const pessimisticSimulation = simulator.simulate(pessimisticGraph, simulateOptions);

    const optimisticEstimate = this.getEstimateFromSimulation(
      optimisticSimulation.timeInMs < optimisticFlexSimulation.timeInMs ?
        optimisticSimulation : optimisticFlexSimulation, {...extras, optimistic: true}
    );

    const pessimisticEstimate = this.getEstimateFromSimulation(
      pessimisticSimulation,
      {...extras, optimistic: false}
    );

    const coefficients = this.getScaledCoefficients(simulator.rtt);
    // Estimates under 1s don't really follow the normal curve fit, minimize the impact of the intercept
    const interceptMultiplier = coefficients.intercept > 0 ?
      Math.min(1, optimisticEstimate.timeInMs / 1000) : 1;
    const timing =
      coefficients.intercept * interceptMultiplier +
      coefficients.optimistic * optimisticEstimate.timeInMs +
      coefficients.pessimistic * pessimisticEstimate.timeInMs;

    return {
      timing,
      optimisticEstimate,
      pessimisticEstimate,
      optimisticGraph,
      pessimisticGraph,
    };
  }

  /**
   * @param {LH.Artifacts.MetricComputationDataInput} data
   * @param {LH.Artifacts.ComputedContext} context
   * @return {Promise<LH.Artifacts.LanternMetric>}
   */
  static async compute_(data, context) {
    return this.computeMetricWithGraphs(data, context);
  }
}

module.exports = LanternMetricArtifact;

},{"../../lib/dependency-graph/base-node.js":86,"../../lib/network-request.js":109,"../load-simulator.js":13,"../page-dependency-graph.js":41,"../processed-navigation.js":42,"../processed-trace.js":43}],28:[function(require,module,exports){
/**
 * @license Copyright 2018 The Lighthouse Authors. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.
 */
'use strict';

const makeComputedArtifact = require('../computed-artifact.js');
const LanternMetric = require('./lantern-metric.js');
const BaseNode = require('../../lib/dependency-graph/base-node.js');
const Speedline = require('../speedline.js');
const LanternFirstContentfulPaint = require('./lantern-first-contentful-paint.js');
const defaultThrottling = require('../../config/constants.js').throttling;

/** @typedef {BaseNode.Node} Node */

class LanternSpeedIndex extends LanternMetric {
  /**
   * @return {LH.Gatherer.Simulation.MetricCoefficients}
   */
  static get COEFFICIENTS() {
    return {
      // Negative intercept is OK because estimate is Math.max(FCP, Speed Index) and
      // the optimistic estimate is based on the real observed speed index rather than a real
      // lantern graph.
      intercept: -250,
      optimistic: 1.4,
      pessimistic: 0.65,
    };
  }

  /**
   * @param {number} rttMs
   * @return {LH.Gatherer.Simulation.MetricCoefficients}
   */
  static getScaledCoefficients(rttMs) { // eslint-disable-line no-unused-vars
    // We want to scale our default coefficients based on the speed of the connection.
    // We will linearly interpolate coefficients for the passed-in rttMs based on two pre-determined points:
    //   1. Baseline point of 30 ms RTT where Speed Index should be a ~50/50 blend of optimistic/pessimistic.
    //      30 ms was based on a typical home WiFi connection's actual RTT.
    //      Coefficients here follow from the fact that the optimistic estimate should be very close
    //      to reality at this connection speed and the pessimistic estimate compensates for minor
    //      connection speed differences.
    //   2. Default throttled point of 150 ms RTT where the default coefficients have been determined to be most accurate.
    //      Coefficients here were determined through thorough analysis and linear regression on the
    //      lantern test data set. See lighthouse-core/scripts/test-lantern.sh for more detail.
    // While the coefficients haven't been analyzed at the interpolated points, it's our current best effort.
    const defaultCoefficients = this.COEFFICIENTS;
    const defaultRttExcess = defaultThrottling.mobileSlow4G.rttMs - 30;
    const multiplier = Math.max((rttMs - 30) / defaultRttExcess, 0);

    return {
      intercept: defaultCoefficients.intercept * multiplier,
      optimistic: 0.5 + (defaultCoefficients.optimistic - 0.5) * multiplier,
      pessimistic: 0.5 + (defaultCoefficients.pessimistic - 0.5) * multiplier,
    };
  }

  /**
   * @param {Node} dependencyGraph
   * @return {Node}
   */
  static getOptimisticGraph(dependencyGraph) {
    return dependencyGraph;
  }

  /**
   * @param {Node} dependencyGraph
   * @return {Node}
   */
  static getPessimisticGraph(dependencyGraph) {
    return dependencyGraph;
  }

  /**
   * @param {LH.Gatherer.Simulation.Result} simulationResult
   * @param {import('./lantern-metric.js').Extras} extras
   * @return {LH.Gatherer.Simulation.Result}
   */
  static getEstimateFromSimulation(simulationResult, extras) {
    if (!extras.fcpResult) throw new Error('missing fcpResult');
    if (!extras.speedline) throw new Error('missing speedline');

    const fcpTimeInMs = extras.fcpResult.pessimisticEstimate.timeInMs;
    const estimate = extras.optimistic
      ? extras.speedline.speedIndex
      : LanternSpeedIndex.computeLayoutBasedSpeedIndex(simulationResult.nodeTimings, fcpTimeInMs);
    return {
      timeInMs: estimate,
      nodeTimings: simulationResult.nodeTimings,
    };
  }

  /**
   * @param {LH.Artifacts.MetricComputationDataInput} data
   * @param {LH.Artifacts.ComputedContext} context
   * @return {Promise<LH.Artifacts.LanternMetric>}
   */
  static async compute_(data, context) {
    const speedline = await Speedline.request(data.trace, context);
    const fcpResult = await LanternFirstContentfulPaint.request(data, context);
    const metricResult = await this.computeMetricWithGraphs(data, context, {
      speedline,
      fcpResult,
    });
    metricResult.timing = Math.max(metricResult.timing, fcpResult.timing);
    return metricResult;
  }

  /**
   * Approximate speed index using layout events from the simulated node timings.
   * The layout-based speed index is the weighted average of the endTime of CPU nodes that contained
   * a 'Layout' task. log(duration) is used as the weight to stand for "significance" to the page.
   *
   * If no layout events can be found or the endTime of a CPU task is too early, FCP is used instead.
   *
   * This approach was determined after evaluating the accuracy/complexity tradeoff of many
   * different methods. Read more in the evaluation doc.
   *
   * @see https://docs.google.com/document/d/1qJWXwxoyVLVadezIp_Tgdk867G3tDNkkVRvUJSH3K1E/edit#
   * @param {LH.Gatherer.Simulation.Result['nodeTimings']} nodeTimings
   * @param {number} fcpTimeInMs
   * @return {number}
   */
  static computeLayoutBasedSpeedIndex(nodeTimings, fcpTimeInMs) {
    /** @type {Array<{time: number, weight: number}>} */
    const layoutWeights = [];
    for (const [node, timing] of nodeTimings.entries()) {
      if (node.type !== BaseNode.TYPES.CPU) continue;

      if (node.childEvents.some(x => x.name === 'Layout')) {
        const timingWeight = Math.max(Math.log2(timing.endTime - timing.startTime), 0);
        layoutWeights.push({time: timing.endTime, weight: timingWeight});
      }
    }

    const totalWeightedTime = layoutWeights
      .map(evt => evt.weight * Math.max(evt.time, fcpTimeInMs))
      .reduce((a, b) => a + b, 0);
    const totalWeight = layoutWeights.map(evt => evt.weight).reduce((a, b) => a + b, 0);

    if (!totalWeight) return fcpTimeInMs;
    return totalWeightedTime / totalWeight;
  }
}

module.exports = makeComputedArtifact(LanternSpeedIndex);

},{"../../config/constants.js":56,"../../lib/dependency-graph/base-node.js":86,"../computed-artifact.js":9,"../speedline.js":46,"./lantern-first-contentful-paint.js":22,"./lantern-metric.js":27}],29:[function(require,module,exports){
/**
 * @license Copyright 2019 The Lighthouse Authors. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.
 */
'use strict';

const makeComputedArtifact = require('../computed-artifact.js');
const LanternMetric = require('./lantern-metric.js');
const BaseNode = require('../../lib/dependency-graph/base-node.js');
const LanternFirstContentfulPaint = require('./lantern-first-contentful-paint.js');
const LanternInteractive = require('./lantern-interactive.js');

/** @typedef {BaseNode.Node} Node */

class LanternTotalBlockingTime extends LanternMetric {
  /**
   * @return {LH.Gatherer.Simulation.MetricCoefficients}
   */
  static get COEFFICIENTS() {
    return {
      intercept: 0,
      optimistic: 0.5,
      pessimistic: 0.5,
    };
  }

  /**
   * @param {Node} dependencyGraph
   * @return {Node}
   */
  static getOptimisticGraph(dependencyGraph) {
    return dependencyGraph;
  }

  /**
   * @param {Node} dependencyGraph
   * @return {Node}
   */
  static getPessimisticGraph(dependencyGraph) {
    return dependencyGraph;
  }

  /**
   * @param {LH.Gatherer.Simulation.Result} simulation
   * @param {import('./lantern-metric.js').Extras} extras
   * @return {LH.Gatherer.Simulation.Result}
   */
  static getEstimateFromSimulation(simulation, extras) {
    if (!extras.fcpResult) throw new Error('missing fcpResult');
    if (!extras.interactiveResult) throw new Error('missing interactiveResult');

    // Intentionally use the opposite FCP estimate. A pessimistic FCP is higher than equal to an
    // optimistic FCP, which means potentially more tasks are excluded from the Total Blocking Time
    // computation. So a more pessimistic FCP gives a more optimistic Total Blocking Time for the
    // same work.
    const fcpTimeInMs = extras.optimistic
      ? extras.fcpResult.pessimisticEstimate.timeInMs
      : extras.fcpResult.optimisticEstimate.timeInMs;

    // Similarly, we always have pessimistic TTI >= optimistic TTI. Therefore, picking optimistic
    // TTI means our window of interest is smaller and thus potentially more tasks are excluded from
    // Total Blocking Time computation, yielding a lower (more optimistic) Total Blocking Time value
    // for the same work.
    const interactiveTimeMs = extras.optimistic
      ? extras.interactiveResult.optimisticEstimate.timeInMs
      : extras.interactiveResult.pessimisticEstimate.timeInMs;

    // Require here to resolve circular dependency.
    const TotalBlockingTime = require('./total-blocking-time.js');
    const minDurationMs = TotalBlockingTime.BLOCKING_TIME_THRESHOLD;

    const events = LanternTotalBlockingTime.getTopLevelEvents(
      simulation.nodeTimings,
      minDurationMs
    );

    return {
      timeInMs: TotalBlockingTime.calculateSumOfBlockingTime(
        events,
        fcpTimeInMs,
        interactiveTimeMs
      ),
      nodeTimings: simulation.nodeTimings,
    };
  }

  /**
   * @param {LH.Artifacts.MetricComputationDataInput} data
   * @param {LH.Artifacts.ComputedContext} context
   * @return {Promise<LH.Artifacts.LanternMetric>}
   */
  static async compute_(data, context) {
    const fcpResult = await LanternFirstContentfulPaint.request(data, context);
    const interactiveResult = await LanternInteractive.request(data, context);
    return this.computeMetricWithGraphs(data, context, {fcpResult, interactiveResult});
  }

  /**
   * @param {LH.Gatherer.Simulation.Result['nodeTimings']} nodeTimings
   * @param {number} minDurationMs
   */
  static getTopLevelEvents(nodeTimings, minDurationMs) {
    /** @type {Array<{start: number, end: number, duration: number}>}
     */
    const events = [];

    for (const [node, timing] of nodeTimings.entries()) {
      if (node.type !== BaseNode.TYPES.CPU) continue;
      // Filtering out events below minimum duration.
      if (timing.duration < minDurationMs) continue;

      events.push({
        start: timing.startTime,
        end: timing.endTime,
        duration: timing.duration,
      });
    }

    return events;
  }
}

module.exports = makeComputedArtifact(LanternTotalBlockingTime);

},{"../../lib/dependency-graph/base-node.js":86,"../computed-artifact.js":9,"./lantern-first-contentful-paint.js":22,"./lantern-interactive.js":24,"./lantern-metric.js":27,"./total-blocking-time.js":37}],30:[function(require,module,exports){
/**
 * @license Copyright 2020 The Lighthouse Authors. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.
 */
'use strict';

/**
 * @fileoverview Computed Largest Contentful Paint (LCP) for all frames.
 */

const makeComputedArtifact = require('../computed-artifact.js');
const NavigationMetric = require('./navigation-metric.js');
const LHError = require('../../lib/lh-error.js');

class LargestContentfulPaintAllFrames extends NavigationMetric {
  /**
   * TODO: Simulate LCP all frames in lantern.
   * @return {Promise<LH.Artifacts.LanternMetric>}
   */
  static async computeSimulatedMetric() {
    throw new Error('LCP All Frames not implemented in lantern');
  }

  /**
   * @param {LH.Artifacts.NavigationMetricComputationData} data
   * @return {Promise<LH.Artifacts.Metric>}
   */
  static async computeObservedMetric(data) {
    const {processedNavigation} = data;
    if (processedNavigation.timings.largestContentfulPaintAllFrames === undefined) {
      throw new LHError(LHError.errors.NO_LCP_ALL_FRAMES);
    }

    return {
      timing: processedNavigation.timings.largestContentfulPaintAllFrames,
      timestamp: processedNavigation.timestamps.largestContentfulPaintAllFrames,
    };
  }
}

module.exports = makeComputedArtifact(LargestContentfulPaintAllFrames);

},{"../../lib/lh-error.js":103,"../computed-artifact.js":9,"./navigation-metric.js":34}],31:[function(require,module,exports){
/**
 * @license Copyright 2019 The Lighthouse Authors. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.
 */
'use strict';

/**
 * @fileoverview Computed Largest Contentful Paint (LCP), the paint time of the largest in-viewport contentful element
 * COMPAT: LCP's trace event was first introduced in m78. We can't surface an LCP for older Chrome versions
 * @see https://github.com/WICG/largest-contentful-paint
 * @see https://wicg.github.io/largest-contentful-paint/
 * @see https://web.dev/largest-contentful-paint
 */

const makeComputedArtifact = require('../computed-artifact.js');
const NavigationMetric = require('./navigation-metric.js');
const LHError = require('../../lib/lh-error.js');
const LanternLargestContentfulPaint = require('./lantern-largest-contentful-paint.js');

class LargestContentfulPaint extends NavigationMetric {
  /**
   * @param {LH.Artifacts.NavigationMetricComputationData} data
   * @param {LH.Artifacts.ComputedContext} context
   * @return {Promise<LH.Artifacts.LanternMetric>}
   */
  static computeSimulatedMetric(data, context) {
    const metricData = NavigationMetric.getMetricComputationInput(data);
    return LanternLargestContentfulPaint.request(metricData, context);
  }

  /**
   * @param {LH.Artifacts.NavigationMetricComputationData} data
   * @return {Promise<LH.Artifacts.Metric>}
   */
  static async computeObservedMetric(data) {
    const {processedNavigation} = data;
    if (processedNavigation.timings.largestContentfulPaint === undefined) {
      throw new LHError(LHError.errors.NO_LCP);
    }

    return {
      timing: processedNavigation.timings.largestContentfulPaint,
      timestamp: processedNavigation.timestamps.largestContentfulPaint,
    };
  }
}

module.exports = makeComputedArtifact(LargestContentfulPaint);

},{"../../lib/lh-error.js":103,"../computed-artifact.js":9,"./lantern-largest-contentful-paint.js":25,"./navigation-metric.js":34}],32:[function(require,module,exports){
/**
 * @license Copyright 2018 The Lighthouse Authors. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.
 */
'use strict';

const makeComputedArtifact = require('../computed-artifact.js');
const NavigationMetric = require('./navigation-metric.js');
const LanternMaxPotentialFID = require('./lantern-max-potential-fid.js');
const TracingProcessor = require('../../lib/tracehouse/trace-processor.js');

class MaxPotentialFID extends NavigationMetric {
  /**
   * @param {LH.Artifacts.NavigationMetricComputationData} data
   * @param {LH.Artifacts.ComputedContext} context
   * @return {Promise<LH.Artifacts.LanternMetric>}
   */
  static computeSimulatedMetric(data, context) {
    const metricData = NavigationMetric.getMetricComputationInput(data);
    return LanternMaxPotentialFID.request(metricData, context);
  }

  /**
   * @param {LH.Artifacts.NavigationMetricComputationData} data
   * @return {Promise<LH.Artifacts.Metric>}
   */
  static computeObservedMetric(data) {
    const {firstContentfulPaint} = data.processedNavigation.timings;

    const events = TracingProcessor.getMainThreadTopLevelEvents(
      data.processedTrace,
      firstContentfulPaint
    ).filter(evt => evt.duration >= 1);

    return Promise.resolve({
      timing: Math.max(...events.map(evt => evt.duration), 16),
    });
  }
}

module.exports = makeComputedArtifact(MaxPotentialFID);

},{"../../lib/tracehouse/trace-processor.js":119,"../computed-artifact.js":9,"./lantern-max-potential-fid.js":26,"./navigation-metric.js":34}],33:[function(require,module,exports){
/**
 * @license Copyright 2018 The Lighthouse Authors. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.
 */
'use strict';

const TracingProcessor = require('../../lib/tracehouse/trace-processor.js');
const ProcessedTrace = require('../processed-trace.js');
const ProcessedNavigation = require('../processed-navigation.js');
const NetworkRecords = require('../network-records.js');

/**
 * @fileOverview Encapsulates logic for choosing the correct metric computation method based on the
 * specified throttling settings, supporting simulated and observed metric types.
 *
 * To implement a fully supported metric:
 *     - Override the computeObservedMetric method with the observed-mode implementation.
 *     - Override the computeSimulatedMetric method with the simulated-mode implementation (which
 *       may call another computed artifact with the name LanternMyMetricName).
 */
class Metric {
  constructor() {}

  /**
   * Narrows the metric computation data to the input so child metric requests can be cached.
   *
   * @param {LH.Artifacts.MetricComputationData} data
   * @return {LH.Artifacts.MetricComputationDataInput}
   */
  static getMetricComputationInput(data) {
    return {
      trace: data.trace,
      devtoolsLog: data.devtoolsLog,
      gatherContext: data.gatherContext,
      settings: data.settings,
    };
  }

  /**
   * @param {LH.Artifacts.MetricComputationData} data
   * @param {LH.Artifacts.ComputedContext} context
   * @return {Promise<LH.Artifacts.LanternMetric>}
   */
  static computeSimulatedMetric(data, context) { // eslint-disable-line no-unused-vars
    throw new Error('Unimplemented');
  }

  /**
   * @param {LH.Artifacts.MetricComputationData} data
   * @param {LH.Artifacts.ComputedContext} context
   * @return {Promise<LH.Artifacts.Metric>}
   */
  static computeObservedMetric(data, context) { // eslint-disable-line no-unused-vars
    throw new Error('Unimplemented');
  }

  /**
   * @param {LH.Artifacts.MetricComputationDataInput} data
   * @param {LH.Artifacts.ComputedContext} context
   * @return {Promise<LH.Artifacts.LanternMetric|LH.Artifacts.Metric>}
   */
  static async compute_(data, context) {
    // TODO: remove this fallback when lighthouse-pub-ads plugin can update.
    const gatherContext = data.gatherContext || {gatherMode: 'navigation'};
    const {trace, devtoolsLog, settings} = data;
    if (!trace || !devtoolsLog || !settings) {
      throw new Error('Did not provide necessary metric computation data');
    }

    const processedTrace = await ProcessedTrace.request(trace, context);
    const processedNavigation = await ProcessedNavigation.request(processedTrace, context);

    const augmentedData = Object.assign({
      networkRecords: await NetworkRecords.request(devtoolsLog, context),
      gatherContext,
      processedTrace,
      processedNavigation,
    }, data);

    TracingProcessor.assertHasToplevelEvents(augmentedData.processedTrace.mainThreadEvents);

    switch (settings.throttlingMethod) {
      case 'simulate':
        if (gatherContext.gatherMode !== 'navigation') {
          throw new Error(`${gatherContext.gatherMode} does not support throttlingMethod simulate`);
        }

        return this.computeSimulatedMetric(augmentedData, context);
      case 'provided':
      case 'devtools':
        return this.computeObservedMetric(augmentedData, context);
      default:
        throw new TypeError(`Unrecognized throttling method: ${settings.throttlingMethod}`);
    }
  }
}

module.exports = Metric;

},{"../../lib/tracehouse/trace-processor.js":119,"../network-records.js":40,"../processed-navigation.js":42,"../processed-trace.js":43}],34:[function(require,module,exports){
/**
 * @license Copyright 2021 The Lighthouse Authors. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.
 */
'use strict';

const Metric = require('./metric.js');

/**
 * @fileOverview Enforces that a metric can only be computed on navigations.
 */
class NavigationMetric extends Metric {
  /**
   * @param {LH.Artifacts.NavigationMetricComputationData} data
   * @param {LH.Artifacts.ComputedContext} context
   * @return {Promise<LH.Artifacts.LanternMetric>}
   */
  static computeSimulatedMetric(data, context) { // eslint-disable-line no-unused-vars
    throw new Error('Unimplemented');
  }

  /**
   * @param {LH.Artifacts.NavigationMetricComputationData} data
   * @param {LH.Artifacts.ComputedContext} context
   * @return {Promise<LH.Artifacts.Metric>}
   */
  static computeObservedMetric(data, context) { // eslint-disable-line no-unused-vars
    throw new Error('Unimplemented');
  }

  /**
   * @param {LH.Artifacts.MetricComputationDataInput} data
   * @param {LH.Artifacts.ComputedContext} context
   * @return {Promise<LH.Artifacts.LanternMetric|LH.Artifacts.Metric>}
   */
  static async compute_(data, context) {
    if (data.gatherContext.gatherMode !== 'navigation') {
      throw new Error(`${this.name} can only be computed on navigations`);
    }

    return super.compute_(data, context);
  }
}

module.exports = NavigationMetric;

},{"./metric.js":33}],35:[function(require,module,exports){
/**
 * @license Copyright 2018 The Lighthouse Authors. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.
 */
'use strict';

const makeComputedArtifact = require('../computed-artifact.js');
const NavigationMetric = require('./navigation-metric.js');
const LanternSpeedIndex = require('./lantern-speed-index.js');
const Speedline = require('../speedline.js');

class SpeedIndex extends NavigationMetric {
  /**
   * @param {LH.Artifacts.NavigationMetricComputationData} data
   * @param {LH.Artifacts.ComputedContext} context
   * @return {Promise<LH.Artifacts.LanternMetric>}
   */
  static computeSimulatedMetric(data, context) {
    const metricData = NavigationMetric.getMetricComputationInput(data);
    return LanternSpeedIndex.request(metricData, context);
  }

  /**
   * @param {LH.Artifacts.NavigationMetricComputationData} data
   * @param {LH.Artifacts.ComputedContext} context
   * @return {Promise<LH.Artifacts.Metric>}
   */
  static async computeObservedMetric(data, context) {
    const speedline = await Speedline.request(data.trace, context);
    const timing = Math.round(speedline.speedIndex);
    const timestamp = (timing + speedline.beginning) * 1000;
    return Promise.resolve({timing, timestamp});
  }
}

module.exports = makeComputedArtifact(SpeedIndex);

},{"../computed-artifact.js":9,"../speedline.js":46,"./lantern-speed-index.js":28,"./navigation-metric.js":34}],36:[function(require,module,exports){
/**
 * @license Copyright 2019 The Lighthouse Authors. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.
 */
'use strict';

const ProcessedTrace = require('../processed-trace.js');
const ProcessedNavigation = require('../processed-navigation.js');
const Speedline = require('../speedline.js');
const FirstContentfulPaint = require('./first-contentful-paint.js');
const FirstContentfulPaintAllFrames = require('./first-contentful-paint-all-frames.js');
const FirstMeaningfulPaint = require('./first-meaningful-paint.js');
const LargestContentfulPaint = require('./largest-contentful-paint.js');
const LargestContentfulPaintAllFrames = require('./largest-contentful-paint-all-frames.js');
const Interactive = require('./interactive.js');
const CumulativeLayoutShift = require('./cumulative-layout-shift.js');
const SpeedIndex = require('./speed-index.js');
const MaxPotentialFID = require('./max-potential-fid.js');
const TotalBlockingTime = require('./total-blocking-time.js');
const makeComputedArtifact = require('../computed-artifact.js');

class TimingSummary {
  /**
     * @param {LH.Trace} trace
     * @param {LH.DevtoolsLog} devtoolsLog
     * @param {LH.Artifacts['GatherContext']} gatherContext
     * @param {ImmutableObject<LH.Config.Settings>} settings
     * @param {LH.Artifacts.ComputedContext} context
     * @return {Promise<{metrics: LH.Artifacts.TimingSummary, debugInfo: Record<string,boolean>}>}
     */
  static async summarize(trace, devtoolsLog, gatherContext, settings, context) {
    const metricComputationData = {trace, devtoolsLog, gatherContext, settings};
    /**
     * @template TArtifacts
     * @template TReturn
     * @param {{request: (artifact: TArtifacts, context: LH.Artifacts.ComputedContext) => Promise<TReturn>}} Artifact
     * @param {TArtifacts} artifact
     * @return {Promise<TReturn|undefined>}
     */
    const requestOrUndefined = (Artifact, artifact) => {
      return Artifact.request(artifact, context).catch(_ => undefined);
    };

    /* eslint-disable max-len */

    const processedTrace = await ProcessedTrace.request(trace, context);
    const processedNavigation = await requestOrUndefined(ProcessedNavigation, processedTrace);
    const speedline = await Speedline.request(trace, context);
    const firstContentfulPaint = await requestOrUndefined(FirstContentfulPaint, metricComputationData);
    const firstContentfulPaintAllFrames = await requestOrUndefined(FirstContentfulPaintAllFrames, metricComputationData);
    const firstMeaningfulPaint = await requestOrUndefined(FirstMeaningfulPaint, metricComputationData);
    const largestContentfulPaint = await requestOrUndefined(LargestContentfulPaint, metricComputationData);
    const largestContentfulPaintAllFrames = await requestOrUndefined(LargestContentfulPaintAllFrames, metricComputationData);
    const interactive = await requestOrUndefined(Interactive, metricComputationData);
    const cumulativeLayoutShiftValues = await requestOrUndefined(CumulativeLayoutShift, trace);
    const maxPotentialFID = await requestOrUndefined(MaxPotentialFID, metricComputationData);
    const speedIndex = await requestOrUndefined(SpeedIndex, metricComputationData);
    const totalBlockingTime = await requestOrUndefined(TotalBlockingTime, metricComputationData);

    const {
      cumulativeLayoutShift,
      cumulativeLayoutShiftMainFrame,
      totalCumulativeLayoutShift,
    } = cumulativeLayoutShiftValues || {};

    /** @type {LH.Artifacts.TimingSummary} */
    const metrics = {
      // Include the simulated/observed performance metrics
      firstContentfulPaint: firstContentfulPaint && firstContentfulPaint.timing,
      firstContentfulPaintTs: firstContentfulPaint && firstContentfulPaint.timestamp,
      firstContentfulPaintAllFrames: firstContentfulPaintAllFrames && firstContentfulPaintAllFrames.timing,
      firstContentfulPaintAllFramesTs: firstContentfulPaintAllFrames && firstContentfulPaintAllFrames.timestamp,
      firstMeaningfulPaint: firstMeaningfulPaint && firstMeaningfulPaint.timing,
      firstMeaningfulPaintTs: firstMeaningfulPaint && firstMeaningfulPaint.timestamp,
      largestContentfulPaint: largestContentfulPaint && largestContentfulPaint.timing,
      largestContentfulPaintTs: largestContentfulPaint && largestContentfulPaint.timestamp,
      largestContentfulPaintAllFrames: largestContentfulPaintAllFrames && largestContentfulPaintAllFrames.timing,
      largestContentfulPaintAllFramesTs: largestContentfulPaintAllFrames && largestContentfulPaintAllFrames.timestamp,
      interactive: interactive && interactive.timing,
      interactiveTs: interactive && interactive.timestamp,
      speedIndex: speedIndex && speedIndex.timing,
      speedIndexTs: speedIndex && speedIndex.timestamp,
      totalBlockingTime: totalBlockingTime && totalBlockingTime.timing,
      maxPotentialFID: maxPotentialFID && maxPotentialFID.timing,
      cumulativeLayoutShift,
      cumulativeLayoutShiftMainFrame,
      totalCumulativeLayoutShift,

      // Include all timestamps of interest from trace of tab
      observedTimeOrigin: processedTrace.timings.timeOrigin,
      observedTimeOriginTs: processedTrace.timestamps.timeOrigin,
      // For now, navigationStart is always timeOrigin.
      observedNavigationStart: processedNavigation && processedNavigation.timings.timeOrigin,
      observedNavigationStartTs: processedNavigation && processedNavigation.timestamps.timeOrigin,
      observedFirstPaint: processedNavigation && processedNavigation.timings.firstPaint,
      observedFirstPaintTs: processedNavigation && processedNavigation.timestamps.firstPaint,
      observedFirstContentfulPaint: processedNavigation && processedNavigation.timings.firstContentfulPaint,
      observedFirstContentfulPaintTs: processedNavigation && processedNavigation.timestamps.firstContentfulPaint,
      observedFirstContentfulPaintAllFrames: processedNavigation && processedNavigation.timings.firstContentfulPaintAllFrames,
      observedFirstContentfulPaintAllFramesTs: processedNavigation && processedNavigation.timestamps.firstContentfulPaintAllFrames,
      observedFirstMeaningfulPaint: processedNavigation && processedNavigation.timings.firstMeaningfulPaint,
      observedFirstMeaningfulPaintTs: processedNavigation && processedNavigation.timestamps.firstMeaningfulPaint,
      observedLargestContentfulPaint: processedNavigation && processedNavigation.timings.largestContentfulPaint,
      observedLargestContentfulPaintTs: processedNavigation && processedNavigation.timestamps.largestContentfulPaint,
      observedLargestContentfulPaintAllFrames: processedNavigation && processedNavigation.timings.largestContentfulPaintAllFrames,
      observedLargestContentfulPaintAllFramesTs: processedNavigation && processedNavigation.timestamps.largestContentfulPaintAllFrames,
      observedTraceEnd: processedTrace.timings.traceEnd,
      observedTraceEndTs: processedTrace.timestamps.traceEnd,
      observedLoad: processedNavigation && processedNavigation.timings.load,
      observedLoadTs: processedNavigation && processedNavigation.timestamps.load,
      observedDomContentLoaded: processedNavigation && processedNavigation.timings.domContentLoaded,
      observedDomContentLoadedTs: processedNavigation && processedNavigation.timestamps.domContentLoaded,
      observedCumulativeLayoutShift: cumulativeLayoutShift,
      observedCumulativeLayoutShiftMainFrame: cumulativeLayoutShiftMainFrame,
      observedTotalCumulativeLayoutShift: totalCumulativeLayoutShift,

      // Include some visual metrics from speedline
      observedFirstVisualChange: speedline.first,
      observedFirstVisualChangeTs: (speedline.first + speedline.beginning) * 1000,
      observedLastVisualChange: speedline.complete,
      observedLastVisualChangeTs: (speedline.complete + speedline.beginning) * 1000,
      observedSpeedIndex: speedline.speedIndex,
      observedSpeedIndexTs: (speedline.speedIndex + speedline.beginning) * 1000,
    };

    /* eslint-enable max-len */

    /** @type {Record<string,boolean>} */
    const debugInfo = {
      lcpInvalidated: !!(processedNavigation && processedNavigation.lcpInvalidated),
    };

    return {metrics, debugInfo};
  }
  /**
   * @param {{trace: LH.Trace, devtoolsLog: LH.DevtoolsLog, gatherContext: LH.Artifacts['GatherContext']; settings: ImmutableObject<LH.Config.Settings>}} data
   * @param {LH.Artifacts.ComputedContext} context
   * @return {Promise<{metrics: LH.Artifacts.TimingSummary, debugInfo: Record<string,boolean>}>}
   */
  static async compute_(data, context) {
    return TimingSummary.summarize(data.trace, data.devtoolsLog, data.gatherContext, data.settings,
      context);
  }
}

module.exports = makeComputedArtifact(TimingSummary);

},{"../computed-artifact.js":9,"../processed-navigation.js":42,"../processed-trace.js":43,"../speedline.js":46,"./cumulative-layout-shift.js":17,"./first-contentful-paint-all-frames.js":18,"./first-contentful-paint.js":19,"./first-meaningful-paint.js":20,"./interactive.js":21,"./largest-contentful-paint-all-frames.js":30,"./largest-contentful-paint.js":31,"./max-potential-fid.js":32,"./speed-index.js":35,"./total-blocking-time.js":37}],37:[function(require,module,exports){
/**
 * @license Copyright 2019 The Lighthouse Authors. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.
 */
'use strict';

const makeComputedArtifact = require('../computed-artifact.js');
const ComputedMetric = require('./metric.js');
const TraceProcessor = require('../../lib/tracehouse/trace-processor.js');
const LanternTotalBlockingTime = require('./lantern-total-blocking-time.js');
const TimetoInteractive = require('./interactive.js');

/**
 * @fileoverview This audit determines Total Blocking Time.

 * We define Blocking Time as any time interval in the loading timeline where task length exceeds
 * 50ms. For example, if there is a 110ms main thread task, the last 60ms of it is blocking time.
 * Total Blocking Time is the sum of all Blocking Time between First Contentful Paint and
 * Interactive Time (TTI).
 *
 * This is a new metric designed to accompany Time to Interactive. TTI is strict and does not
 * reflect incremental improvements to the site performance unless the improvement concerns the last
 * long task. Total Blocking Time on the other hand is designed to be much more responsive
 * to smaller improvements to main thread responsiveness.
 */
class TotalBlockingTime extends ComputedMetric {
  /**
   * @return {number}
   */
  static get BLOCKING_TIME_THRESHOLD() {
    return 50;
  }

  /**
   * @param {Array<{start: number, end: number, duration: number}>} topLevelEvents
   * @param {number} startTimeMs
   * @param {number} endTimeMs
   * @return {number}
   */
  static calculateSumOfBlockingTime(topLevelEvents, startTimeMs, endTimeMs) {
    if (endTimeMs <= startTimeMs) return 0;

    const threshold = TotalBlockingTime.BLOCKING_TIME_THRESHOLD;
    let sumBlockingTime = 0;
    for (const event of topLevelEvents) {
      // Early exit for small tasks, which should far outnumber long tasks.
      if (event.duration < threshold) continue;

      // We only want to consider tasks that fall in our time range (FCP and TTI for navigations).
      // FCP is picked as the lower bound because there is little risk of user input happening
      // before FCP so Long Queuing Qelay regions do not harm user experience. Developers should be
      // optimizing to reach FCP as fast as possible without having to worry about task lengths.
      if (event.end < startTimeMs) continue;

      // TTI is picked as the upper bound because we want a well defined end point for page load.
      if (event.start > endTimeMs) continue;

      // We first perform the clipping, and then calculate Blocking Region. So if we have a 150ms
      // task [0, 150] and FCP happens midway at 50ms, we first clip the task to [50, 150], and then
      // calculate the Blocking Region to be [100, 150]. The rational here is that tasks before FCP
      // are unimportant, so we care whether the main thread is busy more than 50ms at a time only
      // after FCP.
      const clippedStart = Math.max(event.start, startTimeMs);
      const clippedEnd = Math.min(event.end, endTimeMs);
      const clippedDuration = clippedEnd - clippedStart;
      if (clippedDuration < threshold) continue;

      // The duration of the task beyond 50ms at the beginning is considered the Blocking Region.
      // Example:
      //   [              250ms Task                   ]
      //   | First 50ms |   Blocking Region (200ms)    |
      sumBlockingTime += clippedDuration - threshold;
    }

    return sumBlockingTime;
  }

  /**
   * @param {LH.Artifacts.MetricComputationData} data
   * @param {LH.Artifacts.ComputedContext} context
   * @return {Promise<LH.Artifacts.LanternMetric>}
   */
  static computeSimulatedMetric(data, context) {
    const metricData = ComputedMetric.getMetricComputationInput(data);
    return LanternTotalBlockingTime.request(metricData, context);
  }

  /**
   * @param {LH.Artifacts.MetricComputationData} data
   * @param {LH.Artifacts.ComputedContext} context
   * @return {Promise<LH.Artifacts.Metric>}
   */
  static async computeObservedMetric(data, context) {
    const events = TraceProcessor.getMainThreadTopLevelEvents(data.processedTrace);

    if (data.processedNavigation) {
      const {firstContentfulPaint} = data.processedNavigation.timings;
      const metricData = ComputedMetric.getMetricComputationInput(data);
      const interactiveTimeMs = (await TimetoInteractive.request(metricData, context)).timing;

      return {
        timing: TotalBlockingTime.calculateSumOfBlockingTime(
          events,
          firstContentfulPaint,
          interactiveTimeMs
        ),
      };
    } else {
      return {
        timing: TotalBlockingTime.calculateSumOfBlockingTime(
          events,
          0,
          data.processedTrace.timestamps.traceEnd
        ),
      };
    }
  }
}

module.exports = makeComputedArtifact(TotalBlockingTime);

},{"../../lib/tracehouse/trace-processor.js":119,"../computed-artifact.js":9,"./interactive.js":21,"./lantern-total-blocking-time.js":29,"./metric.js":33}],38:[function(require,module,exports){
/**
 * @license Copyright 2020 The Lighthouse Authors. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.
 */
'use strict';

const makeComputedArtifact = require('./computed-artifact.js');
const JsBundles = require('./js-bundles.js');

const RELATIVE_SIZE_THRESHOLD = 0.1;
const ABSOLUTE_SIZE_THRESHOLD_BYTES = 1024 * 0.5;

class ModuleDuplication {
  /**
   * @param {string} source
   */
  static normalizeSource(source) {
    // Trim trailing question mark - b/c webpack.
    source = source.replace(/\?$/, '');

    // Normalize paths for dependencies by only keeping everything after the last `node_modules`.
    const lastNodeModulesIndex = source.lastIndexOf('node_modules');
    if (lastNodeModulesIndex !== -1) {
      source = source.substring(lastNodeModulesIndex);
    }

    return source;
  }

  /**
   * @param {string} source
   */
  static _shouldIgnoreSource(source) {
    // Ignore bundle overhead.
    if (source.includes('webpack/bootstrap')) return true;
    if (source.includes('(webpack)/buildin')) return true;

    // Ignore webpack module shims, i.e. aliases of the form `module.exports = window.jQuery`
    if (source.includes('external ')) return true;

    return false;
  }

  /**
   * @param {Map<string, Array<{scriptUrl: string, resourceSize: number}>>} moduleNameToSourceData
   */
  static _normalizeAggregatedData(moduleNameToSourceData) {
    for (const [key, originalSourceData] of moduleNameToSourceData.entries()) {
      let sourceData = originalSourceData;

      // Sort by resource size.
      sourceData.sort((a, b) => b.resourceSize - a.resourceSize);

      // Remove modules smaller than a % size of largest.
      if (sourceData.length > 1) {
        const largestResourceSize = sourceData[0].resourceSize;
        sourceData = sourceData.filter(data => {
          const percentSize = data.resourceSize / largestResourceSize;
          return percentSize >= RELATIVE_SIZE_THRESHOLD;
        });
      }

      // Remove modules smaller than an absolute theshold.
      sourceData = sourceData.filter(data => data.resourceSize >= ABSOLUTE_SIZE_THRESHOLD_BYTES);

      // Delete source datas with only one value (no duplicates).
      if (sourceData.length > 1) {
        moduleNameToSourceData.set(key, sourceData);
      } else {
        moduleNameToSourceData.delete(key);
      }
    }
  }

  /**
   * @param {LH.Artifacts} artifacts
   * @param {LH.Artifacts.ComputedContext} context
   */
  static async compute_(artifacts, context) {
    const bundles = await JsBundles.request(artifacts, context);

    /**
     * @typedef SourceData
     * @property {string} source
     * @property {number} resourceSize
     */

    /** @type {Map<LH.Artifacts.RawSourceMap, SourceData[]>} */
    const sourceDatasMap = new Map();

    // Determine size of each `sources` entry.
    for (const {rawMap, sizes} of bundles) {
      if ('errorMessage' in sizes) continue;

      /** @type {SourceData[]} */
      const sourceDataArray = [];
      sourceDatasMap.set(rawMap, sourceDataArray);

      for (let i = 0; i < rawMap.sources.length; i++) {
        if (this._shouldIgnoreSource(rawMap.sources[i])) continue;

        const sourceKey = (rawMap.sourceRoot || '') + rawMap.sources[i];
        const sourceSize = sizes.files[sourceKey];
        sourceDataArray.push({
          source: ModuleDuplication.normalizeSource(rawMap.sources[i]),
          resourceSize: sourceSize,
        });
      }
    }

    /** @type {Map<string, Array<{scriptUrl: string, resourceSize: number}>>} */
    const moduleNameToSourceData = new Map();
    for (const {rawMap, script} of bundles) {
      const sourceDataArray = sourceDatasMap.get(rawMap);
      if (!sourceDataArray) continue;

      for (const sourceData of sourceDataArray) {
        let data = moduleNameToSourceData.get(sourceData.source);
        if (!data) {
          data = [];
          moduleNameToSourceData.set(sourceData.source, data);
        }
        data.push({
          scriptUrl: script.src || '',
          resourceSize: sourceData.resourceSize,
        });
      }
    }

    this._normalizeAggregatedData(moduleNameToSourceData);
    return moduleNameToSourceData;
  }
}

module.exports = makeComputedArtifact(ModuleDuplication);

},{"./computed-artifact.js":9,"./js-bundles.js":12}],39:[function(require,module,exports){
/**
 * @license Copyright 2017 The Lighthouse Authors. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.
 */
'use strict';

const makeComputedArtifact = require('./computed-artifact.js');
const NetworkAnalyzer = require('../lib/dependency-graph/simulator/network-analyzer.js');
const NetworkRecords = require('./network-records.js');

class NetworkAnalysis {
  /**
   * @param {Array<LH.Artifacts.NetworkRequest>} records
   * @return {StrictOmit<LH.Artifacts.NetworkAnalysis, 'throughput'>}
   */
  static computeRTTAndServerResponseTime(records) {
    // First pass compute the estimated observed RTT to each origin's servers.
    /** @type {Map<string, number>} */
    const rttByOrigin = new Map();
    for (const [origin, summary] of NetworkAnalyzer.estimateRTTByOrigin(records).entries()) {
      rttByOrigin.set(origin, summary.min);
    }

    // We'll use the minimum RTT as the assumed connection latency since we care about how much addt'l
    // latency each origin introduces as Lantern will be simulating with its own connection latency.
    const minimumRtt = Math.min(...Array.from(rttByOrigin.values()));
    // We'll use the observed RTT information to help estimate the server response time
    const responseTimeSummaries = NetworkAnalyzer.estimateServerResponseTimeByOrigin(records, {
      rttByOrigin,
    });

    /** @type {Map<string, number>} */
    const additionalRttByOrigin = new Map();
    /** @type {Map<string, number>} */
    const serverResponseTimeByOrigin = new Map();
    for (const [origin, summary] of responseTimeSummaries.entries()) {
      // Not all origins have usable timing data, we'll default to using no additional latency.
      const rttForOrigin = rttByOrigin.get(origin) || minimumRtt;
      additionalRttByOrigin.set(origin, rttForOrigin - minimumRtt);
      serverResponseTimeByOrigin.set(origin, summary.median);
    }

    return {
      rtt: minimumRtt,
      additionalRttByOrigin,
      serverResponseTimeByOrigin,
    };
  }

  /**
   * @param {LH.DevtoolsLog} devtoolsLog
   * @param {LH.Artifacts.ComputedContext} context
   * @return {Promise<LH.Artifacts.NetworkAnalysis>}
   */
  static async compute_(devtoolsLog, context) {
    const records = await NetworkRecords.request(devtoolsLog, context);
    const throughput = NetworkAnalyzer.estimateThroughput(records);
    const rttAndServerResponseTime = NetworkAnalysis.computeRTTAndServerResponseTime(records);
    return {throughput, ...rttAndServerResponseTime};
  }
}

module.exports = makeComputedArtifact(NetworkAnalysis);

},{"../lib/dependency-graph/simulator/network-analyzer.js":91,"./computed-artifact.js":9,"./network-records.js":40}],40:[function(require,module,exports){
/**
 * @license Copyright 2017 The Lighthouse Authors. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.
 */
'use strict';

const makeComputedArtifact = require('./computed-artifact.js');
const NetworkRecorder = require('../lib/network-recorder.js');

class NetworkRecords {
  /**
   * @param {LH.DevtoolsLog} devtoolsLog
   * @return {Promise<Array<LH.Artifacts.NetworkRequest>>} networkRecords
   */
  static async compute_(devtoolsLog) {
    return NetworkRecorder.recordsFromLogs(devtoolsLog);
  }
}

module.exports = makeComputedArtifact(NetworkRecords);

},{"../lib/network-recorder.js":108,"./computed-artifact.js":9}],41:[function(require,module,exports){
/**
 * @license Copyright 2017 The Lighthouse Authors. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.
 */
'use strict';

const makeComputedArtifact = require('./computed-artifact.js');
const NetworkNode = require('../lib/dependency-graph/network-node.js');
const CPUNode = require('../lib/dependency-graph/cpu-node.js');
const NetworkAnalyzer = require('../lib/dependency-graph/simulator/network-analyzer.js');
const TracingProcessor = require('../lib/tracehouse/trace-processor.js');
const NetworkRequest = require('../lib/network-request.js');
const ProcessedTrace = require('./processed-trace.js');
const NetworkRecords = require('./network-records.js');

/** @typedef {import('../lib/dependency-graph/base-node.js').Node} Node */

// Shorter tasks have negligible impact on simulation results.
const SIGNIFICANT_DUR_THRESHOLD_MS = 10;

// TODO: video files tend to be enormous and throw off all graph traversals, move this ignore
//    into estimation logic when we use the dependency graph for other purposes.
const IGNORED_MIME_TYPES_REGEX = /^video/;

class PageDependencyGraph {
  /**
   * @param {LH.Artifacts.NetworkRequest} record
   * @return {Array<string>}
   */
  static getNetworkInitiators(record) {
    if (!record.initiator) return [];
    if (record.initiator.url) return [record.initiator.url];
    if (record.initiator.type === 'script') {
      // Script initiators have the stack of callFrames from all functions that led to this request.
      // If async stacks are enabled, then the stack will also have the parent functions that asynchronously
      // led to this request chained in the `parent` property.
      /** @type {Set<string>} */
      const scriptURLs = new Set();
      let stack = record.initiator.stack;
      while (stack) {
        const callFrames = stack.callFrames || [];
        for (const frame of callFrames) {
          if (frame.url) scriptURLs.add(frame.url);
        }

        stack = stack.parent;
      }

      return Array.from(scriptURLs);
    }

    return [];
  }

  /**
   * @param {Array<LH.Artifacts.NetworkRequest>} networkRecords
   * @return {NetworkNodeOutput}
   */
  static getNetworkNodeOutput(networkRecords) {
    /** @type {Array<NetworkNode>} */
    const nodes = [];
    /** @type {Map<string, NetworkNode>} */
    const idToNodeMap = new Map();
    /** @type {Map<string, Array<NetworkNode>>} */
    const urlToNodeMap = new Map();
    /** @type {Map<string, NetworkNode|null>} */
    const frameIdToNodeMap = new Map();

    networkRecords.forEach(record => {
      if (IGNORED_MIME_TYPES_REGEX.test(record.mimeType)) return;

      // Network record requestIds can be duplicated for an unknown reason
      // Suffix all subsequent records with `:duplicate` until it's unique
      // NOTE: This should never happen with modern NetworkRequest library, but old fixtures
      // might still have this issue.
      while (idToNodeMap.has(record.requestId)) {
        record.requestId += ':duplicate';
      }

      const node = new NetworkNode(record);
      nodes.push(node);

      const urlList = urlToNodeMap.get(record.url) || [];
      urlList.push(node);

      idToNodeMap.set(record.requestId, node);
      urlToNodeMap.set(record.url, urlList);

      // If the request was for the root document of an iframe, save an entry in our
      // map so we can link up the task `args.data.frame` dependencies later in graph creation.
      if (record.frameId &&
          record.resourceType === NetworkRequest.TYPES.Document &&
          record.documentURL === record.url) {
        // If there's ever any ambiguity, permanently set the value to `false` to avoid loops in the graph.
        const value = frameIdToNodeMap.has(record.frameId) ? null : node;
        frameIdToNodeMap.set(record.frameId, value);
      }
    });

    return {nodes, idToNodeMap, urlToNodeMap, frameIdToNodeMap};
  }

  /**
   * @param {LH.Artifacts.ProcessedTrace} processedTrace
   * @return {Array<CPUNode>}
   */
  static getCPUNodes({mainThreadEvents}) {
    /** @type {Array<CPUNode>} */
    const nodes = [];
    let i = 0;

    TracingProcessor.assertHasToplevelEvents(mainThreadEvents);

    while (i < mainThreadEvents.length) {
      const evt = mainThreadEvents[i];
      i++;

      // Skip all trace events that aren't schedulable tasks with sizable duration
      if (!TracingProcessor.isScheduleableTask(evt) || !evt.dur) {
        continue;
      }

      // Capture all events that occurred within the task
      /** @type {Array<LH.TraceEvent>} */
      const children = [];
      for (
        const endTime = evt.ts + evt.dur;
        i < mainThreadEvents.length && mainThreadEvents[i].ts < endTime;
        i++
      ) {
        children.push(mainThreadEvents[i]);
      }

      nodes.push(new CPUNode(evt, children));
    }

    return nodes;
  }

  /**
   * @param {NetworkNode} rootNode
   * @param {NetworkNodeOutput} networkNodeOutput
   */
  static linkNetworkNodes(rootNode, networkNodeOutput) {
    networkNodeOutput.nodes.forEach(node => {
      const directInitiatorRequest = node.record.initiatorRequest || rootNode.record;
      const directInitiatorNode =
        networkNodeOutput.idToNodeMap.get(directInitiatorRequest.requestId) || rootNode;
      const initiators = PageDependencyGraph.getNetworkInitiators(node.record);
      if (initiators.length) {
        initiators.forEach(initiator => {
          const parentCandidates = networkNodeOutput.urlToNodeMap.get(initiator) || [];
          // Only add the edge if the parent is unambiguous with valid timing and isn't circular.
          if (parentCandidates.length === 1 &&
              parentCandidates[0].startTime <= node.startTime &&
              !parentCandidates[0].isDependentOn(node)) {
            node.addDependency(parentCandidates[0]);
          } else if (!directInitiatorNode.isDependentOn(node)) {
            directInitiatorNode.addDependent(node);
          }
        });
      } else if (!directInitiatorNode.isDependentOn(node)) {
        directInitiatorNode.addDependent(node);
      }

      // Make sure the nodes are attached to the graph if the initiator information was invalid.
      if (node !== rootNode && node.getDependencies().length === 0) node.addDependency(rootNode);

      if (!node.record.redirects) return;

      const redirects = [...node.record.redirects, node.record];
      for (let i = 1; i < redirects.length; i++) {
        const redirectNode = networkNodeOutput.idToNodeMap.get(redirects[i - 1].requestId);
        const actualNode = networkNodeOutput.idToNodeMap.get(redirects[i].requestId);
        if (actualNode && redirectNode) {
          actualNode.addDependency(redirectNode);
        }
      }
    });
  }

  /**
   * @param {Node} rootNode
   * @param {NetworkNodeOutput} networkNodeOutput
   * @param {Array<CPUNode>} cpuNodes
   */
  static linkCPUNodes(rootNode, networkNodeOutput, cpuNodes) {
    /** @type {Set<LH.Crdp.Network.ResourceType|undefined>} */
    const linkableResourceTypes = new Set([
      NetworkRequest.TYPES.XHR, NetworkRequest.TYPES.Fetch, NetworkRequest.TYPES.Script,
    ]);

    /** @param {CPUNode} cpuNode @param {string} reqId */
    function addDependentNetworkRequest(cpuNode, reqId) {
      const networkNode = networkNodeOutput.idToNodeMap.get(reqId);
      if (!networkNode ||
          // Ignore all network nodes that started before this CPU task started
          // A network request that started earlier could not possibly have been started by this task
          networkNode.startTime <= cpuNode.startTime) return;
      const {record} = networkNode;
      const resourceType = record.resourceType ||
        record.redirectDestination && record.redirectDestination.resourceType;
      if (!linkableResourceTypes.has(resourceType)) {
        // We only link some resources to CPU nodes because we observe LCP simulation
        // regressions when including images, etc.
        return;
      }
      cpuNode.addDependent(networkNode);
    }

    /**
     * If the node has an associated frameId, then create a dependency on the root document request
     * for the frame. The task obviously couldn't have started before the frame was even downloaded.
     *
     * @param {CPUNode} cpuNode
     * @param {string|undefined} frameId
     */
    function addDependencyOnFrame(cpuNode, frameId) {
      if (!frameId) return;
      const networkNode = networkNodeOutput.frameIdToNodeMap.get(frameId);
      if (!networkNode) return;
      // Ignore all network nodes that started after this CPU task started
      // A network request that started after could not possibly be required this task
      if (networkNode.startTime >= cpuNode.startTime) return;
      cpuNode.addDependency(networkNode);
    }

    /** @param {CPUNode} cpuNode @param {string} url */
    function addDependencyOnUrl(cpuNode, url) {
      if (!url) return;
      // Allow network requests that end up to 100ms before the task started
      // Some script evaluations can start before the script finishes downloading
      const minimumAllowableTimeSinceNetworkNodeEnd = -100 * 1000;
      const candidates = networkNodeOutput.urlToNodeMap.get(url) || [];

      let minCandidate = null;
      let minDistance = Infinity;
      // Find the closest request that finished before this CPU task started
      for (const candidate of candidates) {
        // Explicitly ignore all requests that started after this CPU node
        // A network request that started after this task started cannot possibly be a dependency
        if (cpuNode.startTime <= candidate.startTime) return;

        const distance = cpuNode.startTime - candidate.endTime;
        if (distance >= minimumAllowableTimeSinceNetworkNodeEnd && distance < minDistance) {
          minCandidate = candidate;
          minDistance = distance;
        }
      }

      if (!minCandidate) return;
      cpuNode.addDependency(minCandidate);
    }

    /** @type {Map<string, CPUNode>} */
    const timers = new Map();
    for (const node of cpuNodes) {
      for (const evt of node.childEvents) {
        if (!evt.args.data) continue;

        const argsUrl = evt.args.data.url;
        const stackTraceUrls = (evt.args.data.stackTrace || []).map(l => l.url).filter(Boolean);

        switch (evt.name) {
          case 'TimerInstall':
            // @ts-expect-error - 'TimerInstall' event means timerId exists.
            timers.set(evt.args.data.timerId, node);
            stackTraceUrls.forEach(url => addDependencyOnUrl(node, url));
            break;
          case 'TimerFire': {
            // @ts-expect-error - 'TimerFire' event means timerId exists.
            const installer = timers.get(evt.args.data.timerId);
            if (!installer || installer.endTime > node.startTime) break;
            installer.addDependent(node);
            break;
          }

          case 'InvalidateLayout':
          case 'ScheduleStyleRecalculation':
            addDependencyOnFrame(node, evt.args.data.frame);
            stackTraceUrls.forEach(url => addDependencyOnUrl(node, url));
            break;

          case 'EvaluateScript':
            addDependencyOnFrame(node, evt.args.data.frame);
            // @ts-expect-error - 'EvaluateScript' event means argsUrl is defined.
            addDependencyOnUrl(node, argsUrl);
            stackTraceUrls.forEach(url => addDependencyOnUrl(node, url));
            break;

          case 'XHRReadyStateChange':
            // Only create the dependency if the request was completed
            // 'XHRReadyStateChange' event means readyState is defined.
            if (evt.args.data.readyState !== 4) break;

            // @ts-expect-error - 'XHRReadyStateChange' event means argsUrl is defined.
            addDependencyOnUrl(node, argsUrl);
            stackTraceUrls.forEach(url => addDependencyOnUrl(node, url));
            break;

          case 'FunctionCall':
          case 'v8.compile':
            addDependencyOnFrame(node, evt.args.data.frame);
            // @ts-expect-error - events mean argsUrl is defined.
            addDependencyOnUrl(node, argsUrl);
            break;

          case 'ParseAuthorStyleSheet':
            addDependencyOnFrame(node, evt.args.data.frame);
            // @ts-expect-error - 'ParseAuthorStyleSheet' event means styleSheetUrl is defined.
            addDependencyOnUrl(node, evt.args.data.styleSheetUrl);
            break;

          case 'ResourceSendRequest':
            addDependencyOnFrame(node, evt.args.data.frame);
            // @ts-expect-error - 'ResourceSendRequest' event means requestId is defined.
            addDependentNetworkRequest(node, evt.args.data.requestId);
            stackTraceUrls.forEach(url => addDependencyOnUrl(node, url));
            break;
        }
      }

      if (node.getNumberOfDependencies() === 0) {
        node.addDependency(rootNode);
      }
    }

    // Second pass to prune the graph of short tasks.
    const minimumEvtDur = SIGNIFICANT_DUR_THRESHOLD_MS * 1000;
    let foundFirstLayout = false;
    let foundFirstPaint = false;
    let foundFirstParse = false;

    for (const node of cpuNodes) {
      // Don't prune if event is the first ParseHTML/Layout/Paint.
      // See https://github.com/GoogleChrome/lighthouse/issues/9627#issuecomment-526699524 for more.
      let isFirst = false;
      if (!foundFirstLayout && node.childEvents.some(evt => evt.name === 'Layout')) {
        isFirst = foundFirstLayout = true;
      }
      if (!foundFirstPaint && node.childEvents.some(evt => evt.name === 'Paint')) {
        isFirst = foundFirstPaint = true;
      }
      if (!foundFirstParse && node.childEvents.some(evt => evt.name === 'ParseHTML')) {
        isFirst = foundFirstParse = true;
      }

      if (isFirst || node.event.dur >= minimumEvtDur) {
        // Don't prune this node. The task is long / important so it will impact simulation.
        continue;
      }

      // Prune the node if it isn't highly connected to minimize graph size. Rewiring the graph
      // here replaces O(M + N) edges with (M * N) edges, which is fine if either  M or N is at
      // most 1.
      if (node.getNumberOfDependencies() === 1 || node.getNumberOfDependents() <= 1) {
        PageDependencyGraph._pruneNode(node);
      }
    }
  }

  /**
   * Removes the given node from the graph, but retains all paths between its dependencies and
   * dependents.
   * @param {Node} node
   */
  static _pruneNode(node) {
    const dependencies = node.getDependencies();
    const dependents = node.getDependents();
    for (const dependency of dependencies) {
      node.removeDependency(dependency);
      for (const dependent of dependents) {
        dependency.addDependent(dependent);
      }
    }
    for (const dependent of dependents) {
      node.removeDependent(dependent);
    }
  }

  /**
   * @param {LH.Artifacts.ProcessedTrace} processedTrace
   * @param {Array<LH.Artifacts.NetworkRequest>} networkRecords
   * @return {Node}
   */
  static createGraph(processedTrace, networkRecords) {
    const networkNodeOutput = PageDependencyGraph.getNetworkNodeOutput(networkRecords);
    const cpuNodes = PageDependencyGraph.getCPUNodes(processedTrace);

    // The root request is the earliest network request, using position in networkRecords array to break ties.
    const rootRequest = networkRecords.reduce((min, r) => (r.startTime < min.startTime ? r : min));
    const rootNode = networkNodeOutput.idToNodeMap.get(rootRequest.requestId);
    // The main document request is the earliest network request *of type document*.
    // This will be different from the root request when there are server redirects.
    const mainDocumentRequest = NetworkAnalyzer.findMainDocument(networkRecords);
    const mainDocumentNode = networkNodeOutput.idToNodeMap.get(mainDocumentRequest.requestId);

    if (!rootNode || !mainDocumentNode) {
      // Should always be found.
      throw new Error(`${rootNode ? 'mainDocument' : 'root'}Node not found.`);
    }

    if (mainDocumentNode !== rootNode &&
        (!mainDocumentNode.record.redirects ||
        !mainDocumentNode.record.redirects.includes(rootNode.record))) {
      throw new Error('Root node was not in redirect chain of mainDocument');
    }

    PageDependencyGraph.linkNetworkNodes(rootNode, networkNodeOutput);
    PageDependencyGraph.linkCPUNodes(rootNode, networkNodeOutput, cpuNodes);
    mainDocumentNode.setIsMainDocument(true);

    if (NetworkNode.hasCycle(rootNode)) {
      throw new Error('Invalid dependency graph created, cycle detected');
    }

    return rootNode;
  }

  /**
   *
   * @param {Node} rootNode
   */
  static printGraph(rootNode, widthInCharacters = 100) {
    /** @param {string} str @param {number} target */
    function padRight(str, target, padChar = ' ') {
      return str + padChar.repeat(Math.max(target - str.length, 0));
    }

    /** @type {Array<Node>} */
    const nodes = [];
    rootNode.traverse(node => nodes.push(node));
    nodes.sort((a, b) => a.startTime - b.startTime);

    const min = nodes[0].startTime;
    const max = nodes.reduce((max, node) => Math.max(max, node.endTime), 0);

    const totalTime = max - min;
    const timePerCharacter = totalTime / widthInCharacters;
    nodes.forEach(node => {
      const offset = Math.round((node.startTime - min) / timePerCharacter);
      const length = Math.ceil((node.endTime - node.startTime) / timePerCharacter);
      const bar = padRight('', offset) + padRight('', length, '=');

      // @ts-expect-error -- disambiguate displayName from across possible Node types.
      const displayName = node.record ? node.record.url : node.type;
      // eslint-disable-next-line
      console.log(padRight(bar, widthInCharacters), `| ${displayName.slice(0, 30)}`);
    });
  }

  /**
   * @param {{trace: LH.Trace, devtoolsLog: LH.DevtoolsLog}} data
   * @param {LH.Artifacts.ComputedContext} context
   * @return {Promise<Node>}
   */
  static async compute_(data, context) {
    const trace = data.trace;
    const devtoolsLog = data.devtoolsLog;
    const [processedTrace, networkRecords] = await Promise.all([
      ProcessedTrace.request(trace, context),
      NetworkRecords.request(devtoolsLog, context),
    ]);

    return PageDependencyGraph.createGraph(processedTrace, networkRecords);
  }
}

module.exports = makeComputedArtifact(PageDependencyGraph);

/**
 * @typedef {Object} NetworkNodeOutput
 * @property {Array<NetworkNode>} nodes
 * @property {Map<string, NetworkNode>} idToNodeMap
 * @property {Map<string, Array<NetworkNode>>} urlToNodeMap
 * @property {Map<string, NetworkNode|null>} frameIdToNodeMap
 */

},{"../lib/dependency-graph/cpu-node.js":87,"../lib/dependency-graph/network-node.js":88,"../lib/dependency-graph/simulator/network-analyzer.js":91,"../lib/network-request.js":109,"../lib/tracehouse/trace-processor.js":119,"./computed-artifact.js":9,"./network-records.js":40,"./processed-trace.js":43}],42:[function(require,module,exports){
/**
 * @license Copyright 2021 The Lighthouse Authors. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.
 */
'use strict';

const makeComputedArtifact = require('./computed-artifact.js');
const LHTraceProcessor = require('../lib/lh-trace-processor.js');

class ProcessedNavigation {
  /**
     * @param {LH.Artifacts.ProcessedTrace} processedTrace
     * @return {Promise<LH.Artifacts.ProcessedNavigation>}
    */
  static async compute_(processedTrace) {
    return LHTraceProcessor.processNavigation(processedTrace);
  }
}

module.exports = makeComputedArtifact(ProcessedNavigation);

},{"../lib/lh-trace-processor.js":104,"./computed-artifact.js":9}],43:[function(require,module,exports){
/**
 * @license Copyright 2021 The Lighthouse Authors. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.
 */
'use strict';

const makeComputedArtifact = require('./computed-artifact.js');
const LHTraceProcessor = require('../lib/lh-trace-processor.js');

class ProcessedTrace {
  /**
    * @param {LH.Trace} trace
    * @return {Promise<LH.Artifacts.ProcessedTrace>}
   */
  static async compute_(trace) {
    return LHTraceProcessor.processTrace(trace);
  }
}

module.exports = makeComputedArtifact(ProcessedTrace);

},{"../lib/lh-trace-processor.js":104,"./computed-artifact.js":9}],44:[function(require,module,exports){
/**
 * @license Copyright 2019 The Lighthouse Authors. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.
 */
'use strict';

const makeComputedArtifact = require('./computed-artifact.js');
const NetworkRecords = require('./network-records.js');
const URL = require('../lib/url-shim.js');
const NetworkRequest = require('../lib/network-request.js');
const Budget = require('../config/budget.js');
const Util = require('../util-commonjs.js');

/** @typedef {{count: number, resourceSize: number, transferSize: number}} ResourceEntry */

class ResourceSummary {
  /**
   * @param {LH.Artifacts.NetworkRequest} record
   * @return {LH.Budget.ResourceType}
   */
  static determineResourceType(record) {
    if (!record.resourceType) return 'other';
    /** @type {Partial<Record<LH.Crdp.Network.ResourceType, LH.Budget.ResourceType>>} */
    const requestToResourceType = {
      'Stylesheet': 'stylesheet',
      'Image': 'image',
      'Media': 'media',
      'Font': 'font',
      'Script': 'script',
      'Document': 'document',
    };
    return requestToResourceType[record.resourceType] || 'other';
  }

  /**
   * @param {Array<LH.Artifacts.NetworkRequest>} networkRecords
   * @param {string} mainResourceURL
   * @param {ImmutableObject<LH.Budget[]|null>} budgets
   * @return {Record<LH.Budget.ResourceType, ResourceEntry>}
   */
  static summarize(networkRecords, mainResourceURL, budgets) {
    /** @type {Record<LH.Budget.ResourceType, ResourceEntry>} */
    const resourceSummary = {
      'stylesheet': {count: 0, resourceSize: 0, transferSize: 0},
      'image': {count: 0, resourceSize: 0, transferSize: 0},
      'media': {count: 0, resourceSize: 0, transferSize: 0},
      'font': {count: 0, resourceSize: 0, transferSize: 0},
      'script': {count: 0, resourceSize: 0, transferSize: 0},
      'document': {count: 0, resourceSize: 0, transferSize: 0},
      'other': {count: 0, resourceSize: 0, transferSize: 0},
      'total': {count: 0, resourceSize: 0, transferSize: 0},
      'third-party': {count: 0, resourceSize: 0, transferSize: 0},
    };
    const budget = Budget.getMatchingBudget(budgets, mainResourceURL);
    /** @type {ReadonlyArray<string>} */
    let firstPartyHosts = [];
    if (budget && budget.options && budget.options.firstPartyHostnames) {
      firstPartyHosts = budget.options.firstPartyHostnames;
    } else {
      const rootDomain = Util.getRootDomain(mainResourceURL);
      firstPartyHosts = [`*.${rootDomain}`];
    }

    networkRecords.filter(record => {
      // Ignore favicon.co
      // Headless Chrome does not request /favicon.ico, so don't consider this request.
      // Makes resource summary consistent across LR / other channels.
      const type = this.determineResourceType(record);
      if (type === 'other' && record.url.endsWith('/favicon.ico')) {
        return false;
      }
      // Ignore non-network protocols
      if (NetworkRequest.isNonNetworkRequest(record)) return false;
      return true;
    }).forEach((record) => {
      const type = this.determineResourceType(record);
      resourceSummary[type].count++;
      resourceSummary[type].resourceSize += record.resourceSize;
      resourceSummary[type].transferSize += record.transferSize;

      resourceSummary.total.count++;
      resourceSummary.total.resourceSize += record.resourceSize;
      resourceSummary.total.transferSize += record.transferSize;

      const isFirstParty = firstPartyHosts.some((hostExp) => {
        const url = new URL(record.url);
        if (hostExp.startsWith('*.')) {
          return url.hostname.endsWith(hostExp.slice(2));
        }
        return url.hostname === hostExp;
      });

      if (!isFirstParty) {
        resourceSummary['third-party'].count++;
        resourceSummary['third-party'].resourceSize += record.resourceSize;
        resourceSummary['third-party'].transferSize += record.transferSize;
      }
    });
    return resourceSummary;
  }

  /**
   * @param {{URL: LH.Artifacts['URL'], devtoolsLog: LH.DevtoolsLog, budgets: ImmutableObject<LH.Budget[]|null>}} data
   * @param {LH.Artifacts.ComputedContext} context
   * @return {Promise<Record<LH.Budget.ResourceType,ResourceEntry>>}
   */
  static async compute_(data, context) {
    const networkRecords = await NetworkRecords.request(data.devtoolsLog, context);
    return ResourceSummary.summarize(networkRecords, data.URL.finalUrl, data.budgets);
  }
}

module.exports = makeComputedArtifact(ResourceSummary);

},{"../config/budget.js":52,"../lib/network-request.js":109,"../lib/url-shim.js":"url","../util-commonjs.js":124,"./computed-artifact.js":9,"./network-records.js":40}],45:[function(require,module,exports){
/**
 * @license Copyright 2016 The Lighthouse Authors. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.
 */
'use strict';

const makeComputedArtifact = require('./computed-artifact.js');

const SCREENSHOT_TRACE_NAME = 'Screenshot';

class Screenshots {
  /**
   * @param {LH.Trace} trace
   * @return {Promise<Array<{timestamp: number, datauri: string}>>}
  */
  static async compute_(trace) {
    return trace.traceEvents
      .filter(evt => evt.name === SCREENSHOT_TRACE_NAME)
      .map(evt => {
        return {
          timestamp: evt.ts,
          datauri: `data:image/jpeg;base64,${evt.args.snapshot}`,
        };
      });
  }
}

module.exports = makeComputedArtifact(Screenshots);

},{"./computed-artifact.js":9}],46:[function(require,module,exports){
/**
 * @license Copyright 2016 The Lighthouse Authors. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.
 */
'use strict';

const makeComputedArtifact = require('./computed-artifact.js');
const speedline = require('speedline-core');
const LHError = require('../lib/lh-error.js');
const ProcessedTrace = require('./processed-trace.js');

class Speedline {
  /**
   * @param {LH.Trace} trace
   * @param {LH.Artifacts.ComputedContext} context
   * @return {Promise<LH.Artifacts.Speedline>}
   */
  static async compute_(trace, context) {
    // speedline() may throw without a promise, so we resolve immediately
    // to get in a promise chain.
    return ProcessedTrace.request(trace, context).then(processedTrace => {
      // Use a shallow copy of traceEvents so speedline can sort as it pleases.
      // See https://github.com/GoogleChrome/lighthouse/issues/2333
      const traceEvents = trace.traceEvents.slice();
      // Force use of timeOrigin as reference point for speedline
      // See https://github.com/GoogleChrome/lighthouse/issues/2095
      const timeOrigin = processedTrace.timestamps.timeOrigin;
      return speedline(traceEvents, {
        timeOrigin,
        fastMode: true,
        include: 'speedIndex',
      });
    }).catch(err => {
      if (/No screenshots found in trace/.test(err.message)) {
        throw new LHError(LHError.errors.NO_SCREENSHOTS);
      }

      throw err;
    }).then(speedline => {
      if (speedline.frames.length === 0) {
        throw new LHError(LHError.errors.NO_SPEEDLINE_FRAMES);
      }

      if (speedline.speedIndex === 0) {
        throw new LHError(LHError.errors.SPEEDINDEX_OF_ZERO);
      }

      return speedline;
    });
  }
}

module.exports = makeComputedArtifact(Speedline);

},{"../lib/lh-error.js":103,"./computed-artifact.js":9,"./processed-trace.js":43,"speedline-core":232}],47:[function(require,module,exports){
/**
 * @license Copyright 2019 The Lighthouse Authors. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.
 */
'use strict';

/** @fileoverview This file is no longer used internally, but remains here for backcompat with plugins. */

const log = require('lighthouse-logger');
const makeComputedArtifact = require('./computed-artifact.js');
const ProcessedTrace = require('./processed-trace.js');
const ProcessedNavigation = require('./processed-navigation.js');

class TraceOfTab {
  /**
     * @param {LH.Trace} trace
     * @param {LH.Artifacts.ComputedContext} context
     * @return {Promise<any>}
    */
  static async compute_(trace, context) {
    const processedTrace = await ProcessedTrace.request(trace, context);
    const processedNavigation = await ProcessedNavigation.request(processedTrace, context);
    return {...processedTrace, ...processedNavigation};
  }
}

log.warn(`trace-of-tab`, `trace-of-tab is deprecated, use processed-trace / processed-navigation instead`); // eslint-disable-line max-len
module.exports = makeComputedArtifact(TraceOfTab);


},{"./computed-artifact.js":9,"./processed-navigation.js":42,"./processed-trace.js":43,"lighthouse-logger":188}],48:[function(require,module,exports){
/**
 * @license Copyright 2019 The Lighthouse Authors. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.
 */
'use strict';

const makeComputedArtifact = require('./computed-artifact.js');
const ByteEfficiencyAudit = require('../audits/byte-efficiency/byte-efficiency-audit.js');
const NetworkRecords = require('./network-records.js');

const PREVIEW_LENGTH = 100;

/** @typedef {LH.Artifacts.CSSStyleSheetInfo & {networkRecord: LH.Artifacts.NetworkRequest, usedRules: Array<LH.Crdp.CSS.RuleUsage>}} StyleSheetInfo */

class UnusedCSS {
  /**
   * @param {Array<LH.Artifacts.CSSStyleSheetInfo>} styles The output of the Styles gatherer.
   * @param {Array<LH.Artifacts.NetworkRequest>} networkRecords
   * @return {Object<string, StyleSheetInfo>} A map of styleSheetId to stylesheet information.
   */
  static indexStylesheetsById(styles, networkRecords) {
    const indexedNetworkRecords = networkRecords
        // Some phantom network records appear with a 0 resourceSize that aren't real.
        // A network record that has no size data is just as good as no network record at all for our
        // purposes, so we'll just filter them out. https://github.com/GoogleChrome/lighthouse/issues/9684#issuecomment-532381611
        .filter(record => record.resourceSize > 0)
        .reduce((indexed, record) => {
          indexed[record.url] = record;
          return indexed;
        }, /** @type {Object<string, LH.Artifacts.NetworkRequest>} */ ({}));

    return styles.reduce((indexed, stylesheet) => {
      indexed[stylesheet.header.styleSheetId] = Object.assign({
        usedRules: [],
        networkRecord: indexedNetworkRecords[stylesheet.header.sourceURL],
      }, stylesheet);
      return indexed;
    }, /** @type {Object<string, StyleSheetInfo>} */ ({}));
  }

  /**
   * Adds used rules to their corresponding stylesheet.
   * @param {Array<LH.Crdp.CSS.RuleUsage>} rules The output of the CSSUsage gatherer.
   * @param {Object<string, StyleSheetInfo>} indexedStylesheets Stylesheet information indexed by id.
   */
  static indexUsedRules(rules, indexedStylesheets) {
    rules.forEach(rule => {
      const stylesheetInfo = indexedStylesheets[rule.styleSheetId];

      if (!stylesheetInfo) {
        return;
      }

      if (rule.used) {
        stylesheetInfo.usedRules.push(rule);
      }
    });
  }

  /**
   * @param {StyleSheetInfo} stylesheetInfo
   * @return {{wastedBytes: number, totalBytes: number, wastedPercent: number}}
   */
  static computeUsage(stylesheetInfo) {
    let usedUncompressedBytes = 0;
    const totalUncompressedBytes = stylesheetInfo.content.length;

    for (const usedRule of stylesheetInfo.usedRules) {
      usedUncompressedBytes += usedRule.endOffset - usedRule.startOffset;
    }

    const totalTransferredBytes = ByteEfficiencyAudit.estimateTransferSize(
        stylesheetInfo.networkRecord, totalUncompressedBytes, 'Stylesheet');
    const percentUnused = (totalUncompressedBytes - usedUncompressedBytes) / totalUncompressedBytes;
    const wastedBytes = Math.round(percentUnused * totalTransferredBytes);

    return {
      wastedBytes,
      wastedPercent: percentUnused * 100,
      totalBytes: totalTransferredBytes,
    };
  }

  /**
   * Trims stylesheet content down to the first rule-set definition.
   * @param {string=} content
   * @return {string}
   */
  static determineContentPreview(content) {
    let preview = (content || '')
        .slice(0, PREVIEW_LENGTH * 5)
        .replace(/( {2,}|\t)+/g, '  ') // remove leading indentation if present
        .replace(/\n\s+}/g, '\n}') // completely remove indentation of closing braces
        .trim(); // trim the leading whitespace

    if (preview.length > PREVIEW_LENGTH) {
      const firstRuleStart = preview.indexOf('{');
      const firstRuleEnd = preview.indexOf('}');

      if (firstRuleStart === -1 || firstRuleEnd === -1
          || firstRuleStart > firstRuleEnd
          || firstRuleStart > PREVIEW_LENGTH) {
        // We couldn't determine the first rule-set or it's not within the preview
        preview = preview.slice(0, PREVIEW_LENGTH) + '...';
      } else if (firstRuleEnd < PREVIEW_LENGTH) {
        // The entire first rule-set fits within the preview
        preview = preview.slice(0, firstRuleEnd + 1) + ' ...';
      } else {
        // The first rule-set doesn't fit within the preview, just show as many as we can
        const lastSemicolonIndex = preview.slice(0, PREVIEW_LENGTH).lastIndexOf(';');
        preview = lastSemicolonIndex < firstRuleStart ?
            preview.slice(0, PREVIEW_LENGTH) + '... } ...' :
            preview.slice(0, lastSemicolonIndex + 1) + ' ... } ...';
      }
    }

    return preview;
  }

  /**
   * @param {StyleSheetInfo} stylesheetInfo The stylesheetInfo object.
   * @param {string} pageUrl The URL of the page, used to identify inline styles.
   * @return {LH.Audit.ByteEfficiencyItem}
   */
  static mapSheetToResult(stylesheetInfo, pageUrl) {
    let url = stylesheetInfo.header.sourceURL;
    if (!url || url === pageUrl) {
      const contentPreview = UnusedCSS.determineContentPreview(stylesheetInfo.content);
      url = contentPreview;
    }

    const usage = UnusedCSS.computeUsage(stylesheetInfo);
    return {url, ...usage};
  }

  /**
   * @param {{CSSUsage: LH.Artifacts['CSSUsage'], URL: LH.Artifacts['URL'], devtoolsLog: LH.DevtoolsLog}} data
   * @param {LH.Artifacts.ComputedContext} context
   * @return {Promise<LH.Audit.ByteEfficiencyItem[]>}
  */
  static async compute_(data, context) {
    const {CSSUsage, URL, devtoolsLog} = data;
    const networkRecords = await NetworkRecords.request(devtoolsLog, context);
    const indexedSheets = UnusedCSS.indexStylesheetsById(CSSUsage.stylesheets, networkRecords);
    UnusedCSS.indexUsedRules(CSSUsage.rules, indexedSheets);

    const items = Object.keys(indexedSheets)
      .map(sheetId => UnusedCSS.mapSheetToResult(indexedSheets[sheetId], URL.finalUrl));
    return items;
  }
}

module.exports = makeComputedArtifact(UnusedCSS);

},{"../audits/byte-efficiency/byte-efficiency-audit.js":4,"./computed-artifact.js":9,"./network-records.js":40}],49:[function(require,module,exports){
/**
 * @license Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.
 */
'use strict';

const makeComputedArtifact = require('./computed-artifact.js');

/**
 * @typedef WasteData
 * @property {Uint8Array} unusedByIndex
 * @property {number} unusedLength
 * @property {number} contentLength
 */

/**
 * @typedef ComputeInput
 * @property {string} url
 * @property {Array<Omit<LH.Crdp.Profiler.ScriptCoverage, 'url'>>} scriptCoverages
 * @property {LH.Artifacts.Bundle=} bundle
 */

/**
 * @typedef Summary
 * @property {string} url
 * @property {number} wastedBytes
 * @property {number} totalBytes
 * @property {number} wastedBytes
 * @property {number=} wastedPercent
 * @property {Record<string, number>=} sourcesWastedBytes Keyed by file name. Includes (unmapped) key too.
 */

class UnusedJavascriptSummary {
  /**
   * @param {Omit<LH.Crdp.Profiler.ScriptCoverage, 'url'>} scriptCoverage
   * @return {WasteData}
   */
  static computeWaste(scriptCoverage) {
    let maximumEndOffset = 0;
    for (const func of scriptCoverage.functions) {
      maximumEndOffset = Math.max(maximumEndOffset, ...func.ranges.map(r => r.endOffset));
    }

    // We only care about unused ranges of the script, so we can ignore all the nesting and safely
    // assume that if a range is unexecuted, all nested ranges within it will also be unexecuted.
    const unusedByIndex = new Uint8Array(maximumEndOffset);
    for (const func of scriptCoverage.functions) {
      for (const range of func.ranges) {
        if (range.count === 0) {
          for (let i = range.startOffset; i < range.endOffset; i++) {
            unusedByIndex[i] = 1;
          }
        }
      }
    }

    let unused = 0;
    for (const x of unusedByIndex) {
      unused += x;
    }

    return {
      unusedByIndex,
      unusedLength: unused,
      contentLength: maximumEndOffset,
    };
  }

  /**
   * @param {string} url
   * @param {ReturnType<typeof UnusedJavascriptSummary.determineLengths>} lengths
   * @return {Summary}
   */
  static createItem(url, lengths) {
    const wastedRatio = (lengths.unused / lengths.content) || 0;
    const wastedBytes = Math.round(lengths.content * wastedRatio);

    return {
      url,
      totalBytes: lengths.content,
      wastedBytes,
      wastedPercent: 100 * wastedRatio,
    };
  }

  /**
   * @param {WasteData[]} wasteData
   */
  static determineLengths(wasteData) {
    let unused = 0;
    let content = 0;
    // TODO: this is right for multiple script tags in an HTML document,
    // but may be wrong for multiple frames using the same script resource.
    for (const usage of wasteData) {
      unused += usage.unusedLength;
      content += usage.contentLength;
    }

    return {
      content,
      unused,
    };
  }

  /**
   * @param {WasteData[]} wasteData
   * @param {LH.Artifacts.Bundle} bundle
   */
  static createSourceWastedBytes(wasteData, bundle) {
    if (!bundle.script.content) return;

    /** @type {Record<string, number>} */
    const files = {};

    const lineLengths = bundle.script.content.split('\n').map(l => l.length);
    let totalSoFar = 0;
    const lineOffsets = lineLengths.map(len => {
      const retVal = totalSoFar;
      totalSoFar += len + 1;
      return retVal;
    });

    // @ts-expect-error: We will upstream computeLastGeneratedColumns to CDT eventually.
    bundle.map.computeLastGeneratedColumns();
    for (const mapping of bundle.map.mappings()) {
      let offset = lineOffsets[mapping.lineNumber];

      offset += mapping.columnNumber;
      const lastColumnOfMapping =
        // @ts-expect-error: We will upstream lastColumnNumber to CDT eventually.
        (mapping.lastColumnNumber - 1) || lineLengths[mapping.lineNumber];
      for (let i = mapping.columnNumber; i <= lastColumnOfMapping; i++) {
        if (wasteData.every(data => data.unusedByIndex[offset] === 1)) {
          const key = mapping.sourceURL || '(unmapped)';
          files[key] = (files[key] || 0) + 1;
        }
        offset += 1;
      }
    }

    const dataSorted = Object.entries(files)
      .sort(([_, unusedBytes1], [__, unusedBytes2]) => unusedBytes2 - unusedBytes1);

    /** @type {Record<string, number>} */
    const bundleData = {};
    for (const [key, unusedBytes] of dataSorted) {
      bundleData[key] = unusedBytes;
    }
    return bundleData;
  }

  /**
   * @param {ComputeInput} data
   * @return {Promise<Summary>}
   */
  static async compute_(data) {
    const {url, scriptCoverages, bundle} = data;

    const wasteData = scriptCoverages.map(UnusedJavascriptSummary.computeWaste);
    const lengths = UnusedJavascriptSummary.determineLengths(wasteData);
    const item = UnusedJavascriptSummary.createItem(url, lengths);
    if (!bundle) return item;

    return {
      ...item,
      sourcesWastedBytes: UnusedJavascriptSummary.createSourceWastedBytes(wasteData, bundle),
    };
  }
}

module.exports = makeComputedArtifact(UnusedJavascriptSummary);

},{"./computed-artifact.js":9}],50:[function(require,module,exports){
/**
 * @license Copyright 2018 The Lighthouse Authors. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.
 */
'use strict';

const makeComputedArtifact = require('./computed-artifact.js');
const ProcessedTrace = require('./processed-trace.js');

/** @typedef {{name: string, isMark: true, args: LH.TraceEvent['args'], startTime: number}} MarkEvent */
/** @typedef {{name: string, isMark: false, args: LH.TraceEvent['args'], startTime: number, endTime: number, duration: number}} MeasureEvent */

class UserTimings {
  /**
   * @param {LH.Trace} trace
   * @param {LH.Artifacts.ComputedContext} context
   * @return {Promise<Array<MarkEvent|MeasureEvent>>}
   */
  static async compute_(trace, context) {
    const processedTrace = await ProcessedTrace.request(trace, context);
    /** @type {Array<MarkEvent|MeasureEvent>} */
    const userTimings = [];
    /** @type {Record<string, number>} */
    const measuresStartTimes = {};

    // Get all blink.user_timing events
    // The event phases we are interested in are mark and instant events (R, i, I)
    // and duration events which correspond to measures (B, b, E, e).
    // @see https://docs.google.com/document/d/1CvAClvFfyA5R-PhYUmn5OOQtYMH4h6I0nSsKchNAySU/preview#
    processedTrace.processEvents.filter(evt => {
      if (!evt.cat.includes('blink.user_timing')) {
        return false;
      }

      // reject these "userTiming" events that aren't really UserTiming, by nuking ones with frame data (or requestStart)
      // https://cs.chromium.org/search/?q=trace_event.*?user_timing&sq=package:chromium&type=cs
      return evt.name !== 'requestStart' &&
          evt.name !== 'navigationStart' &&
          evt.name !== 'paintNonDefaultBackgroundColor' &&
          evt.args.frame === undefined;
    })
    .forEach(ut => {
      // Mark events fall under phases R and I (or i)
      if (ut.ph === 'R' || ut.ph.toUpperCase() === 'I') {
        userTimings.push({
          name: ut.name,
          isMark: true,
          args: ut.args,
          startTime: ut.ts,
        });

      // Beginning of measure event, keep track of this events start time
      } else if (ut.ph.toLowerCase() === 'b') {
        measuresStartTimes[ut.name] = ut.ts;

      // End of measure event
      } else if (ut.ph.toLowerCase() === 'e') {
        userTimings.push({
          name: ut.name,
          isMark: false,
          args: ut.args,
          startTime: measuresStartTimes[ut.name],
          endTime: ut.ts,
          duration: ut.ts - measuresStartTimes[ut.name],
        });
      }
    });

    // baseline the timestamps against the timeOrigin, and translate to milliseconds
    userTimings.forEach(ut => {
      ut.startTime = (ut.startTime - processedTrace.timeOriginEvt.ts) / 1000;
      if (!ut.isMark) {
        ut.endTime = (ut.endTime - processedTrace.timeOriginEvt.ts) / 1000;
        ut.duration = ut.duration / 1000;
      }
    });

    return userTimings;
  }
}

module.exports = makeComputedArtifact(UserTimings);

},{"./computed-artifact.js":9,"./processed-trace.js":43}],51:[function(require,module,exports){
/**
 * @license Copyright 2019 The Lighthouse Authors. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.
 */
'use strict';

const Parser = require('metaviewport-parser');

const makeComputedArtifact = require('./computed-artifact.js');

class ViewportMeta {
  /**
   * @param {LH.GathererArtifacts['MetaElements']} MetaElements
   * @return {Promise<ViewportMetaResult>}
  */
  static async compute_(MetaElements) {
    const viewportMeta = MetaElements.find(meta => meta.name === 'viewport');

    if (!viewportMeta) {
      return {
        hasViewportTag: false,
        isMobileOptimized: false,
        parserWarnings: [],
      };
    }

    const warnings = [];
    const parsedProps = Parser.parseMetaViewPortContent(viewportMeta.content || '');

    if (Object.keys(parsedProps.unknownProperties).length) {
      warnings.push(`Invalid properties found: ${JSON.stringify(parsedProps.unknownProperties)}`);
    }
    if (Object.keys(parsedProps.invalidValues).length) {
      warnings.push(`Invalid values found: ${JSON.stringify(parsedProps.invalidValues)}`);
    }

    const viewportProps = parsedProps.validProperties;
    const isMobileOptimized = Boolean(viewportProps.width || viewportProps['initial-scale']);

    return {
      hasViewportTag: true,
      isMobileOptimized,
      parserWarnings: warnings,
    };
  }
}

module.exports = makeComputedArtifact(ViewportMeta);

/**
 * @typedef {object} ViewportMetaResult
 * @property {boolean} hasViewportTag Whether the page has any viewport tag.
 * @property {boolean} isMobileOptimized Whether the viewport tag is optimized for mobile screens.
 * @property {Array<string>} parserWarnings Warnings if the parser encountered invalid content in the viewport tag.
 */

},{"./computed-artifact.js":9,"metaviewport-parser":220}],52:[function(require,module,exports){
/**
 * @license Copyright 2019 The Lighthouse Authors. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.
 */
'use strict';

/**
 * @param {unknown} arr
 * @return {arr is Array<Record<string, unknown>>}
 */
function isArrayOfUnknownObjects(arr) {
  return Array.isArray(arr) && arr.every(isObjectOfUnknownProperties);
}

/**
 * @param {unknown} val
 * @return {val is Record<string, unknown>}
 */
function isObjectOfUnknownProperties(val) {
  return typeof val === 'object' && val !== null && !Array.isArray(val);
}

/**
 * Returns whether `val` is numeric. Will not coerce to a number. `NaN` will
 * return false, however ±Infinity will return true.
 * @param {unknown} val
 * @return {val is number}
 */
function isNumber(val) {
  return typeof val === 'number' && !isNaN(val);
}

class Budget {
  /**
   * Asserts that obj has no own properties, throwing a nice error message if it does.
   * `objectName` is included for nicer logging.
   * @param {Record<string, unknown>} obj
   * @param {string} objectName
   */
  static assertNoExcessProperties(obj, objectName) {
    const invalidKeys = Object.keys(obj);
    if (invalidKeys.length > 0) {
      const keys = invalidKeys.join(', ');
      throw new Error(`${objectName} has unrecognized properties: [${keys}]`);
    }
  }

  /**
   * Asserts that `strings` has no duplicate strings in it, throwing an error if
   * it does. `arrayName` is included for nicer logging.
   * @param {Array<string>} strings
   * @param {string} arrayName
   */
  static assertNoDuplicateStrings(strings, arrayName) {
    const foundStrings = new Set();
    for (const string of strings) {
      if (foundStrings.has(string)) {
        throw new Error(`${arrayName} has duplicate entry of type '${string}'`);
      }
      foundStrings.add(string);
    }
  }

  /**
   * @param {Record<string, unknown>} resourceBudget
   * @return {LH.Budget.ResourceBudget}
   */
  static validateResourceBudget(resourceBudget) {
    const {resourceType, budget, ...invalidRest} = resourceBudget;
    Budget.assertNoExcessProperties(invalidRest, 'Resource Budget');

    /** @type {Array<LH.Budget.ResourceType>} */
    const validResourceTypes = [
      'total',
      'document',
      'script',
      'stylesheet',
      'image',
      'media',
      'font',
      'other',
      'third-party',
    ];
    // Assume resourceType is an allowed string, throw if not.
    if (!validResourceTypes.includes(/** @type {LH.Budget.ResourceType} */ (resourceType))) {
      throw new Error(`Invalid resource type: ${resourceType}. \n` +
        `Valid resource types are: ${validResourceTypes.join(', ') }`);
    }
    if (!isNumber(budget)) {
      throw new Error(`Invalid budget: ${budget}`);
    }
    return {
      resourceType: /** @type {LH.Budget.ResourceType} */ (resourceType),
      budget,
    };
  }

  /**
   * @param {unknown} path
   * @param {string} error
   */
  static throwInvalidPathError(path, error) {
    throw new Error(`Invalid path ${path}. ${error}\n` +
      `'Path' should be specified using the 'robots.txt' format.\n` +
      `Learn more about the 'robots.txt' format here:\n` +
      `https://developers.google.com/search/reference/robots_txt#url-matching-based-on-path-values`);
  }


  /**
   * Validates that path is either: a) undefined or ) properly formed.
   * Verifies the quantity and location of the two robot.txt regex characters: $, *
   * @param {unknown} path
   * @return {undefined|string}
   */
  static validatePath(path) {
    if (path === undefined) {
      return undefined;
    } else if (typeof path !== 'string') {
      this.throwInvalidPathError(path, `Path should be a string.`);
      return;
    } else if (!path.startsWith('/')) {
      this.throwInvalidPathError(path, `Path should start with '/'.`);
    } else if ((path.match(/\*/g) || []).length > 1) {
      this.throwInvalidPathError(path, `Path should only contain one '*'.`);
    } else if ((path.match(/\$/g) || []).length > 1) {
      this.throwInvalidPathError(path, `Path should only contain one '$' character.`);
    } else if (path.includes('$') && !path.endsWith('$')) {
      this.throwInvalidPathError(path, `'$' character should only occur at end of path.`);
    }
    return path;
  }

  /**
   * Returns the budget that applies to a given URL.
   * If multiple budgets match based on thier 'path' property,
   * then the last-listed of those budgets is returned.
   * @param {Immutable<Array<LH.Budget>>|null} budgets
   * @param {string} url
   * @return {Immutable<LH.Budget> | undefined} budget
   */
  static getMatchingBudget(budgets, url) {
    if (budgets === null) return;

    // Applies the LAST matching budget.
    for (let i = budgets.length - 1; i >= 0; i--) {
      const budget = budgets[i];
      if (this.urlMatchesPattern(url, budget.path)) {
        return budget;
      }
    }
  }

  /**
   * Determines whether a URL matches against a robots.txt-style "path".
   * Pattern should use the robots.txt format. E.g. "/*-article.html" or "/". Reference:
   * https://developers.google.com/search/reference/robots_txt#url-matching-based-on-path-values
   * @param {string} url
   * @param {string=} pattern
   * @return {boolean}
   */
  static urlMatchesPattern(url, pattern = '/') {
    const urlObj = new URL(url);
    const urlPath = urlObj.pathname + urlObj.search;

    const hasWildcard = pattern.includes('*');
    const hasDollarSign = pattern.includes('$');

    /**
     * There are 4 different cases of path strings.
     * Paths should have already been validated with #validatePath.
     *
     * Case #1: No special characters
     * Example: "/cat"
     * Behavior: URL should start with given pattern.
     */
    if (!hasWildcard && !hasDollarSign) {
      return urlPath.startsWith(pattern);
    /**
     * Case #2: $ only
     * Example: "/js$"
     * Behavior: URL should be identical to pattern.
     */
    } else if (!hasWildcard && hasDollarSign) {
      return urlPath === pattern.slice(0, -1);
    /**
     * Case #3: * only
     * Example: "/vendor*chunk"
     * Behavior: URL should start with the string pattern that comes before the wildcard
     * & later in the string contain the string pattern that comes after the wildcard.
     */
    } else if (hasWildcard && !hasDollarSign) {
      const [beforeWildcard, afterWildcard] = pattern.split('*');
      const remainingUrl = urlPath.slice(beforeWildcard.length);
      return urlPath.startsWith(beforeWildcard) && remainingUrl.includes(afterWildcard);
    /**
     * Case #4: $ and *
     * Example: "/vendor*chunk.js$"
     * Behavior: URL should start with the string pattern that comes before the wildcard
     * & later in the string end with the string pattern that comes after the wildcard.
     */
    } else if (hasWildcard && hasDollarSign) {
      const [beforeWildcard, afterWildcard] = pattern.split('*');
      const urlEnd = urlPath.slice(beforeWildcard.length);
      return urlPath.startsWith(beforeWildcard) && urlEnd.endsWith(afterWildcard.slice(0, -1));
    }
    return false;
  }

  /**
   * @param {Record<string, unknown>} timingBudget
   * @return {LH.Budget.TimingBudget}
   */
  static validateTimingBudget(timingBudget) {
    const {metric, budget, ...invalidRest} = timingBudget;
    Budget.assertNoExcessProperties(invalidRest, 'Timing Budget');

    /** @type {Array<LH.Budget.TimingMetric>} */
    const validTimingMetrics = [
      'first-contentful-paint',
      'interactive',
      'first-meaningful-paint',
      'max-potential-fid',
      'total-blocking-time',
      'speed-index',
      'largest-contentful-paint',
      'cumulative-layout-shift',
    ];
    // Assume metric is an allowed string, throw if not.
    if (!validTimingMetrics.includes(/** @type {LH.Budget.TimingMetric} */ (metric))) {
      throw new Error(`Invalid timing metric: ${metric}. \n` +
        `Valid timing metrics are: ${validTimingMetrics.join(', ')}`);
    }
    if (!isNumber(budget)) {
      throw new Error(`Invalid budget: ${budget}`);
    }
    return {
      metric: /** @type {LH.Budget.TimingMetric} */ (metric),
      budget,
    };
  }

  /**
   * @param {string} hostname
   * @return {string}
   */
  static validateHostname(hostname) {
    const errMsg = `${hostname} is not a valid hostname.`;
    if (hostname.length === 0) {
      throw new Error(errMsg);
    }
    if (hostname.includes('/')) {
      throw new Error(errMsg);
    }
    if (hostname.includes(':')) {
      throw new Error(errMsg);
    }
    if (hostname.includes('*')) {
      if (!hostname.startsWith('*.') || hostname.lastIndexOf('*') > 0) {
        throw new Error(errMsg);
      }
    }
    return hostname;
  }

  /**
   * @param {unknown} hostnames
   * @return {undefined|Array<string>}
   */
  static validateHostnames(hostnames) {
    if (Array.isArray(hostnames) && hostnames.every(host => typeof host === 'string')) {
      return hostnames.map(Budget.validateHostname);
    } else if (hostnames !== undefined) {
      throw new Error(`firstPartyHostnames should be defined as an array of strings.`);
    }
  }

  /**
   * More info on the Budget format:
   * https://github.com/GoogleChrome/lighthouse/issues/6053#issuecomment-428385930
   * @param {unknown} budgetJson
   * @return {Array<LH.Budget>}
   */
  static initializeBudget(budgetJson) {
    // Clone to prevent modifications of original and to deactivate any live properties.
    budgetJson = JSON.parse(JSON.stringify(budgetJson));
    if (!isArrayOfUnknownObjects(budgetJson)) {
      throw new Error('Budget file is not defined as an array of budgets.');
    }

    const budgets = budgetJson.map((b, index) => {
      /** @type {LH.Budget} */
      const budget = {};

      const {path, options, resourceSizes, resourceCounts, timings, ...invalidRest} = b;
      Budget.assertNoExcessProperties(invalidRest, 'Budget');

      budget.path = Budget.validatePath(path);

      if (isObjectOfUnknownProperties(options)) {
        const {firstPartyHostnames, ...invalidRest} = options;
        Budget.assertNoExcessProperties(invalidRest, 'Options property');
        budget.options = {};
        budget.options.firstPartyHostnames = Budget.validateHostnames(firstPartyHostnames);
      } else if (options !== undefined) {
        throw new Error(`Invalid options property in budget at index ${index}`);
      }

      if (isArrayOfUnknownObjects(resourceSizes)) {
        budget.resourceSizes = resourceSizes.map(Budget.validateResourceBudget);
        Budget.assertNoDuplicateStrings(budget.resourceSizes.map(r => r.resourceType),
          `budgets[${index}].resourceSizes`);
      } else if (resourceSizes !== undefined) {
        throw new Error(`Invalid resourceSizes entry in budget at index ${index}`);
      }

      if (isArrayOfUnknownObjects(resourceCounts)) {
        budget.resourceCounts = resourceCounts.map(Budget.validateResourceBudget);
        Budget.assertNoDuplicateStrings(budget.resourceCounts.map(r => r.resourceType),
          `budgets[${index}].resourceCounts`);
      } else if (resourceCounts !== undefined) {
        throw new Error(`Invalid resourceCounts entry in budget at index ${index}`);
      }

      if (isArrayOfUnknownObjects(timings)) {
        budget.timings = timings.map(Budget.validateTimingBudget);
        Budget.assertNoDuplicateStrings(budget.timings.map(r => r.metric),
          `budgets[${index}].timings`);
      } else if (timings !== undefined) {
        throw new Error(`Invalid timings entry in budget at index ${index}`);
      }

      return budget;
    });

    return budgets;
  }
}

module.exports = Budget;

},{}],53:[function(require,module,exports){
(function (process,global,__dirname){(function (){
/**
 * @license Copyright 2019 The Lighthouse Authors. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.
 */
'use strict';

const path = require('path');
const isDeepEqual = require('lodash.isequal');
const constants = require('./constants.js');
const Budget = require('./budget.js');
const Audit = require('../audits/audit.js');
const Runner = require('../runner.js');
const i18n = require('../lib/i18n/i18n.js');

/** @typedef {typeof import('../gather/gatherers/gatherer.js')} GathererConstructor */
/** @typedef {InstanceType<GathererConstructor>} Gatherer */

/**
 * If any items with identical `path` properties are found in the input array,
 * merge their `options` properties into the first instance and then discard any
 * other instances.
 * Until support of jsdoc templates with constraints, type in config.d.ts.
 * See https://github.com/Microsoft/TypeScript/issues/24283
 * @type {LH.Config.MergeOptionsOfItems}
 */
const mergeOptionsOfItems = function(items) {
  /** @type {Array<{id: string, path?: string, options?: Object<string, any>}>} */
  const mergedItems = [];

  for (const item of items) {
    const existingItem = item.path && mergedItems.find(candidate => candidate.path === item.path);
    if (!existingItem) {
      mergedItems.push(item);
      continue;
    }

    existingItem.options = Object.assign({}, existingItem.options, item.options);
  }

  return mergedItems;
};

/**
 * Recursively merges config fragment objects in a somewhat Lighthouse-specific way.
 *
 *    - `null` is treated similarly to `undefined` for whether a value should be overridden.
 *    - `overwriteArrays` controls array extension behavior:
 *        - true: Arrays are overwritten without any merging or concatenation.
 *        - false: Arrays are concatenated and de-duped by isDeepEqual.
 *    - Objects are recursively merged.
 *    - If the `settings` key is encountered while traversing an object, its arrays are *always*
 *      overridden, not concatenated. (`overwriteArrays` is flipped to `true`)
 *
 * More widely typed than exposed merge() function, below.
 * @param {Object<string, any>|Array<any>|undefined|null} base
 * @param {Object<string, any>|Array<any>} extension
 * @param {boolean=} overwriteArrays
 */
function _mergeConfigFragment(base, extension, overwriteArrays = false) {
  // If the default value doesn't exist or is explicitly null, defer to the extending value
  if (typeof base === 'undefined' || base === null) {
    return extension;
  } else if (typeof extension === 'undefined') {
    return base;
  } else if (Array.isArray(extension)) {
    if (overwriteArrays) return extension;
    if (!Array.isArray(base)) throw new TypeError(`Expected array but got ${typeof base}`);
    const merged = base.slice();
    extension.forEach(item => {
      if (!merged.some(candidate => isDeepEqual(candidate, item))) merged.push(item);
    });

    return merged;
  } else if (typeof extension === 'object') {
    if (typeof base !== 'object') throw new TypeError(`Expected object but got ${typeof base}`);
    if (Array.isArray(base)) throw new TypeError('Expected object but got Array');
    Object.keys(extension).forEach(key => {
      const localOverwriteArrays = overwriteArrays ||
        (key === 'settings' && typeof base[key] === 'object');
      base[key] = _mergeConfigFragment(base[key], extension[key], localOverwriteArrays);
    });
    return base;
  }

  return extension;
}

/**
 * Until support of jsdoc templates with constraints, type in config.d.ts.
 * See https://github.com/Microsoft/TypeScript/issues/24283
 * @type {LH.Config.Merge}
 */
const mergeConfigFragment = _mergeConfigFragment;

/**
 * Validate the settings after they've been built
 * @param {LH.Config.Settings} settings
 */
function assertValidSettings(settings) {
  if (!settings.formFactor) {
    throw new Error(`\`settings.formFactor\` must be defined as 'mobile' or 'desktop'. See https://github.com/GoogleChrome/lighthouse/blob/master/docs/emulation.md`);
  }

  if (!settings.screenEmulation.disabled) {
    // formFactor doesn't control emulation. So we don't want a mismatch:
    //   Bad mismatch A: user wants mobile emulation but scoring is configured for desktop
    //   Bad mismtach B: user wants everything desktop and set formFactor, but accidentally not screenEmulation
    if (settings.screenEmulation.mobile !== (settings.formFactor === 'mobile')) {
      throw new Error(`Screen emulation mobile setting (${settings.screenEmulation.mobile}) does not match formFactor setting (${settings.formFactor}). See https://github.com/GoogleChrome/lighthouse/blob/master/docs/emulation.md`);
    }
  }
}

/**
 * Throws an error if the provided object does not implement the required properties of an audit
 * definition.
 * @param {LH.Config.AuditDefn} auditDefinition
 */
function assertValidAudit(auditDefinition) {
  const {implementation, path: auditPath} = auditDefinition;
  const auditName = auditPath ||
    (implementation && implementation.meta && implementation.meta.id) ||
    'Unknown audit';

  if (typeof implementation.audit !== 'function' || implementation.audit === Audit.audit) {
    throw new Error(`${auditName} has no audit() method.`);
  }

  if (typeof implementation.meta.id !== 'string') {
    throw new Error(`${auditName} has no meta.id property, or the property is not a string.`);
  }

  if (!i18n.isStringOrIcuMessage(implementation.meta.title)) {
    throw new Error(`${auditName} has no meta.title property, or the property is not a string.`);
  }

  // If it'll have a ✔ or ✖ displayed alongside the result, it should have failureTitle
  if (
    !i18n.isStringOrIcuMessage(implementation.meta.failureTitle) &&
    implementation.meta.scoreDisplayMode === Audit.SCORING_MODES.BINARY
  ) {
    throw new Error(`${auditName} has no failureTitle and should.`);
  }

  if (!i18n.isStringOrIcuMessage(implementation.meta.description)) {
    throw new Error(
      `${auditName} has no meta.description property, or the property is not a string.`
    );
  } else if (implementation.meta.description === '') {
    throw new Error(
      `${auditName} has an empty meta.description string. Please add a description for the UI.`
    );
  }

  if (!Array.isArray(implementation.meta.requiredArtifacts)) {
    throw new Error(
      `${auditName} has no meta.requiredArtifacts property, or the property is not an array.`
    );
  }
}

/**
 * Expands a gatherer from user-specified to an internal gatherer definition format.
 *
 * Input Examples:
 *  - 'my-gatherer'
 *  - class MyGatherer extends Gatherer { }
 *  - {instance: myGathererInstance}
 *
 * @param {LH.Config.GathererJson} gatherer
 * @return {{instance?: Gatherer, implementation?: GathererConstructor, path?: string}} passes
 */
function expandGathererShorthand(gatherer) {
  if (typeof gatherer === 'string') {
    // just 'path/to/gatherer'
    return {path: gatherer};
  } else if ('implementation' in gatherer || 'instance' in gatherer) {
    // {implementation: GathererConstructor, ...} or {instance: GathererInstance, ...}
    return gatherer;
  } else if ('path' in gatherer) {
    // {path: 'path/to/gatherer', ...}
    if (typeof gatherer.path !== 'string') {
      throw new Error('Invalid Gatherer type ' + JSON.stringify(gatherer));
    }
    return gatherer;
  } else if (typeof gatherer === 'function') {
    // just GathererConstructor
    return {implementation: gatherer};
  } else if (gatherer && typeof gatherer.beforePass === 'function') {
    // just GathererInstance
    return {instance: gatherer};
  } else {
    throw new Error('Invalid Gatherer type ' + JSON.stringify(gatherer));
  }
}

/**
 * Expands the audits from user-specified JSON to an internal audit definition format.
 * @param {LH.Config.AuditJson} audit
 * @return {{id?: string, path: string, options?: {}} | {id?: string, implementation: typeof Audit, path?: string, options?: {}}}
 */
function expandAuditShorthand(audit) {
  if (typeof audit === 'string') {
    // just 'path/to/audit'
    return {path: audit, options: {}};
  } else if ('implementation' in audit && typeof audit.implementation.audit === 'function') {
    // {implementation: AuditClass, ...}
    return audit;
  } else if ('path' in audit && typeof audit.path === 'string') {
    // {path: 'path/to/audit', ...}
    return audit;
  } else if ('audit' in audit && typeof audit.audit === 'function') {
    // just AuditClass
    return {implementation: audit, options: {}};
  } else {
    throw new Error('Invalid Audit type ' + JSON.stringify(audit));
  }
}

/**
 * @param {string} gathererPath
 * @param {Array<string>} coreGathererList
 * @param {string=} configDir
 * @return {LH.Config.GathererDefn}
 */
function requireGatherer(gathererPath, coreGathererList, configDir) {
  const coreGatherer = coreGathererList.find(a => a === `${gathererPath}.js`);

  let requirePath = `../gather/gatherers/${gathererPath}`;
  if (!coreGatherer) {
    // Otherwise, attempt to find it elsewhere. This throws if not found.
    requirePath = resolveModulePath(gathererPath, configDir, 'gatherer');
  }

  const GathererClass = /** @type {GathererConstructor} */ (require(requirePath));

  return {
    instance: new GathererClass(),
    implementation: GathererClass,
    path: gathererPath,
  };
}

/**
 *
 * @param {string} auditPath
 * @param {Array<string>} coreAuditList
 * @param {string=} configDir
 * @return {LH.Config.AuditDefn['implementation']}
 */
function requireAudit(auditPath, coreAuditList, configDir) {
// See if the audit is a Lighthouse core audit.
  const auditPathJs = `${auditPath}.js`;
  const coreAudit = coreAuditList.find(a => a === auditPathJs);
  let requirePath = `../audits/${auditPath}`;
  if (!coreAudit) {
  // TODO: refactor and delete `global.isDevtools`.
    if (global.isDevtools || global.isLightrider) {
    // This is for pubads bundling.
      requirePath = auditPath;
    } else {
    // Otherwise, attempt to find it elsewhere. This throws if not found.
      const absolutePath = resolveModulePath(auditPath, configDir, 'audit');
      // Use a relative path so bundler can easily expose it.
      requirePath = path.relative(__dirname, absolutePath);
    }
  }

  return require(requirePath);
}

/**
 * Creates a settings object from potential flags object by dropping all the properties
 * that don't exist on Config.Settings.
 * @param {Partial<LH.Flags>=} flags
 * @return {RecursivePartial<LH.Config.Settings>}
*/
function cleanFlagsForSettings(flags = {}) {
  /** @type {RecursivePartial<LH.Config.Settings>} */
  const settings = {};

  for (const key of Object.keys(flags)) {
    if (key in constants.defaultSettings) {
      // @ts-expect-error tsc can't yet express that key is only a single type in each iteration, not a union of types.
      settings[key] = flags[key];
    }
  }

  return settings;
}

/**
 * @param {LH.SharedFlagsSettings} settingsJson
 * @param {LH.Flags|undefined} overrides
 * @return {LH.Config.Settings}
 */
function resolveSettings(settingsJson = {}, overrides = undefined) {
  // If a locale is requested in flags or settings, use it. A typical CLI run will not have one,
  // however `lookupLocale` will always determine which of our supported locales to use (falling
  // back if necessary).
  const locale = i18n.lookupLocale((overrides && overrides.locale) || settingsJson.locale);

  // Fill in missing settings with defaults
  const {defaultSettings} = constants;
  const settingWithDefaults = mergeConfigFragment(deepClone(defaultSettings), settingsJson, true);

  // Override any applicable settings with CLI flags
  const settingsWithFlags = mergeConfigFragment(
    settingWithDefaults,
    cleanFlagsForSettings(overrides),
    true
  );

  if (settingsWithFlags.budgets) {
    settingsWithFlags.budgets = Budget.initializeBudget(settingsWithFlags.budgets);
  }
  // Locale is special and comes only from flags/settings/lookupLocale.
  settingsWithFlags.locale = locale;

  // Default constants uses the mobile UA. Explicitly stating to true asks LH to use the associated UA.
  // It's a little awkward, but the alternatives are not allowing `true` or a dedicated `disableUAEmulation` setting.
  if (settingsWithFlags.emulatedUserAgent === true) {
    settingsWithFlags.emulatedUserAgent = constants.userAgents[settingsWithFlags.formFactor];
  }

  assertValidSettings(settingsWithFlags);
  return settingsWithFlags;
}


/**
 * Turns a GathererJson into a GathererDefn which involves a few main steps:
 *    - Expanding the JSON shorthand the full definition format.
 *    - `require`ing in the implementation.
 *    - Creating a gatherer instance from the implementation.
 * @param {LH.Config.GathererJson} gathererJson
 * @param {Array<string>} coreGathererList
 * @param {string=} configDir
 * @return {LH.Config.GathererDefn}
 */
function resolveGathererToDefn(gathererJson, coreGathererList, configDir) {
  const gathererDefn = expandGathererShorthand(gathererJson);
  if (gathererDefn.instance) {
    return {
      instance: gathererDefn.instance,
      implementation: gathererDefn.implementation,
      path: gathererDefn.path,
    };
  } else if (gathererDefn.implementation) {
    const GathererClass = gathererDefn.implementation;
    return {
      instance: new GathererClass(),
      implementation: gathererDefn.implementation,
      path: gathererDefn.path,
    };
  } else if (gathererDefn.path) {
    const path = gathererDefn.path;
    return requireGatherer(path, coreGathererList, configDir);
  } else {
    throw new Error('Invalid expanded Gatherer: ' + JSON.stringify(gathererDefn));
  }
}

/**
 * Take an array of audits and audit paths and require any paths (possibly
 * relative to the optional `configDir`) using `resolveModule`,
 * leaving only an array of AuditDefns.
 * @param {LH.Config.Json['audits']} audits
 * @param {string=} configDir
 * @return {Array<LH.Config.AuditDefn>|null}
 */
function resolveAuditsToDefns(audits, configDir) {
  if (!audits) {
    return null;
  }

  const coreList = Runner.getAuditList();
  const auditDefns = audits.map(auditJson => {
    const auditDefn = expandAuditShorthand(auditJson);
    let implementation;
    if ('implementation' in auditDefn) {
      implementation = auditDefn.implementation;
    } else {
      implementation = requireAudit(auditDefn.path, coreList, configDir);
    }

    return {
      implementation,
      path: auditDefn.path,
      options: auditDefn.options || {},
    };
  });

  const mergedAuditDefns = mergeOptionsOfItems(auditDefns);
  mergedAuditDefns.forEach(audit => assertValidAudit(audit));
  return mergedAuditDefns;
}

/**
 * Resolves the location of the specified module and returns an absolute
 * string path to the file. Used for loading custom audits and gatherers.
 * Throws an error if no module is found.
 * @param {string} moduleIdentifier
 * @param {string=} configDir The absolute path to the directory of the config file, if there is one.
 * @param {string=} category Optional plugin category (e.g. 'audit') for better error messages.
 * @return {string}
 * @throws {Error}
 */
function resolveModulePath(moduleIdentifier, configDir, category) {
  // module in a node_modules/ that is...
  // |                                | Lighthouse globally installed | Lighthouse locally installed |
  // |--------------------------------|-------------------------------|------------------------------|
  // | global                         |   1.                          |   1.                         |
  // | in current working directory   |   2.                          |   1.                         |
  // | relative to config.js file     |   5.                          |   -                          |

  // module given by a path that is...
  // |                                           | Lighthouse globally/locally installed |
  // |-------------------------------------------|---------------------------------------|
  // | absolute                                  |   1.                                  |
  // | relative to the current working directory |   3.                                  |
  // | relative to the config.js file            |   4.                                  |

  // 1.
  // First try straight `require()`. Unlikely to be specified relative to this
  // file, but adds support for Lighthouse modules from npm since
  // `require()` walks up parent directories looking inside any node_modules/
  // present. Also handles absolute paths.
  try {
    return require.resolve(moduleIdentifier);
  } catch (e) {}

  // 2.
  // Lighthouse globally installed, node_modules/ in current working directory.
  // ex: lighthouse https://test.com
  //
  // working directory/
  //   |-- node_modules/
  //   |-- package.json
  try {
    return require.resolve(moduleIdentifier, {paths: [process.cwd()]});
  } catch (e) {}

  // 3.
  // See if the module resolves relative to the current working directory.
  // Most useful to handle the case of invoking Lighthouse as a module, since
  // then the config is an object and so has no path.
  const cwdPath = path.resolve(process.cwd(), moduleIdentifier);
  try {
    return require.resolve(cwdPath);
  } catch (e) {}

  const errorString = 'Unable to locate ' + (category ? `${category}: ` : '') +
    `\`${moduleIdentifier}\`.
     Tried to require() from these locations:
       ${__dirname}
       ${cwdPath}`;

  if (!configDir) {
    throw new Error(errorString);
  }

  // 4.
  // Try looking up relative to the config file path. Just like the
  // relative path passed to `require()` is found relative to the file it's
  // in, this allows module paths to be specified relative to the config file.
  const relativePath = path.resolve(configDir, moduleIdentifier);
  try {
    return require.resolve(relativePath);
  } catch (requireError) {}

  // 5.
  // Lighthouse globally installed, node_modules/ in config directory.
  // ex: lighthouse https://test.com --config-path=./config/config.js
  //
  // working directory/
  //   |-- config/
  //     |-- node_modules/
  //     |-- config.js
  //     |-- package.json
  try {
    return require.resolve(moduleIdentifier, {paths: [configDir]});
  } catch (requireError) {}

  throw new Error(errorString + `
       ${relativePath}`);
}

/**
 * Many objects in the config can be an object whose properties are not serializable.
 * We use a shallow clone for these objects instead.
 * Any value that isn't an object will not be cloned.
 *
 * @template T
 * @param {T} item
 * @return {T}
 */
function shallowClone(item) {
  if (typeof item === 'object') {
    // Return copy of instance and prototype chain (in case item is instantiated class).
    return Object.assign(
      Object.create(
        Object.getPrototypeOf(item)
      ),
      item
    );
  }

  return item;
}

/**
 * // TODO(bckenny): could adopt "jsonified" type to ensure T will survive JSON
 * round trip: https://github.com/Microsoft/TypeScript/issues/21838
 * @template T
 * @param {T} json
 * @return {T}
 */
function deepClone(json) {
  return JSON.parse(JSON.stringify(json));
}

/**
 * Deep clone a ConfigJson, copying over any "live" gatherer or audit that
 * wouldn't make the JSON round trip.
 * @param {LH.Config.Json} json
 * @return {LH.Config.Json}
 */
function deepCloneConfigJson(json) {
  const cloned = deepClone(json);

  // Copy arrays that could contain non-serializable properties to allow for programmatic
  // injection of audit and gatherer implementations.
  if (Array.isArray(cloned.passes) && Array.isArray(json.passes)) {
    for (let i = 0; i < cloned.passes.length; i++) {
      const pass = cloned.passes[i];
      pass.gatherers = (json.passes[i].gatherers || []).map(gatherer => shallowClone(gatherer));
    }
  }

  if (Array.isArray(json.audits)) {
    cloned.audits = json.audits.map(audit => shallowClone(audit));
  }

  if (Array.isArray(json.artifacts)) {
    cloned.artifacts = json.artifacts.map(artifact => ({
      ...artifact,
      gatherer: shallowClone(artifact.gatherer),
    }));
  }

  return cloned;
}

module.exports = {
  deepClone,
  deepCloneConfigJson,
  mergeOptionsOfItems,
  mergeConfigFragment,
  resolveSettings,
  resolveGathererToDefn,
  resolveAuditsToDefns,
  resolveModulePath,
};

}).call(this)}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},"/lighthouse-core/config")
},{"../audits/audit.js":3,"../lib/i18n/i18n.js":96,"../runner.js":122,"./budget.js":52,"./constants.js":56,"_process":223,"lodash.isequal":217,"path":222}],54:[function(require,module,exports){
/**
 * @license Copyright 2019 The Lighthouse Authors. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.
 */
'use strict';

const i18n = require('../lib/i18n/i18n.js');

/**
 * @param {unknown} arr
 * @return {arr is Array<Record<string, unknown>>}
 */
function isArrayOfUnknownObjects(arr) {
  return Array.isArray(arr) && arr.every(isObjectOfUnknownProperties);
}

/**
 * @param {unknown} val
 * @return {val is Record<string, unknown>}
 */
function isObjectOfUnknownProperties(val) {
  return typeof val === 'object' && val !== null && !Array.isArray(val);
}

/**
 * Asserts that obj has no own properties, throwing a nice error message if it does.
 * Plugin and object name are included for nicer logging.
 * @param {Record<string, unknown>} obj
 * @param {string} pluginName
 * @param {string=} objectName
 */
function assertNoExcessProperties(obj, pluginName, objectName = '') {
  if (objectName) {
    objectName += ' ';
  }

  const invalidKeys = Object.keys(obj);
  if (invalidKeys.length > 0) {
    const keys = invalidKeys.join(', ');
    throw new Error(`${pluginName} has unrecognized ${objectName}properties: [${keys}]`);
  }
}

/**
 * A set of methods for extracting and validating a Lighthouse plugin config.
 */
class ConfigPlugin {
  /**
   * Extract and validate the list of AuditDefns added by the plugin (or undefined
   * if no additional audits are being added by the plugin).
   * @param {unknown} auditsJson
   * @param {string} pluginName
   * @return {Array<{path: string}>|undefined}
   */
  static _parseAuditsList(auditsJson, pluginName) {
    // Plugin audits aren't required (relying on LH default audits) so fall back to [].
    if (auditsJson === undefined) {
      return undefined;
    } else if (!isArrayOfUnknownObjects(auditsJson)) {
      throw new Error(`${pluginName} has an invalid audits array.`);
    }

    return auditsJson.map(auditDefnJson => {
      const {path, ...invalidRest} = auditDefnJson;
      assertNoExcessProperties(invalidRest, pluginName, 'audit');

      if (typeof path !== 'string') {
        throw new Error(`${pluginName} has a missing audit path.`);
      }
      return {
        path,
      };
    });
  }

  /**
   * Extract and validate the list of category AuditRefs added by the plugin.
   * @param {unknown} auditRefsJson
   * @param {string} pluginName
   * @return {Array<LH.Config.AuditRefJson>}
   */
  static _parseAuditRefsList(auditRefsJson, pluginName) {
    if (!isArrayOfUnknownObjects(auditRefsJson)) {
      throw new Error(`${pluginName} has no valid auditsRefs.`);
    }

    return auditRefsJson.map(auditRefJson => {
      const {id, weight, group, ...invalidRest} = auditRefJson;
      assertNoExcessProperties(invalidRest, pluginName, 'auditRef');

      if (typeof id !== 'string') {
        throw new Error(`${pluginName} has an invalid auditRef id.`);
      }
      if (typeof weight !== 'number') {
        throw new Error(`${pluginName} has an invalid auditRef weight.`);
      }
      if (typeof group !== 'string' && typeof group !== 'undefined') {
        throw new Error(`${pluginName} has an invalid auditRef group.`);
      }

      const prependedGroup = group ? `${pluginName}-${group}` : group;
      return {
        id,
        weight,
        group: prependedGroup,
      };
    });
  }

  /**
   * Extract and validate the category added by the plugin.
   * @param {unknown} categoryJson
   * @param {string} pluginName
   * @return {LH.Config.CategoryJson}
   */
  static _parseCategory(categoryJson, pluginName) {
    if (!isObjectOfUnknownProperties(categoryJson)) {
      throw new Error(`${pluginName} has no valid category.`);
    }

    const {
      title,
      description,
      manualDescription,
      auditRefs: auditRefsJson,
      ...invalidRest
    } = categoryJson;

    assertNoExcessProperties(invalidRest, pluginName, 'category');

    if (!i18n.isStringOrIcuMessage(title)) {
      throw new Error(`${pluginName} has an invalid category tile.`);
    }
    if (!i18n.isStringOrIcuMessage(description) && description !== undefined) {
      throw new Error(`${pluginName} has an invalid category description.`);
    }
    if (!i18n.isStringOrIcuMessage(manualDescription) && manualDescription !== undefined) {
      throw new Error(`${pluginName} has an invalid category manualDescription.`);
    }
    const auditRefs = ConfigPlugin._parseAuditRefsList(auditRefsJson, pluginName);

    return {
      title,
      auditRefs,
      description: description,
      manualDescription: manualDescription,
    };
  }


  /**
   * Extract and validate groups JSON added by the plugin.
   * @param {unknown} groupsJson
   * @param {string} pluginName
   * @return {Record<string, LH.Config.GroupJson>|undefined}
   */
  static _parseGroups(groupsJson, pluginName) {
    if (groupsJson === undefined) {
      return undefined;
    }

    if (!isObjectOfUnknownProperties(groupsJson)) {
      throw new Error(`${pluginName} groups json is not defined as an object.`);
    }

    const groups = Object.entries(groupsJson);

    /** @type {Record<string, LH.Config.GroupJson>} */
    const parsedGroupsJson = {};
    groups.forEach(([groupId, groupJson]) => {
      if (!isObjectOfUnknownProperties(groupJson)) {
        throw new Error(`${pluginName} has a group not defined as an object.`);
      }
      const {title, description, ...invalidRest} = groupJson;
      assertNoExcessProperties(invalidRest, pluginName, 'group');

      if (!i18n.isStringOrIcuMessage(title)) {
        throw new Error(`${pluginName} has an invalid group title.`);
      }
      if (!i18n.isStringOrIcuMessage(description) && description !== undefined) {
        throw new Error(`${pluginName} has an invalid group description.`);
      }
      parsedGroupsJson[`${pluginName}-${groupId}`] = {
        title,
        description,
      };
    });
    return parsedGroupsJson;
  }

  /**
   * Extracts and validates a ConfigJson from the provided plugin input, throwing
   * if it deviates from the expected object shape.
   * @param {unknown} pluginJson
   * @param {string} pluginName
   * @return {LH.Config.Json}
   */
  static parsePlugin(pluginJson, pluginName) {
    // Clone to prevent modifications of original and to deactivate any live properties.
    pluginJson = JSON.parse(JSON.stringify(pluginJson));
    if (!isObjectOfUnknownProperties(pluginJson)) {
      throw new Error(`${pluginName} is not defined as an object.`);
    }

    const {
      audits: pluginAuditsJson,
      category: pluginCategoryJson,
      groups: pluginGroupsJson,
      ...invalidRest
    } = pluginJson;

    assertNoExcessProperties(invalidRest, pluginName);

    return {
      audits: ConfigPlugin._parseAuditsList(pluginAuditsJson, pluginName),
      categories: {
        [pluginName]: ConfigPlugin._parseCategory(pluginCategoryJson, pluginName),
      },
      groups: ConfigPlugin._parseGroups(pluginGroupsJson, pluginName),
    };
  }
}

module.exports = ConfigPlugin;

},{"../lib/i18n/i18n.js":96}],55:[function(require,module,exports){
(function (global,__dirname){(function (){
/**
 * @license Copyright 2016 The Lighthouse Authors. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.
 */
'use strict';

const defaultConfigPath = './default-config.js';
const defaultConfig = require('./default-config.js');
const constants = require('./constants.js');
const i18n = require('./../lib/i18n/i18n.js');

const log = require('lighthouse-logger');
const path = require('path');
const Runner = require('../runner.js');
const ConfigPlugin = require('./config-plugin.js');
const {
  mergeConfigFragment,
  resolveSettings,
  resolveAuditsToDefns,
  resolveGathererToDefn,
  resolveModulePath,
  deepClone,
  deepCloneConfigJson,
} = require('./config-helpers.js');

/** @typedef {typeof import('../gather/gatherers/gatherer.js')} GathererConstructor */
/** @typedef {InstanceType<GathererConstructor>} Gatherer */

/**
 * Define with object literal so that tsc will require it to stay updated.
 * @type {Record<keyof LH.BaseArtifacts, ''>}
 */
const BASE_ARTIFACT_BLANKS = {
  fetchTime: '',
  LighthouseRunWarnings: '',
  HostFormFactor: '',
  HostUserAgent: '',
  NetworkUserAgent: '',
  BenchmarkIndex: '',
  WebAppManifest: '',
  InstallabilityErrors: '',
  Stacks: '',
  traces: '',
  devtoolsLogs: '',
  settings: '',
  URL: '',
  Timing: '',
  PageLoadError: '',
};
const BASE_ARTIFACT_NAMES = Object.keys(BASE_ARTIFACT_BLANKS);

/**
 * @param {Config['passes']} passes
 * @param {Config['audits']} audits
 */
function assertValidPasses(passes, audits) {
  if (!Array.isArray(passes)) {
    return;
  }

  const requestedGatherers = Config.getGatherersRequestedByAudits(audits);
  // Base artifacts are provided by GatherRunner, so start foundGatherers with them.
  const foundGatherers = new Set(BASE_ARTIFACT_NAMES);

  // Log if we are running gathers that are not needed by the audits listed in the config
  passes.forEach((pass, passIndex) => {
    if (passIndex === 0 && pass.loadFailureMode !== 'fatal') {
      log.warn(`"${pass.passName}" is the first pass but was marked as non-fatal. ` +
        `The first pass will always be treated as loadFailureMode=fatal.`);
      pass.loadFailureMode = 'fatal';
    }

    pass.gatherers.forEach(gathererDefn => {
      const gatherer = gathererDefn.instance;
      foundGatherers.add(gatherer.name);
      const isGatherRequiredByAudits = requestedGatherers.has(gatherer.name);
      if (!isGatherRequiredByAudits) {
        const msg = `${gatherer.name} gatherer requested, however no audit requires it.`;
        log.warn('config', msg);
      }
    });
  });

  // All required gatherers must be found in the config. Throw otherwise.
  for (const auditDefn of audits || []) {
    const auditMeta = auditDefn.implementation.meta;
    for (const requiredArtifact of auditMeta.requiredArtifacts) {
      if (!foundGatherers.has(requiredArtifact)) {
        throw new Error(`${requiredArtifact} gatherer, required by audit ${auditMeta.id}, ` +
            'was not found in config.');
      }
    }
  }

  // Passes must have unique `passName`s. Throw otherwise.
  const usedNames = new Set();
  passes.forEach(pass => {
    const passName = pass.passName;
    if (usedNames.has(passName)) {
      throw new Error(`Passes must have unique names (repeated passName: ${passName}.`);
    }
    usedNames.add(passName);
  });
}

/**
 * @param {Config['categories']} categories
 * @param {Config['audits']} audits
 * @param {Config['groups']} groups
 */
function assertValidCategories(categories, audits, groups) {
  if (!categories) {
    return;
  }

  /** @type {Map<string, LH.Config.AuditDefn>} */
  const auditsKeyedById = new Map((audits || []).map(audit => {
    return [audit.implementation.meta.id, audit];
  }));

  Object.keys(categories).forEach(categoryId => {
    categories[categoryId].auditRefs.forEach((auditRef, index) => {
      if (!auditRef.id) {
        throw new Error(`missing an audit id at ${categoryId}[${index}]`);
      }

      const audit = auditsKeyedById.get(auditRef.id);
      if (!audit) {
        throw new Error(`could not find ${auditRef.id} audit for category ${categoryId}`);
      }

      const auditImpl = audit.implementation;
      const isManual = auditImpl.meta.scoreDisplayMode === 'manual';
      if (categoryId === 'accessibility' && !auditRef.group && !isManual) {
        throw new Error(`${auditRef.id} accessibility audit does not have a group`);
      }

      if (auditRef.weight > 0 && isManual) {
        throw new Error(`${auditRef.id} is manual but has a positive weight`);
      }

      if (auditRef.group && (!groups || !groups[auditRef.group])) {
        throw new Error(`${auditRef.id} references unknown group ${auditRef.group}`);
      }
    });
  });
}

/**
 * @param {Gatherer} gathererInstance
 * @param {string=} gathererName
 */
function assertValidGatherer(gathererInstance, gathererName) {
  gathererName = gathererName || gathererInstance.name || 'gatherer';

  if (typeof gathererInstance.beforePass !== 'function') {
    throw new Error(`${gathererName} has no beforePass() method.`);
  }

  if (typeof gathererInstance.pass !== 'function') {
    throw new Error(`${gathererName} has no pass() method.`);
  }

  if (typeof gathererInstance.afterPass !== 'function') {
    throw new Error(`${gathererName} has no afterPass() method.`);
  }
}


/**
 * Validate the LH.Flags
 * @param {LH.Flags} flags
 */
function assertValidFlags(flags) {
  // COMPAT: compatibility layer for devtools as it uses the old way and we need tests to pass
  // TODO(paulirish): remove this from LH once emulation refactor has rolled into DevTools
  // @ts-expect-error Deprecated flag
  if (flags.channel === 'devtools' && flags.internalDisableDeviceScreenEmulation) {
    // @ts-expect-error Deprecated flag
    flags.formFactor = flags.emulatedFormFactor;
    // @ts-expect-error Deprecated flag
    flags.emulatedFormFactor = flags.internalDisableDeviceScreenEmulation = undefined;
  }


  // @ts-expect-error Checking for removed flags
  if (flags.emulatedFormFactor || flags.internalDisableDeviceScreenEmulation) {
    throw new Error('Invalid emulation flag. Emulation configuration changed in LH 7.0. See https://github.com/GoogleChrome/lighthouse/blob/master/docs/emulation.md');
  }
}

/**
 * Throws if pluginName is invalid or (somehow) collides with a category in the
 * configJSON being added to.
 * @param {LH.Config.Json} configJSON
 * @param {string} pluginName
 */
function assertValidPluginName(configJSON, pluginName) {
  if (!pluginName.startsWith('lighthouse-plugin-')) {
    throw new Error(`plugin name '${pluginName}' does not start with 'lighthouse-plugin-'`);
  }

  if (configJSON.categories && configJSON.categories[pluginName]) {
    throw new Error(`plugin name '${pluginName}' not allowed because it is the id of a category already found in config`); // eslint-disable-line max-len
  }
}


/**
 * @implements {LH.Config.Config}
 */
class Config {
  /**
   * @constructor
   * @param {LH.Config.Json=} configJSON
   * @param {LH.Flags=} flags
   */
  constructor(configJSON, flags) {
    const status = {msg: 'Create config', id: 'lh:init:config'};
    log.time(status, 'verbose');
    let configPath = flags && flags.configPath;

    if (!configJSON) {
      configJSON = defaultConfig;
      configPath = path.resolve(__dirname, defaultConfigPath);
    }

    if (configPath && !path.isAbsolute(configPath)) {
      throw new Error('configPath must be an absolute path.');
    }

    // We don't want to mutate the original config object
    configJSON = deepCloneConfigJson(configJSON);

    // Extend the default config if specified
    if (configJSON.extends) {
      if (configJSON.extends !== 'lighthouse:default') {
        throw new Error('`lighthouse:default` is the only valid extension method.');
      }
      configJSON = Config.extendConfigJSON(deepCloneConfigJson(defaultConfig), configJSON);
    }

    // The directory of the config path, if one was provided.
    const configDir = configPath ? path.dirname(configPath) : undefined;

    // Validate and merge in plugins (if any).
    configJSON = Config.mergePlugins(configJSON, flags, configDir);

    if (flags) {
      assertValidFlags(flags);
    }
    const settings = resolveSettings(configJSON.settings || {}, flags);

    // Augment passes with necessary defaults and require gatherers.
    const passesWithDefaults = Config.augmentPassesWithDefaults(configJSON.passes);
    Config.adjustDefaultPassForThrottling(settings, passesWithDefaults);
    const passes = Config.requireGatherers(passesWithDefaults, configDir);

    /** @type {LH.Config.Settings} */
    this.settings = settings;
    /** @type {?Array<LH.Config.Pass>} */
    this.passes = passes;
    /** @type {?Array<LH.Config.AuditDefn>} */
    this.audits = Config.requireAudits(configJSON.audits, configDir);
    /** @type {?Record<string, LH.Config.Category>} */
    this.categories = configJSON.categories || null;
    /** @type {?Record<string, LH.Config.Group>} */
    this.groups = configJSON.groups || null;

    Config.filterConfigIfNeeded(this);

    assertValidPasses(this.passes, this.audits);
    assertValidCategories(this.categories, this.audits, this.groups);

    log.timeEnd(status);
  }

  /**
   * Provides a cleaned-up, stringified version of this config. Gatherer and
   * Audit `implementation` and `instance` do not survive this process.
   * @return {string}
   */
  getPrintString() {
    const jsonConfig = deepClone(this);

    if (jsonConfig.passes) {
      for (const pass of jsonConfig.passes) {
        for (const gathererDefn of pass.gatherers) {
          gathererDefn.implementation = undefined;
          // @ts-expect-error Breaking the Config.GathererDefn type.
          gathererDefn.instance = undefined;
        }
      }
    }

    if (jsonConfig.audits) {
      for (const auditDefn of jsonConfig.audits) {
        // @ts-expect-error Breaking the Config.AuditDefn type.
        auditDefn.implementation = undefined;
        if (Object.keys(auditDefn.options).length === 0) {
          // @ts-expect-error Breaking the Config.AuditDefn type.
          auditDefn.options = undefined;
        }
      }
    }

    // Printed config is more useful with localized strings.
    i18n.replaceIcuMessages(jsonConfig, jsonConfig.settings.locale);

    return JSON.stringify(jsonConfig, null, 2);
  }

  /**
   * @param {LH.Config.Json} baseJSON The JSON of the configuration to extend
   * @param {LH.Config.Json} extendJSON The JSON of the extensions
   * @return {LH.Config.Json}
   */
  static extendConfigJSON(baseJSON, extendJSON) {
    if (extendJSON.passes && baseJSON.passes) {
      for (const pass of extendJSON.passes) {
        // use the default pass name if one is not specified
        const passName = pass.passName || constants.defaultPassConfig.passName;
        const basePass = baseJSON.passes.find(candidate => candidate.passName === passName);

        if (!basePass) {
          baseJSON.passes.push(pass);
        } else {
          mergeConfigFragment(basePass, pass);
        }
      }

      delete extendJSON.passes;
    }

    return mergeConfigFragment(baseJSON, extendJSON);
  }

  /**
   * @param {LH.Config.Json} configJSON
   * @param {LH.Flags=} flags
   * @param {string=} configDir
   * @return {LH.Config.Json}
   */
  static mergePlugins(configJSON, flags, configDir) {
    const configPlugins = configJSON.plugins || [];
    const flagPlugins = (flags && flags.plugins) || [];
    const pluginNames = new Set([...configPlugins, ...flagPlugins]);

    for (const pluginName of pluginNames) {
      assertValidPluginName(configJSON, pluginName);

      // TODO: refactor and delete `global.isDevtools`.
      const pluginPath = global.isDevtools || global.isLightrider ?
        pluginName :
        resolveModulePath(pluginName, configDir, 'plugin');
      const rawPluginJson = require(pluginPath);
      const pluginJson = ConfigPlugin.parsePlugin(rawPluginJson, pluginName);

      configJSON = Config.extendConfigJSON(configJSON, pluginJson);
    }

    return configJSON;
  }

  /**
   * @param {LH.Config.Json['passes']} passes
   * @return {?Array<Required<LH.Config.PassJson>>}
   */
  static augmentPassesWithDefaults(passes) {
    if (!passes) {
      return null;
    }

    const {defaultPassConfig} = constants;
    return passes.map(pass => mergeConfigFragment(deepClone(defaultPassConfig), pass));
  }

  /**
   * Observed throttling methods (devtools/provided) require at least 5s of quiet for the metrics to
   * be computed. This method adjusts the quiet thresholds to the required minimums if necessary.
   * @param {LH.Config.Settings} settings
   * @param {?Array<Required<LH.Config.PassJson>>} passes
   */
  static adjustDefaultPassForThrottling(settings, passes) {
    if (!passes ||
        (settings.throttlingMethod !== 'devtools' && settings.throttlingMethod !== 'provided')) {
      return;
    }

    const defaultPass = passes.find(pass => pass.passName === 'defaultPass');
    if (!defaultPass) return;
    const overrides = constants.nonSimulatedPassConfigOverrides;
    defaultPass.pauseAfterFcpMs =
      Math.max(overrides.pauseAfterFcpMs, defaultPass.pauseAfterFcpMs);
    defaultPass.pauseAfterLoadMs =
      Math.max(overrides.pauseAfterLoadMs, defaultPass.pauseAfterLoadMs);
    defaultPass.cpuQuietThresholdMs =
      Math.max(overrides.cpuQuietThresholdMs, defaultPass.cpuQuietThresholdMs);
    defaultPass.networkQuietThresholdMs =
      Math.max(overrides.networkQuietThresholdMs, defaultPass.networkQuietThresholdMs);
  }

  /**
   * Filter out any unrequested items from the config, based on requested categories or audits.
   * @param {Config} config
   */
  static filterConfigIfNeeded(config) {
    const settings = config.settings;
    if (!settings.onlyCategories && !settings.onlyAudits && !settings.skipAudits) {
      return;
    }

    // 1. Filter to just the chosen categories/audits
    const {categories, requestedAuditNames} = Config.filterCategoriesAndAudits(config.categories,
      settings);

    // 2. Resolve which audits will need to run
    const audits = config.audits && config.audits.filter(auditDefn =>
        requestedAuditNames.has(auditDefn.implementation.meta.id));

    // 3. Resolve which gatherers will need to run
    const requestedGathererIds = Config.getGatherersRequestedByAudits(audits);

    // 4. Filter to only the neccessary passes
    const passes = Config.generatePassesNeededByGatherers(config.passes, requestedGathererIds);

    config.categories = categories;
    config.audits = audits;
    config.passes = passes;
  }

  /**
   * Filter out any unrequested categories or audits from the categories object.
   * @param {Config['categories']} oldCategories
   * @param {LH.Config.Settings} settings
   * @return {{categories: Config['categories'], requestedAuditNames: Set<string>}}
   */
  static filterCategoriesAndAudits(oldCategories, settings) {
    if (!oldCategories) {
      return {categories: null, requestedAuditNames: new Set()};
    }

    if (settings.onlyAudits && settings.skipAudits) {
      throw new Error('Cannot set both skipAudits and onlyAudits');
    }

    /** @type {NonNullable<Config['categories']>} */
    const categories = {};
    const filterByIncludedCategory = !!settings.onlyCategories;
    const filterByIncludedAudit = !!settings.onlyAudits;
    const categoryIds = settings.onlyCategories || [];
    const auditIds = settings.onlyAudits || [];
    const skipAuditIds = settings.skipAudits || [];

    // warn if the category is not found
    categoryIds.forEach(categoryId => {
      if (!oldCategories[categoryId]) {
        log.warn('config', `unrecognized category in 'onlyCategories': ${categoryId}`);
      }
    });

    // warn if the audit is not found in a category or there are overlaps
    const auditsToValidate = new Set(auditIds.concat(skipAuditIds));
    for (const auditId of auditsToValidate) {
      const foundCategory = Object.keys(oldCategories).find(categoryId => {
        const auditRefs = oldCategories[categoryId].auditRefs;
        return !!auditRefs.find(candidate => candidate.id === auditId);
      });

      if (!foundCategory) {
        const parentKeyName = skipAuditIds.includes(auditId) ? 'skipAudits' : 'onlyAudits';
        log.warn('config', `unrecognized audit in '${parentKeyName}': ${auditId}`);
      } else if (auditIds.includes(auditId) && categoryIds.includes(foundCategory)) {
        log.warn('config', `${auditId} in 'onlyAudits' is already included by ` +
            `${foundCategory} in 'onlyCategories'`);
      }
    }

    const includedAudits = new Set(auditIds);
    skipAuditIds.forEach(id => includedAudits.delete(id));

    Object.keys(oldCategories).forEach(categoryId => {
      const category = deepClone(oldCategories[categoryId]);

      if (filterByIncludedCategory && filterByIncludedAudit) {
        // If we're filtering by category and audit, include the union of the two
        if (!categoryIds.includes(categoryId)) {
          category.auditRefs = category.auditRefs.filter(audit => auditIds.includes(audit.id));
        }
      } else if (filterByIncludedCategory) {
        // If we're filtering by just category, and the category is not included, skip it
        if (!categoryIds.includes(categoryId)) {
          return;
        }
      } else if (filterByIncludedAudit) {
        category.auditRefs = category.auditRefs.filter(audit => auditIds.includes(audit.id));
      }

      // always filter based on skipAuditIds
      category.auditRefs = category.auditRefs.filter(audit => !skipAuditIds.includes(audit.id));

      if (category.auditRefs.length) {
        categories[categoryId] = category;
        category.auditRefs.forEach(audit => includedAudits.add(audit.id));
      }
    });

    // The `full-page-screenshot` audit belongs to no category, but we still want to include
    // it (unless explictly excluded) because there are audits in every category that can use it.
    if (settings.onlyCategories) {
      const explicitlyExcludesFullPageScreenshot =
        settings.skipAudits && settings.skipAudits.includes('full-page-screenshot');
      if (!explicitlyExcludesFullPageScreenshot) {
        includedAudits.add('full-page-screenshot');
      }
    }

    return {categories, requestedAuditNames: includedAudits};
  }

  /**
   * From some requested audits, return names of all required and optional artifacts
   * @param {Config['audits']} audits
   * @return {Set<string>}
   */
  static getGatherersRequestedByAudits(audits) {
    // It's possible we weren't given any audits (but existing audit results), in which case
    // there is no need to do any work here.
    if (!audits) {
      return new Set();
    }

    const gatherers = new Set();
    for (const auditDefn of audits) {
      const {requiredArtifacts, __internalOptionalArtifacts} = auditDefn.implementation.meta;
      requiredArtifacts.forEach(artifact => gatherers.add(artifact));
      if (__internalOptionalArtifacts) {
        __internalOptionalArtifacts.forEach(artifact => gatherers.add(artifact));
      }
    }
    return gatherers;
  }

  /**
   * Filters to only requested passes and gatherers, returning a new passes array.
   * @param {Config['passes']} passes
   * @param {Set<string>} requestedGatherers
   * @return {Config['passes']}
   */
  static generatePassesNeededByGatherers(passes, requestedGatherers) {
    if (!passes) {
      return null;
    }

    const auditsNeedTrace = requestedGatherers.has('traces');
    const filteredPasses = passes.map(pass => {
      // remove any unncessary gatherers from within the passes
      pass.gatherers = pass.gatherers.filter(gathererDefn => {
        const gatherer = gathererDefn.instance;
        return requestedGatherers.has(gatherer.name);
      });

      // disable the trace if no audit requires a trace
      if (pass.recordTrace && !auditsNeedTrace) {
        const passName = pass.passName || 'unknown pass';
        log.warn('config', `Trace not requested by an audit, dropping trace in ${passName}`);
        pass.recordTrace = false;
      }

      return pass;
    }).filter(pass => {
      // remove any passes lacking concrete gatherers, unless they are dependent on the trace
      if (pass.recordTrace) return true;
      // Always keep defaultPass
      if (pass.passName === 'defaultPass') return true;
      return pass.gatherers.length > 0;
    });
    return filteredPasses;
  }

  /**
   * Take an array of audits and audit paths and require any paths (possibly
   * relative to the optional `configDir`) using `resolveModulePath`,
   * leaving only an array of AuditDefns.
   * @param {LH.Config.Json['audits']} audits
   * @param {string=} configDir
   * @return {Config['audits']}
   */
  static requireAudits(audits, configDir) {
    const status = {msg: 'Requiring audits', id: 'lh:config:requireAudits'};
    log.time(status, 'verbose');
    const auditDefns = resolveAuditsToDefns(audits, configDir);
    log.timeEnd(status);
    return auditDefns;
  }

  /**
   * Takes an array of passes with every property now initialized except the
   * gatherers and requires them, (relative to the optional `configDir` if
   * provided) using `resolveModulePath`, returning an array of full Passes.
   * @param {?Array<Required<LH.Config.PassJson>>} passes
   * @param {string=} configDir
   * @return {Config['passes']}
   */
  static requireGatherers(passes, configDir) {
    if (!passes) {
      return null;
    }
    const status = {msg: 'Requiring gatherers', id: 'lh:config:requireGatherers'};
    log.time(status, 'verbose');

    const coreList = Runner.getGathererList();
    const fullPasses = passes.map(pass => {
      const gathererDefns = pass.gatherers
        .map(gatherer => resolveGathererToDefn(gatherer, coreList, configDir));

      // De-dupe gatherers by artifact name because artifact IDs must be unique at runtime.
      const uniqueDefns = Array.from(
        new Map(gathererDefns.map(defn => [defn.instance.name, defn])).values()
      );
      uniqueDefns.forEach(gatherer => assertValidGatherer(gatherer.instance, gatherer.path));

      return Object.assign(pass, {gatherers: uniqueDefns});
    });
    log.timeEnd(status);
    return fullPasses;
  }
}

module.exports = Config;

}).call(this)}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},"/lighthouse-core/config")
},{"../runner.js":122,"./../lib/i18n/i18n.js":96,"./config-helpers.js":53,"./config-plugin.js":54,"./constants.js":56,"./default-config.js":57,"lighthouse-logger":188,"path":222}],56:[function(require,module,exports){
/**
 * @license Copyright 2018 The Lighthouse Authors. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.
 */
'use strict';

/**
 * Adjustments needed for DevTools network throttling to simulate
 * more realistic network conditions.
 * @see https://crbug.com/721112
 * @see https://docs.google.com/document/d/10lfVdS1iDWCRKQXPfbxEn4Or99D64mvNlugP1AQuFlE/edit
 */
const DEVTOOLS_RTT_ADJUSTMENT_FACTOR = 3.75;
const DEVTOOLS_THROUGHPUT_ADJUSTMENT_FACTOR = 0.9;

const throttling = {
  DEVTOOLS_RTT_ADJUSTMENT_FACTOR,
  DEVTOOLS_THROUGHPUT_ADJUSTMENT_FACTOR,
  // These values align with WebPageTest's definition of "Fast 3G"
  // But offer similar charateristics to roughly the 75th percentile of 4G connections.
  mobileSlow4G: {
    rttMs: 150,
    throughputKbps: 1.6 * 1024,
    requestLatencyMs: 150 * DEVTOOLS_RTT_ADJUSTMENT_FACTOR,
    downloadThroughputKbps: 1.6 * 1024 * DEVTOOLS_THROUGHPUT_ADJUSTMENT_FACTOR,
    uploadThroughputKbps: 750 * DEVTOOLS_THROUGHPUT_ADJUSTMENT_FACTOR,
    cpuSlowdownMultiplier: 4,
  },
  // These values partially align with WebPageTest's definition of "Regular 3G".
  // These values are meant to roughly align with Chrome UX report's 3G definition which are based
  // on HTTP RTT of 300-1400ms and downlink throughput of <700kbps.
  mobileRegular3G: {
    rttMs: 300,
    throughputKbps: 700,
    requestLatencyMs: 300 * DEVTOOLS_RTT_ADJUSTMENT_FACTOR,
    downloadThroughputKbps: 700 * DEVTOOLS_THROUGHPUT_ADJUSTMENT_FACTOR,
    uploadThroughputKbps: 700 * DEVTOOLS_THROUGHPUT_ADJUSTMENT_FACTOR,
    cpuSlowdownMultiplier: 4,
  },
  // Using a "broadband" connection type
  // Corresponds to "Dense 4G 25th percentile" in https://docs.google.com/document/d/1Ft1Bnq9-t4jK5egLSOc28IL4TvR-Tt0se_1faTA4KTY/edit#heading=h.bb7nfy2x9e5v
  desktopDense4G: {
    rttMs: 40,
    throughputKbps: 10 * 1024,
    cpuSlowdownMultiplier: 1,
    requestLatencyMs: 0, // 0 means unset
    downloadThroughputKbps: 0,
    uploadThroughputKbps: 0,
  },
};

/**
 * @type {Required<LH.SharedFlagsSettings['screenEmulation']>}
 */
const MOTOG4_EMULATION_METRICS = {
  mobile: true,
  width: 360,
  height: 640,
  // Moto G4 is really 3, but a higher value here works against
  // our perf recommendations.
  // https://github.com/GoogleChrome/lighthouse/issues/10741#issuecomment-626903508
  deviceScaleFactor: 2.625,
  disabled: false,
};

/**
 * Desktop metrics adapted from emulated_devices/module.json
 * @type {Required<LH.SharedFlagsSettings['screenEmulation']>}
 */
const DESKTOP_EMULATION_METRICS = {
  mobile: false,
  width: 1350,
  height: 940,
  deviceScaleFactor: 1,
  disabled: false,
};

const screenEmulationMetrics = {
  mobile: MOTOG4_EMULATION_METRICS,
  desktop: DESKTOP_EMULATION_METRICS,
};

// eslint-disable-next-line max-len
const MOTOG4_USERAGENT = 'Mozilla/5.0 (Linux; Android 7.0; Moto G (4)) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/90.0.4420.0 Mobile Safari/537.36 Chrome-Lighthouse';
// eslint-disable-next-line max-len
const DESKTOP_USERAGENT = 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_6) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/90.0.4420.0 Safari/537.36 Chrome-Lighthouse';

const userAgents = {
  mobile: MOTOG4_USERAGENT,
  desktop: DESKTOP_USERAGENT,
};

/** @type {LH.Config.Settings} */
const defaultSettings = {
  output: 'json',
  maxWaitForFcp: 30 * 1000,
  maxWaitForLoad: 45 * 1000,

  formFactor: 'mobile',
  throttling: throttling.mobileSlow4G,
  throttlingMethod: 'simulate',
  screenEmulation: screenEmulationMetrics.mobile,
  emulatedUserAgent: userAgents.mobile,

  auditMode: false,
  gatherMode: false,
  disableStorageReset: false,
  channel: 'node',

  // the following settings have no defaults but we still want ensure that `key in settings`
  // in config will work in a typechecked way
  budgets: null,
  locale: 'en-US', // actual default determined by Config using lib/i18n
  blockedUrlPatterns: null,
  additionalTraceCategories: null,
  extraHeaders: null,
  precomputedLanternData: null,
  onlyAudits: null,
  onlyCategories: null,
  skipAudits: null,
};

/** @type {LH.Config.Pass} */
const defaultPassConfig = {
  passName: 'defaultPass',
  loadFailureMode: 'fatal',
  recordTrace: false,
  useThrottling: false,
  pauseAfterFcpMs: 0,
  pauseAfterLoadMs: 0,
  networkQuietThresholdMs: 0,
  cpuQuietThresholdMs: 0,
  blockedUrlPatterns: [],
  blankPage: 'about:blank',
  gatherers: [],
};

/** @type {Required<LH.Config.NavigationJson>} */
const defaultNavigationConfig = {
  id: 'default',
  loadFailureMode: 'fatal',
  disableThrottling: false,
  disableStorageReset: false,
  pauseAfterFcpMs: 0,
  pauseAfterLoadMs: 0,
  networkQuietThresholdMs: 0,
  cpuQuietThresholdMs: 0,
  blockedUrlPatterns: [],
  blankPage: 'about:blank',
  artifacts: [],
};

const nonSimulatedPassConfigOverrides = {
  pauseAfterFcpMs: 5250,
  pauseAfterLoadMs: 5250,
  networkQuietThresholdMs: 5250,
  cpuQuietThresholdMs: 5250,
};

module.exports = {
  throttling,
  screenEmulationMetrics,
  userAgents,
  defaultSettings,
  defaultPassConfig,
  defaultNavigationConfig,
  nonSimulatedPassConfigOverrides,
};

},{}],57:[function(require,module,exports){
(function (__filename){(function (){
/**
 * @license Copyright 2018 The Lighthouse Authors. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.
 */
'use strict';

/* eslint-disable max-len */

const constants = require('./constants.js');
const i18n = require('../lib/i18n/i18n.js');
const m2a = require('./metrics-to-audits.js');

const UIStrings = {
  /** Title of the Performance category of audits. Equivalent to 'Web performance', this term is inclusive of all web page speed and loading optimization topics. Also used as a label of a score gauge; try to limit to 20 characters. */
  performanceCategoryTitle: 'Performance',
  /** Title of the Budgets section of the Performance Category. 'Budgets' refers to a budget (like a financial budget), but applied to the amount of resources on a page, rather than money. */
  budgetsGroupTitle: 'Budgets',
  /** Description of the Budgets section of the Performance category. Within this section the budget results are displayed. */
  budgetsGroupDescription: 'Performance budgets set standards for the performance of your site.',
  /** Title of the speed metrics section of the Performance category. Within this section are various speed metrics which quantify the pageload performance into values presented in seconds and milliseconds. */
  metricGroupTitle: 'Metrics',
  /** Title of the opportunity section of the Performance category. Within this section are audits with imperative titles that suggest actions the user can take to improve the loading performance of their web page. 'Suggestion'/'Optimization'/'Recommendation' are reasonable synonyms for 'opportunity' in this case. */
  loadOpportunitiesGroupTitle: 'Opportunities',
  /** Description of the opportunity section of the Performance category. 'Suggestions' could also be 'recommendations'. Within this section are audits with imperative titles that suggest actions the user can take to improve the loading performance of their web page. */
  loadOpportunitiesGroupDescription: 'These suggestions can help your page load faster. They don\'t [directly affect](https://web.dev/performance-scoring/) the Performance score.',
  /** Title of an opportunity sub-section of the Performance category. Within this section are audits with imperative titles that suggest actions the user can take to improve the time of the first initial render of the webpage. */
  firstPaintImprovementsGroupTitle: 'First Paint Improvements',
  /** Description of an opportunity sub-section of the Performance category. Within this section are audits with imperative titles that suggest actions the user can take to improve the time of the first initial render of the webpage. */
  firstPaintImprovementsGroupDescription: 'The most critical aspect of performance is how quickly pixels are rendered onscreen. Key metrics: First Contentful Paint, First Meaningful Paint',
  /** Title of an opportunity sub-section of the Performance category. Within this section are audits with imperative titles that suggest actions the user can take to improve the overall loading performance of their web page. */
  overallImprovementsGroupTitle: 'Overall Improvements',
  /** Description of an opportunity sub-section of the Performance category. Within this section are audits with imperative titles that suggest actions the user can take to improve the overall loading performance of their web page. */
  overallImprovementsGroupDescription: 'Enhance the overall loading experience, so the page is responsive and ready to use as soon as possible. Key metrics: Time to Interactive, Speed Index',
  /** Title of the diagnostics section of the Performance category. Within this section are audits with non-imperative titles that provide more detail on the page's page load performance characteristics. Whereas the 'Opportunities' suggest an action along with expected time savings, diagnostics do not. Within this section, the user may read the details and deduce additional actions they could take. */
  diagnosticsGroupTitle: 'Diagnostics',
  /** Description of the diagnostics section of the Performance category. Within this section are audits with non-imperative titles that provide more detail on a web page's load performance characteristics. Within this section, the user may read the details and deduce additional actions they could take to improve performance. */
  diagnosticsGroupDescription: 'More information about the performance of your application. These numbers don\'t [directly affect](https://web.dev/performance-scoring/) the Performance score.',
  /** Title of the Accessibility category of audits. This section contains audits focused on making web content accessible to all users. Also used as a label of a score gauge; try to limit to 20 characters. */
  a11yCategoryTitle: 'Accessibility',
  /** Description of the Accessibility category. This is displayed at the top of a list of audits focused on making web content accessible to all users. No character length limits. 'improve the accessibility of your web app' becomes link text to additional documentation. */
  a11yCategoryDescription: 'These checks highlight opportunities to [improve the accessibility of your web app](https://developers.google.com/web/fundamentals/accessibility). Only a subset of accessibility issues can be automatically detected so manual testing is also encouraged.',
  /** Description of the Accessibility manual checks category. This description is displayed above a list of accessibility audits that currently have no automated test and so must be verified manually by the user. No character length limits. 'conducting an accessibility review' becomes link text to additional documentation. */
  a11yCategoryManualDescription: 'These items address areas which an automated testing tool cannot cover. Learn more in our guide on [conducting an accessibility review](https://developers.google.com/web/fundamentals/accessibility/how-to-review).',
  /** Title of the best practices section of the Accessibility category. Within this section are audits with descriptive titles that highlight common accessibility best practices. */
  a11yBestPracticesGroupTitle: 'Best practices',
  /** Description of the best practices section within the Accessibility category. Within this section are audits with descriptive titles that highlight common accessibility best practices. */
  a11yBestPracticesGroupDescription: 'These items highlight common accessibility best practices.',
  /** Title of the color contrast section within the Accessibility category. Within this section are audits with descriptive titles that highlight the color and vision aspects of the page's accessibility that are passing or failing. */
  a11yColorContrastGroupTitle: 'Contrast',
  /** Description of the color contrast section within the Accessibility category. Within this section are audits with descriptive titles that highlight the color and vision aspects of the page's accessibility that are passing or failing. */
  a11yColorContrastGroupDescription: 'These are opportunities to improve the legibility of your content.',
  /** Title of the HTML element naming section within the Accessibility category. Within this section are audits with descriptive titles that highlight if the non-textual HTML elements on the page have names discernible by a screen reader. */
  a11yNamesLabelsGroupTitle: 'Names and labels',
  /** Description of the HTML element naming section within the Accessibility category. Within this section are audits with descriptive titles that highlight if the non-textual HTML elements on the page have names discernible by a screen reader. */
  a11yNamesLabelsGroupDescription: 'These are opportunities to improve the semantics of the controls in your application. This may enhance the experience for users of assistive technology, like a screen reader.',
  /** Title of the navigation section within the Accessibility category. Within this section are audits with descriptive titles that highlight opportunities to improve keyboard navigation. */
  a11yNavigationGroupTitle: 'Navigation',
  /** Description of the navigation section within the Accessibility category. Within this section are audits with descriptive titles that highlight opportunities to improve keyboard navigation. */
  a11yNavigationGroupDescription: 'These are opportunities to improve keyboard navigation in your application.',
  /** Title of the ARIA validity section within the Accessibility category. Within this section are audits with descriptive titles that highlight if whether all the aria-* HTML attributes have been used properly. */
  a11yAriaGroupTitle: 'ARIA',
  /** Description of the ARIA validity section within the Accessibility category. Within this section are audits with descriptive titles that highlight if whether all the aria-* HTML attributes have been used properly. */
  a11yAriaGroupDescription: 'These are opportunities to improve the usage of ARIA in your application which may enhance the experience for users of assistive technology, like a screen reader.',
  /** Title of the language section within the Accessibility category. Within this section are audits with descriptive titles that highlight if the language has been annotated in the correct HTML attributes on the page. */
  a11yLanguageGroupTitle: 'Internationalization and localization',
  /** Description of the language section within the Accessibility category. Within this section are audits with descriptive titles that highlight if the language has been annotated in the correct HTML attributes on the page. */
  a11yLanguageGroupDescription: 'These are opportunities to improve the interpretation of your content by users in different locales.',
  /** Title of the navigation section within the Accessibility category. Within this section are audits with descriptive titles that highlight opportunities to provide alternative content for audio and video. */
  a11yAudioVideoGroupTitle: 'Audio and video',
  /** Description of the navigation section within the Accessibility category. Within this section are audits with descriptive titles that highlight opportunities to provide alternative content for audio and video. */
  a11yAudioVideoGroupDescription: 'These are opportunities to provide alternative content for audio and video. This may improve the experience for users with hearing or vision impairments.',
  /** Title of the navigation section within the Accessibility category. Within this section are audits with descriptive titles that highlight opportunities to improve the experience of reading tabular or list data using assistive technology. */
  a11yTablesListsVideoGroupTitle: 'Tables and lists',
  /** Description of the navigation section within the Accessibility category. Within this section are audits with descriptive titles that highlight opportunities to improve the experience of reading tabular or list data using assistive technology. */
  a11yTablesListsVideoGroupDescription: 'These are opportunities to improve the experience of reading tabular or list data using assistive technology, like a screen reader.',
  /** Title of the Search Engine Optimization (SEO) category of audits. This is displayed at the top of a list of audits focused on topics related to optimizing a website for indexing by search engines. Also used as a label of a score gauge; try to limit to 20 characters. */
  seoCategoryTitle: 'SEO',
  /** Description of the Search Engine Optimization (SEO) category. This is displayed at the top of a list of audits focused on optimizing a website for indexing by search engines. No character length limits. 'Learn More' becomes link text to additional documentation. */
  seoCategoryDescription: 'These checks ensure that your page is optimized for search engine results ranking. ' +
  'There are additional factors Lighthouse does not check that may affect your search ranking. ' +
  '[Learn more](https://support.google.com/webmasters/answer/35769).',
  /** Description of the Search Engine Optimization (SEO) manual checks category, the additional validators must be run by hand in order to check all SEO best practices. This is displayed at the top of a list of manually run audits focused on optimizing a website for indexing by search engines. No character length limits. */
  seoCategoryManualDescription: 'Run these additional validators on your site to check additional SEO best practices.',
  /** Title of the navigation section within the Search Engine Optimization (SEO) category. Within this section are audits with descriptive titles that highlight opportunities to make a page more usable on mobile devices. */
  seoMobileGroupTitle: 'Mobile Friendly',
  /** Description of the navigation section within the Search Engine Optimization (SEO) category. Within this section are audits with descriptive titles that highlight opportunities to make a page more usable on mobile devices. */
  seoMobileGroupDescription: 'Make sure your pages are mobile friendly so users don’t have to pinch or zoom ' +
  'in order to read the content pages. [Learn more](https://developers.google.com/search/mobile-sites/).',
  /** Title of the navigation section within the Search Engine Optimization (SEO) category. Within this section are audits with descriptive titles that highlight ways to make a website content more easily understood by search engine crawler bots. */
  seoContentGroupTitle: 'Content Best Practices',
  /** Description of the navigation section within the Search Engine Optimization (SEO) category. Within this section are audits with descriptive titles that highlight ways to make a website content more easily understood by search engine crawler bots. */
  seoContentGroupDescription: 'Format your HTML in a way that enables crawlers to better understand your app’s content.',
  /** Title of the navigation section within the Search Engine Optimization (SEO) category. Within this section are audits with descriptive titles that highlight ways to make a website accessible to search engine crawlers. */
  seoCrawlingGroupTitle: 'Crawling and Indexing',
  /** Description of the navigation section within the Search Engine Optimization (SEO) category. Within this section are audits with descriptive titles that highlight ways to make a website accessible to search engine crawlers. */
  seoCrawlingGroupDescription: 'To appear in search results, crawlers need access to your app.',
  /** Title of the Progressive Web Application (PWA) category of audits. This is displayed at the top of a list of audits focused on topics related to whether or not a site is a progressive web app, e.g. responds offline, uses a service worker, is on https, etc. Also used as a label of a score gauge. */
  pwaCategoryTitle: 'Progressive Web App',
  /** Description of the Progressive Web Application (PWA) category. This is displayed at the top of a list of audits focused on topics related to whether or not a site is a progressive web app, e.g. responds offline, uses a service worker, is on https, etc. No character length limits. 'Learn More' becomes link text to additional documentation. */
  pwaCategoryDescription: 'These checks validate the aspects of a Progressive Web App. ' +
  '[Learn more](https://developers.google.com/web/progressive-web-apps/checklist).',
  /** Description of the Progressive Web Application (PWA) manual checks category, containing a list of additional validators must be run by hand in order to check all PWA best practices. This is displayed at the top of a list of manually run audits focused on topics related to whether or not a site is a progressive web app, e.g. responds offline, uses a service worker, is on https, etc.. No character length limits. */
  pwaCategoryManualDescription: 'These checks are required by the baseline ' +
  '[PWA Checklist](https://developers.google.com/web/progressive-web-apps/checklist) but are ' +
  'not automatically checked by Lighthouse. They do not affect your score but it\'s important that you verify them manually.',
  /** Title of the Best Practices category of audits. This is displayed at the top of a list of audits focused on topics related to following web development best practices and accepted guidelines. Also used as a label of a score gauge; try to limit to 20 characters. */
  bestPracticesCategoryTitle: 'Best Practices',
  /** Title of the Trust & Safety group of audits. This is displayed at the top of a list of audits focused on maintaining user trust and protecting security in web development. */
  bestPracticesTrustSafetyGroupTitle: 'Trust and Safety',
  /** Title of the User Experience group of the Best Practices category. Within this section are the audits related to the end user's experience of the webpage. */
  bestPracticesUXGroupTitle: 'User Experience',
  /** Title of the Browser Compatibility group of the Best Practices category. Within this section are the audits related to whether the page is interpreted consistently by browsers. */
  bestPracticesBrowserCompatGroupTitle: 'Browser Compatibility',
  /** Title of the General group of the Best Practices category. Within this section are the audits that don't belong to a specific group but are of general interest. */
  bestPracticesGeneralGroupTitle: 'General',
  /** Title of the Installable section of the web app category. Within this section are audits that check if Chrome supports installing the web site as an app on their device. */
  pwaInstallableGroupTitle: 'Installable',
  /** Title of the "PWA Optimized" section of the web app category. Within this section are audits that check if the developer has taken advantage of features to make their web page more enjoyable and engaging for the user. */
  pwaOptimizedGroupTitle: 'PWA Optimized',
};

const str_ = i18n.createMessageInstanceIdFn(__filename, UIStrings);

/** @type {LH.Config.Json} */
const defaultConfig = {
  settings: constants.defaultSettings,
  passes: [{
    passName: 'defaultPass',
    recordTrace: true,
    useThrottling: true,
    pauseAfterFcpMs: 1000,
    pauseAfterLoadMs: 1000,
    networkQuietThresholdMs: 1000,
    cpuQuietThresholdMs: 1000,
    gatherers: [
      'css-usage',
      'js-usage',
      'viewport-dimensions',
      'console-messages',
      'anchor-elements',
      'image-elements',
      'link-elements',
      'meta-elements',
      'script-elements',
      'iframe-elements',
      'form-elements',
      'main-document-content',
      'gather-context',
      'global-listeners',
      'dobetterweb/appcache',
      'dobetterweb/doctype',
      'dobetterweb/domstats',
      'dobetterweb/optimized-images',
      'dobetterweb/password-inputs-with-prevented-paste',
      'dobetterweb/response-compression',
      'dobetterweb/tags-blocking-first-paint',
      'seo/font-size',
      'seo/embedded-content',
      'seo/robots-txt',
      'seo/tap-targets',
      'accessibility',
      'trace-elements',
      'inspector-issues',
      'source-maps',
      'full-page-screenshot',
    ],
  },
  {
    passName: 'offlinePass',
    loadFailureMode: 'ignore',
    gatherers: [
      'service-worker',
    ],
  },
  {
    passName: 'redirectPass',
    loadFailureMode: 'warn',
    // Speed up the redirect pass by blocking stylesheets, fonts, and images
    blockedUrlPatterns: ['*.css', '*.jpg', '*.jpeg', '*.png', '*.gif', '*.svg', '*.ttf', '*.woff', '*.woff2'],
    gatherers: [
      'http-redirect',
    ],
  }],
  audits: [
    'is-on-https',
    'redirects-http',
    'service-worker',
    'viewport',
    'metrics/first-contentful-paint',
    'metrics/largest-contentful-paint',
    'metrics/first-meaningful-paint',
    'metrics/speed-index',
    'screenshot-thumbnails',
    'final-screenshot',
    'metrics/total-blocking-time',
    'metrics/max-potential-fid',
    'metrics/cumulative-layout-shift',
    'errors-in-console',
    'server-response-time',
    'metrics/interactive',
    'user-timings',
    'critical-request-chains',
    'redirects',
    'installable-manifest',
    'apple-touch-icon',
    'splash-screen',
    'themed-omnibox',
    'maskable-icon',
    'content-width',
    'image-aspect-ratio',
    'image-size-responsive',
    'preload-fonts',
    'deprecations',
    'mainthread-work-breakdown',
    'bootup-time',
    'uses-rel-preload',
    'uses-rel-preconnect',
    'font-display',
    'diagnostics',
    'network-requests',
    'network-rtt',
    'network-server-latency',
    'main-thread-tasks',
    'metrics',
    'performance-budget',
    'timing-budget',
    'resource-summary',
    'third-party-summary',
    'third-party-facades',
    'largest-contentful-paint-element',
    'layout-shift-elements',
    'long-tasks',
    'no-unload-listeners',
    'non-composited-animations',
    'unsized-images',
    'valid-source-maps',
    'preload-lcp-image',
    'csp-xss',
    'full-page-screenshot',
    'script-treemap-data',
    'manual/pwa-cross-browser',
    'manual/pwa-page-transitions',
    'manual/pwa-each-page-has-url',
    'accessibility/accesskeys',
    'accessibility/aria-allowed-attr',
    'accessibility/aria-command-name',
    'accessibility/aria-hidden-body',
    'accessibility/aria-hidden-focus',
    'accessibility/aria-input-field-name',
    'accessibility/aria-meter-name',
    'accessibility/aria-progressbar-name',
    'accessibility/aria-required-attr',
    'accessibility/aria-required-children',
    'accessibility/aria-required-parent',
    'accessibility/aria-roles',
    'accessibility/aria-toggle-field-name',
    'accessibility/aria-tooltip-name',
    'accessibility/aria-treeitem-name',
    'accessibility/aria-valid-attr-value',
    'accessibility/aria-valid-attr',
    'accessibility/button-name',
    'accessibility/bypass',
    'accessibility/color-contrast',
    'accessibility/definition-list',
    'accessibility/dlitem',
    'accessibility/document-title',
    'accessibility/duplicate-id-active',
    'accessibility/duplicate-id-aria',
    'accessibility/form-field-multiple-labels',
    'accessibility/frame-title',
    'accessibility/heading-order',
    'accessibility/html-has-lang',
    'accessibility/html-lang-valid',
    'accessibility/image-alt',
    'accessibility/input-image-alt',
    'accessibility/label',
    'accessibility/link-name',
    'accessibility/list',
    'accessibility/listitem',
    'accessibility/meta-refresh',
    'accessibility/meta-viewport',
    'accessibility/object-alt',
    'accessibility/tabindex',
    'accessibility/td-headers-attr',
    'accessibility/th-has-data-cells',
    'accessibility/valid-lang',
    'accessibility/video-caption',
    'accessibility/manual/custom-controls-labels',
    'accessibility/manual/custom-controls-roles',
    'accessibility/manual/focus-traps',
    'accessibility/manual/focusable-controls',
    'accessibility/manual/interactive-element-affordance',
    'accessibility/manual/logical-tab-order',
    'accessibility/manual/managed-focus',
    'accessibility/manual/offscreen-content-hidden',
    'accessibility/manual/use-landmarks',
    'accessibility/manual/visual-order-follows-dom',
    'byte-efficiency/uses-long-cache-ttl',
    'byte-efficiency/total-byte-weight',
    'byte-efficiency/offscreen-images',
    'byte-efficiency/render-blocking-resources',
    'byte-efficiency/unminified-css',
    'byte-efficiency/unminified-javascript',
    'byte-efficiency/unused-css-rules',
    'byte-efficiency/unused-javascript',
    'byte-efficiency/modern-image-formats',
    'byte-efficiency/uses-optimized-images',
    'byte-efficiency/uses-text-compression',
    'byte-efficiency/uses-responsive-images',
    'byte-efficiency/efficient-animated-content',
    'byte-efficiency/duplicated-javascript',
    'byte-efficiency/legacy-javascript',
    'dobetterweb/appcache-manifest',
    'dobetterweb/doctype',
    'dobetterweb/charset',
    'dobetterweb/dom-size',
    'dobetterweb/external-anchors-use-rel-noopener',
    'dobetterweb/geolocation-on-start',
    'dobetterweb/inspector-issues',
    'dobetterweb/no-document-write',
    'dobetterweb/no-vulnerable-libraries',
    'dobetterweb/js-libraries',
    'dobetterweb/notification-on-start',
    'dobetterweb/password-inputs-can-be-pasted-into',
    'dobetterweb/uses-http2',
    'dobetterweb/uses-passive-event-listeners',
    'seo/meta-description',
    'seo/http-status-code',
    'seo/font-size',
    'seo/link-text',
    'seo/crawlable-anchors',
    'seo/is-crawlable',
    'seo/robots-txt',
    'seo/tap-targets',
    'seo/hreflang',
    'seo/plugins',
    'seo/canonical',
    'seo/manual/structured-data',
  ],

  groups: {
    'metrics': {
      title: str_(UIStrings.metricGroupTitle),
    },
    'load-opportunities': {
      title: str_(UIStrings.loadOpportunitiesGroupTitle),
      description: str_(UIStrings.loadOpportunitiesGroupDescription),
    },
    'budgets': {
      title: str_(UIStrings.budgetsGroupTitle),
      description: str_(UIStrings.budgetsGroupDescription),
    },
    'diagnostics': {
      title: str_(UIStrings.diagnosticsGroupTitle),
      description: str_(UIStrings.diagnosticsGroupDescription),
    },
    'pwa-installable': {
      title: str_(UIStrings.pwaInstallableGroupTitle),
    },
    'pwa-optimized': {
      title: str_(UIStrings.pwaOptimizedGroupTitle),
    },
    'a11y-best-practices': {
      title: str_(UIStrings.a11yBestPracticesGroupTitle),
      description: str_(UIStrings.a11yBestPracticesGroupDescription),
    },
    'a11y-color-contrast': {
      title: str_(UIStrings.a11yColorContrastGroupTitle),
      description: str_(UIStrings.a11yColorContrastGroupDescription),
    },
    'a11y-names-labels': {
      title: str_(UIStrings.a11yNamesLabelsGroupTitle),
      description: str_(UIStrings.a11yNamesLabelsGroupDescription),
    },
    'a11y-navigation': {
      title: str_(UIStrings.a11yNavigationGroupTitle),
      description: str_(UIStrings.a11yNavigationGroupDescription),
    },
    'a11y-aria': {
      title: str_(UIStrings.a11yAriaGroupTitle),
      description: str_(UIStrings.a11yAriaGroupDescription),
    },
    'a11y-language': {
      title: str_(UIStrings.a11yLanguageGroupTitle),
      description: str_(UIStrings.a11yLanguageGroupDescription),
    },
    'a11y-audio-video': {
      title: str_(UIStrings.a11yAudioVideoGroupTitle),
      description: str_(UIStrings.a11yAudioVideoGroupDescription),
    },
    'a11y-tables-lists': {
      title: str_(UIStrings.a11yTablesListsVideoGroupTitle),
      description: str_(UIStrings.a11yTablesListsVideoGroupDescription),
    },
    'seo-mobile': {
      title: str_(UIStrings.seoMobileGroupTitle),
      description: str_(UIStrings.seoMobileGroupDescription),
    },
    'seo-content': {
      title: str_(UIStrings.seoContentGroupTitle),
      description: str_(UIStrings.seoContentGroupDescription),
    },
    'seo-crawl': {
      title: str_(UIStrings.seoCrawlingGroupTitle),
      description: str_(UIStrings.seoCrawlingGroupDescription),
    },
    'best-practices-trust-safety': {
      title: str_(UIStrings.bestPracticesTrustSafetyGroupTitle),
    },
    'best-practices-ux': {
      title: str_(UIStrings.bestPracticesUXGroupTitle),
    },
    'best-practices-browser-compat': {
      title: str_(UIStrings.bestPracticesBrowserCompatGroupTitle),
    },
    'best-practices-general': {
      title: str_(UIStrings.bestPracticesGeneralGroupTitle),
    },
  },
  categories: {
    'performance': {
      title: str_(UIStrings.performanceCategoryTitle),
      auditRefs: [
        {id: 'first-contentful-paint', weight: 10, group: 'metrics', acronym: 'FCP', relevantAudits: m2a.fcpRelevantAudits},
        {id: 'speed-index', weight: 10, group: 'metrics', acronym: 'SI'},
        {id: 'largest-contentful-paint', weight: 25, group: 'metrics', acronym: 'LCP', relevantAudits: m2a.lcpRelevantAudits},
        {id: 'interactive', weight: 10, group: 'metrics', acronym: 'TTI'},
        {id: 'total-blocking-time', weight: 30, group: 'metrics', acronym: 'TBT', relevantAudits: m2a.tbtRelevantAudits},
        {id: 'cumulative-layout-shift', weight: 15, group: 'metrics', acronym: 'CLS', relevantAudits: m2a.clsRelevantAudits},

        // These are our "invisible" metrics. Not displayed, but still in the LHR
        {id: 'max-potential-fid', weight: 0},
        {id: 'first-meaningful-paint', weight: 0, acronym: 'FMP'},

        {id: 'render-blocking-resources', weight: 0, group: 'load-opportunities'},
        {id: 'uses-responsive-images', weight: 0, group: 'load-opportunities'},
        {id: 'offscreen-images', weight: 0, group: 'load-opportunities'},
        {id: 'unminified-css', weight: 0, group: 'load-opportunities'},
        {id: 'unminified-javascript', weight: 0, group: 'load-opportunities'},
        {id: 'unused-css-rules', weight: 0, group: 'load-opportunities'},
        {id: 'unused-javascript', weight: 0, group: 'load-opportunities'},
        {id: 'uses-optimized-images', weight: 0, group: 'load-opportunities'},
        {id: 'modern-image-formats', weight: 0, group: 'load-opportunities'},
        {id: 'uses-text-compression', weight: 0, group: 'load-opportunities'},
        {id: 'uses-rel-preconnect', weight: 0, group: 'load-opportunities'},
        {id: 'server-response-time', weight: 0, group: 'load-opportunities'},
        {id: 'redirects', weight: 0, group: 'load-opportunities'},
        {id: 'uses-rel-preload', weight: 0, group: 'load-opportunities'},
        {id: 'uses-http2', weight: 0, group: 'load-opportunities'},
        {id: 'efficient-animated-content', weight: 0, group: 'load-opportunities'},
        {id: 'duplicated-javascript', weight: 0, group: 'load-opportunities'},
        {id: 'legacy-javascript', weight: 0, group: 'load-opportunities'},
        {id: 'preload-lcp-image', weight: 0, group: 'load-opportunities'},
        {id: 'total-byte-weight', weight: 0, group: 'diagnostics'},
        {id: 'uses-long-cache-ttl', weight: 0, group: 'diagnostics'},
        {id: 'dom-size', weight: 0, group: 'diagnostics'},
        {id: 'critical-request-chains', weight: 0, group: 'diagnostics'},
        {id: 'user-timings', weight: 0, group: 'diagnostics'},
        {id: 'bootup-time', weight: 0, group: 'diagnostics'},
        {id: 'mainthread-work-breakdown', weight: 0, group: 'diagnostics'},
        {id: 'font-display', weight: 0, group: 'diagnostics'},
        {id: 'performance-budget', weight: 0, group: 'budgets'},
        {id: 'timing-budget', weight: 0, group: 'budgets'},
        {id: 'resource-summary', weight: 0, group: 'diagnostics'},
        {id: 'third-party-summary', weight: 0, group: 'diagnostics'},
        {id: 'third-party-facades', weight: 0, group: 'diagnostics'},
        {id: 'largest-contentful-paint-element', weight: 0, group: 'diagnostics'},
        {id: 'layout-shift-elements', weight: 0, group: 'diagnostics'},
        {id: 'uses-passive-event-listeners', weight: 0, group: 'diagnostics'},
        {id: 'no-document-write', weight: 0, group: 'diagnostics'},
        {id: 'long-tasks', weight: 0, group: 'diagnostics'},
        {id: 'non-composited-animations', weight: 0, group: 'diagnostics'},
        {id: 'unsized-images', weight: 0, group: 'diagnostics'},
        // Audits past this point don't belong to a group and will not be shown automatically
        {id: 'network-requests', weight: 0},
        {id: 'network-rtt', weight: 0},
        {id: 'network-server-latency', weight: 0},
        {id: 'main-thread-tasks', weight: 0},
        {id: 'diagnostics', weight: 0},
        {id: 'metrics', weight: 0},
        {id: 'screenshot-thumbnails', weight: 0},
        {id: 'final-screenshot', weight: 0},
        {id: 'script-treemap-data', weight: 0},
      ],
    },
    'accessibility': {
      title: str_(UIStrings.a11yCategoryTitle),
      description: str_(UIStrings.a11yCategoryDescription),
      manualDescription: str_(UIStrings.a11yCategoryManualDescription),
      // Audit weights are meant to match the aXe scoring system of
      // minor, moderate, serious, and critical.
      // See the audits listed at dequeuniversity.com/rules/axe/4.1.
      // Click on an audit and check the right hand column to see its severity.
      auditRefs: [
        {id: 'accesskeys', weight: 3, group: 'a11y-navigation'},
        {id: 'aria-allowed-attr', weight: 10, group: 'a11y-aria'},
        {id: 'aria-command-name', weight: 3, group: 'a11y-aria'},
        {id: 'aria-hidden-body', weight: 10, group: 'a11y-aria'},
        {id: 'aria-hidden-focus', weight: 3, group: 'a11y-aria'},
        {id: 'aria-input-field-name', weight: 3, group: 'a11y-aria'},
        {id: 'aria-meter-name', weight: 3, group: 'a11y-aria'},
        {id: 'aria-progressbar-name', weight: 3, group: 'a11y-aria'},
        {id: 'aria-required-attr', weight: 10, group: 'a11y-aria'},
        {id: 'aria-required-children', weight: 10, group: 'a11y-aria'},
        {id: 'aria-required-parent', weight: 10, group: 'a11y-aria'},
        {id: 'aria-roles', weight: 10, group: 'a11y-aria'},
        {id: 'aria-toggle-field-name', weight: 3, group: 'a11y-aria'},
        {id: 'aria-tooltip-name', weight: 3, group: 'a11y-aria'},
        {id: 'aria-treeitem-name', weight: 3, group: 'a11y-aria'},
        {id: 'aria-valid-attr-value', weight: 10, group: 'a11y-aria'},
        {id: 'aria-valid-attr', weight: 10, group: 'a11y-aria'},
        {id: 'button-name', weight: 10, group: 'a11y-names-labels'},
        {id: 'bypass', weight: 3, group: 'a11y-navigation'},
        {id: 'color-contrast', weight: 3, group: 'a11y-color-contrast'},
        {id: 'definition-list', weight: 3, group: 'a11y-tables-lists'},
        {id: 'dlitem', weight: 3, group: 'a11y-tables-lists'},
        {id: 'document-title', weight: 3, group: 'a11y-names-labels'},
        {id: 'duplicate-id-active', weight: 3, group: 'a11y-navigation'},
        {id: 'duplicate-id-aria', weight: 10, group: 'a11y-aria'},
        {id: 'form-field-multiple-labels', weight: 2, group: 'a11y-names-labels'},
        {id: 'frame-title', weight: 3, group: 'a11y-names-labels'},
        {id: 'heading-order', weight: 2, group: 'a11y-navigation'},
        {id: 'html-has-lang', weight: 3, group: 'a11y-language'},
        {id: 'html-lang-valid', weight: 3, group: 'a11y-language'},
        {id: 'image-alt', weight: 10, group: 'a11y-names-labels'},
        {id: 'input-image-alt', weight: 10, group: 'a11y-names-labels'},
        {id: 'label', weight: 10, group: 'a11y-names-labels'},
        {id: 'link-name', weight: 3, group: 'a11y-names-labels'},
        {id: 'list', weight: 3, group: 'a11y-tables-lists'},
        {id: 'listitem', weight: 3, group: 'a11y-tables-lists'},
        {id: 'meta-refresh', weight: 10, group: 'a11y-best-practices'},
        {id: 'meta-viewport', weight: 10, group: 'a11y-best-practices'},
        {id: 'object-alt', weight: 3, group: 'a11y-names-labels'},
        {id: 'tabindex', weight: 3, group: 'a11y-navigation'},
        {id: 'td-headers-attr', weight: 3, group: 'a11y-tables-lists'},
        {id: 'th-has-data-cells', weight: 3, group: 'a11y-tables-lists'},
        {id: 'valid-lang', weight: 3, group: 'a11y-language'},
        {id: 'video-caption', weight: 10, group: 'a11y-audio-video'},
        // Manual audits
        {id: 'logical-tab-order', weight: 0},
        {id: 'focusable-controls', weight: 0},
        {id: 'interactive-element-affordance', weight: 0},
        {id: 'managed-focus', weight: 0},
        {id: 'focus-traps', weight: 0},
        {id: 'custom-controls-labels', weight: 0},
        {id: 'custom-controls-roles', weight: 0},
        {id: 'visual-order-follows-dom', weight: 0},
        {id: 'offscreen-content-hidden', weight: 0},
        {id: 'use-landmarks', weight: 0},
      ],
    },
    'best-practices': {
      title: str_(UIStrings.bestPracticesCategoryTitle),
      auditRefs: [
        // Trust & Safety
        {id: 'is-on-https', weight: 1, group: 'best-practices-trust-safety'},
        {id: 'external-anchors-use-rel-noopener', weight: 1, group: 'best-practices-trust-safety'},
        {id: 'geolocation-on-start', weight: 1, group: 'best-practices-trust-safety'},
        {id: 'notification-on-start', weight: 1, group: 'best-practices-trust-safety'},
        {id: 'no-vulnerable-libraries', weight: 1, group: 'best-practices-trust-safety'},
        {id: 'csp-xss', weight: 0, group: 'best-practices-trust-safety'},
        // User Experience
        {id: 'password-inputs-can-be-pasted-into', weight: 1, group: 'best-practices-ux'},
        {id: 'image-aspect-ratio', weight: 1, group: 'best-practices-ux'},
        {id: 'image-size-responsive', weight: 1, group: 'best-practices-ux'},
        {id: 'preload-fonts', weight: 1, group: 'best-practices-ux'},
        // Browser Compatibility
        {id: 'doctype', weight: 1, group: 'best-practices-browser-compat'},
        {id: 'charset', weight: 1, group: 'best-practices-browser-compat'},
        // General Group
        {id: 'no-unload-listeners', weight: 1, group: 'best-practices-general'},
        {id: 'appcache-manifest', weight: 1, group: 'best-practices-general'},
        {id: 'js-libraries', weight: 0, group: 'best-practices-general'},
        {id: 'deprecations', weight: 1, group: 'best-practices-general'},
        {id: 'errors-in-console', weight: 1, group: 'best-practices-general'},
        {id: 'valid-source-maps', weight: 0, group: 'best-practices-general'},
        {id: 'inspector-issues', weight: 1, group: 'best-practices-general'},
      ],
    },
    'seo': {
      title: str_(UIStrings.seoCategoryTitle),
      description: str_(UIStrings.seoCategoryDescription),
      manualDescription: str_(UIStrings.seoCategoryManualDescription),
      auditRefs: [
        {id: 'viewport', weight: 1, group: 'seo-mobile'},
        {id: 'document-title', weight: 1, group: 'seo-content'},
        {id: 'meta-description', weight: 1, group: 'seo-content'},
        {id: 'http-status-code', weight: 1, group: 'seo-crawl'},
        {id: 'link-text', weight: 1, group: 'seo-content'},
        {id: 'crawlable-anchors', weight: 1, group: 'seo-crawl'},
        {id: 'is-crawlable', weight: 1, group: 'seo-crawl'},
        {id: 'robots-txt', weight: 1, group: 'seo-crawl'},
        {id: 'image-alt', weight: 1, group: 'seo-content'},
        {id: 'hreflang', weight: 1, group: 'seo-content'},
        {id: 'canonical', weight: 1, group: 'seo-content'},
        {id: 'font-size', weight: 1, group: 'seo-mobile'},
        {id: 'plugins', weight: 1, group: 'seo-content'},
        {id: 'tap-targets', weight: 1, group: 'seo-mobile'},
        // Manual audits
        {id: 'structured-data', weight: 0},
      ],
    },
    'pwa': {
      title: str_(UIStrings.pwaCategoryTitle),
      description: str_(UIStrings.pwaCategoryDescription),
      manualDescription: str_(UIStrings.pwaCategoryManualDescription),
      auditRefs: [
        // Installable
        {id: 'installable-manifest', weight: 2, group: 'pwa-installable'},
        // PWA Optimized
        {id: 'service-worker', weight: 1, group: 'pwa-optimized'},
        {id: 'redirects-http', weight: 2, group: 'pwa-optimized'},
        {id: 'splash-screen', weight: 1, group: 'pwa-optimized'},
        {id: 'themed-omnibox', weight: 1, group: 'pwa-optimized'},
        {id: 'content-width', weight: 1, group: 'pwa-optimized'},
        {id: 'viewport', weight: 2, group: 'pwa-optimized'},
        {id: 'apple-touch-icon', weight: 1, group: 'pwa-optimized'},
        {id: 'maskable-icon', weight: 1, group: 'pwa-optimized'},
        // Manual audits
        {id: 'pwa-cross-browser', weight: 0},
        {id: 'pwa-page-transitions', weight: 0},
        {id: 'pwa-each-page-has-url', weight: 0},
      ],
    },
  },
};

module.exports = defaultConfig;

// Use `defineProperty` so that the strings are accesible from original but ignored when we copy it
Object.defineProperty(module.exports, 'UIStrings', {
  enumerable: false,
  get: () => UIStrings,
});

}).call(this)}).call(this,"/lighthouse-core/config/default-config.js")
},{"../lib/i18n/i18n.js":96,"./constants.js":56,"./metrics-to-audits.js":58}],58:[function(require,module,exports){
/**
 * @license Copyright 2021 The Lighthouse Authors. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.
 */
'use strict';

// go/lh-audit-metric-mapping
const fcpRelevantAudits = [
  'server-response-time',
  'render-blocking-resources',
  'redirects',
  'critical-request-chains',
  'uses-text-compression',
  'uses-rel-preconnect',
  'uses-rel-preload',
  'font-display',
  'unminified-javascript',
  'unminified-css',
  'unused-css-rules',
];

const lcpRelevantAudits = [
  ...fcpRelevantAudits,
  'largest-contentful-paint-element',
  'preload-lcp-image',
  'unused-javascript',
  'efficient-animated-content',
  'total-byte-weight',
];

const tbtRelevantAudits = [
  'long-tasks',
  'third-party-summary',
  'third-party-facades',
  'bootup-time',
  'mainthread-work-breakdown',
  'dom-size',
  'duplicated-javascript',
  'legacy-javascript',
];

const clsRelevantAudits = [
  'layout-shift-elements',
  'non-composited-animations',
  'unsized-images',
  // 'preload-fonts', // actually in BP, rather than perf
];

module.exports = {
  fcpRelevantAudits,
  lcpRelevantAudits,
  tbtRelevantAudits,
  clsRelevantAudits,
};

},{}],59:[function(require,module,exports){
/**
 * @license Copyright 2021 The Lighthouse Authors. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.
 */
'use strict';

const log = require('lighthouse-logger');
const isEqual = require('lodash.isequal');
const {
  getBenchmarkIndex,
  getEnvironmentWarnings,
} = require('../../gather/driver/environment.js');

/**
 * @param {LH.Config.FRConfig} config
 * @param {LH.Gatherer.FRTransitionalDriver} driver
 * @return {Promise<LH.BaseArtifacts>}
 */
async function getBaseArtifacts(config, driver) {
  const BenchmarkIndex = await getBenchmarkIndex(driver.executionContext);

  return {
    // Meta artifacts.
    fetchTime: new Date().toJSON(),
    Timing: [],
    LighthouseRunWarnings: [],
    settings: config.settings,
    // Environment artifacts that can always be computed.
    BenchmarkIndex,
    // Contextual artifacts whose collection changes based on gather mode.
    URL: {requestedUrl: '', finalUrl: ''},
    PageLoadError: null,
    // Artifacts that have been replaced by regular gatherers in Fraggle Rock.
    HostFormFactor: 'mobile',
    HostUserAgent: '',
    Stacks: [],
    NetworkUserAgent: '',
    WebAppManifest: null,
    InstallabilityErrors: {errors: []},
    traces: {},
    devtoolsLogs: {},
  };
}

/**
 * Deduplicates identical warnings.
 * @param {Array<string | LH.IcuMessage>} warnings
 * @return {Array<string | LH.IcuMessage>}
 */
function deduplicateWarnings(warnings) {
  /** @type {Array<string | LH.IcuMessage>} */
  const unique = [];

  for (const warning of warnings) {
    if (unique.some(existing => isEqual(warning, existing))) continue;
    unique.push(warning);
  }

  return unique;
}

/**
 * @param {LH.FRBaseArtifacts} baseArtifacts
 * @param {Partial<LH.Artifacts>} gathererArtifacts
 * @return {LH.Artifacts}
 */
function finalizeArtifacts(baseArtifacts, gathererArtifacts) {
  const warnings = baseArtifacts.LighthouseRunWarnings
    .concat(gathererArtifacts.LighthouseRunWarnings || [])
    .concat(getEnvironmentWarnings({settings: baseArtifacts.settings, baseArtifacts}));

  // Cast to remove the partial from gathererArtifacts.
  const artifacts = /** @type {LH.Artifacts} */ ({...baseArtifacts, ...gathererArtifacts});

  // Set the post-run meta artifacts.
  artifacts.Timing = log.getTimeEntries();
  artifacts.LighthouseRunWarnings = deduplicateWarnings(warnings);

  // Check that the runner remembered to mutate the special-case URL artifact.
  if (!artifacts.URL.requestedUrl) throw new Error('Runner did not set requestedUrl');
  if (!artifacts.URL.finalUrl) throw new Error('Runner did not set finalUrl');

  return artifacts;
}

module.exports = {
  getBaseArtifacts,
  finalizeArtifacts,
};

},{"../../gather/driver/environment.js":66,"lighthouse-logger":188,"lodash.isequal":217}],60:[function(require,module,exports){
/**
 * @license Copyright 2021 The Lighthouse Authors. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.
 */
'use strict';

/* eslint-disable no-unused-vars */

/**
 * Base class for all gatherers supporting both Fraggle Rock and the legacy flow.
 * Most extending classes should implement the Fraggle Rock API and let this class handle translation.
 * See lighthouse-core/gather/gatherers/gatherer.js for legacy method explanations.
 *
 * @implements {LH.Gatherer.GathererInstance}
 * @implements {LH.Gatherer.FRGathererInstance}
 */
class FRGatherer {
  /** @type {LH.Gatherer.GathererMeta} */
  meta = {supportedModes: []}

  /**
   * Method to start observing a page for an arbitrary period of time.
   * @param {LH.Gatherer.FRTransitionalContext} passContext
   * @return {Promise<void>|void}
   */
  startInstrumentation(passContext) { }

  /**
   * Method to start observing a page when the measurements are very sensitive and
   * should observe as little Lighthouse-induced work as possible.
   * @param {LH.Gatherer.FRTransitionalContext} passContext
   * @return {Promise<void>|void}
   */
  startSensitiveInstrumentation(passContext) { }

  /**
   * Method to stop observing a page when the measurements are very sensitive and
   * should observe as little Lighthouse-induced work as possible.
   *
   * @param {LH.Gatherer.FRTransitionalContext} passContext
   * @return {Promise<void>|void}
   */
  stopSensitiveInstrumentation(passContext) { }

  /**
   * Method to end observing a page after an arbitrary period of time.
   * @param {LH.Gatherer.FRTransitionalContext} passContext
   * @return {Promise<void>|void}
   */
  stopInstrumentation(passContext) { }

  /**
   * Method to gather results about a page.
   * @param {LH.Gatherer.FRTransitionalContext} passContext
   * @return {LH.Gatherer.PhaseResult}
   */
  getArtifact(passContext) { }

  /**
   * Legacy property used to define the artifact ID. In Fraggle Rock, the artifact ID lives on the config.
   * @return {keyof LH.GathererArtifacts}
   */
  get name() {
    // @ts-expect-error - assume that class name has been added to LH.GathererArtifacts.
    return this.constructor.name;
  }

  /**
   * Legacy method. Called before navigation to target url, roughly corresponds to `startInstrumentation`.
   * @param {LH.Gatherer.PassContext} passContext
   * @return {Promise<LH.Gatherer.PhaseResultNonPromise>}
   */
  async beforePass(passContext) {
    await this.startInstrumentation({...passContext, dependencies: {}});
    await this.startSensitiveInstrumentation({...passContext, dependencies: {}});
  }

  /**
   * Legacy method. Should never be used by a Fraggle Rock gatherer, here for compat only.
   * @param {LH.Gatherer.PassContext} passContext
   * @return {LH.Gatherer.PhaseResult}
   */
  pass(passContext) { }

  /**
   * Legacy method. Roughly corresponds to `stopInstrumentation` or `getArtifact` depending on type of gatherer.
   * @param {LH.Gatherer.PassContext} passContext
   * @param {LH.Gatherer.LoadData} loadData
   * @return {Promise<LH.Gatherer.PhaseResultNonPromise>}
   */
  async afterPass(passContext, loadData) {
    if ('dependencies' in this.meta) {
      throw Error('Gatherer with dependencies should override afterPass');
    }
    await this.stopSensitiveInstrumentation({...passContext, dependencies: {}});
    await this.stopInstrumentation({...passContext, dependencies: {}});
    return this.getArtifact({...passContext, dependencies: {}});
  }
}

module.exports = FRGatherer;

},{}],61:[function(require,module,exports){
/**
 * @license Copyright 2016 The Lighthouse Authors. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.
 */
'use strict';

const EventEmitter = require('events').EventEmitter;
const log = require('lighthouse-logger');
const LHError = require('../../lib/lh-error.js');

// TODO(bckenny): CommandCallback properties should be tied by command type after
// https://github.com/Microsoft/TypeScript/pull/22348. See driver.js TODO.
/**
 * @typedef {{'protocolevent': [LH.Protocol.RawEventMessage]}} ProtocolEventRecord
 * @typedef {LH.Protocol.StrictEventEmitter<ProtocolEventRecord>} CrdpEventMessageEmitter
 * @typedef {LH.CrdpCommands[keyof LH.CrdpCommands]} CommandInfo
 * @typedef {{resolve: function(Promise<CommandInfo['returnType']>): void, method: keyof LH.CrdpCommands}} CommandCallback
 */

class Connection {
  constructor() {
    this._lastCommandId = 0;
    /** @type {Map<number, CommandCallback>} */
    this._callbacks = new Map();

    this._eventEmitter = /** @type {?CrdpEventMessageEmitter} */ (new EventEmitter());
  }

  /**
   * @return {Promise<void>}
   */
  connect() {
    return Promise.reject(new Error('Not implemented'));
  }

  /**
   * @return {Promise<void>}
   */
  disconnect() {
    return Promise.reject(new Error('Not implemented'));
  }

  /**
   * @return {Promise<string>}
   */
  wsEndpoint() {
    return Promise.reject(new Error('Not implemented'));
  }

  /**
   * Call protocol methods
   * @template {keyof LH.CrdpCommands} C
   * @param {C} method
   * @param {string|undefined} sessionId
   * @param {LH.CrdpCommands[C]['paramsType']} paramArgs,
   * @return {Promise<LH.CrdpCommands[C]['returnType']>}
   */
  sendCommand(method, sessionId, ...paramArgs) {
    // Reify params since we need it as a property so can't just spread again.
    const params = paramArgs.length ? paramArgs[0] : undefined;

    log.formatProtocol('method => browser', {method, params}, 'verbose');
    const id = ++this._lastCommandId;
    const message = JSON.stringify({id, sessionId, method, params});
    this.sendRawMessage(message);

    return new Promise(resolve => {
      this._callbacks.set(id, {method, resolve});
    });
  }

  /**
   * Bind listeners for connection events.
   * @param {'protocolevent'} eventName
   * @param {function(LH.Protocol.RawEventMessage): void} cb
   */
  on(eventName, cb) {
    if (eventName !== 'protocolevent') {
      throw new Error('Only supports "protocolevent" events');
    }

    if (!this._eventEmitter) {
      throw new Error('Attempted to add event listener after connection disposed.');
    }
    this._eventEmitter.on(eventName, cb);
  }

  /**
   * Unbind listeners for connection events.
   * @param {'protocolevent'} eventName
   * @param {function(LH.Protocol.RawEventMessage): void} cb
   */
  off(eventName, cb) {
    if (eventName !== 'protocolevent') {
      throw new Error('Only supports "protocolevent" events');
    }

    if (!this._eventEmitter) {
      throw new Error('Attempted to remove event listener after connection disposed.');
    }
    this._eventEmitter.removeListener(eventName, cb);
  }

  /* eslint-disable no-unused-vars */

  /**
   * @param {string} message
   * @protected
   */
  sendRawMessage(message) {
    throw new Error('Not implemented');
  }

  /* eslint-enable no-unused-vars */

  /**
   * @param {string} message
   * @return {void}
   * @protected
   */
  handleRawMessage(message) {
    /** @type {LH.Protocol.RawMessage} */
    const object = JSON.parse(message);

    // Responses to commands carry "id" property, while events do not.
    if (!('id' in object)) {
      log.formatProtocol('<= event',
          {method: object.method, params: object.params}, 'verbose');
      this.emitProtocolEvent(object);
      return;
    }

    const callback = this._callbacks.get(object.id);
    if (callback) {
      this._callbacks.delete(object.id);

      callback.resolve(Promise.resolve().then(_ => {
        if (object.error) {
          log.formatProtocol('method <= browser ERR', {method: callback.method}, 'error');
          throw LHError.fromProtocolMessage(callback.method, object.error);
        }

        log.formatProtocol('method <= browser OK',
          {method: callback.method, params: object.result}, 'verbose');
        return object.result;
      }));
    } else {
      // In DevTools we receive responses to commands we did not send which we cannot act on, so we
      // just log these occurrences.
      const error = object.error && object.error.message;
      log.formatProtocol(`disowned method <= browser ${error ? 'ERR' : 'OK'}`,
          {method: 'UNKNOWN', params: error || object.result}, 'verbose');
    }
  }

  /**
   * @param {LH.Protocol.RawEventMessage} eventMessage
   */
  emitProtocolEvent(eventMessage) {
    if (!this._eventEmitter) {
      throw new Error('Attempted to emit event after connection disposed.');
    }

    this._eventEmitter.emit('protocolevent', eventMessage);
  }

  /**
   * @protected
   */
  dispose() {
    if (this._eventEmitter) {
      this._eventEmitter.removeAllListeners();
      this._eventEmitter = null;
    }
  }
}

module.exports = Connection;

},{"../../lib/lh-error.js":103,"events":162,"lighthouse-logger":188}],62:[function(require,module,exports){
/**
 * @license Copyright 2016 The Lighthouse Authors. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.
 */
'use strict';

const Connection = require('./connection.js');

/* eslint-disable no-unused-vars */

/**
 * @typedef {object} Port
 * @property {(eventName: 'message'|'close', cb: ((arg: string) => void) | (() => void)) => void} on
 * @property {(message: string) => void} send
 * @property {() => void} close
 */

/* eslint-enable no-unused-vars */

class RawConnection extends Connection {
  /**
   * @param {Port} port
   */
  constructor(port) {
    super();
    this._port = port;
    this._port.on('message', this.handleRawMessage.bind(this));
    this._port.on('close', this.dispose.bind(this));
  }

  /**
   * @override
   * @return {Promise<void>}
   */
  connect() {
    return Promise.resolve();
  }

  /**
   * @return {Promise<void>}
   */
  disconnect() {
    this._port.close();
    return Promise.resolve();
  }

  /**
   * @override
   * @param {string} message
   * @protected
   */
  sendRawMessage(message) {
    this._port.send(message);
  }
}

module.exports = RawConnection;

},{"./connection.js":61}],63:[function(require,module,exports){
/**
 * @license Copyright 2017 The Lighthouse Authors. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.
 */
'use strict';

/**
 * @fileoverview This class saves all protocol messages whose method match a particular
 *    regex filter. Used when saving assets for later analysis by another tool such as
 *    Webpagetest.
 */
class DevtoolsLog {
  /**
   * @param {RegExp=} regexFilter
   */
  constructor(regexFilter) {
    this._filter = regexFilter;

    /** @type {LH.DevtoolsLog} */
    this._messages = [];
    this._isRecording = false;
  }

  /**
   * @return {LH.DevtoolsLog}
   */
  get messages() {
    return this._messages;
  }

  reset() {
    this._messages = [];
  }

  beginRecording() {
    this._isRecording = true;
  }

  endRecording() {
    this._isRecording = false;
  }

  /**
   * Records a message if method matches filter and recording has been started.
   * @param {LH.Protocol.RawEventMessage} message
   */
  record(message) {
    if (this._isRecording && (!this._filter || this._filter.test(message.method))) {
      this._messages.push(message);
    }
  }
}

module.exports = DevtoolsLog;

},{}],64:[function(require,module,exports){
/**
 * @license Copyright 2016 The Lighthouse Authors. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.
 */
'use strict';

const Fetcher = require('./fetcher.js');
const ExecutionContext = require('./driver/execution-context.js');
const LHError = require('../lib/lh-error.js');
const {fetchResponseBodyFromCache} = require('../gather/driver/network.js');
const EventEmitter = require('events').EventEmitter;

const log = require('lighthouse-logger');
const DevtoolsLog = require('./devtools-log.js');
const TraceGatherer = require('./gatherers/trace.js');

// Pulled in for Connection type checking.
// eslint-disable-next-line no-unused-vars
const Connection = require('./connections/connection.js');
const {getBrowserVersion} = require('./driver/environment.js');

// Controls how long to wait for a response after sending a DevTools protocol command.
const DEFAULT_PROTOCOL_TIMEOUT = 30000;

/**
 * @typedef {LH.Protocol.StrictEventEmitter<LH.CrdpEvents>} CrdpEventEmitter
 */

/**
 * @implements {LH.Gatherer.FRTransitionalDriver}
 */
class Driver {
  /**
   * @pri_vate (This should be private, but that makes our tests harder).
   * An event emitter that enforces mapping between Crdp event names and payload types.
   */
  _eventEmitter = /** @type {CrdpEventEmitter} */ (new EventEmitter());

  /**
   * @private
   * Used to save network and lifecycle protocol traffic. Just Page and Network are needed.
   */
  _devtoolsLog = new DevtoolsLog(/^(Page|Network)\./);

  /**
   * @private
   * @type {Map<string, number>}
   */
  _domainEnabledCounts = new Map();

  /**
   * @type {number}
   * @private
   */
  _nextProtocolTimeout = DEFAULT_PROTOCOL_TIMEOUT;

  online = true;

  // eslint-disable-next-line no-invalid-this
  executionContext = new ExecutionContext(this);

  // eslint-disable-next-line no-invalid-this
  defaultSession = this;

  // eslint-disable-next-line no-invalid-this
  fetcher = new Fetcher(this.defaultSession, this.executionContext);

  /**
   * @param {Connection} connection
   */
  constructor(connection) {
    this._connection = connection;

    this.on('Target.attachedToTarget', event => {
      this._handleTargetAttached(event).catch(this._handleEventError);
    });

    this.on('Page.frameNavigated', event => {
      // We're only interested in setting autoattach on the root via this method.
      // `_handleTargetAttached` takes care of the recursive piece.
      if (event.frame.parentId) return;

      // Enable auto-attaching to subtargets so we receive iframe information.
      this.sendCommand('Target.setAutoAttach', {
        flatten: true,
        autoAttach: true,
        // Pause targets on startup so we don't miss anything
        waitForDebuggerOnStart: true,
      }).catch(this._handleEventError);
    });

    connection.on('protocolevent', this._handleProtocolEvent.bind(this));

    /** @private @deprecated Only available for plugin backcompat. */
    this.evaluate = this.executionContext.evaluate.bind(this.executionContext);
    /** @private @deprecated Only available for plugin backcompat. */
    this.evaluateAsync = this.executionContext.evaluateAsync.bind(this.executionContext);
  }

  /** @deprecated - Not available on Fraggle Rock driver. */
  static get traceCategories() {
    return TraceGatherer.getDefaultTraceCategories();
  }

  /**
   * @return {Promise<LH.Crdp.Browser.GetVersionResponse & {milestone: number}>}
   */
  async getBrowserVersion() {
    return getBrowserVersion(this);
  }

  /**
   * @return {Promise<void>}
   */
  async connect() {
    const status = {msg: 'Connecting to browser', id: 'lh:init:connect'};
    log.time(status);
    await this._connection.connect();
    log.timeEnd(status);
  }

  /**
   * @return {Promise<void>}
   */
  disconnect() {
    return this._connection.disconnect();
  }

  /**
   * Get the browser WebSocket endpoint for devtools protocol clients like Puppeteer.
   * Only works with WebSocket connection, not extension or devtools.
   * @return {Promise<string>}
   */
  wsEndpoint() {
    return this._connection.wsEndpoint();
  }

  /**
   * Bind listeners for protocol events.
   * @template {keyof LH.CrdpEvents} E
   * @param {E} eventName
   * @param {(...args: LH.CrdpEvents[E]) => void} cb
   */
  on(eventName, cb) {
    if (this._eventEmitter === null) {
      throw new Error('connect() must be called before attempting to listen to events.');
    }

    // log event listeners being bound
    log.formatProtocol('listen for event =>', {method: eventName}, 'verbose');
    this._eventEmitter.on(eventName, cb);
  }

  /**
   * Bind a one-time listener for protocol events. Listener is removed once it
   * has been called.
   * @template {keyof LH.CrdpEvents} E
   * @param {E} eventName
   * @param {(...args: LH.CrdpEvents[E]) => void} cb
   */
  once(eventName, cb) {
    if (this._eventEmitter === null) {
      throw new Error('connect() must be called before attempting to listen to events.');
    }
    // log event listeners being bound
    log.formatProtocol('listen once for event =>', {method: eventName}, 'verbose');
    this._eventEmitter.once(eventName, cb);
  }

  /**
   * Unbind event listener.
   * @template {keyof LH.CrdpEvents} E
   * @param {E} eventName
   * @param {Function} cb
   */
  off(eventName, cb) {
    if (this._eventEmitter === null) {
      throw new Error('connect() must be called before attempting to remove an event listener.');
    }

    this._eventEmitter.removeListener(eventName, cb);
  }

  /**
   * Bind to *any* protocol event.
   * @param {(payload: LH.Protocol.RawEventMessage) => void} callback
   */
  addProtocolMessageListener(callback) {
    this._connection.on('protocolevent', callback);
  }

  /**
   * Unbind to *any* protocol event.
   * @param {(payload: LH.Protocol.RawEventMessage) => void} callback
   */
  removeProtocolMessageListener(callback) {
    this._connection.off('protocolevent', callback);
  }

  /**
   * Debounce enabling or disabling domains to prevent driver users from
   * stomping on each other. Maintains an internal count of the times a domain
   * has been enabled. Returns false if the command would have no effect (domain
   * is already enabled or disabled), or if command would interfere with another
   * user of that domain (e.g. two gatherers have enabled a domain, both need to
   * disable it for it to be disabled). Returns true otherwise.
   * @param {string} domain
   * @param {string|undefined} sessionId
   * @param {boolean} enable
   * @return {boolean}
   * @private
   */
  _shouldToggleDomain(domain, sessionId, enable) {
    const key = domain + (sessionId || '');
    const enabledCount = this._domainEnabledCounts.get(key) || 0;
    const newCount = enabledCount + (enable ? 1 : -1);
    this._domainEnabledCounts.set(key, Math.max(0, newCount));

    // Switching to enabled or disabled, respectively.
    if ((enable && newCount === 1) || (!enable && newCount === 0)) {
      log.verbose('Driver', `${domain}.${enable ? 'enable' : 'disable'}`);
      return true;
    } else {
      if (newCount < 0) {
        log.error('Driver', `Attempted to disable domain '${domain}' when already disabled.`);
      }
      return false;
    }
  }

  /**
   * @return {boolean}
   */
  hasNextProtocolTimeout() {
    return this._nextProtocolTimeout !== DEFAULT_PROTOCOL_TIMEOUT;
  }

  /**
   * @return {number}
   */
  getNextProtocolTimeout() {
    return this._nextProtocolTimeout;
  }

  /**
   * timeout is used for the next call to 'sendCommand'.
   * NOTE: This can eventually be replaced when TypeScript
   * resolves https://github.com/Microsoft/TypeScript/issues/5453.
   * @param {number} timeout
   */
  setNextProtocolTimeout(timeout) {
    this._nextProtocolTimeout = timeout;
  }

  /**
   * @param {LH.Protocol.RawEventMessage} event
   */
  _handleProtocolEvent(event) {
    this._devtoolsLog.record(event);

    // @ts-expect-error TODO(bckenny): tsc can't type event.params correctly yet,
    // typing as property of union instead of narrowing from union of
    // properties. See https://github.com/Microsoft/TypeScript/pull/22348.
    this._eventEmitter.emit(event.method, event.params);
  }

  /**
   * @param {Error} error
   */
  _handleEventError(error) {
    log.error('Driver', 'Unhandled event error', error.message);
  }

  /**
   * @param {LH.Crdp.Target.AttachedToTargetEvent} event
   */
  async _handleTargetAttached(event) {
    // We're only interested in network requests from iframes for now as those are "part of the page".
    // If it's not an iframe, just resume it and move on.
    if (event.targetInfo.type !== 'iframe') {
      // We suspended the target when we auto-attached, so make sure it goes back to being normal.
      await this.sendCommandToSession('Runtime.runIfWaitingForDebugger', event.sessionId);
      return;
    }

    // Events from subtargets will be stringified and sent back on `Target.receivedMessageFromTarget`.
    // We want to receive information about network requests from iframes, so enable the Network domain.
    await this.sendCommandToSession('Network.enable', event.sessionId);

    // We also want to receive information about subtargets of subtargets, so make sure we autoattach recursively.
    await this.sendCommandToSession('Target.setAutoAttach', event.sessionId, {
      autoAttach: true,
      flatten: true,
      // Pause targets on startup so we don't miss anything
      waitForDebuggerOnStart: true,
    });

    // We suspended the target when we auto-attached, so make sure it goes back to being normal.
    await this.sendCommandToSession('Runtime.runIfWaitingForDebugger', event.sessionId);
  }

  /**
   * Call protocol methods, with a timeout.
   * To configure the timeout for the next call, use 'setNextProtocolTimeout'.
   * If 'sessionId' is undefined, the message is sent to the main session.
   * @template {keyof LH.CrdpCommands} C
   * @param {C} method
   * @param {string|undefined} sessionId
   * @param {LH.CrdpCommands[C]['paramsType']} params
   * @return {Promise<LH.CrdpCommands[C]['returnType']>}
   */
  sendCommandToSession(method, sessionId, ...params) {
    const timeout = this._nextProtocolTimeout;
    this._nextProtocolTimeout = DEFAULT_PROTOCOL_TIMEOUT;

    /** @type {NodeJS.Timer|undefined} */
    let asyncTimeout;
    const timeoutPromise = new Promise((resolve, reject) => {
      if (timeout === Infinity) return;
      asyncTimeout = setTimeout((() => {
        const err = new LHError(
          LHError.errors.PROTOCOL_TIMEOUT,
          {protocolMethod: method}
        );
        reject(err);
      }), timeout);
    });

    return Promise.race([
      this._innerSendCommand(method, sessionId, ...params),
      timeoutPromise,
    ]).finally(() => {
      asyncTimeout && clearTimeout(asyncTimeout);
    });
  }

  /**
   * Alias for 'sendCommandToSession(method, undefined, ...params)'
   * @template {keyof LH.CrdpCommands} C
   * @param {C} method
   * @param {LH.CrdpCommands[C]['paramsType']} params
   * @return {Promise<LH.CrdpCommands[C]['returnType']>}
   */
  sendCommand(method, ...params) {
    return this.sendCommandToSession(method, undefined, ...params);
  }

  /**
   * Call protocol methods.
   * @private
   * @template {keyof LH.CrdpCommands} C
   * @param {C} method
   * @param {string|undefined} sessionId
   * @param {LH.CrdpCommands[C]['paramsType']} params
   * @return {Promise<LH.CrdpCommands[C]['returnType']>}
   */
  _innerSendCommand(method, sessionId, ...params) {
    const domainCommand = /^(\w+)\.(enable|disable)$/.exec(method);
    if (domainCommand) {
      const enable = domainCommand[2] === 'enable';
      if (!this._shouldToggleDomain(domainCommand[1], sessionId, enable)) {
        return Promise.resolve();
      }
    }
    return this._connection.sendCommand(method, sessionId, ...params);
  }

  /**
   * Returns whether a domain is currently enabled.
   * @param {string} domain
   * @return {boolean}
   */
  isDomainEnabled(domain) {
    // Defined, non-zero elements of the domains map are enabled.
    return !!this._domainEnabledCounts.get(domain);
  }

  /**
   * Return the body of the response with the given ID. Rejects if getting the
   * body times out.
   * @param {string} requestId
   * @param {number} [timeout]
   * @return {Promise<string>}
   */
  async getRequestContent(requestId, timeout = 1000) {
    return fetchResponseBodyFromCache(this.defaultSession, requestId, timeout);
  }

  /**
   * @param {{x: number, y: number}} position
   * @return {Promise<void>}
   */
  scrollTo(position) {
    const scrollExpression = `window.scrollTo(${position.x}, ${position.y})`;
    return this.executionContext.evaluateAsync(scrollExpression, {useIsolation: true});
  }

  /**
   * @return {Promise<{x: number, y: number}>}
   */
  getScrollPosition() {
    return this.executionContext.evaluateAsync(`({x: window.scrollX, y: window.scrollY})`,
      {useIsolation: true});
  }

  /**
   * @param {{additionalTraceCategories?: string|null}=} settings
   * @return {Promise<void>}
   */
  async beginTrace(settings) {
    const additionalCategories = (settings && settings.additionalTraceCategories &&
        settings.additionalTraceCategories.split(',')) || [];
    const traceCategories = TraceGatherer.getDefaultTraceCategories().concat(additionalCategories);

    const uniqueCategories = Array.from(new Set(traceCategories));

    // Check any domains that could interfere with or add overhead to the trace.
    if (this.isDomainEnabled('CSS')) {
      throw new Error('CSS domain enabled when starting trace');
    }
    if (this.isDomainEnabled('DOM')) {
      throw new Error('DOM domain enabled when starting trace');
    }

    // Enable Page domain to wait for Page.loadEventFired
    return this.sendCommand('Page.enable')
      .then(_ => this.sendCommand('Tracing.start', {
        categories: uniqueCategories.join(','),
        options: 'sampling-frequency=10000', // 1000 is default and too slow.
      }));
  }

  /**
   * @return {Promise<LH.Trace>}
   */
  endTrace() {
    return TraceGatherer.endTraceAndCollectEvents(this.defaultSession);
  }

  /**
   * Begin recording devtools protocol messages.
   */
  beginDevtoolsLog() {
    this._devtoolsLog.reset();
    this._devtoolsLog.beginRecording();
  }

  /**
   * Stop recording to devtoolsLog and return log contents.
   * @return {LH.DevtoolsLog}
   */
  endDevtoolsLog() {
    this._devtoolsLog.endRecording();
    return this._devtoolsLog.messages;
  }
}

module.exports = Driver;

},{"../gather/driver/network.js":70,"../lib/lh-error.js":103,"./connections/connection.js":61,"./devtools-log.js":63,"./driver/environment.js":66,"./driver/execution-context.js":67,"./fetcher.js":75,"./gatherers/trace.js":"../gather/gatherers/trace","events":162,"lighthouse-logger":188}],65:[function(require,module,exports){
/**
 * @license Copyright 2021 The Lighthouse Authors. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.
 */
'use strict';

/**
 * @param {Error} err
 * @return {undefined}
 */
function handlePotentialMissingNodeError(err) {
  if (
    /No node.*found/.test(err.message) ||
    /Node.*does not belong to the document/.test(err.message)
  ) {
    return undefined;
  }
  throw err;
}

/**
 * Resolves a backend node ID (from a trace event, protocol, etc) to the object ID for use with
 * `Runtime.callFunctionOn`. `undefined` means the node could not be found.
 *
 * @param {LH.Gatherer.FRProtocolSession} session
 * @param {number} backendNodeId
 * @return {Promise<string|undefined>}
 */
async function resolveNodeIdToObjectId(session, backendNodeId) {
  try {
    const resolveNodeResponse = await session.sendCommand('DOM.resolveNode', {backendNodeId});
    return resolveNodeResponse.object.objectId;
  } catch (err) {
    return handlePotentialMissingNodeError(err);
  }
}

/**
 * Resolves a proprietary devtools node path (created from page-function.js) to the object ID for use
 * with `Runtime.callFunctionOn`. `undefined` means the node could not be found.
 * Requires `DOM.getDocument` to have been called since the object's creation or it will always be `undefined`.
 *
 * @param {LH.Gatherer.FRProtocolSession} session
 * @param {string} path
 * @return {Promise<string|undefined>}
 */
async function resolveDevtoolsNodePathToObjectId(session, path) {
  try {
    const {nodeId} = await session.sendCommand('DOM.pushNodeByPathToFrontend', {path});
    const {object: {objectId}} = await session.sendCommand('DOM.resolveNode', {nodeId});
    return objectId;
  } catch (err) {
    return handlePotentialMissingNodeError(err);
  }
}

module.exports = {resolveNodeIdToObjectId, resolveDevtoolsNodePathToObjectId};

},{}],66:[function(require,module,exports){
(function (__filename){(function (){
/**
 * @license Copyright 2021 The Lighthouse Authors. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.
 */
'use strict';

const log = require('lighthouse-logger');
const constants = require('../../config/constants.js');
const pageFunctions = require('../../lib/page-functions.js');
const i18n = require('../../lib/i18n/i18n.js');

const UIStrings = {
  /**
   * @description Warning that the host device where Lighthouse is running appears to have a slower
   * CPU than the expected Lighthouse baseline.
   */
  warningSlowHostCpu: 'The tested device appears to have a slower CPU than  ' +
  'Lighthouse expects. This can negatively affect your performance score. Learn more about ' +
  '[calibrating an appropriate CPU slowdown multiplier](https://github.com/GoogleChrome/lighthouse/blob/master/docs/throttling.md#cpu-throttling).',
};

/**
 * We want to warn when the CPU seemed to be at least ~2x weaker than our regular target device.
 * We're starting with a more conservative value that will increase over time to our true target threshold.
 * @see https://github.com/GoogleChrome/lighthouse/blob/ccbc8002fd058770d14e372a8301cc4f7d256414/docs/throttling.md#calibrating-multipliers
 */
const SLOW_CPU_BENCHMARK_INDEX_THRESHOLD = 1000;

const str_ = i18n.createMessageInstanceIdFn(__filename, UIStrings);

/**
 * @param {LH.Gatherer.FRProtocolSession} session
 * @return {Promise<LH.Crdp.Browser.GetVersionResponse & {milestone: number}>}
 */
async function getBrowserVersion(session) {
  const status = {msg: 'Getting browser version', id: 'lh:gather:getVersion'};
  log.time(status, 'verbose');
  const version = await session.sendCommand('Browser.getVersion');
  const match = version.product.match(/\/(\d+)/); // eg 'Chrome/71.0.3577.0'
  const milestone = match ? parseInt(match[1]) : 0;
  log.timeEnd(status);
  return Object.assign(version, {milestone});
}

/**
 * Computes the benchmark index to get a rough estimate of device class.
 * @param {LH.Gatherer.FRTransitionalDriver['executionContext']} executionContext
 * @return {Promise<number>}
 */
async function getBenchmarkIndex(executionContext) {
  const status = {msg: 'Benchmarking machine', id: 'lh:gather:getBenchmarkIndex'};
  log.time(status);
  const indexVal = await executionContext.evaluate(pageFunctions.computeBenchmarkIndex, {
    args: [],
  });
  log.timeEnd(status);
  return indexVal;
}

/**
 * Returns a warning if the host device appeared to be underpowered according to BenchmarkIndex.
 *
 * @param {{settings: LH.Config.Settings; baseArtifacts: Pick<LH.Artifacts, 'BenchmarkIndex'>}} context
 * @return {LH.IcuMessage | undefined}
 */
function getSlowHostCpuWarning(context) {
  const {settings, baseArtifacts} = context;
  const {throttling, throttlingMethod} = settings;
  const defaultThrottling = constants.defaultSettings.throttling;

  // We only want to warn when the user can take an action to fix it.
  // Eventually, this should expand to cover DevTools.
  if (settings.channel !== 'cli') return;

  // Only warn if they are using the default throttling settings.
  const isThrottledMethod = throttlingMethod === 'simulate' || throttlingMethod === 'devtools';
  const isDefaultMultiplier =
    throttling.cpuSlowdownMultiplier === defaultThrottling.cpuSlowdownMultiplier;
  if (!isThrottledMethod || !isDefaultMultiplier) return;

  // Only warn if the device didn't meet the threshold.
  // See https://github.com/GoogleChrome/lighthouse/blob/master/docs/throttling.md#cpu-throttling
  if (baseArtifacts.BenchmarkIndex > SLOW_CPU_BENCHMARK_INDEX_THRESHOLD) return;

  return str_(UIStrings.warningSlowHostCpu);
}

/**
 * @param {{settings: LH.Config.Settings, baseArtifacts: Pick<LH.Artifacts, 'BenchmarkIndex'>}} context
 * @return {Array<LH.IcuMessage>}
 */
function getEnvironmentWarnings(context) {
  return [
    getSlowHostCpuWarning(context),
  ].filter(/** @return {s is LH.IcuMessage} */ s => !!s);
}

module.exports = {
  UIStrings,
  getBrowserVersion,
  getBenchmarkIndex,
  getSlowHostCpuWarning,
  getEnvironmentWarnings,
};

}).call(this)}).call(this,"/lighthouse-core/gather/driver/environment.js")
},{"../../config/constants.js":56,"../../lib/i18n/i18n.js":96,"../../lib/page-functions.js":110,"lighthouse-logger":188}],67:[function(require,module,exports){
/**
 * @license Copyright 2020 The Lighthouse Authors. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.
 */
'use strict';

/* global window */

const pageFunctions = require('../../lib/page-functions.js');

class ExecutionContext {
  /** @param {LH.Gatherer.FRProtocolSession} session */
  constructor(session) {
    this._session = session;

    /** @type {number|undefined} */
    this._executionContextId = undefined;

    // We use isolated execution contexts for `evaluateAsync` that can be destroyed through navigation
    // and other page actions. Cleanup our relevant bookkeeping as we see those events.
    // Domains are enabled when a dedicated execution context is requested.
    session.on('Page.frameNavigated', () => this.clearContextId());
    session.on('Runtime.executionContextDestroyed', event => {
      if (event.executionContextId === this._executionContextId) {
        this.clearContextId();
      }
    });
  }

  /**
   * Returns the isolated context ID currently in use.
   */
  getContextId() {
    return this._executionContextId;
  }

  /**
   * Clears the remembered context ID. Use this method when we have knowledge that the runtime context
   * we were using has been destroyed by the browser and is no longer available.
   */
  clearContextId() {
    this._executionContextId = undefined;
  }

  /**
   * Returns the cached isolated execution context ID or creates a new execution context for the main
   * frame. The cached execution context is cleared on every gotoURL invocation, so a new one will
   * always be created on the first call on a new page.
   * @return {Promise<number>}
   */
  async _getOrCreateIsolatedContextId() {
    if (typeof this._executionContextId === 'number') return this._executionContextId;

    await this._session.sendCommand('Page.enable');
    await this._session.sendCommand('Runtime.enable');

    const resourceTreeResponse = await this._session.sendCommand('Page.getResourceTree');
    const mainFrameId = resourceTreeResponse.frameTree.frame.id;

    const isolatedWorldResponse = await this._session.sendCommand('Page.createIsolatedWorld', {
      frameId: mainFrameId,
      worldName: 'lighthouse_isolated_context',
    });

    this._executionContextId = isolatedWorldResponse.executionContextId;
    return isolatedWorldResponse.executionContextId;
  }


  /**
   * Evaluate an expression in the given execution context; an undefined contextId implies the main
   * page without isolation.
   * @param {string} expression
   * @param {number|undefined} contextId
   * @return {Promise<*>}
   */
  async _evaluateInContext(expression, contextId) {
    // Use a higher than default timeout if the user hasn't specified a specific timeout.
    // Otherwise, use whatever was requested.
    const timeout = this._session.hasNextProtocolTimeout() ?
      this._session.getNextProtocolTimeout() :
      60000;

    const evaluationParams = {
      // We need to explicitly wrap the raw expression for several purposes:
      // 1. Ensure that the expression will be a native Promise and not a polyfill/non-Promise.
      // 2. Ensure that errors in the expression are captured by the Promise.
      // 3. Ensure that errors captured in the Promise are converted into plain-old JS Objects
      //    so that they can be serialized properly b/c JSON.stringify(new Error('foo')) === '{}'
      expression: `(function wrapInNativePromise() {
        ${ExecutionContext._cachedNativesPreamble};
        globalThis.__lighthouseExecutionContextId = ${contextId};
        return new Promise(function (resolve) {
          return Promise.resolve()
            .then(_ => ${expression})
            .catch(${pageFunctions.wrapRuntimeEvalErrorInBrowserString})
            .then(resolve);
        });
      }())`,
      includeCommandLineAPI: true,
      awaitPromise: true,
      returnByValue: true,
      timeout,
      contextId,
    };

    this._session.setNextProtocolTimeout(timeout);
    const response = await this._session.sendCommand('Runtime.evaluate', evaluationParams);
    if (response.exceptionDetails) {
      // An error occurred before we could even create a Promise, should be *very* rare.
      // Also occurs when the expression is not valid JavaScript.
      const errorMessage = response.exceptionDetails.exception ?
        response.exceptionDetails.exception.description :
        response.exceptionDetails.text;
      return Promise.reject(new Error(`Evaluation exception: ${errorMessage}`));
    }
    // Protocol should always return a 'result' object, but it is sometimes undefined.  See #6026.
    if (response.result === undefined) {
      return Promise.reject(
        new Error('Runtime.evaluate response did not contain a "result" object'));
    }
    const value = response.result.value;
    if (value && value.__failedInBrowser) {
      return Promise.reject(Object.assign(new Error(), value));
    } else {
      return value;
    }
  }

  /**
   * Note: Prefer `evaluate` instead.
   * Evaluate an expression in the context of the current page. If useIsolation is true, the expression
   * will be evaluated in a content script that has access to the page's DOM but whose JavaScript state
   * is completely separate.
   * Returns a promise that resolves on the expression's value.
   * @param {string} expression
   * @param {{useIsolation?: boolean}=} options
   * @return {Promise<*>}
   */
  async evaluateAsync(expression, options = {}) {
    const contextId = options.useIsolation ? await this._getOrCreateIsolatedContextId() : undefined;

    try {
      // `await` is not redundant here because we want to `catch` the async errors
      return await this._evaluateInContext(expression, contextId);
    } catch (err) {
      // If we were using isolation and the context disappeared on us, retry one more time.
      if (contextId && err.message.includes('Cannot find context')) {
        this.clearContextId();
        const freshContextId = await this._getOrCreateIsolatedContextId();
        return this._evaluateInContext(expression, freshContextId);
      }

      throw err;
    }
  }

  /**
   * Evaluate a function in the context of the current page.
   * If `useIsolation` is true, the function will be evaluated in a content script that has
   * access to the page's DOM but whose JavaScript state is completely separate.
   * Returns a promise that resolves on a value of `mainFn`'s return type.
   * @template {unknown[]} T, R
   * @param {((...args: T) => R)} mainFn The main function to call.
   * @param {{args: T, useIsolation?: boolean, deps?: Array<Function|string>}} options `args` should
   *   match the args of `mainFn`, and can be any serializable value. `deps` are functions that must be
   *   defined for `mainFn` to work.
   * @return {FlattenedPromise<R>}
   */
  evaluate(mainFn, options) {
    const argsSerialized = ExecutionContext.serializeArguments(options.args);
    const depsSerialized = options.deps ? options.deps.join('\n') : '';
    const expression = `(() => {
      ${depsSerialized}
      return (${mainFn})(${argsSerialized});
    })()`;
    return this.evaluateAsync(expression, options);
  }

  /**
   * Evaluate a function on every new frame from now on.
   * @template {unknown[]} T
   * @param {((...args: T) => void)} mainFn The main function to call.
   * @param {{args: T, deps?: Array<Function|string>}} options `args` should
   *   match the args of `mainFn`, and can be any serializable value. `deps` are functions that must be
   *   defined for `mainFn` to work.
   * @return {Promise<void>}
   */
  async evaluateOnNewDocument(mainFn, options) {
    const argsSerialized = ExecutionContext.serializeArguments(options.args);
    const depsSerialized = options.deps ? options.deps.join('\n') : '';

    const expression = `(() => {
      ${ExecutionContext._cachedNativesPreamble};
      ${depsSerialized};
      (${mainFn})(${argsSerialized});
    })()`;

    await this._session.sendCommand('Page.addScriptToEvaluateOnNewDocument', {source: expression});
  }

  /**
   * Cache native functions/objects inside window so we are sure polyfills do not overwrite the
   * native implementations when the page loads.
   * @return {Promise<void>}
   */
  async cacheNativesOnNewDocument() {
    await this.evaluateOnNewDocument(() => {
      /* c8 ignore start */
      window.__nativePromise = window.Promise;
      window.__nativeURL = window.URL;
      window.__nativePerformance = window.performance;
      window.__ElementMatches = window.Element.prototype.matches;
      // Ensure the native `performance.now` is not overwritable.
      const performance = window.performance;
      const performanceNow = window.performance.now;
      Object.defineProperty(performance, 'now', {
        value: () => performanceNow.call(performance),
        writable: false,
      });
      /* c8 ignore stop */
    }, {args: []});
  }

  /**
   * Prefix every script evaluation with a shadowing of common globals that tend to be ponyfilled
   * incorrectly by many sites. This allows functions to still refer to `Promise` instead of
   * Lighthouse-specific backups like `__nativePromise` (injected by `cacheNativesOnNewDocument` above).
   */
  static _cachedNativesPreamble = [
    'const Promise = globalThis.__nativePromise || globalThis.Promise',
    'const URL = globalThis.__nativeURL || globalThis.URL',
    'const performance = globalThis.__nativePerformance || globalThis.performance',
  ].join(';\n');

  /**
   * Serializes an array of arguments for use in an `eval` string across the protocol.
   * @param {unknown[]} args
   * @return {string}
   */
  static serializeArguments(args) {
    return args.map(arg => arg === undefined ? 'undefined' : JSON.stringify(arg)).join(',');
  }
}

module.exports = ExecutionContext;

},{"../../lib/page-functions.js":110}],68:[function(require,module,exports){
(function (__filename){(function (){
/**
 * @license Copyright 2021 The Lighthouse Authors. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.
 */
'use strict';

const NetworkMonitor = require('./network-monitor.js');
const {waitForFullyLoaded, waitForFrameNavigated} = require('./wait-for-condition.js');
const constants = require('../../config/constants.js');
const i18n = require('../../lib/i18n/i18n.js');
const URL = require('../../lib/url-shim.js');

const UIStrings = {
  /**
   * @description Warning that the web page redirected during testing and that may have affected the load.
   * @example {https://example.com/requested/page} requested
   * @example {https://example.com/final/resolved/page} final
   */
  warningRedirected: 'The page may not be loading as expected because your test URL ' +
  `({requested}) was redirected to {final}. ` +
  'Try testing the second URL directly.',
  /**
   * @description Warning that Lighthouse timed out while waiting for the page to load.
   */
  warningTimeout: 'The page loaded too slowly to finish within the time limit. ' +
  'Results may be incomplete.',
};

const str_ = i18n.createMessageInstanceIdFn(__filename, UIStrings);


// Controls how long to wait after FCP before continuing
const DEFAULT_PAUSE_AFTER_FCP = 0;
// Controls how long to wait after onLoad before continuing
const DEFAULT_PAUSE_AFTER_LOAD = 0;
// Controls how long to wait between network requests before determining the network is quiet
const DEFAULT_NETWORK_QUIET_THRESHOLD = 5000;
// Controls how long to wait between longtasks before determining the CPU is idle, off by default
const DEFAULT_CPU_QUIET_THRESHOLD = 0;

/** @typedef {{waitUntil: Array<'fcp'|'load'|'navigated'>} & LH.Config.SharedPassNavigationJson & Partial<Pick<LH.Config.Settings, 'maxWaitForFcp'|'maxWaitForLoad'>>} NavigationOptions */

/** @param {NavigationOptions} options */
function resolveWaitForFullyLoadedOptions(options) {
  /* eslint-disable max-len */
  let {pauseAfterFcpMs, pauseAfterLoadMs, networkQuietThresholdMs, cpuQuietThresholdMs} = options;
  let maxWaitMs = options.maxWaitForLoad;
  let maxFCPMs = options.maxWaitForFcp;

  if (typeof pauseAfterFcpMs !== 'number') pauseAfterFcpMs = DEFAULT_PAUSE_AFTER_FCP;
  if (typeof pauseAfterLoadMs !== 'number') pauseAfterLoadMs = DEFAULT_PAUSE_AFTER_LOAD;
  if (typeof networkQuietThresholdMs !== 'number') {
    networkQuietThresholdMs = DEFAULT_NETWORK_QUIET_THRESHOLD;
  }
  if (typeof cpuQuietThresholdMs !== 'number') cpuQuietThresholdMs = DEFAULT_CPU_QUIET_THRESHOLD;
  if (typeof maxWaitMs !== 'number') maxWaitMs = constants.defaultSettings.maxWaitForLoad;
  if (typeof maxFCPMs !== 'number') maxFCPMs = constants.defaultSettings.maxWaitForFcp;
  /* eslint-enable max-len */

  if (!options.waitUntil.includes('fcp')) maxFCPMs = undefined;

  return {
    pauseAfterFcpMs,
    pauseAfterLoadMs,
    networkQuietThresholdMs,
    cpuQuietThresholdMs,
    maxWaitForLoadedMs: maxWaitMs,
    maxWaitForFcpMs: maxFCPMs,
  };
}

/**
 * Navigates to the given URL, assuming that the page is not already on this URL.
 * Resolves on the url of the loaded page, taking into account any redirects.
 * Typical use of this method involves navigating to a neutral page such as `about:blank` in between
 * navigations.
 *
 * @param {LH.Gatherer.FRTransitionalDriver} driver
 * @param {string} url
 * @param {NavigationOptions} options
 * @return {Promise<{finalUrl: string, warnings: Array<LH.IcuMessage>}>}
 */
async function gotoURL(driver, url, options) {
  const session = driver.defaultSession;
  const networkMonitor = new NetworkMonitor(driver.defaultSession);

  // Enable the events and network monitor needed to track navigation progress.
  await networkMonitor.enable();
  await session.sendCommand('Page.enable');
  await session.sendCommand('Page.setLifecycleEventsEnabled', {enabled: true});

  // No timeout needed for Page.navigate. See https://github.com/GoogleChrome/lighthouse/pull/6413
  session.setNextProtocolTimeout(Infinity);
  const waitforPageNavigateCmd = session.sendCommand('Page.navigate', {url});

  const waitForNavigated = options.waitUntil.includes('navigated');
  const waitForLoad = options.waitUntil.includes('load');
  const waitForFcp = options.waitUntil.includes('fcp');

  /** @type {Array<Promise<{timedOut: boolean}>>} */
  const waitConditionPromises = [];

  if (waitForNavigated) {
    const navigatedPromise = waitForFrameNavigated(session).promise;
    waitConditionPromises.push(navigatedPromise.then(() => ({timedOut: false})));
  }

  if (waitForLoad) {
    const waitOptions = resolveWaitForFullyLoadedOptions(options);
    waitConditionPromises.push(waitForFullyLoaded(session, networkMonitor, waitOptions));
  } else if (waitForFcp) {
    throw new Error('Cannot wait for FCP without waiting for page load');
  }

  const waitConditions = await Promise.all(waitConditionPromises);
  const timedOut = waitConditions.some(condition => condition.timedOut);
  const finalUrl = (await networkMonitor.getFinalNavigationUrl()) || url;

  // Bring `Page.navigate` errors back into the promise chain. See https://github.com/GoogleChrome/lighthouse/pull/6739.
  await waitforPageNavigateCmd;
  await networkMonitor.disable();

  return {
    finalUrl,
    warnings: getNavigationWarnings({timedOut, finalUrl, requestedUrl: url}),
  };
}

/**
 * @param {{timedOut: boolean, requestedUrl: string, finalUrl: string; }} navigation
 * @return {Array<LH.IcuMessage>}
 */
function getNavigationWarnings(navigation) {
  const {requestedUrl, finalUrl} = navigation;
  /** @type {Array<LH.IcuMessage>} */
  const warnings = [];

  if (navigation.timedOut) warnings.push(str_(UIStrings.warningTimeout));

  if (
    !URL.equalWithExcludedFragments(requestedUrl, finalUrl) &&
    !finalUrl.startsWith('chrome-error://')
  ) {
    warnings.push(str_(UIStrings.warningRedirected, {
      requested: requestedUrl,
      final: finalUrl,
    }));
  }

  return warnings;
}

module.exports = {gotoURL, getNavigationWarnings, UIStrings};

}).call(this)}).call(this,"/lighthouse-core/gather/driver/navigation.js")
},{"../../config/constants.js":56,"../../lib/i18n/i18n.js":96,"../../lib/url-shim.js":"url","./network-monitor.js":69,"./wait-for-condition.js":74}],69:[function(require,module,exports){
/**
 * @license Copyright 2021 The Lighthouse Authors. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.
 */
'use strict';

/**
 * @fileoverview This class wires up the procotol to a network recorder and provides overall
 * status inspection state.
 */

const log = require('lighthouse-logger');
const {EventEmitter} = require('events');
const NetworkRecorder = require('../../lib/network-recorder.js');
const NetworkRequest = require('../../lib/network-request.js');
const URL = require('../../lib/url-shim.js');

/** @typedef {import('../../lib/network-recorder.js').NetworkRecorderEvent} NetworkRecorderEvent */
/** @typedef {'network-2-idle'|'network-critical-idle'|'networkidle'|'networkbusy'|'network-critical-busy'|'network-2-busy'} NetworkMonitorEvent_ */
/** @typedef {NetworkRecorderEvent|NetworkMonitorEvent_} NetworkMonitorEvent */

class NetworkMonitor extends EventEmitter {
  /** @type {NetworkRecorder|undefined} */
  _networkRecorder = undefined;
  /** @type {Array<LH.Crdp.Page.Frame>} */
  _frameNavigations = [];

  /** @param {LH.Gatherer.FRProtocolSession} session */
  constructor(session) {
    super();
    this._session = session;

    /** @param {LH.Crdp.Page.FrameNavigatedEvent} event */
    this._onFrameNavigated = event => this._frameNavigations.push(event.frame);

    /** @param {LH.Protocol.RawEventMessage} event */
    this._onProtocolMessage = event => {
      if (!this._networkRecorder) return;
      this._networkRecorder.dispatch(event);
    };

    // Redefine the event emitter types with a narrower type signature.
    /** @param {NetworkMonitorEvent} event @param {*} listener  */
    this.on = (event, listener) => super.on(event, listener);
    /** @param {NetworkMonitorEvent} event @param {*} listener  */
    this.once = (event, listener) => super.once(event, listener);
    /** @param {NetworkMonitorEvent} event @param {*} listener  */
    this.off = (event, listener) => super.off(event, listener);
  }

  /**
   * @return {Promise<void>}
   */
  async enable() {
    if (this._networkRecorder) return;

    this._frameNavigations = [];
    this._networkRecorder = new NetworkRecorder();

    /**
     * Reemit the same network recorder events.
     * @param {NetworkRecorderEvent} event
     * @return {(r: NetworkRequest) => void}
     */
    const reEmit = event => r => {
      this.emit(event, r);
      this._emitNetworkStatus();
    };

    this._networkRecorder.on('requeststarted', reEmit('requeststarted'));
    this._networkRecorder.on('requestloaded', reEmit('requestloaded'));

    this._session.on('Page.frameNavigated', this._onFrameNavigated);
    this._session.addProtocolMessageListener(this._onProtocolMessage);

    await this._session.sendCommand('Page.enable');
    await this._session.sendCommand('Network.enable');
  }

  /**
   * @return {Promise<void>}
   */
  async disable() {
    this._session.off('Page.frameNavigated', this._onFrameNavigated);
    this._session.removeProtocolMessageListener(this._onProtocolMessage);

    this._frameNavigations = [];
    this._networkRecorder = undefined;
  }

  /** @return {Promise<string | undefined>} */
  async getFinalNavigationUrl() {
    const frameNavigations = this._frameNavigations;
    if (!frameNavigations.length) return undefined;

    const resourceTreeResponse = await this._session.sendCommand('Page.getResourceTree');
    const mainFrameId = resourceTreeResponse.frameTree.frame.id;
    const mainFrameNavigations = frameNavigations.filter(frame => frame.id === mainFrameId);
    const finalNavigation = mainFrameNavigations[mainFrameNavigations.length - 1];
    if (!finalNavigation) log.warn('NetworkMonitor', 'No detected navigations');

    return finalNavigation && finalNavigation.url;
  }

  /**
   * @return {Array<NetworkRequest>}
   */
  getInflightRequests() {
    if (!this._networkRecorder) return [];
    return this._networkRecorder.getRawRecords().filter(request => !request.finished);
  }

  /**
   * Returns whether the network is completely idle (i.e. there are 0 inflight network requests).
   */
  isIdle() {
    return this._isActiveIdlePeriod(0);
  }

  /**
   * Returns whether any important resources for the page are in progress.
   * Above-the-fold images and XHRs should be included.
   * Tracking pixels, low priority images, and cross frame requests should be excluded.
   * @return {boolean}
   */
  isCriticalIdle() {
    if (!this._networkRecorder) return false;
    const requests = this._networkRecorder.getRawRecords();
    const rootFrameRequest = requests.find(r => r.resourceType === 'Document');
    const rootFrameId = rootFrameRequest && rootFrameRequest.frameId;

    return this._isActiveIdlePeriod(
      0,
      request =>
        request.frameId === rootFrameId &&
        (request.priority === 'VeryHigh' || request.priority === 'High')
    );
  }

  /**
   * Returns whether the network is semi-idle (i.e. there are 2 or fewer inflight network requests).
   */
  is2Idle() {
    return this._isActiveIdlePeriod(2);
  }

  /**
   * Returns whether the number of currently inflight requests is less than or
   * equal to the number of allowed concurrent requests.
   * @param {number} allowedRequests
   * @param {(request: NetworkRequest) => boolean} [requestFilter]
   * @return {boolean}
   */
  _isActiveIdlePeriod(allowedRequests, requestFilter) {
    if (!this._networkRecorder) return false;
    const requests = this._networkRecorder.getRawRecords();
    let inflightRequests = 0;

    for (let i = 0; i < requests.length; i++) {
      const request = requests[i];
      if (request.finished) continue;
      if (requestFilter && !requestFilter(request)) continue;
      if (NetworkRequest.isNonNetworkRequest(request)) continue;
      inflightRequests++;
    }

    return inflightRequests <= allowedRequests;
  }

  /**
   * Emits the appropriate network status event.
   */
  _emitNetworkStatus() {
    const zeroQuiet = this.isIdle();
    const twoQuiet = this.is2Idle();
    const criticalQuiet = this.isCriticalIdle();

    this.emit(zeroQuiet ? 'networkidle' : 'networkbusy');
    this.emit(twoQuiet ? 'network-2-idle' : 'network-2-busy');
    this.emit(criticalQuiet ? 'network-critical-idle' : 'network-critical-busy');

    if (twoQuiet && zeroQuiet) log.verbose('NetworkRecorder', 'network fully-quiet');
    else if (twoQuiet && !zeroQuiet) log.verbose('NetworkRecorder', 'network semi-quiet');
    else log.verbose('NetworkRecorder', 'network busy');
  }

  /**
   * Finds all time periods where the number of inflight requests is less than or equal to the
   * number of allowed concurrent requests.
   * @param {Array<LH.Artifacts.NetworkRequest>} requests
   * @param {number} allowedConcurrentRequests
   * @param {number=} endTime
   * @return {Array<{start: number, end: number}>}
   */
  static findNetworkQuietPeriods(requests, allowedConcurrentRequests, endTime = Infinity) {
    // First collect the timestamps of when requests start and end
    /** @type {Array<{time: number, isStart: boolean}>} */
    let timeBoundaries = [];
    requests.forEach(request => {
      if (URL.isNonNetworkProtocol(request.protocol)) return;
      if (request.protocol === 'ws' || request.protocol === 'wss') return;

      // convert the network timestamp to ms
      timeBoundaries.push({time: request.startTime * 1000, isStart: true});
      if (request.finished) {
        timeBoundaries.push({time: request.endTime * 1000, isStart: false});
      }
    });

    timeBoundaries = timeBoundaries
      .filter(boundary => boundary.time <= endTime)
      .sort((a, b) => a.time - b.time);

    let numInflightRequests = 0;
    let quietPeriodStart = 0;
    /** @type {Array<{start: number, end: number}>} */
    const quietPeriods = [];
    timeBoundaries.forEach(boundary => {
      if (boundary.isStart) {
        // we've just started a new request. are we exiting a quiet period?
        if (numInflightRequests === allowedConcurrentRequests) {
          quietPeriods.push({start: quietPeriodStart, end: boundary.time});
        }
        numInflightRequests++;
      } else {
        numInflightRequests--;
        // we've just completed a request. are we entering a quiet period?
        if (numInflightRequests === allowedConcurrentRequests) {
          quietPeriodStart = boundary.time;
        }
      }
    });

    // Check we ended in a quiet period
    if (numInflightRequests <= allowedConcurrentRequests) {
      quietPeriods.push({start: quietPeriodStart, end: endTime});
    }

    return quietPeriods.filter(period => period.start !== period.end);
  }
}

module.exports = NetworkMonitor;

},{"../../lib/network-recorder.js":108,"../../lib/network-request.js":109,"../../lib/url-shim.js":"url","events":162,"lighthouse-logger":188}],70:[function(require,module,exports){
/**
 * @license Copyright 2021 The Lighthouse Authors. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.
 */
'use strict';

const NetworkRequest = require('../../lib/network-request.js');

/**
 * Return the body of the response with the given ID. Rejects if getting the
 * body times out.
 * @param {LH.Gatherer.FRProtocolSession} session
 * @param {string} requestId
 * @param {number} [timeout]
 * @return {Promise<string>}
 */
async function fetchResponseBodyFromCache(session, requestId, timeout = 1000) {
  requestId = NetworkRequest.getRequestIdForBackend(requestId);

  // Encoding issues may lead to hanging getResponseBody calls: https://github.com/GoogleChrome/lighthouse/pull/4718
  // session.sendCommand will handle timeout after 1s.
  session.setNextProtocolTimeout(timeout);
  const result = await session.sendCommand('Network.getResponseBody', {requestId});
  return result.body;
}

module.exports = {fetchResponseBodyFromCache};

},{"../../lib/network-request.js":109}],71:[function(require,module,exports){
/**
 * @license Copyright 2021 The Lighthouse Authors. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.
 */
'use strict';

const log = require('lighthouse-logger');
const storage = require('./storage.js');
const emulation = require('../../lib/emulation.js');
const pageFunctions = require('../../lib/page-functions.js');

/**
 * Enables `Debugger` domain to receive async stacktrace information on network request initiators.
 * This is critical for tracking attribution of tasks and performance simulation accuracy.
 * @param {LH.Gatherer.FRProtocolSession} session
 */
async function enableAsyncStacks(session) {
  const enable = async () => {
    await session.sendCommand('Debugger.enable');
    await session.sendCommand('Debugger.setSkipAllPauses', {skip: true});
    await session.sendCommand('Debugger.setAsyncCallStackDepth', {maxDepth: 8});
  };

  // Resume any pauses that make it through `setSkipAllPauses`
  session.on('Debugger.paused', () => session.sendCommand('Debugger.resume'));

  // `Debugger.setSkipAllPauses` is reset after every navigation, so retrigger it on main frame navigations.
  // See https://bugs.chromium.org/p/chromium/issues/detail?id=990945&q=setSkipAllPauses&can=2
  session.on('Page.frameNavigated', event => {
    if (event.frame.parentId) return;
    enable().catch(err => log.error('Driver', err));
  });

  await enable();
}

/**
 * Use a RequestIdleCallback shim for tests run with simulated throttling, so that the deadline can be used without
 * a penalty.
 * @param {LH.Gatherer.FRTransitionalDriver} driver
 * @param {LH.Config.Settings} settings
 * @return {Promise<void>}
 */
async function shimRequestIdleCallbackOnNewDocument(driver, settings) {
  await driver.executionContext.evaluateOnNewDocument(pageFunctions.wrapRequestIdleCallback, {
    args: [settings.throttling.cpuSlowdownMultiplier],
  });
}

/**
 * Dismiss JavaScript dialogs (alert, confirm, prompt), providing a
 * generic promptText in case the dialog is a prompt.
 * @param {LH.Gatherer.FRProtocolSession} session
 * @return {Promise<void>}
 */
async function dismissJavaScriptDialogs(session) {
  session.on('Page.javascriptDialogOpening', data => {
    log.warn('Driver', `${data.type} dialog opened by the page automatically suppressed.`);

    session
      .sendCommand('Page.handleJavaScriptDialog', {
        accept: true,
        promptText: 'Lighthouse prompt response',
      })
      .catch(err => log.warn('Driver', err));
  });

  await session.sendCommand('Page.enable');
}

/**
 * @param {LH.Gatherer.FRProtocolSession} session
 * @param {{url: string}} navigation
 * @return {Promise<{warnings: Array<LH.IcuMessage>}>}
 */
async function resetStorageForNavigation(session, navigation) {
  /** @type {Array<LH.IcuMessage>} */
  const warnings = [];

  // Reset the storage and warn if there appears to be other important data.
  const warning = await storage.getImportantStorageWarning(session, navigation.url);
  if (warning) warnings.push(warning);
  await storage.clearDataForOrigin(session, navigation.url);
  await storage.clearBrowserCaches(session);

  return {warnings};
}

/**
 * Prepares a target for a particular navigation by resetting storage and setting throttling.
 *
 * This method assumes `prepareTargetForNavigationMode` has already been invoked.
 *
 * @param {LH.Gatherer.FRProtocolSession} session
 * @param {LH.Config.Settings} settings
 * @param {Pick<LH.Config.NavigationDefn, 'disableThrottling'|'disableStorageReset'|'blockedUrlPatterns'> & {url: string}} navigation
 */
async function prepareNetworkForNavigation(session, settings, navigation) {
  const status = {msg: 'Preparing network conditions', id: `lh:gather:prepareNetworkForNavigation`};
  log.time(status);

  if (navigation.disableThrottling) await emulation.clearThrottling(session);
  else await emulation.throttle(session, settings);

  // Set request blocking before any network activity.
  // No "clearing" is done at the end of the navigation since Network.setBlockedURLs([]) will unset all if
  // neccessary at the beginning of the next navigation.
  const blockedUrls = (navigation.blockedUrlPatterns || []).concat(
    settings.blockedUrlPatterns || []
  );
  await session.sendCommand('Network.setBlockedURLs', {urls: blockedUrls});

  const headers = settings.extraHeaders;
  if (headers) await session.sendCommand('Network.setExtraHTTPHeaders', {headers});

  log.timeEnd(status);
}

/**
 * Prepares a target to be analyzed in navigation mode by enabling protocol domains, emulation, and new document
 * handlers for global APIs or error handling.
 *
 * This method should be used in combination with `prepareTargetForIndividualNavigation` before a specific navigation occurs.
 *
 * @param {LH.Gatherer.FRTransitionalDriver} driver
 * @param {LH.Config.Settings} settings
 */
async function prepareTargetForNavigationMode(driver, settings) {
  // Enable network domain here so future calls to `emulate()` don't clear cache (#12631)
  await driver.defaultSession.sendCommand('Network.enable');

  // Emulate our target device screen and user agent.
  await emulation.emulate(driver.defaultSession, settings);

  // Enable better stacks on network requests.
  await enableAsyncStacks(driver.defaultSession);

  // Automatically handle any JavaScript dialogs to prevent a hung renderer.
  await dismissJavaScriptDialogs(driver.defaultSession);

  // Inject our snippet to cache important web platform APIs before they're (possibly) ponyfilled by the page.
  await driver.executionContext.cacheNativesOnNewDocument();

  // Wrap requestIdleCallback so pages under simulation receive the correct rIC deadlines.
  if (settings.throttlingMethod === 'simulate') {
    await shimRequestIdleCallbackOnNewDocument(driver, settings);
  }
}

/**
 * Prepares a target for a particular navigation by resetting storage and setting network.
 *
 * This method assumes `prepareTargetForNavigationMode` has already been invoked.
 *
 * @param {LH.Gatherer.FRProtocolSession} session
 * @param {LH.Config.Settings} settings
 * @param {Pick<LH.Config.NavigationDefn, 'disableThrottling'|'disableStorageReset'|'blockedUrlPatterns'> & {url: string}} navigation
 * @return {Promise<{warnings: Array<LH.IcuMessage>}>}
 */
async function prepareTargetForIndividualNavigation(session, settings, navigation) {
  /** @type {Array<LH.IcuMessage>} */
  const warnings = [];

  const shouldResetStorage = !settings.disableStorageReset && !navigation.disableStorageReset;
  if (shouldResetStorage) {
    const {warnings: storageWarnings} = await resetStorageForNavigation(session, navigation);
    warnings.push(...storageWarnings);
  }

  await prepareNetworkForNavigation(session, settings, navigation);

  return {warnings};
}

module.exports = {
  prepareNetworkForNavigation,
  prepareTargetForNavigationMode,
  prepareTargetForIndividualNavigation,
};

},{"../../lib/emulation.js":95,"../../lib/page-functions.js":110,"./storage.js":73,"lighthouse-logger":188}],72:[function(require,module,exports){
/**
 * @license Copyright 2021 The Lighthouse Authors. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.
 */
'use strict';

/**
 * @param {LH.Gatherer.FRProtocolSession} session
 * @return {Promise<LH.Crdp.ServiceWorker.WorkerVersionUpdatedEvent>}
 */
function getServiceWorkerVersions(session) {
  return new Promise((resolve, reject) => {
    /**
     * @param {LH.Crdp.ServiceWorker.WorkerVersionUpdatedEvent} data
     */
    const versionUpdatedListener = data => {
      // find a service worker with runningStatus that looks like active
      // on slow connections the serviceworker might still be installing
      const activateCandidates = data.versions.filter(sw => {
        return sw.status !== 'redundant';
      });

      const hasActiveServiceWorker = activateCandidates.find(sw => {
        return sw.status === 'activated';
      });

      if (!activateCandidates.length || hasActiveServiceWorker) {
        session.off('ServiceWorker.workerVersionUpdated', versionUpdatedListener);
        session.sendCommand('ServiceWorker.disable').then(_ => resolve(data), reject);
      }
    };

    session.on('ServiceWorker.workerVersionUpdated', versionUpdatedListener);

    session.sendCommand('ServiceWorker.enable').catch(reject);
  });
}

/**
 * @param {LH.Gatherer.FRProtocolSession} session
 * @return {Promise<LH.Crdp.ServiceWorker.WorkerRegistrationUpdatedEvent>}
 */
function getServiceWorkerRegistrations(session) {
  return new Promise((resolve, reject) => {
    session.once('ServiceWorker.workerRegistrationUpdated', data => {
      session.sendCommand('ServiceWorker.disable').then(_ => resolve(data), reject);
    });
    session.sendCommand('ServiceWorker.enable').catch(reject);
  });
}

module.exports = {getServiceWorkerVersions, getServiceWorkerRegistrations};

},{}],73:[function(require,module,exports){
(function (__filename){(function (){
/**
 * @license Copyright 2021 The Lighthouse Authors. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.
 */
'use strict';

const log = require('lighthouse-logger');
const i18n = require('../../lib/i18n/i18n.js');

const UIStrings = {
  /**
   * @description A warning that previously-saved data may have affected the measured performance and instructions on how to avoid the problem. "locations" will be a list of possible types of data storage locations, e.g. "IndexedDB",  "Local Storage", or "Web SQL".
   * @example {IndexedDB, Local Storage} locations
   */
  warningData: `{locationCount, plural,
    =1 {There may be stored data affecting loading performance in this location: {locations}. ` +
      `Audit this page in an incognito window to prevent those resources ` +
      `from affecting your scores.}
    other {There may be stored data affecting loading ` +
      `performance in these locations: {locations}. ` +
      `Audit this page in an incognito window to prevent those resources ` +
      `from affecting your scores.}
  }`,
};

const str_ = i18n.createMessageInstanceIdFn(__filename, UIStrings);


/**
 * @param {LH.Gatherer.FRProtocolSession} session
 * @param {string} url
 * @return {Promise<void>}
 */
async function clearDataForOrigin(session, url) {
  const origin = new URL(url).origin;

  // Clear some types of storage.
  // Cookies are not cleared, so the user isn't logged out.
  // indexeddb, websql, and localstorage are not cleared to prevent loss of potentially important data.
  //   https://chromedevtools.github.io/debugger-protocol-viewer/tot/Storage/#type-StorageType
  const typesToClear = [
    'appcache',
    // 'cookies',
    'file_systems',
    'shader_cache',
    'service_workers',
    'cache_storage',
  ].join(',');

  // `Storage.clearDataForOrigin` is one of our PROTOCOL_TIMEOUT culprits and this command is also
  // run in the context of PAGE_HUNG to cleanup. We'll keep the timeout low and just warn if it fails.
  session.setNextProtocolTimeout(5000);

  try {
    await session.sendCommand('Storage.clearDataForOrigin', {
      origin: origin,
      storageTypes: typesToClear,
    });
  } catch (err) {
    if (/** @type {LH.LighthouseError} */ (err).code === 'PROTOCOL_TIMEOUT') {
      log.warn('Driver', 'clearDataForOrigin timed out');
    } else {
      throw err;
    }
  }
}

/**
 * @param {LH.Gatherer.FRProtocolSession} session
 * @param {string} url
 * @return {Promise<LH.IcuMessage | undefined>}
 */
async function getImportantStorageWarning(session, url) {
  const usageData = await session.sendCommand('Storage.getUsageAndQuota', {
    origin: url,
  });
  /** @type {Record<string, string>} */
  const storageTypeNames = {
    local_storage: 'Local Storage',
    indexeddb: 'IndexedDB',
    websql: 'Web SQL',
  };
  const locations = usageData.usageBreakdown
    .filter(usage => usage.usage)
    .map(usage => storageTypeNames[usage.storageType] || '')
    .filter(Boolean);
  if (locations.length) {
    // TODO(#11495): Use Intl.ListFormat with Node 12
    return str_(UIStrings.warningData, {
      locations: locations.join(', '),
      locationCount: locations.length,
    });
  }
}


/**
 * Clear the network cache on disk and in memory.
 * @param {LH.Gatherer.FRProtocolSession} session
 * @return {Promise<void>}
 */
async function clearBrowserCaches(session) {
  const status = {msg: 'Cleaning browser cache', id: 'lh:storage:clearBrowserCaches'};
  log.time(status);

  // Wipe entire disk cache
  await session.sendCommand('Network.clearBrowserCache');
  // Toggle 'Disable Cache' to evict the memory cache
  await session.sendCommand('Network.setCacheDisabled', {cacheDisabled: true});
  await session.sendCommand('Network.setCacheDisabled', {cacheDisabled: false});

  log.timeEnd(status);
}

module.exports = {
  clearDataForOrigin,
  clearBrowserCaches,
  getImportantStorageWarning,
  UIStrings,
};

}).call(this)}).call(this,"/lighthouse-core/gather/driver/storage.js")
},{"../../lib/i18n/i18n.js":96,"lighthouse-logger":188}],74:[function(require,module,exports){
/**
 * @license Copyright 2020 The Lighthouse Authors. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.
 */
'use strict';

/* global window, performance */

const log = require('lighthouse-logger');
const LHError = require('../../lib/lh-error.js');
const ExecutionContext = require('./execution-context.js');

/** @typedef {import('./network-monitor.js')} NetworkMonitor */
/** @typedef {import('./network-monitor.js').NetworkMonitorEvent} NetworkMonitorEvent */
/** @typedef {{promise: Promise<void>, cancel: function(): void}} CancellableWait */

/**
 * @typedef WaitOptions
 * @prop {number} pauseAfterFcpMs
 * @prop {number} pauseAfterLoadMs
 * @prop {number} networkQuietThresholdMs
 * @prop {number} cpuQuietThresholdMs
 * @prop {number} maxWaitForLoadedMs
 * @prop {number|undefined} maxWaitForFcpMs
 * @prop {{waitForFcp: typeof waitForFcp, waitForLoadEvent: typeof waitForLoadEvent, waitForNetworkIdle: typeof waitForNetworkIdle, waitForCPUIdle: typeof waitForCPUIdle}} [_waitForTestOverrides]
 */

/**
 * Returns a promise that resolves immediately.
 * Used for placeholder conditions that we don't want to start waiting for just yet, but still want
 * to satisfy the same interface.
 * @return {{promise: Promise<void>, cancel: function(): void}}
 */
function waitForNothing() {
  return {promise: Promise.resolve(), cancel() {}};
}

/**
 * Returns a promise that resolve when a frame has been navigated.
 * Used for detecting that our about:blank reset has been completed.
 * @param {LH.Gatherer.FRProtocolSession} session
 * @return {CancellableWait}
 */
function waitForFrameNavigated(session) {
  /** @type {(() => void)} */
  let cancel = () => {
    throw new Error('waitForFrameNavigated.cancel() called before it was defined');
  };

  const promise = new Promise((resolve, reject) => {
    session.once('Page.frameNavigated', resolve);
    cancel = () => {
      session.off('Page.frameNavigated', resolve);
      reject(new Error('Wait for navigated cancelled'));
    };
  });

  return {promise, cancel};
}

/**
 * Returns a promise that resolve when a frame has a FCP.
 * @param {LH.Gatherer.FRProtocolSession} session
 * @param {number} pauseAfterFcpMs
 * @param {number} maxWaitForFcpMs
 * @return {CancellableWait}
 */
function waitForFcp(session, pauseAfterFcpMs, maxWaitForFcpMs) {
  /** @type {(() => void)} */
  let cancel = () => {
    throw new Error('waitForFcp.cancel() called before it was defined');
  };

  /** @type {Promise<void>} */
  const promise = new Promise((resolve, reject) => {
    const maxWaitTimeout = setTimeout(() => {
      reject(new LHError(LHError.errors.NO_FCP));
    }, maxWaitForFcpMs);
    /** @type {NodeJS.Timeout|undefined} */
    let loadTimeout;

    /** @param {LH.Crdp.Page.LifecycleEventEvent} e */
    const lifecycleListener = e => {
      if (e.name === 'firstContentfulPaint') {
        loadTimeout = setTimeout(() => {
          resolve();
          cancel();
        }, pauseAfterFcpMs);
      }
    };

    session.on('Page.lifecycleEvent', lifecycleListener);

    let canceled = false;
    cancel = () => {
      if (canceled) return;
      canceled = true;
      session.off('Page.lifecycleEvent', lifecycleListener);
      maxWaitTimeout && clearTimeout(maxWaitTimeout);
      loadTimeout && clearTimeout(loadTimeout);
      reject(new Error('Wait for FCP canceled'));
    };
  });

  return {
    promise,
    cancel,
  };
}

/**
 * Returns a promise that resolves when the network has been idle (after DCL) for
 * `networkQuietThresholdMs` ms and a method to cancel internal network listeners/timeout.
 * @param {LH.Gatherer.FRProtocolSession} session
 * @param {NetworkMonitor} networkMonitor
 * @param {{networkQuietThresholdMs: number, busyEvent: NetworkMonitorEvent, idleEvent: NetworkMonitorEvent, isIdle(recorder: NetworkMonitor): boolean}} networkQuietOptions
 * @return {CancellableWait}
 */
function waitForNetworkIdle(session, networkMonitor, networkQuietOptions) {
  let hasDCLFired = false;
  /** @type {NodeJS.Timer|undefined} */
  let idleTimeout;
  /** @type {(() => void)} */
  let cancel = () => {
    throw new Error('waitForNetworkIdle.cancel() called before it was defined');
  };

  const {networkQuietThresholdMs, busyEvent, idleEvent, isIdle} = networkQuietOptions;

  /** @type {Promise<void>} */
  const promise = new Promise((resolve, reject) => {
    const onIdle = () => {
      // eslint-disable-next-line no-use-before-define
      networkMonitor.once(busyEvent, onBusy);
      idleTimeout = setTimeout(() => {
        cancel();
        resolve();
      }, networkQuietThresholdMs);
    };

    const onBusy = () => {
      networkMonitor.once(idleEvent, onIdle);
      idleTimeout && clearTimeout(idleTimeout);
    };

    const domContentLoadedListener = () => {
      hasDCLFired = true;
      if (isIdle(networkMonitor)) {
        onIdle();
      } else {
        onBusy();
      }
    };

    // We frequently need to debug why LH is still waiting for the page.
    // This listener is added to all network events to verbosely log what URLs we're waiting on.
    const logStatus = () => {
      if (!hasDCLFired) {
        log.verbose('waitFor', 'Waiting on DomContentLoaded');
        return;
      }

      const inflightRecords = networkMonitor.getInflightRequests();
      // If there are more than 20 inflight requests, load is still in full swing.
      // Wait until it calms down a bit to be a little less spammy.
      if (inflightRecords.length < 20) {
        for (const record of inflightRecords) {
          log.verbose('waitFor', `Waiting on ${record.url.slice(0, 120)} to finish`);
        }
      }
    };

    networkMonitor.on('requeststarted', logStatus);
    networkMonitor.on('requestloaded', logStatus);
    networkMonitor.on(busyEvent, logStatus);

    session.once('Page.domContentEventFired', domContentLoadedListener);
    let canceled = false;
    cancel = () => {
      if (canceled) return;
      canceled = true;
      idleTimeout && clearTimeout(idleTimeout);
      session.off('Page.domContentEventFired', domContentLoadedListener);
      networkMonitor.removeListener(busyEvent, onBusy);
      networkMonitor.removeListener(idleEvent, onIdle);
      networkMonitor.removeListener('requeststarted', logStatus);
      networkMonitor.removeListener('requestloaded', logStatus);
      networkMonitor.removeListener(busyEvent, logStatus);
    };
  });

  return {
    promise,
    cancel,
  };
}

/**
 * Resolves when there have been no long tasks for at least waitForCPUQuiet ms.
 * @param {LH.Gatherer.FRProtocolSession} session
 * @param {number} waitForCPUQuiet
 * @return {CancellableWait}
 */
function waitForCPUIdle(session, waitForCPUQuiet) {
  if (!waitForCPUQuiet) {
    return {
      promise: Promise.resolve(),
      cancel: () => undefined,
    };
  }

  /** @type {NodeJS.Timer|undefined} */
  let lastTimeout;
  let canceled = false;

  /**
   * @param {ExecutionContext} executionContext
   * @param {() => void} resolve
   * @return {Promise<void>}
   */
  async function checkForQuiet(executionContext, resolve) {
    if (canceled) return;
    const timeSinceLongTask =
      await executionContext.evaluate(checkTimeSinceLastLongTaskInPage, {args: []});
    if (canceled) return;

    if (typeof timeSinceLongTask === 'number') {
      if (timeSinceLongTask >= waitForCPUQuiet) {
        log.verbose('waitFor', `CPU has been idle for ${timeSinceLongTask} ms`);
        resolve();
      } else {
        log.verbose('waitFor', `CPU has been idle for ${timeSinceLongTask} ms`);
        const timeToWait = waitForCPUQuiet - timeSinceLongTask;
        lastTimeout = setTimeout(() => checkForQuiet(executionContext, resolve), timeToWait);
      }
    }
  }

  /** @type {(() => void)} */
  let cancel = () => {
    throw new Error('waitForCPUIdle.cancel() called before it was defined');
  };

  const executionContext = new ExecutionContext(session);
  /** @type {Promise<void>} */
  const promise = new Promise((resolve, reject) => {
    executionContext.evaluate(registerPerformanceObserverInPage, {args: []})
      .then(() => checkForQuiet(executionContext, resolve))
      .catch(reject);
    cancel = () => {
      if (canceled) return;
      canceled = true;
      if (lastTimeout) clearTimeout(lastTimeout);
      reject(new Error('Wait for CPU idle canceled'));
    };
  });

  return {
    promise,
    cancel,
  };
}

/* c8 ignore start */

/**
 * This function is executed in the page itself when the document is first loaded.
 *
 * Used by _waitForCPUIdle and executed in the context of the page, updates the ____lastLongTask
 * property on window to the end time of the last long task.
 */
function registerPerformanceObserverInPage() {
  // Do not re-register if we've already run this script.
  if (window.____lastLongTask !== undefined) return;

  window.____lastLongTask = performance.now();
  const observer = new window.PerformanceObserver(entryList => {
    const entries = entryList.getEntries();
    for (const entry of entries) {
      if (entry.entryType === 'longtask') {
        const taskEnd = entry.startTime + entry.duration;
        window.____lastLongTask = Math.max(window.____lastLongTask || 0, taskEnd);
      }
    }
  });

  observer.observe({type: 'longtask', buffered: true});
}

/**
 * This function is executed in the page itself.
 *
 * Used by _waitForCPUIdle and executed in the context of the page, returns time since last long task.
 * @return {Promise<number>}
 */
function checkTimeSinceLastLongTaskInPage() {
  // This function attempts to return the time since the last long task occurred.
  // `PerformanceObserver`s don't always immediately fire though, so we check twice with some time in
  // between to make sure nothing has happened very recently.

  // Chrome 88 introduced heavy throttling of timers which means our `setTimeout` will be executed
  // at some point farish (several hundred ms) into the future and the time at which it executes isn't
  // a reliable indicator of long task existence, instead we check if any information has changed.
  // See https://developer.chrome.com/blog/timer-throttling-in-chrome-88/
  return new Promise(resolve => {
    const firstAttemptTs = performance.now();
    const firstAttemptLastLongTaskTs = window.____lastLongTask || 0;

    setTimeout(() => {
      // We can't be sure a long task hasn't occurred since our first attempt, but if the `____lastLongTask`
      // value is the same (i.e. the perf observer didn't have any new information), we can be pretty
      // confident that the long task info was accurate *at the time of our first attempt*.
      const secondAttemptLastLongTaskTs = window.____lastLongTask || 0;
      const timeSinceLongTask =
        firstAttemptLastLongTaskTs === secondAttemptLastLongTaskTs
          ? // The time of the last long task hasn't changed, the information from our first attempt is accurate.
            firstAttemptTs - firstAttemptLastLongTaskTs
          : // The time of the last long task *did* change, we can't really trust the information we have.
            0;
      resolve(timeSinceLongTask);
    }, 150);
  });
}

/* c8 ignore stop */

/**
 * Return a promise that resolves `pauseAfterLoadMs` after the load event
 * fires and a method to cancel internal listeners and timeout.
 * @param {LH.Gatherer.FRProtocolSession} session
 * @param {number} pauseAfterLoadMs
 * @return {CancellableWait}
 */
function waitForLoadEvent(session, pauseAfterLoadMs) {
  /** @type {(() => void)} */
  let cancel = () => {
    throw new Error('waitForLoadEvent.cancel() called before it was defined');
  };

  const promise = new Promise((resolve, reject) => {
    /** @type {NodeJS.Timer|undefined} */
    let loadTimeout;
    const loadListener = function() {
      loadTimeout = setTimeout(resolve, pauseAfterLoadMs);
    };
    session.once('Page.loadEventFired', loadListener);

    let canceled = false;
    cancel = () => {
      if (canceled) return;
      canceled = true;
      session.off('Page.loadEventFired', loadListener);
      loadTimeout && clearTimeout(loadTimeout);
    };
  });

  return {
    promise,
    cancel,
  };
}

/**
 * Returns whether the page appears to be hung.
 * @param {LH.Gatherer.FRProtocolSession} session
 * @return {Promise<boolean>}
 */
async function isPageHung(session) {
  try {
    session.setNextProtocolTimeout(1000);
    await session.sendCommand('Runtime.evaluate', {
      expression: '"ping"',
      returnByValue: true,
      timeout: 1000,
    });

    return false;
  } catch (err) {
    return true;
  }
}

/** @type {Required<WaitOptions>['_waitForTestOverrides']} */
const DEFAULT_WAIT_FUNCTIONS = {waitForFcp, waitForLoadEvent, waitForCPUIdle, waitForNetworkIdle};

/**
 * Returns a promise that resolves when:
 * - All of the following conditions have been met:
 *    - page has no security issues
 *    - pauseAfterLoadMs milliseconds have passed since the load event.
 *    - networkQuietThresholdMs milliseconds have passed since the last network request that exceeded
 *      2 inflight requests (network-2-quiet has been reached).
 *    - cpuQuietThresholdMs have passed since the last long task after network-2-quiet.
 * - maxWaitForLoadedMs milliseconds have passed.
 * See https://github.com/GoogleChrome/lighthouse/issues/627 for more.
 * @param {LH.Gatherer.FRProtocolSession} session
 * @param {NetworkMonitor} networkMonitor
 * @param {WaitOptions} options
 * @return {Promise<{timedOut: boolean}>}
 */
async function waitForFullyLoaded(session, networkMonitor, options) {
  const {pauseAfterFcpMs, pauseAfterLoadMs, networkQuietThresholdMs,
    cpuQuietThresholdMs, maxWaitForLoadedMs, maxWaitForFcpMs} = options;
  const {waitForFcp, waitForLoadEvent, waitForNetworkIdle, waitForCPUIdle} =
    options._waitForTestOverrides || DEFAULT_WAIT_FUNCTIONS;
  /** @type {NodeJS.Timer|undefined} */
  let maxTimeoutHandle;

  // Listener for FCP. Resolves pauseAfterFcpMs ms after first FCP event.
  const resolveOnFcp = maxWaitForFcpMs ?
    waitForFcp(session, pauseAfterFcpMs, maxWaitForFcpMs) :
    waitForNothing();
  // Listener for onload. Resolves pauseAfterLoadMs ms after load.
  const resolveOnLoadEvent = waitForLoadEvent(session, pauseAfterLoadMs);
  // General network listener. Resolves when the network has been 2-idle for networkQuietThresholdMs.
  const resolveOnNetworkIdle = waitForNetworkIdle(session, networkMonitor, {
    networkQuietThresholdMs,
    busyEvent: 'network-2-busy',
    idleEvent: 'network-2-idle',
    isIdle: recorder => recorder.is2Idle(),
  });
  // Critical network listener. Resolves when the network has had 0 critical requests for networkQuietThresholdMs.
  const resolveOnCriticalNetworkIdle = waitForNetworkIdle(session, networkMonitor, {
    networkQuietThresholdMs,
    busyEvent: 'network-critical-busy',
    idleEvent: 'network-critical-idle',
    isIdle: recorder => recorder.isCriticalIdle(),
  });
  // CPU listener. Resolves when the CPU has been idle for cpuQuietThresholdMs after network idle.
  let resolveOnCPUIdle = waitForNothing();

  // Wait for all initial load promises. Resolves on cleanup function the clears load
  // timeout timer.
  /** @type {Promise<() => Promise<{timedOut: boolean}>>} */
  const loadPromise = Promise.all([
    resolveOnFcp.promise,
    resolveOnLoadEvent.promise,
    resolveOnNetworkIdle.promise,
    resolveOnCriticalNetworkIdle.promise,
  ]).then(() => {
    resolveOnCPUIdle = waitForCPUIdle(session, cpuQuietThresholdMs);
    return resolveOnCPUIdle.promise;
  }).then(() => {
    /** @return {Promise<{timedOut: boolean}>} */
    const cleanupFn = async function() {
      log.verbose('waitFor', 'loadEventFired and network considered idle');
      return {timedOut: false};
    };

    return cleanupFn;
  }).catch(err => {
    // Throw the error in the cleanupFn so we still cleanup all our handlers.
    return function() {
      throw err;
    };
  });

  // Last resort timeout. Resolves maxWaitForLoadedMs ms from now on
  // cleanup function that removes loadEvent and network idle listeners.
  /** @type {Promise<() => Promise<{timedOut: boolean}>>} */
  const maxTimeoutPromise = new Promise((resolve, reject) => {
    maxTimeoutHandle = setTimeout(resolve, maxWaitForLoadedMs);
  }).then(_ => {
    return async () => {
      log.warn('waitFor', 'Timed out waiting for page load. Checking if page is hung...');
      if (await isPageHung(session)) {
        log.warn('waitFor', 'Page appears to be hung, killing JavaScript...');
        await session.sendCommand('Emulation.setScriptExecutionDisabled', {value: true});
        await session.sendCommand('Runtime.terminateExecution');
        throw new LHError(LHError.errors.PAGE_HUNG);
      }

      return {timedOut: true};
    };
  });

  // Wait for load or timeout and run the cleanup function the winner returns.
  const cleanupFn = await Promise.race([
    loadPromise,
    maxTimeoutPromise,
  ]);

  maxTimeoutHandle && clearTimeout(maxTimeoutHandle);
  resolveOnFcp.cancel();
  resolveOnLoadEvent.cancel();
  resolveOnNetworkIdle.cancel();
  resolveOnCPUIdle.cancel();

  return cleanupFn();
}

module.exports = {
  waitForNothing,
  waitForFrameNavigated,
  waitForFcp,
  waitForLoadEvent,
  waitForNetworkIdle,
  waitForCPUIdle,
  waitForFullyLoaded,
};

},{"../../lib/lh-error.js":103,"./execution-context.js":67,"lighthouse-logger":188}],75:[function(require,module,exports){
(function (Buffer){(function (){
/**
 * @license Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.
 */
'use strict';

/**
 * @fileoverview Fetcher is a utility for making requests within the context of the page.
 * Requests can circumvent CORS, and so are good for fetching source maps that may be hosted
 * on a different origin.
 */

/* global document */

/** @typedef {{content: string|null, status: number|null}} FetchResponse */

const log = require('lighthouse-logger');
const {getBrowserVersion} = require('./driver/environment.js');

class Fetcher {
  /**
   * @param {LH.Gatherer.FRProtocolSession} session
   * @param {import('./driver/execution-context.js')} executionContext
   */
  constructor(session, executionContext) {
    this.session = session;
    this.executionContext = executionContext;
    /** @type {Map<string, (event: LH.Crdp.Fetch.RequestPausedEvent) => void>} */
    this._onRequestPausedHandlers = new Map();
    this._onRequestPaused = this._onRequestPaused.bind(this);
    this._enabled = false;
  }

  /**
   * Chrome M92 and above:
   * We use `Network.loadNetworkResource` to fetch each resource.
   *
   * Chrome <M92:
   * The Fetch domain accepts patterns for controlling what requests are intercepted, but we
   * enable the domain for all patterns and filter events at a lower level to support multiple
   * concurrent usages. Reasons for this:
   *
   * 1) only one set of patterns may be applied for the entire domain.
   * 2) every request that matches the patterns are paused and only resumes when certain Fetch
   *    commands are sent. So a listener of the `Fetch.requestPaused` event must either handle
   *    the requests it cares about, or explicitly allow them to continue.
   * 3) if multiple commands to continue the same request are sent, protocol errors occur.
   *
   * So instead we have one global `Fetch.enable` / `Fetch.requestPaused` pair, and allow specific
   * urls to be intercepted via `fetcher._setOnRequestPausedHandler`.
   */
  async enable() {
    if (this._enabled) return;

    this._enabled = true;
    await this.session.sendCommand('Fetch.enable', {
      patterns: [{requestStage: 'Request'}, {requestStage: 'Response'}],
    });
    await this.session.on('Fetch.requestPaused', this._onRequestPaused);
  }

  async disable() {
    if (!this._enabled) return;

    this._enabled = false;
    await this.session.off('Fetch.requestPaused', this._onRequestPaused);
    await this.session.sendCommand('Fetch.disable');
    this._onRequestPausedHandlers.clear();
  }

  /**
   * @param {string} url
   * @param {(event: LH.Crdp.Fetch.RequestPausedEvent) => void} handler
   */
  async _setOnRequestPausedHandler(url, handler) {
    this._onRequestPausedHandlers.set(url, handler);
  }

  /**
   * @param {LH.Crdp.Fetch.RequestPausedEvent} event
   */
  _onRequestPaused(event) {
    const handler = this._onRequestPausedHandlers.get(event.request.url);
    if (handler) {
      handler(event);
    } else {
      // Nothing cares about this URL, so continue.
      this.session.sendCommand('Fetch.continueRequest', {requestId: event.requestId}).catch(err => {
        log.error('Fetcher', `Failed to continueRequest: ${err.message}`);
      });
    }
  }

  /**
   * Requires that `fetcher.enable` has been called.
   *
   * Fetches any resource in a way that circumvents CORS.
   *
   * @param {string} url
   * @param {{timeout: number}=} options timeout is in ms
   * @return {Promise<FetchResponse>}
   */
  async fetchResource(url, options = {timeout: 500}) {
    if (!this._enabled) {
      throw new Error('Must call `enable` before using fetchResource');
    }

    // `Network.loadNetworkResource` was introduced in M88.
    // The long timeout bug with `IO.read` was fixed in M92:
    // https://bugs.chromium.org/p/chromium/issues/detail?id=1191757
    const {milestone} = await getBrowserVersion(this.session);
    if (milestone >= 92) {
      return await this._fetchResourceOverProtocol(url, options);
    }
    return await this._fetchResourceIframe(url, options);
  }

  /**
   * @param {string} handle
   * @param {{timeout: number}=} options,
   * @return {Promise<string>}
   */
  async _readIOStream(handle, options = {timeout: 500}) {
    const startTime = Date.now();

    let ioResponse;
    let data = '';
    while (!ioResponse || !ioResponse.eof) {
      const elapsedTime = Date.now() - startTime;
      if (elapsedTime > options.timeout) {
        throw new Error('Waiting for the end of the IO stream exceeded the allotted time.');
      }
      ioResponse = await this.session.sendCommand('IO.read', {handle});
      const responseData = ioResponse.base64Encoded ?
        Buffer.from(ioResponse.data, 'base64').toString('utf-8') :
        ioResponse.data;
      data = data.concat(responseData);
    }

    return data;
  }

  /**
   * @param {string} url
   * @return {Promise<{stream: LH.Crdp.IO.StreamHandle|null, status: number|null}>}
   */
  async _loadNetworkResource(url) {
    const frameTreeResponse = await this.session.sendCommand('Page.getFrameTree');
    const networkResponse = await this.session.sendCommand('Network.loadNetworkResource', {
      frameId: frameTreeResponse.frameTree.frame.id,
      url,
      options: {
        disableCache: true,
        includeCredentials: true,
      },
    });

    return {
      stream: networkResponse.resource.success ? (networkResponse.resource.stream || null) : null,
      status: networkResponse.resource.httpStatusCode || null,
    };
  }

  /**
   * @param {string} requestId
   * @return {Promise<string>}
   */
  async _resolveResponseBody(requestId) {
    const responseBody = await this.session.sendCommand('Fetch.getResponseBody', {requestId});
    if (responseBody.base64Encoded) {
      return Buffer.from(responseBody.body, 'base64').toString();
    }
    return responseBody.body;
  }

  /**
   * @param {string} url
   * @param {{timeout: number}} options timeout is in ms
   * @return {Promise<FetchResponse>}
   */
  async _fetchResourceOverProtocol(url, options) {
    const startTime = Date.now();

    /** @type {NodeJS.Timeout} */
    let timeoutHandle;
    const timeoutPromise = new Promise((_, reject) => {
      timeoutHandle = setTimeout(() => {
        reject(new Error('Timed out fetching resource'));
      }, options.timeout);
    });

    const responsePromise = this._loadNetworkResource(url);

    /** @type {{stream: LH.Crdp.IO.StreamHandle|null, status: number|null}} */
    const response = await Promise.race([responsePromise, timeoutPromise])
      .finally(() => clearTimeout(timeoutHandle));

    const isOk = response.status && response.status >= 200 && response.status <= 299;
    if (!response.stream || !isOk) return {status: response.status, content: null};

    const timeout = options.timeout - (Date.now() - startTime);
    const content = await this._readIOStream(response.stream, {timeout});
    return {status: response.status, content};
  }

  /**
   * Fetches resource by injecting an iframe into the page.
   * @param {string} url
   * @param {{timeout: number}} options timeout is in ms
   * @return {Promise<FetchResponse>}
   */
  async _fetchResourceIframe(url, options) {
    /** @type {Promise<FetchResponse>} */
    const requestInterceptionPromise = new Promise((resolve, reject) => {
      /** @param {LH.Crdp.Fetch.RequestPausedEvent} event */
      const handlerAsync = async event => {
        const {requestId, responseStatusCode} = event;

        // The first requestPaused event is for the request stage. Continue it.
        if (!responseStatusCode) {
          // Remove cookies so we aren't buying stuff on Amazon.
          const headers = Object.entries(event.request.headers)
            .filter(([name]) => name !== 'Cookie')
            .map(([name, value]) => {
              return {name, value};
            });

          await this.session.sendCommand('Fetch.continueRequest', {
            requestId,
            headers,
          });
          return;
        }

        if (responseStatusCode >= 200 && responseStatusCode <= 299) {
          resolve({
            status: responseStatusCode,
            content: await this._resolveResponseBody(requestId),
          });
        } else {
          resolve({status: responseStatusCode, content: null});
        }

        // Fail the request (from the page's perspective) so that the iframe never loads.
        await this.session.sendCommand('Fetch.failRequest', {requestId, errorReason: 'Aborted'});
      };
      this._setOnRequestPausedHandler(url, event => handlerAsync(event).catch(reject));
    });

    /**
     * @param {string} src
     */
    /* c8 ignore start */
    function injectIframe(src) {
      const iframe = document.createElement('iframe');
      // Try really hard not to affect the page.
      iframe.style.display = 'none';
      iframe.style.visibility = 'hidden';
      iframe.style.position = 'absolute';
      iframe.style.top = '-1000px';
      iframe.style.left = '-1000px';
      iframe.style.width = '1px';
      iframe.style.height = '1px';
      iframe.src = src;
      iframe.onload = iframe.onerror = () => {
        iframe.remove();
        iframe.onload = null;
        iframe.onerror = null;
      };
      document.body.appendChild(iframe);
    }
    /* c8 ignore stop */

    /** @type {NodeJS.Timeout} */
    let timeoutHandle;
    /** @type {Promise<never>} */
    const timeoutPromise = new Promise((_, reject) => {
      const errorMessage = 'Timed out fetching resource.';
      timeoutHandle = setTimeout(() => reject(new Error(errorMessage)), options.timeout);
    });

    const racePromise = Promise.race([
      timeoutPromise,
      requestInterceptionPromise,
    ]).finally(() => clearTimeout(timeoutHandle));

    // Temporarily disable auto-attaching for this iframe.
    await this.session.sendCommand('Target.setAutoAttach', {
      autoAttach: false,
      waitForDebuggerOnStart: false,
    });

    const injectionPromise = this.executionContext.evaluate(injectIframe, {
      args: [url],
      useIsolation: true,
    });

    const [fetchResult] = await Promise.all([racePromise, injectionPromise]);

    await this.session.sendCommand('Target.setAutoAttach', {
      flatten: true,
      autoAttach: true,
      waitForDebuggerOnStart: true,
    });

    return fetchResult;
  }
}

module.exports = Fetcher;

}).call(this)}).call(this,require("buffer").Buffer)
},{"./driver/environment.js":66,"buffer":145,"lighthouse-logger":188}],76:[function(require,module,exports){
/**
 * @license Copyright 2016 The Lighthouse Authors. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.
 */
'use strict';

const log = require('lighthouse-logger');
const NetworkRecords = require('../computed/network-records.js');
const {getPageLoadError} = require('../lib/navigation-error.js');
const emulation = require('../lib/emulation.js');
const constants = require('../config/constants.js');
const i18n = require('../lib/i18n/i18n.js');
const {getBenchmarkIndex, getEnvironmentWarnings} = require('./driver/environment.js');
const prepare = require('./driver/prepare.js');
const storage = require('./driver/storage.js');
const navigation = require('./driver/navigation.js');
const serviceWorkers = require('./driver/service-workers.js');
const WebAppManifest = require('./gatherers/web-app-manifest.js');
const InstallabilityErrors = require('./gatherers/installability-errors.js');
const NetworkUserAgent = require('./gatherers/network-user-agent.js');
const Stacks = require('./gatherers/stacks.js');
const {finalizeArtifacts} = require('../fraggle-rock/gather/base-artifacts.js');

/** @typedef {import('../gather/driver.js')} Driver */
/** @typedef {import('../lib/arbitrary-equality-map.js')} ArbitraryEqualityMap */

/**
 * Each entry in each gatherer result array is the output of a gatherer phase:
 * `beforePass`, `pass`, and `afterPass`. Flattened into an `LH.Artifacts` in
 * `collectArtifacts`.
 * @typedef {Record<keyof LH.GathererArtifacts, Array<LH.Gatherer.PhaseResult>>} GathererResults
 */
/** @typedef {Array<[keyof GathererResults, GathererResults[keyof GathererResults]]>} GathererResultsEntries */

/**
 * Class that drives browser to load the page and runs gatherer lifecycle hooks.
 */
class GatherRunner {
  /**
   * Loads about:blank and waits there briefly. Since a Page.reload command does
   * not let a service worker take over, we navigate away and then come back to
   * reload. We do not `waitForLoad` on about:blank since a page load event is
   * never fired on it.
   * @param {Driver} driver
   * @param {string=} url
   * @return {Promise<void>}
   */
  static async loadBlank(driver, url = constants.defaultPassConfig.blankPage) {
    const status = {msg: 'Resetting state with about:blank', id: 'lh:gather:loadBlank'};
    log.time(status);
    await navigation.gotoURL(driver, url, {waitUntil: ['navigated']});
    log.timeEnd(status);
  }

  /**
   * Loads options.url with specified options. If the main document URL
   * redirects, options.url will be updated accordingly. As such, options.url
   * will always represent the post-redirected URL. options.requestedUrl is the
   * pre-redirect starting URL. If the navigation errors with "expected" errors such as
   * NO_FCP, a `navigationError` is returned.
   * @param {Driver} driver
   * @param {LH.Gatherer.PassContext} passContext
   * @return {Promise<{navigationError?: LH.LighthouseError}>}
   */
  static async loadPage(driver, passContext) {
    const status = {
      msg: 'Loading page & waiting for onload',
      id: `lh:gather:loadPage-${passContext.passConfig.passName}`,
    };
    log.time(status);
    try {
      const requestedUrl = passContext.url;
      const {finalUrl, warnings} = await navigation.gotoURL(driver, requestedUrl, {
        waitUntil: passContext.passConfig.recordTrace ?
          ['load', 'fcp'] : ['load'],
        maxWaitForFcp: passContext.settings.maxWaitForFcp,
        maxWaitForLoad: passContext.settings.maxWaitForLoad,
        ...passContext.passConfig,
      });
      passContext.url = finalUrl;
      if (passContext.passConfig.loadFailureMode === 'fatal') {
        passContext.LighthouseRunWarnings.push(...warnings);
      }
    } catch (err) {
      // If it's one of our loading-based LHErrors, we'll treat it as a page load error.
      if (err.code === 'NO_FCP' || err.code === 'PAGE_HUNG') {
        return {navigationError: err};
      }

      throw err;
    } finally {
      log.timeEnd(status);
    }

    return {};
  }

  /**
   * Rejects if any open tabs would share a service worker with the target URL.
   * This includes the target tab, so navigation to something like about:blank
   * should be done before calling.
   * @param {LH.Gatherer.FRProtocolSession} session
   * @param {string} pageUrl
   * @return {Promise<void>}
   */
  static assertNoSameOriginServiceWorkerClients(session, pageUrl) {
    /** @type {Array<LH.Crdp.ServiceWorker.ServiceWorkerRegistration>} */
    let registrations;
    /** @type {Array<LH.Crdp.ServiceWorker.ServiceWorkerVersion>} */
    let versions;

    return serviceWorkers.getServiceWorkerRegistrations(session)
      .then(data => {
        registrations = data.registrations;
      })
      .then(_ => serviceWorkers.getServiceWorkerVersions(session))
      .then(data => {
        versions = data.versions;
      })
      .then(_ => {
        const origin = new URL(pageUrl).origin;

        registrations
          .filter(reg => {
            const swOrigin = new URL(reg.scopeURL).origin;

            return origin === swOrigin;
          })
          .forEach(reg => {
            versions.forEach(ver => {
              // Ignore workers unaffiliated with this registration
              if (ver.registrationId !== reg.registrationId) {
                return;
              }

              // Throw if service worker for this origin has active controlledClients.
              if (ver.controlledClients && ver.controlledClients.length > 0) {
                throw new Error('You probably have multiple tabs open to the same origin.');
              }
            });
          });
      });
  }

  /**
   * @param {Driver} driver
   * @param {{requestedUrl: string, settings: LH.Config.Settings}} options
   * @return {Promise<void>}
   */
  static async setupDriver(driver, options) {
    const status = {msg: 'Initializing…', id: 'lh:gather:setupDriver'};
    log.time(status);
    const session = driver.defaultSession;

    // Assert no service workers are still installed, so we test that they would actually be installed for a new user.
    // TODO(FR-COMPAT): re-evaluate the necessity of this check
    await GatherRunner.assertNoSameOriginServiceWorkerClients(session, options.requestedUrl);

    await prepare.prepareTargetForNavigationMode(driver, options.settings);

    log.timeEnd(status);
  }

  /**
   * Reset browser state where needed and release the connection.
   * @param {Driver} driver
   * @param {{requestedUrl: string, settings: LH.Config.Settings}} options
   * @return {Promise<void>}
   */
  static async disposeDriver(driver, options) {
    const status = {msg: 'Disconnecting from browser...', id: 'lh:gather:disconnect'};

    log.time(status);
    try {
      // If storage was cleared for the run, clear at the end so Lighthouse specifics aren't cached.
      const session = driver.defaultSession;
      const resetStorage = !options.settings.disableStorageReset;
      if (resetStorage) await storage.clearDataForOrigin(session, options.requestedUrl);

      // Disable fetcher, in case a gatherer enabled it.
      // This cleanup should be removed once the only usage of
      // fetcher (fetching arbitrary URLs) is replaced by new protocol support.
      await driver.fetcher.disable();

      await driver.disconnect();
    } catch (err) {
      // Ignore disconnecting error if browser was already closed.
      // See https://github.com/GoogleChrome/lighthouse/issues/1583
      if (!(/close\/.*status: (500|404)$/.test(err.message))) {
        log.error('GatherRunner disconnect', err.message);
      }
    }
    log.timeEnd(status);
  }

  /**
   * Beging recording devtoolsLog and trace (if requested).
   * @param {LH.Gatherer.PassContext} passContext
   * @return {Promise<void>}
   */
  static async beginRecording(passContext) {
    const status = {msg: 'Beginning devtoolsLog and trace', id: 'lh:gather:beginRecording'};
    log.time(status);

    const {driver, passConfig, settings} = passContext;

    // Always record devtoolsLog
    await driver.beginDevtoolsLog();

    if (passConfig.recordTrace) {
      await driver.beginTrace(settings);
    }

    log.timeEnd(status);
  }

  /**
   * End recording devtoolsLog and trace (if requested), returning an
   * `LH.Gatherer.LoadData` with the recorded data.
   * @param {LH.Gatherer.PassContext} passContext
   * @return {Promise<LH.Gatherer.LoadData>}
   */
  static async endRecording(passContext) {
    const {driver, passConfig} = passContext;

    let trace;
    if (passConfig.recordTrace) {
      const status = {msg: 'Gathering trace', id: `lh:gather:getTrace`};
      log.time(status);
      trace = await driver.endTrace();
      log.timeEnd(status);
    }

    const status = {
      msg: 'Gathering devtoolsLog & network records',
      id: `lh:gather:getDevtoolsLog`,
    };
    log.time(status);
    const devtoolsLog = driver.endDevtoolsLog();
    const networkRecords = await NetworkRecords.request(devtoolsLog, passContext);
    log.timeEnd(status);

    return {
      networkRecords,
      devtoolsLog,
      trace,
    };
  }

  /**
   * Run beforePass() on gatherers.
   * @param {LH.Gatherer.PassContext} passContext
   * @param {Partial<GathererResults>} gathererResults
   * @return {Promise<void>}
   */
  static async beforePass(passContext, gathererResults) {
    const bpStatus = {msg: `Running beforePass methods`, id: `lh:gather:beforePass`};
    log.time(bpStatus, 'verbose');

    for (const gathererDefn of passContext.passConfig.gatherers) {
      const gatherer = gathererDefn.instance;
      const status = {
        msg: `Gathering setup: ${gatherer.name}`,
        id: `lh:gather:beforePass:${gatherer.name}`,
      };
      log.time(status, 'verbose');
      const artifactPromise = Promise.resolve().then(_ => gatherer.beforePass(passContext));
      gathererResults[gatherer.name] = [artifactPromise];
      await artifactPromise.catch(() => {});
      log.timeEnd(status);
    }
    log.timeEnd(bpStatus);
  }

  /**
   * Run pass() on gatherers.
   * @param {LH.Gatherer.PassContext} passContext
   * @param {Partial<GathererResults>} gathererResults
   * @return {Promise<void>}
   */
  static async pass(passContext, gathererResults) {
    const config = passContext.passConfig;
    const gatherers = config.gatherers;

    const pStatus = {msg: `Running pass methods`, id: `lh:gather:pass`};
    log.time(pStatus, 'verbose');

    for (const gathererDefn of gatherers) {
      const gatherer = gathererDefn.instance;
      const status = {
        msg: `Gathering in-page: ${gatherer.name}`,
        id: `lh:gather:pass:${gatherer.name}`,
      };
      log.time(status);
      const artifactPromise = Promise.resolve().then(_ => gatherer.pass(passContext));

      const gathererResult = gathererResults[gatherer.name] || [];
      gathererResult.push(artifactPromise);
      gathererResults[gatherer.name] = gathererResult;
      await artifactPromise.catch(() => {});
    }

    log.timeEnd(pStatus);
  }

  /**
   * Run afterPass() on gatherers.
   * @param {LH.Gatherer.PassContext} passContext
   * @param {LH.Gatherer.LoadData} loadData
   * @param {Partial<GathererResults>} gathererResults
   * @return {Promise<void>}
   */
  static async afterPass(passContext, loadData, gathererResults) {
    const driver = passContext.driver;
    const config = passContext.passConfig;
    const gatherers = config.gatherers;

    const apStatus = {msg: `Running afterPass methods`, id: `lh:gather:afterPass`};
    log.time(apStatus, 'verbose');

    // Some gatherers scroll the page which can cause unexpected results for other gatherers.
    // We reset the scroll position in between each gatherer.
    const scrollPosition = await driver.getScrollPosition();

    for (const gathererDefn of gatherers) {
      const gatherer = gathererDefn.instance;
      const status = {
        msg: `Gathering: ${gatherer.name}`,
        id: `lh:gather:afterPass:${gatherer.name}`,
      };
      log.time(status);

      const artifactPromise = Promise.resolve()
        .then(_ => gatherer.afterPass(passContext, loadData));

      const gathererResult = gathererResults[gatherer.name] || [];
      gathererResult.push(artifactPromise);
      gathererResults[gatherer.name] = gathererResult;
      await artifactPromise.catch(() => {});
      await driver.scrollTo(scrollPosition);
      log.timeEnd(status);
    }
    log.timeEnd(apStatus);
  }

  /**
   * Takes the results of each gatherer phase for each gatherer and uses the
   * last produced value (that's not undefined) as the artifact for that
   * gatherer. If an error was rejected from a gatherer phase,
   * uses that error object as the artifact instead.
   * @param {Partial<GathererResults>} gathererResults
   * @return {Promise<{artifacts: Partial<LH.GathererArtifacts>}>}
   */
  static async collectArtifacts(gathererResults) {
    /** @type {Partial<LH.GathererArtifacts>} */
    const gathererArtifacts = {};

    const resultsEntries = /** @type {GathererResultsEntries} */ (Object.entries(gathererResults));
    for (const [gathererName, phaseResultsPromises] of resultsEntries) {
      try {
        const phaseResults = await Promise.all(phaseResultsPromises);
        // Take the last defined pass result as artifact. If none are defined, the undefined check below handles it.
        const definedResults = phaseResults.filter(element => element !== undefined);
        const artifact = definedResults[definedResults.length - 1];
        // @ts-expect-error tsc can't yet express that gathererName is only a single type in each iteration, not a union of types.
        gathererArtifacts[gathererName] = artifact;
      } catch (err) {
        // Return error to runner to handle turning it into an error audit.
        gathererArtifacts[gathererName] = err;
      }

      if (gathererArtifacts[gathererName] === undefined) {
        throw new Error(`${gathererName} failed to provide an artifact.`);
      }
    }

    return {
      artifacts: gathererArtifacts,
    };
  }

  /**
   * Return an initialized but mostly empty set of base artifacts, to be
   * populated as the run continues.
   * @param {{driver: Driver, requestedUrl: string, settings: LH.Config.Settings}} options
   * @return {Promise<LH.BaseArtifacts>}
   */
  static async initializeBaseArtifacts(options) {
    const hostUserAgent = (await options.driver.getBrowserVersion()).userAgent;

    // Whether Lighthouse was run on a mobile device (i.e. not on a desktop machine).
    const HostFormFactor = hostUserAgent.includes('Android') || hostUserAgent.includes('Mobile') ?
      'mobile' : 'desktop';

    return {
      fetchTime: (new Date()).toJSON(),
      LighthouseRunWarnings: [],
      HostFormFactor,
      HostUserAgent: hostUserAgent,
      NetworkUserAgent: '', // updated later
      BenchmarkIndex: 0, // updated later
      WebAppManifest: null, // updated later
      InstallabilityErrors: {errors: []}, // updated later
      Stacks: [], // updated later
      traces: {},
      devtoolsLogs: {},
      settings: options.settings,
      URL: {requestedUrl: options.requestedUrl, finalUrl: options.requestedUrl},
      Timing: [],
      PageLoadError: null,
    };
  }

  /**
   * Populates the important base artifacts from a fully loaded test page.
   * Currently must be run before `start-url` gatherer so that `WebAppManifest`
   * will be available to it.
   * @param {LH.Gatherer.PassContext} passContext
   */
  static async populateBaseArtifacts(passContext) {
    const status = {msg: 'Populate base artifacts', id: 'lh:gather:populateBaseArtifacts'};
    log.time(status);
    const baseArtifacts = passContext.baseArtifacts;

    // Copy redirected URL to artifact.
    baseArtifacts.URL.finalUrl = passContext.url;

    // Fetch the manifest, if it exists.
    baseArtifacts.WebAppManifest = await WebAppManifest.getWebAppManifest(
      passContext.driver.defaultSession, passContext.url);

    if (baseArtifacts.WebAppManifest) {
      baseArtifacts.InstallabilityErrors = await InstallabilityErrors.getInstallabilityErrors(
        passContext.driver.defaultSession);
    }

    baseArtifacts.Stacks = await Stacks.collectStacks(passContext.driver.executionContext);

    // Find the NetworkUserAgent actually used in the devtoolsLogs.
    const devtoolsLog = baseArtifacts.devtoolsLogs[passContext.passConfig.passName];
    baseArtifacts.NetworkUserAgent = NetworkUserAgent.getNetworkUserAgent(devtoolsLog);

    const environmentWarnings = getEnvironmentWarnings(passContext);
    baseArtifacts.LighthouseRunWarnings.push(...environmentWarnings);

    log.timeEnd(status);
  }

  /**
   * @param {Array<LH.Config.Pass>} passConfigs
   * @param {{driver: Driver, requestedUrl: string, settings: LH.Config.Settings, computedCache: Map<string, ArbitraryEqualityMap>}} options
   * @return {Promise<LH.Artifacts>}
   */
  static async run(passConfigs, options) {
    const driver = options.driver;

    /** @type {Partial<LH.GathererArtifacts>} */
    const artifacts = {};

    try {
      await driver.connect();
      // In the devtools/extension case, we can't still be on the site while trying to clear state
      // So we first navigate to about:blank, then apply our emulation & setup
      await GatherRunner.loadBlank(driver);

      const baseArtifacts = await GatherRunner.initializeBaseArtifacts(options);
      baseArtifacts.BenchmarkIndex = await getBenchmarkIndex(driver.executionContext);

      await GatherRunner.setupDriver(driver, options);

      let isFirstPass = true;
      for (const passConfig of passConfigs) {
        /** @type {LH.Gatherer.PassContext} */
        const passContext = {
          gatherMode: 'navigation',
          driver,
          url: options.requestedUrl,
          settings: options.settings,
          passConfig,
          baseArtifacts,
          computedCache: options.computedCache,
          LighthouseRunWarnings: baseArtifacts.LighthouseRunWarnings,
        };
        const passResults = await GatherRunner.runPass(passContext);
        Object.assign(artifacts, passResults.artifacts);

        // If we encountered a pageLoadError, don't try to keep loading the page in future passes.
        if (passResults.pageLoadError && passConfig.loadFailureMode === 'fatal') {
          baseArtifacts.PageLoadError = passResults.pageLoadError;
          break;
        }

        if (isFirstPass) {
          await GatherRunner.populateBaseArtifacts(passContext);
          isFirstPass = false;
        }

        // Disable fetcher for every pass, in case a gatherer enabled it.
        // Noop if fetcher was never enabled.
        // This cleanup should be removed once the only usage of
        // fetcher (fetching arbitrary URLs) is replaced by new protocol support.
        await driver.fetcher.disable();
      }

      await GatherRunner.disposeDriver(driver, options);
      return finalizeArtifacts(baseArtifacts, artifacts);
    } catch (err) {
      // Clean up on error. Don't await so that the root error, not a disposal error, is shown.
      GatherRunner.disposeDriver(driver, options);

      throw err;
    }
  }

  /**
   * Save the devtoolsLog and trace (if applicable) to baseArtifacts.
   * @param {LH.Gatherer.PassContext} passContext
   * @param {LH.Gatherer.LoadData} loadData
   * @param {string} passName
   */
  static _addLoadDataToBaseArtifacts(passContext, loadData, passName) {
    const baseArtifacts = passContext.baseArtifacts;
    baseArtifacts.devtoolsLogs[passName] = loadData.devtoolsLog;
    if (loadData.trace) baseArtifacts.traces[passName] = loadData.trace;
  }

  /**
   * Starting from about:blank, load the page and run gatherers for this pass.
   * @param {LH.Gatherer.PassContext} passContext
   * @return {Promise<{artifacts: Partial<LH.GathererArtifacts>, pageLoadError?: LH.LighthouseError}>}
   */
  static async runPass(passContext) {
    const status = {
      msg: `Running ${passContext.passConfig.passName} pass`,
      id: `lh:gather:runPass-${passContext.passConfig.passName}`,
      args: [passContext.passConfig.gatherers.map(g => g.instance.name).join(', ')],
    };
    log.time(status);

    /** @type {Partial<GathererResults>} */
    const gathererResults = {};
    const {driver, passConfig} = passContext;

    // Go to about:blank, set up, and run `beforePass()` on gatherers.
    await GatherRunner.loadBlank(driver, passConfig.blankPage);
    const {warnings} = await prepare.prepareTargetForIndividualNavigation(
      driver.defaultSession,
      passContext.settings,
      {
        url: passContext.url,
        disableStorageReset: !passConfig.useThrottling,
        disableThrottling: !passConfig.useThrottling,
        blockedUrlPatterns: passConfig.blockedUrlPatterns,
      }
    );
    passContext.LighthouseRunWarnings.push(...warnings);
    await GatherRunner.beforePass(passContext, gathererResults);

    // Navigate, start recording, and run `pass()` on gatherers.
    await GatherRunner.beginRecording(passContext);
    const {navigationError: possibleNavError} = await GatherRunner.loadPage(driver, passContext);
    await GatherRunner.pass(passContext, gathererResults);
    const loadData = await GatherRunner.endRecording(passContext);

    // Disable throttling so the afterPass analysis isn't throttled.
    await emulation.clearThrottling(driver.defaultSession);

    // In case of load error, save log and trace with an error prefix, return no artifacts for this pass.
    const pageLoadError = getPageLoadError(possibleNavError, {
      url: passContext.url,
      loadFailureMode: passConfig.loadFailureMode,
      networkRecords: loadData.networkRecords,
    });
    if (pageLoadError) {
      const localizedMessage = i18n.getFormatted(pageLoadError.friendlyMessage,
          passContext.settings.locale);
      log.error('GatherRunner', localizedMessage, passContext.url);

      passContext.LighthouseRunWarnings.push(pageLoadError.friendlyMessage);
      GatherRunner._addLoadDataToBaseArtifacts(passContext, loadData,
          `pageLoadError-${passConfig.passName}`);

      log.timeEnd(status);
      return {artifacts: {}, pageLoadError};
    }

    // If no error, save devtoolsLog and trace.
    GatherRunner._addLoadDataToBaseArtifacts(passContext, loadData, passConfig.passName);

    // Run `afterPass()` on gatherers and return collected artifacts.
    await GatherRunner.afterPass(passContext, loadData, gathererResults);
    const artifacts = GatherRunner.collectArtifacts(gathererResults);

    log.timeEnd(status);
    return artifacts;
  }
}

module.exports = GatherRunner;

},{"../computed/network-records.js":40,"../config/constants.js":56,"../fraggle-rock/gather/base-artifacts.js":59,"../lib/emulation.js":95,"../lib/i18n/i18n.js":96,"../lib/navigation-error.js":107,"./driver/environment.js":66,"./driver/navigation.js":68,"./driver/prepare.js":71,"./driver/service-workers.js":72,"./driver/storage.js":73,"./gatherers/installability-errors.js":"../gather/gatherers/installability-errors","./gatherers/network-user-agent.js":"../gather/gatherers/network-user-agent","./gatherers/stacks.js":"../gather/gatherers/stacks","./gatherers/web-app-manifest.js":"../gather/gatherers/web-app-manifest","lighthouse-logger":188}],77:[function(require,module,exports){
/**
 * @license Copyright 2016 The Lighthouse Authors. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.
 */
'use strict';

/**
 * Base class for all gatherers; defines pass lifecycle methods. The artifact
 * from the gatherer is the last not-undefined value returned by a lifecycle
 * method. All methods can return the artifact value directly or return a
 * Promise that resolves to that value.
 *
 * If an Error is thrown (or a Promise that rejects on an Error),
 * the runner will treat it as an error internal to the gatherer and
 * continue execution of any remaining gatherers.
 *
 * @implements {LH.Gatherer.GathererInstance}
 */
class Gatherer {
  /**
   * @return {keyof LH.GathererArtifacts}
   */
  get name() {
    // @ts-expect-error - assume that class name has been added to LH.GathererArtifacts.
    return this.constructor.name;
  }

  /* eslint-disable no-unused-vars */

  /**
   * Called before navigation to target url.
   * @param {LH.Gatherer.PassContext} passContext
   * @return {LH.Gatherer.PhaseResult}
   */
  beforePass(passContext) { }

  /**
   * Called after target page is loaded. If a trace is enabled for this pass,
   * the trace is still being recorded.
   * @param {LH.Gatherer.PassContext} passContext
   * @return {LH.Gatherer.PhaseResult}
   */
  pass(passContext) { }

  /**
   * Called after target page is loaded, all gatherer `pass` methods have been
   * executed, and — if generated in this pass — the trace is ended. The trace
   * and record of network activity are provided in `loadData`.
   * @param {LH.Gatherer.PassContext} passContext
   * @param {LH.Gatherer.LoadData} loadData
   * @return {LH.Gatherer.PhaseResult}
   */
  afterPass(passContext, loadData) { }

  /* eslint-enable no-unused-vars */
}

module.exports = Gatherer;

},{}],78:[function(require,module,exports){
/**
 * @license Copyright 2016 The Lighthouse Authors. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.
 */
'use strict';

const Runner = require('./runner.js');
const log = require('lighthouse-logger');
const ChromeProtocol = require('./gather/connections/cri.js');
const Config = require('./config/config.js');

/** @typedef {import('./gather/connections/connection.js')} Connection */

/*
 * The relationship between these root modules:
 *
 *   index.js  - the require('lighthouse') hook for Node modules (including the CLI)
 *
 *   runner.js - marshalls the actions that must be taken (Gather / Audit)
 *               config file is used to determine which of these actions are needed
 *
 *         lighthouse-cli \
 *                         -- core/index.js ----> runner.js ----> [Gather / Audit]
 *                clients /
 */

/**
 * Run Lighthouse.
 * @param {string=} url The URL to test. Optional if running in auditMode.
 * @param {LH.Flags=} flags Optional settings for the Lighthouse run. If present,
 *   they will override any settings in the config.
 * @param {LH.Config.Json=} configJSON Configuration for the Lighthouse run. If
 *   not present, the default config is used.
 * @param {Connection=} userConnection
 * @return {Promise<LH.RunnerResult|undefined>}
 */
async function lighthouse(url, flags = {}, configJSON, userConnection) {
  // set logging preferences, assume quiet
  flags.logLevel = flags.logLevel || 'error';
  log.setLevel(flags.logLevel);

  const config = generateConfig(configJSON, flags);
  const computedCache = new Map();
  const options = {url, config, computedCache};
  const connection = userConnection || new ChromeProtocol(flags.port, flags.hostname);

  // kick off a lighthouse run
  /** @param {{requestedUrl: string}} runnerData */
  const gatherFn = ({requestedUrl}) => {
    return Runner._gatherArtifactsFromBrowser(requestedUrl, options, connection);
  };
  return Runner.run(gatherFn, options);
}

/**
 * Generate a Lighthouse Config.
 * @param {LH.Config.Json=} configJson Configuration for the Lighthouse run. If
 *   not present, the default config is used.
 * @param {LH.Flags=} flags Optional settings for the Lighthouse run. If present,
 *   they will override any settings in the config.
 * @return {Config}
 */
function generateConfig(configJson, flags) {
  return new Config(configJson, flags);
}

lighthouse.generateConfig = generateConfig;
lighthouse.getAuditList = Runner.getAuditList;
lighthouse.traceCategories = require('./gather/driver.js').traceCategories;
lighthouse.Audit = require('./audits/audit.js');
lighthouse.Gatherer = require('./gather/gatherers/gatherer.js');
lighthouse.NetworkRecords = require('./computed/network-records.js');

module.exports = lighthouse;

},{"./audits/audit.js":3,"./computed/network-records.js":40,"./config/config.js":55,"./gather/connections/cri.js":144,"./gather/driver.js":64,"./gather/gatherers/gatherer.js":77,"./runner.js":122,"lighthouse-logger":188}],79:[function(require,module,exports){
/**
 * @license Copyright 2018 The Lighthouse Authors. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.
 */
'use strict';

const isEqual = require('lodash.isequal');

/**
 * @fileoverview This class is designed to allow maps with arbitrary equality functions.
 * It is not meant to be performant and is well-suited to use cases where the number of entries is
 * likely to be small (like computed artifacts).
 */
class ArbitraryEqualityMap {
  constructor() {
    this._equalsFn = ArbitraryEqualityMap.deepEquals;
    /** @type {Array<{key: *, value: *}>} */
    this._entries = [];
  }

  /**
   * @param {function(*,*):boolean} equalsFn
   */
  setEqualityFn(equalsFn) {
    this._equalsFn = equalsFn;
  }

  /**
   * @param {*} key
   * @return {boolean}
   */
  has(key) {
    return this._findIndexOf(key) !== -1;
  }

  /**
   * @param {*} key
   * @return {*}
   */
  get(key) {
    const entry = this._entries[this._findIndexOf(key)];
    return entry && entry.value;
  }

  /**
   * @param {*} key
   * @param {*} value
   */
  set(key, value) {
    let index = this._findIndexOf(key);
    if (index === -1) index = this._entries.length;
    this._entries[index] = {key, value};
  }

  /**
   * @param {*} key
   * @return {number}
   */
  _findIndexOf(key) {
    for (let i = 0; i < this._entries.length; i++) {
      if (this._equalsFn(key, this._entries[i].key)) return i;
    }

    return -1;
  }

  /**
   * Determines whether two objects are deeply equal. Defers to lodash isEqual, but is kept here for
   * easy usage by consumers.
   * See https://lodash.com/docs/4.17.5#isEqual.
   * @param {*} objA
   * @param {*} objB
   * @return {boolean}
   */
  static deepEquals(objA, objB) {
    return isEqual(objA, objB);
  }
}

module.exports = ArbitraryEqualityMap;

},{"lodash.isequal":217}],80:[function(require,module,exports){
(function (process){(function (){
/**
 * @license Copyright 2016 The Lighthouse Authors. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.
 */
'use strict';

const fs = require('fs');
const path = require('path');
const log = require('lighthouse-logger');
const stream = require('stream');
const {promisify} = require('util');
const Simulator = require('./dependency-graph/simulator/simulator.js');
const lanternTraceSaver = require('./lantern-trace-saver.js');
const Metrics = require('./traces/pwmetrics-events.js');
const NetworkAnalysisComputed = require('../computed/network-analysis.js');
const LoadSimulatorComputed = require('../computed/load-simulator.js');
const LHError = require('../lib/lh-error.js');
const pipeline = promisify(stream.pipeline);

const artifactsFilename = 'artifacts.json';
const traceSuffix = '.trace.json';
const devtoolsLogSuffix = '.devtoolslog.json';

/**
 * @typedef {object} PreparedAssets
 * @property {string} passName
 * @property {LH.Trace} traceData
 * @property {LH.DevtoolsLog} devtoolsLog
 */


/**
 * Load artifacts object from files located within basePath
 * Also save the traces to their own files
 * @param {string} basePath
 * @return {LH.Artifacts}
 */
function loadArtifacts(basePath) {
  log.log('Reading artifacts from disk:', basePath);

  if (!fs.existsSync(basePath)) {
    throw new Error('No saved artifacts found at ' + basePath);
  }

  // load artifacts.json using a reviver to deserialize any LHErrors in artifacts.
  const artifactsStr = fs.readFileSync(path.join(basePath, artifactsFilename), 'utf8');
  /** @type {LH.Artifacts} */
  const artifacts = JSON.parse(artifactsStr, LHError.parseReviver);

  const filenames = fs.readdirSync(basePath);

  // load devtoolsLogs
  artifacts.devtoolsLogs = {};
  filenames.filter(f => f.endsWith(devtoolsLogSuffix)).forEach(filename => {
    const passName = filename.replace(devtoolsLogSuffix, '');
    const devtoolsLog = JSON.parse(fs.readFileSync(path.join(basePath, filename), 'utf8'));
    artifacts.devtoolsLogs[passName] = devtoolsLog;
  });

  // load traces
  artifacts.traces = {};
  filenames.filter(f => f.endsWith(traceSuffix)).forEach(filename => {
    const file = fs.readFileSync(path.join(basePath, filename), {encoding: 'utf-8'});
    const trace = JSON.parse(file);
    const passName = filename.replace(traceSuffix, '');
    artifacts.traces[passName] = Array.isArray(trace) ? {traceEvents: trace} : trace;
  });

  if (Array.isArray(artifacts.Timing)) {
    // Any Timing entries in saved artifacts will have a different timeOrigin than the auditing phase
    // The `gather` prop is read later in generate-timing-trace and they're added to a separate track of trace events
    artifacts.Timing.forEach(entry => (entry.gather = true));
  }
  return artifacts;
}

/**
 * A replacer function for JSON.stingify of the artifacts. Used to serialize objects that
 * JSON won't normally handle.
 * @param {string} key
 * @param {any} value
 */
function stringifyReplacer(key, value) {
  // Currently only handle LHError and other Error types.
  if (value instanceof Error) {
    return LHError.stringifyReplacer(value);
  }

  return value;
}

/**
 * Save artifacts object mostly to single file located at basePath/artifacts.json.
 * Also save the traces & devtoolsLogs to their own files
 * @param {LH.Artifacts} artifacts
 * @param {string} basePath
 * @return {Promise<void>}
 */
async function saveArtifacts(artifacts, basePath) {
  const status = {msg: 'Saving artifacts', id: 'lh:assetSaver:saveArtifacts'};
  log.time(status);
  fs.mkdirSync(basePath, {recursive: true});

  // Delete any previous artifacts in this directory.
  const filenames = fs.readdirSync(basePath);
  for (const filename of filenames) {
    if (filename.endsWith(traceSuffix) || filename.endsWith(devtoolsLogSuffix) ||
        filename === artifactsFilename) {
      fs.unlinkSync(`${basePath}/${filename}`);
    }
  }

  const {traces, devtoolsLogs, ...restArtifacts} = artifacts;

  // save traces
  for (const [passName, trace] of Object.entries(traces)) {
    await saveTrace(trace, `${basePath}/${passName}${traceSuffix}`);
  }

  // save devtools log
  for (const [passName, devtoolsLog] of Object.entries(devtoolsLogs)) {
    await saveDevtoolsLog(devtoolsLog, `${basePath}/${passName}${devtoolsLogSuffix}`);
  }

  // save everything else, using a replacer to serialize LHErrors in the artifacts.
  const restArtifactsString = JSON.stringify(restArtifacts, stringifyReplacer, 2) + '\n';
  fs.writeFileSync(`${basePath}/${artifactsFilename}`, restArtifactsString, 'utf8');
  log.log('Artifacts saved to disk in folder:', basePath);
  log.timeEnd(status);
}

/**
 * Save LHR to file located at basePath/lhr.report.json.
 * @param {LH.Result} lhr
 * @param {string} basePath
 */
function saveLhr(lhr, basePath) {
  fs.writeFileSync(`${basePath}/lhr.report.json`, JSON.stringify(lhr, null, 2));
}

/**
 * Filter traces and extract screenshots to prepare for saving.
 * @param {LH.Artifacts} artifacts
 * @param {LH.Audit.Results} [audits]
 * @return {Promise<Array<PreparedAssets>>}
 */
async function prepareAssets(artifacts, audits) {
  const passNames = Object.keys(artifacts.traces);
  /** @type {Array<PreparedAssets>} */
  const assets = [];

  for (const passName of passNames) {
    const trace = artifacts.traces[passName];
    const devtoolsLog = artifacts.devtoolsLogs[passName];

    const traceData = Object.assign({}, trace);
    if (audits) {
      const evts = new Metrics(traceData.traceEvents, audits).generateFakeEvents();
      traceData.traceEvents = traceData.traceEvents.concat(evts);
    }

    assets.push({
      passName,
      traceData,
      devtoolsLog,
    });
  }

  return assets;
}

/**
 * Generates a JSON representation of an array of objects with the objects
 * printed one per line for a more readable (but not too verbose) version.
 * @param {Array<unknown>} arrayOfObjects
 * @return {IterableIterator<string>}
 */
function* arrayOfObjectsJsonGenerator(arrayOfObjects) {
  const ITEMS_PER_ITERATION = 500;

  // Stringify and emit items separately to avoid a giant string in memory.
  yield '[\n';
  if (arrayOfObjects.length > 0) {
    const itemsIterator = arrayOfObjects[Symbol.iterator]();
    // Emit first item manually to avoid a trailing comma.
    const firstItem = itemsIterator.next().value;
    yield `  ${JSON.stringify(firstItem)}`;

    let itemsRemaining = ITEMS_PER_ITERATION;
    let itemsJSON = '';
    for (const item of itemsIterator) {
      itemsJSON += `,\n  ${JSON.stringify(item)}`;
      itemsRemaining--;
      if (itemsRemaining === 0) {
        yield itemsJSON;
        itemsRemaining = ITEMS_PER_ITERATION;
        itemsJSON = '';
      }
    }
    yield itemsJSON;
  }
  yield '\n]';
}

/**
 * Generates a JSON representation of traceData line-by-line for a nicer printed
 * version with one trace event per line.
 * @param {LH.Trace} traceData
 * @return {IterableIterator<string>}
 */
function* traceJsonGenerator(traceData) {
  const {traceEvents, ...rest} = traceData;

  yield '{\n';

  yield '"traceEvents": ';
  yield* arrayOfObjectsJsonGenerator(traceEvents);

  // Emit the rest of the object (usually just `metadata`, if anything).
  for (const [key, value] of Object.entries(rest)) {
    yield `,\n"${key}": ${JSON.stringify(value, null, 2)}`;
  }

  yield '}\n';
}

/**
 * Save a trace as JSON by streaming to disk at traceFilename.
 * @param {LH.Trace} traceData
 * @param {string} traceFilename
 * @return {Promise<void>}
 */
async function saveTrace(traceData, traceFilename) {
  const traceIter = traceJsonGenerator(traceData);
  const writeStream = fs.createWriteStream(traceFilename);

  // TODO: Can remove Readable.from() in Node 13, promisify(pipeline) in Node 15.
  // https://nodejs.org/api/stream.html#stream_stream_pipeline_streams_callback
  return pipeline(stream.Readable.from(traceIter), writeStream);
}

/**
 * Save a devtoolsLog as JSON by streaming to disk at devtoolLogFilename.
 * @param {LH.DevtoolsLog} devtoolsLog
 * @param {string} devtoolLogFilename
 * @return {Promise<void>}
 */
function saveDevtoolsLog(devtoolsLog, devtoolLogFilename) {
  const logIter = arrayOfObjectsJsonGenerator(devtoolsLog);
  const writeStream = fs.createWriteStream(devtoolLogFilename);

  return pipeline(stream.Readable.from(logIter), writeStream);
}

/**
 * @param {string} pathWithBasename
 * @return {Promise<void>}
 */
async function saveLanternDebugTraces(pathWithBasename) {
  if (!process.env.LANTERN_DEBUG) return;

  for (const [label, nodeTimings] of Simulator.ALL_NODE_TIMINGS) {
    if (lanternTraceSaver.simulationNamesToIgnore.includes(label)) continue;

    const traceFilename = `${pathWithBasename}-${label}${traceSuffix}`;
    await saveTrace(lanternTraceSaver.convertNodeTimingsToTrace(nodeTimings), traceFilename);
    log.log('saveAssets', `${label} lantern trace file streamed to disk: ${traceFilename}`);
  }
}

/**
 * Writes trace(s) and associated asset(s) to disk.
 * @param {LH.Artifacts} artifacts
 * @param {LH.Audit.Results} audits
 * @param {string} pathWithBasename
 * @return {Promise<void>}
 */
async function saveAssets(artifacts, audits, pathWithBasename) {
  const allAssets = await prepareAssets(artifacts, audits);
  const saveAll = allAssets.map(async (passAssets, index) => {
    const devtoolsLogFilename = `${pathWithBasename}-${index}${devtoolsLogSuffix}`;
    fs.writeFileSync(devtoolsLogFilename, JSON.stringify(passAssets.devtoolsLog, null, 2));
    log.log('saveAssets', 'devtools log saved to disk: ' + devtoolsLogFilename);

    const streamTraceFilename = `${pathWithBasename}-${index}${traceSuffix}`;
    log.log('saveAssets', 'streaming trace file to disk: ' + streamTraceFilename);
    await saveTrace(passAssets.traceData, streamTraceFilename);
    log.log('saveAssets', 'trace file streamed to disk: ' + streamTraceFilename);
  });

  await Promise.all(saveAll);
  await saveLanternDebugTraces(pathWithBasename);
}

/**
 * @param {LH.DevtoolsLog} devtoolsLog
 * @param {string} outputPath
 * @return {Promise<void>}
 */
async function saveLanternNetworkData(devtoolsLog, outputPath) {
  /** @type {LH.Audit.Context} */
  // @ts-expect-error - the full audit context isn't needed for analysis.
  const context = {computedCache: new Map()};
  const networkAnalysis = await NetworkAnalysisComputed.request(devtoolsLog, context);
  const lanternData = LoadSimulatorComputed.convertAnalysisToSaveableLanternData(networkAnalysis);

  fs.writeFileSync(outputPath, JSON.stringify(lanternData));
}

module.exports = {
  saveArtifacts,
  saveLhr,
  loadArtifacts,
  saveAssets,
  prepareAssets,
  saveTrace,
  saveDevtoolsLog,
  saveLanternNetworkData,
  stringifyReplacer,
};

}).call(this)}).call(this,require('_process'))
},{"../computed/load-simulator.js":13,"../computed/network-analysis.js":39,"../lib/lh-error.js":103,"./dependency-graph/simulator/simulator.js":93,"./lantern-trace-saver.js":99,"./traces/pwmetrics-events.js":120,"_process":223,"fs":144,"lighthouse-logger":188,"path":222,"stream":234,"util":257}],81:[function(require,module,exports){
/**
 * @license Copyright 2020 The Lighthouse Authors. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.
 */
'use strict';


const source = "/*! axe v4.2.3\n * Copyright (c) 2021 Deque Systems, Inc.\n *\n * Your use of this Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n *\n * This entire copyright notice must appear in every copy of this file you\n * distribute or in any file that contains substantial portions of this source\n * code.\n */\n!function e(window){var Bu=window,document=window.document;function Lu(e){return(Lu=\"function\"==typeof Symbol&&\"symbol\"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&\"function\"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?\"symbol\":typeof e})(e)}var axe=axe||{};function qu(e){this.name=\"SupportError\",this.cause=e.cause,this.message=\"`\".concat(e.cause,\"` - feature unsupported in your environment.\"),e.ruleId&&(this.ruleId=e.ruleId,this.message+=\" Skipping \".concat(this.ruleId,\" rule.\")),this.stack=(new Error).stack}axe.version=\"4.2.3\",\"function\"==typeof define&&define.amd&&define(\"axe-core\",[],function(){return axe}),\"object\"===(\"undefined\"==typeof module?\"undefined\":Lu(module))&&module.exports&&\"function\"==typeof e.toString&&(axe.source=\"(\"+e.toString()+')(typeof window === \"object\" ? window : this);',module.exports=axe),\"function\"==typeof window.getComputedStyle&&(window.axe=axe),(qu.prototype=Object.create(Error.prototype)).constructor=qu;var Mu=[\"variant\"],ju=[\"matches\"],Uu=[\"chromium\"],Vu=[\"noImplicit\"],Hu=[\"noPresentational\"];function zu(e,t){if(null==e)return{};var r,a=function(e,t){if(null==e)return{};var r,a,n={},o=Object.keys(e);for(a=0;a<o.length;a++)r=o[a],0<=t.indexOf(r)||(n[r]=e[r]);return n}(e,t);if(Object.getOwnPropertySymbols)for(var n=Object.getOwnPropertySymbols(e),o=0;o<n.length;o++)r=n[o],0<=t.indexOf(r)||Object.prototype.propertyIsEnumerable.call(e,r)&&(a[r]=e[r]);return a}function $u(e,t){if(\"function\"!=typeof t&&null!==t)throw new TypeError(\"Super expression must either be null or a function\");e.prototype=Object.create(t&&t.prototype,{constructor:{value:e,writable:!0,configurable:!0}}),t&&r(e,t)}function r(e,t){return(r=Object.setPrototypeOf||function(e,t){return e.__proto__=t,e})(e,t)}function Wu(r){var a=function(){if(\"undefined\"==typeof Reflect||!Reflect.construct)return!1;if(Reflect.construct.sham)return!1;if(\"function\"==typeof Proxy)return!0;try{return Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],function(){})),!0}catch(e){return!1}}();return function(){var e,t=n(r);return e=a?(e=n(this).constructor,Reflect.construct(t,arguments,e)):t.apply(this,arguments),t=this,!(e=e)||\"object\"!==Lu(e)&&\"function\"!=typeof e?Gu(t):e}}function Gu(e){if(void 0===e)throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");return e}function n(e){return(n=Object.setPrototypeOf?Object.getPrototypeOf:function(e){return e.__proto__||Object.getPrototypeOf(e)})(e)}function Yu(e){return function(e){if(Array.isArray(e))return o(e)}(e)||function(e){if(\"undefined\"!=typeof Symbol&&null!=e[Symbol.iterator]||null!=e[\"@@iterator\"])return Array.from(e)}(e)||l(e)||function(){throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\")}()}function Ku(e,t){return function(e){if(Array.isArray(e))return e}(e)||function(e,t){var r=null==e?null:\"undefined\"!=typeof Symbol&&e[Symbol.iterator]||e[\"@@iterator\"];if(null!=r){var a,n,o=[],i=!0,l=!1;try{for(r=r.call(e);!(i=(a=r.next()).done)&&(o.push(a.value),!t||o.length!==t);i=!0);}catch(e){l=!0,n=e}finally{try{i||null==r.return||r.return()}finally{if(l)throw n}}return o}}(e,t)||l(e,t)||function(){throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\")}()}function Xu(){return(Xu=Object.assign||function(e){for(var t=1;t<arguments.length;t++){var r,a=arguments[t];for(r in a)Object.prototype.hasOwnProperty.call(a,r)&&(e[r]=a[r])}return e}).apply(this,arguments)}function Ju(e,t){if(!(e instanceof t))throw new TypeError(\"Cannot call a class as a function\")}function a(e,t){for(var r=0;r<t.length;r++){var a=t[r];a.enumerable=a.enumerable||!1,a.configurable=!0,\"value\"in a&&(a.writable=!0),Object.defineProperty(e,a.key,a)}}function Qu(e,t,r){return t&&a(e.prototype,t),r&&a(e,r),e}function Zu(e,t){var r=\"undefined\"!=typeof Symbol&&e[Symbol.iterator]||e[\"@@iterator\"];if(!r){if(Array.isArray(e)||(r=l(e))||t&&e&&\"number\"==typeof e.length){r&&(e=r);var a=0,t=function(){};return{s:t,n:function(){return a>=e.length?{done:!0}:{done:!1,value:e[a++]}},e:function(e){throw e},f:t}}throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\")}var n,o=!0,i=!1;return{s:function(){r=r.call(e)},n:function(){var e=r.next();return o=e.done,e},e:function(e){i=!0,n=e},f:function(){try{o||null==r.return||r.return()}finally{if(i)throw n}}}}function l(e,t){if(e){if(\"string\"==typeof e)return o(e,t);var r=Object.prototype.toString.call(e).slice(8,-1);return\"Map\"===(r=\"Object\"===r&&e.constructor?e.constructor.name:r)||\"Set\"===r?Array.from(e):\"Arguments\"===r||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r)?o(e,t):void 0}}function o(e,t){(null==t||t>e.length)&&(t=e.length);for(var r=0,a=new Array(t);r<t;r++)a[r]=e[r];return a}function Lu(e){return(Lu=\"function\"==typeof Symbol&&\"symbol\"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&\"function\"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?\"symbol\":typeof e})(e)}!function(){function i(e){return l(e,\"__esModule\",{value:!0})}function t(t,r,a){if(i(t),\"object\"===Lu(r)||\"function\"==typeof r){var n,o=Zu(e(r));try{for(o.s();!(n=o.n()).done;)!function(){var e=n.value;s.call(t,e)||\"default\"===e||l(t,e,{get:function(){return r[e]},enumerable:!(a=u(r,e))||a.enumerable})}()}catch(e){o.e(e)}finally{o.f()}}return t}var r=Object.create,l=Object.defineProperty,a=Object.getPrototypeOf,s=Object.prototype.hasOwnProperty,e=Object.getOwnPropertyNames,u=Object.getOwnPropertyDescriptor,n=function(e,t){return function(){return t||e((t={exports:{}}).exports,t),t.exports}},o=function(e,t){for(var r in i(e),t)l(e,r,{get:t[r],enumerable:!0})},c=function(e){return e&&e.__esModule?e:t(l(r(a(e)),\"default\",{value:e,enumerable:!0}),e)},d=n(function(i){\"use strict\";Object.defineProperty(i,\"__esModule\",{value:!0}),i.isIdentStart=function(e){return\"a\"<=e&&e<=\"z\"||\"A\"<=e&&e<=\"Z\"||\"-\"===e||\"_\"===e},i.isIdent=function(e){return\"a\"<=e&&e<=\"z\"||\"A\"<=e&&e<=\"Z\"||\"0\"<=e&&e<=\"9\"||\"-\"===e||\"_\"===e},i.isHex=function(e){return\"a\"<=e&&e<=\"f\"||\"A\"<=e&&e<=\"F\"||\"0\"<=e&&e<=\"9\"},i.escapeIdentifier=function(e){for(var t=e.length,r=\"\",a=0;a<t;){var n=e.charAt(a);if(i.identSpecialChars[n])r+=\"\\\\\"+n;else if(\"_\"===n||\"-\"===n||\"A\"<=n&&n<=\"Z\"||\"a\"<=n&&n<=\"z\"||0!==a&&\"0\"<=n&&n<=\"9\")r+=n;else{var o=n.charCodeAt(0);if(55296==(63488&o)){n=e.charCodeAt(a++);if(55296!=(64512&o)||56320!=(64512&n))throw Error(\"UCS-2(decode): illegal sequence\");o=((1023&o)<<10)+(1023&n)+65536}r+=\"\\\\\"+o.toString(16)+\" \"}a++}return r},i.escapeStr=function(e){for(var t,r=e.length,a=\"\",n=0;n<r;){var o=e.charAt(n);'\"'===o?o='\\\\\"':\"\\\\\"===o?o=\"\\\\\\\\\":void 0!==(t=i.strReplacementsRev[o])&&(o=t),a+=o,n++}return'\"'+a+'\"'},i.identSpecialChars={\"!\":!0,'\"':!0,\"#\":!0,$:!0,\"%\":!0,\"&\":!0,\"'\":!0,\"(\":!0,\")\":!0,\"*\":!0,\"+\":!0,\",\":!0,\".\":!0,\"/\":!0,\";\":!0,\"<\":!0,\"=\":!0,\">\":!0,\"?\":!0,\"@\":!0,\"[\":!0,\"\\\\\":!0,\"]\":!0,\"^\":!0,\"`\":!0,\"{\":!0,\"|\":!0,\"}\":!0,\"~\":!0},i.strReplacementsRev={\"\\n\":\"\\\\n\",\"\\r\":\"\\\\r\",\"\\t\":\"\\\\t\",\"\\f\":\"\\\\f\",\"\\v\":\"\\\\v\"},i.singleQuoteEscapeChars={n:\"\\n\",r:\"\\r\",t:\"\\t\",f:\"\\f\",\"\\\\\":\"\\\\\",\"'\":\"'\"},i.doubleQuotesEscapeChars={n:\"\\n\",r:\"\\r\",t:\"\\t\",f:\"\\f\",\"\\\\\":\"\\\\\",'\"':'\"'}}),p=n(function(e){\"use strict\";Object.defineProperty(e,\"__esModule\",{value:!0});var b=d();e.parseCssSelector=function(o,i,l,s,n,u){var c=o.length,d=\"\";function p(e,t){var r=\"\";for(i++,d=o.charAt(i);i<c;){if(d===e)return i++,r;if(\"\\\\\"===d){i++;var a;if((d=o.charAt(i))===e)r+=e;else if(void 0!==(a=t[d]))r+=a;else{if(b.isHex(d)){var n=d;for(i++,d=o.charAt(i);b.isHex(d);)n+=d,i++,d=o.charAt(i);\" \"===d&&(i++,d=o.charAt(i)),r+=String.fromCharCode(parseInt(n,16));continue}r+=d}}else r+=d;i++,d=o.charAt(i)}return r}function f(){var e=\"\";for(d=o.charAt(i);i<c;){if(b.isIdent(d))e+=d;else{if(\"\\\\\"!==d)return e;if(c<=++i)throw Error(\"Expected symbol but end of file reached.\");if(d=o.charAt(i),b.identSpecialChars[d])e+=d;else{if(b.isHex(d)){var t=d;for(i++,d=o.charAt(i);b.isHex(d);)t+=d,i++,d=o.charAt(i);\" \"===d&&(i++,d=o.charAt(i)),e+=String.fromCharCode(parseInt(t,16));continue}e+=d}}i++,d=o.charAt(i)}return e}function m(){d=o.charAt(i);for(var e=!1;\" \"===d||\"\\t\"===d||\"\\n\"===d||\"\\r\"===d||\"\\f\"===d;)e=!0,i++,d=o.charAt(i);return e}function h(){var e=r();if(!e)return null;var t=e;for(d=o.charAt(i);\",\"===d;){if(i++,m(),\"selectors\"!==t.type&&(t={type:\"selectors\",selectors:[e]}),!(e=r()))throw Error('Rule expected after \",\".');t.selectors.push(e)}return t}function r(){m();var e={type:\"ruleSet\"},t=g();if(!t)return null;for(var r=e;t&&(t.type=\"rule\",r.rule=t,r=t,m(),d=o.charAt(i),!(c<=i||\",\"===d||\")\"===d));)if(n[d]){var a=d;if(i++,m(),!(t=g()))throw Error('Rule expected after \"'+a+'\".');t.nestingOperator=a}else(t=g())&&(t.nestingOperator=null);return e}function g(){for(var e=null;i<c;)if(\"*\"===(d=o.charAt(i)))i++,(e=e||{}).tagName=\"*\";else if(b.isIdentStart(d)||\"\\\\\"===d)(e=e||{}).tagName=f();else if(\".\"===d)i++,((e=e||{}).classNames=e.classNames||[]).push(f());else if(\"#\"===d)i++,(e=e||{}).id=f();else if(\"[\"===d){i++,m();var t={name:f()};if(m(),\"]\"===d)i++;else{var r=\"\";if(s[d]&&(r=d,i++,d=o.charAt(i)),c<=i)throw Error('Expected \"=\" but end of file reached.');if(\"=\"!==d)throw Error('Expected \"=\" but \"'+d+'\" found.');t.operator=r+\"=\",i++,m();var a=\"\";if(t.valueType=\"string\",'\"'===d)a=p('\"',b.doubleQuotesEscapeChars);else if(\"'\"===d)a=p(\"'\",b.singleQuoteEscapeChars);else if(u&&\"$\"===d)i++,a=f(),t.valueType=\"substitute\";else{for(;i<c&&\"]\"!==d;)a+=d,i++,d=o.charAt(i);a=a.trim()}if(m(),c<=i)throw Error('Expected \"]\" but end of file reached.');if(\"]\"!==d)throw Error('Expected \"]\" but \"'+d+'\" found.');i++,t.value=a}((e=e||{}).attrs=e.attrs||[]).push(t)}else{if(\":\"!==d)break;i++;r=f(),t={name:r};if(\"(\"===d){i++;var n=\"\";if(m(),\"selector\"===l[r])t.valueType=\"selector\",n=h();else{if(t.valueType=l[r]||\"string\",'\"'===d)n=p('\"',b.doubleQuotesEscapeChars);else if(\"'\"===d)n=p(\"'\",b.singleQuoteEscapeChars);else if(u&&\"$\"===d)i++,n=f(),t.valueType=\"substitute\";else{for(;i<c&&\")\"!==d;)n+=d,i++,d=o.charAt(i);n=n.trim()}m()}if(c<=i)throw Error('Expected \")\" but end of file reached.');if(\")\"!==d)throw Error('Expected \")\" but \"'+d+'\" found.');i++,t.value=n}((e=e||{}).pseudos=e.pseudos||[]).push(t)}return e}return function(){var e=h();if(i<c)throw Error('Rule expected but \"'+o.charAt(i)+'\" found.');return e}()}}),f=n(function(e){\"use strict\";Object.defineProperty(e,\"__esModule\",{value:!0});var o=d();e.renderEntity=function t(e){var r=\"\";switch(e.type){case\"ruleSet\":for(var a=e.rule,n=[];a;)a.nestingOperator&&n.push(a.nestingOperator),n.push(t(a)),a=a.rule;r=n.join(\" \");break;case\"selectors\":r=e.selectors.map(t).join(\", \");break;case\"rule\":e.tagName&&(r=\"*\"===e.tagName?\"*\":o.escapeIdentifier(e.tagName)),e.id&&(r+=\"#\"+o.escapeIdentifier(e.id)),e.classNames&&(r+=e.classNames.map(function(e){return\".\"+o.escapeIdentifier(e)}).join(\"\")),e.attrs&&(r+=e.attrs.map(function(e){return\"operator\"in e?\"substitute\"===e.valueType?\"[\"+o.escapeIdentifier(e.name)+e.operator+\"$\"+e.value+\"]\":\"[\"+o.escapeIdentifier(e.name)+e.operator+o.escapeStr(e.value)+\"]\":\"[\"+o.escapeIdentifier(e.name)+\"]\"}).join(\"\")),e.pseudos&&(r+=e.pseudos.map(function(e){return e.valueType?\"selector\"===e.valueType?\":\"+o.escapeIdentifier(e.name)+\"(\"+t(e.value)+\")\":\"substitute\"===e.valueType?\":\"+o.escapeIdentifier(e.name)+\"($\"+e.value+\")\":\"numeric\"===e.valueType?\":\"+o.escapeIdentifier(e.name)+\"(\"+e.value+\")\":\":\"+o.escapeIdentifier(e.name)+\"(\"+o.escapeIdentifier(e.value)+\")\":\":\"+o.escapeIdentifier(e.name)}).join(\"\"));break;default:throw Error('Unknown entity type: \"'+e.type+'\".')}return r}}),m=n(function(e){\"use strict\";Object.defineProperty(e,\"__esModule\",{value:!0});var t=p(),r=f(),a=(n.prototype.registerSelectorPseudos=function(){for(var e=[],t=0;t<arguments.length;t++)e[t]=arguments[t];for(var r=0,a=e;r<a.length;r++){var n=a[r];this.pseudos[n]=\"selector\"}return this},n.prototype.unregisterSelectorPseudos=function(){for(var e=[],t=0;t<arguments.length;t++)e[t]=arguments[t];for(var r=0,a=e;r<a.length;r++){var n=a[r];delete this.pseudos[n]}return this},n.prototype.registerNumericPseudos=function(){for(var e=[],t=0;t<arguments.length;t++)e[t]=arguments[t];for(var r=0,a=e;r<a.length;r++){var n=a[r];this.pseudos[n]=\"numeric\"}return this},n.prototype.unregisterNumericPseudos=function(){for(var e=[],t=0;t<arguments.length;t++)e[t]=arguments[t];for(var r=0,a=e;r<a.length;r++){var n=a[r];delete this.pseudos[n]}return this},n.prototype.registerNestingOperators=function(){for(var e=[],t=0;t<arguments.length;t++)e[t]=arguments[t];for(var r=0,a=e;r<a.length;r++){var n=a[r];this.ruleNestingOperators[n]=!0}return this},n.prototype.unregisterNestingOperators=function(){for(var e=[],t=0;t<arguments.length;t++)e[t]=arguments[t];for(var r=0,a=e;r<a.length;r++){var n=a[r];delete this.ruleNestingOperators[n]}return this},n.prototype.registerAttrEqualityMods=function(){for(var e=[],t=0;t<arguments.length;t++)e[t]=arguments[t];for(var r=0,a=e;r<a.length;r++){var n=a[r];this.attrEqualityMods[n]=!0}return this},n.prototype.unregisterAttrEqualityMods=function(){for(var e=[],t=0;t<arguments.length;t++)e[t]=arguments[t];for(var r=0,a=e;r<a.length;r++){var n=a[r];delete this.attrEqualityMods[n]}return this},n.prototype.enableSubstitutes=function(){return this.substitutesEnabled=!0,this},n.prototype.disableSubstitutes=function(){return this.substitutesEnabled=!1,this},n.prototype.parse=function(e){return t.parseCssSelector(e,0,this.pseudos,this.attrEqualityMods,this.ruleNestingOperators,this.substitutesEnabled)},n.prototype.render=function(e){return r.renderEntity(e).trim()},n);function n(){this.pseudos={},this.attrEqualityMods={},this.ruleNestingOperators={},this.substitutesEnabled=!1}e.CssSelectorParser=a}),h=n(function(e,t){\"use strict\";t.exports=function(){}}),C=n(function(e,t){\"use strict\";var r=h()();t.exports=function(e){return e!==r&&null!==e}}),g=n(function(e,t){\"use strict\";var r=C(),a=Array.prototype.forEach,n=Object.create;t.exports=function(e){var t=n(null);return a.call(arguments,function(e){r(e)&&function(e,t){for(var r in e)t[r]=e[r]}(Object(e),t)}),t}}),b=n(function(e,t){\"use strict\";t.exports=function(){var e=Math.sign;return\"function\"==typeof e&&(1===e(10)&&-1===e(-20))}}),y=n(function(e,t){\"use strict\";t.exports=function(e){return e=Number(e),isNaN(e)||0===e?e:0<e?1:-1}}),v=n(function(e,t){\"use strict\";t.exports=b()()?Math.sign:y()}),D=n(function(e,t){\"use strict\";var r=v(),a=Math.abs,n=Math.floor;t.exports=function(e){return isNaN(e)?0:0!==(e=Number(e))&&isFinite(e)?r(e)*n(a(e)):e}}),F=n(function(e,t){\"use strict\";var r=D(),a=Math.max;t.exports=function(e){return a(0,r(e))}}),w=n(function(e,t){\"use strict\";var a=F();t.exports=function(e,t,r){return isNaN(e)?0<=t?r&&t?t-1:t:1:!1!==e&&a(e)}}),k=n(function(e,t){\"use strict\";t.exports=function(e){if(\"function\"!=typeof e)throw new TypeError(e+\" is not a function\");return e}}),R=n(function(e,t){\"use strict\";var r=C();t.exports=function(e){if(!r(e))throw new TypeError(\"Cannot use null or undefined\");return e}}),x=n(function(e,t){\"use strict\";var l=k(),s=R(),u=Function.prototype.bind,c=Function.prototype.call,d=Object.keys,p=Object.prototype.propertyIsEnumerable;t.exports=function(o,i){return function(r,a){var e,n=arguments[2],t=arguments[3];return r=Object(s(r)),l(a),e=d(r),t&&e.sort(\"function\"==typeof t?u.call(t,r):void 0),\"function\"!=typeof o&&(o=e[o]),c.call(o,e,function(e,t){return p.call(r,e)?c.call(a,n,r[e],e,r,t):i})}}}),E=n(function(e,t){\"use strict\";t.exports=x()(\"forEach\")}),A=n(function(){}),T=n(function(e,t){\"use strict\";t.exports=function(){var e=Object.assign;return\"function\"==typeof e&&(e(e={foo:\"raz\"},{bar:\"dwa\"},{trzy:\"trzy\"}),e.foo+e.bar+e.trzy===\"razdwatrzy\")}}),N=n(function(e,t){\"use strict\";t.exports=function(){try{return Object.keys(\"primitive\"),!0}catch(e){return!1}}}),_=n(function(e,t){\"use strict\";var r=C(),a=Object.keys;t.exports=function(e){return a(r(e)?Object(e):e)}}),O=n(function(e,t){\"use strict\";t.exports=N()()?Object.keys:_()}),S=n(function(e,t){\"use strict\";var i=O(),l=R(),s=Math.max;t.exports=function(t,r){var a,e,n,o=s(arguments.length,2);for(t=Object(l(t)),n=function(e){try{t[e]=r[e]}catch(e){a=a||e}},e=1;e<o;++e)i(r=arguments[e]).forEach(n);if(void 0!==a)throw a;return t}}),P=n(function(e,t){\"use strict\";t.exports=T()()?Object.assign:S()}),I=n(function(e,t){\"use strict\";var r=C(),a={function:!0,object:!0};t.exports=function(e){return r(e)&&a[Lu(e)]||!1}}),B=n(function(e,a){\"use strict\";var n=P(),o=I(),i=C(),l=Error.captureStackTrace;a.exports=function(e){var t=new Error(e),r=arguments[1],e=arguments[2];return i(e)||o(r)&&(e=r,r=null),i(e)&&n(t,e),i(r)&&(t.code=r),l&&l(t,a.exports),t}}),L=n(function(e,t){\"use strict\";var n=R(),o=Object.defineProperty,i=Object.getOwnPropertyDescriptor,l=Object.getOwnPropertyNames,s=Object.getOwnPropertySymbols;t.exports=function(t,r){var a,e=Object(n(r));if(t=Object(n(t)),l(e).forEach(function(e){try{o(t,e,i(r,e))}catch(e){a=e}}),\"function\"==typeof s&&s(e).forEach(function(e){try{o(t,e,i(r,e))}catch(e){a=e}}),void 0!==a)throw a;return t}}),q=n(function(e,t){\"use strict\";function r(e,t){return t}var a,n,o,i,l,s=F();try{Object.defineProperty(r,\"length\",{configurable:!0,writable:!1,enumerable:!1,value:1})}catch(e){}1===r.length?(a={configurable:!0,writable:!1,enumerable:!1},n=Object.defineProperty,t.exports=function(e,t){return t=s(t),e.length===t?e:(a.value=t,n(e,\"length\",a))}):(i=L(),l=[],o=function(e){var t,r=0;if(l[e])return l[e];for(t=[];e--;)t.push(\"a\"+(++r).toString(36));return new Function(\"fn\",\"return function (\"+t.join(\", \")+\") { return fn.apply(this, arguments); };\")},t.exports=function(e,t){if(t=s(t),e.length===t)return e;t=o(t)(e);try{i(t,e)}catch(e){}return t})}),M=n(function(e,t){\"use strict\";t.exports=function(e){return null!=e}}),j=n(function(e,t){\"use strict\";var r=M(),a={object:!0,function:!0,undefined:!0};t.exports=function(e){return!!r(e)&&hasOwnProperty.call(a,Lu(e))}}),U=n(function(e,t){\"use strict\";var r=j();t.exports=function(e){if(!r(e))return!1;try{return e.constructor?e.constructor.prototype===e:!1}catch(e){return!1}}}),V=n(function(e,t){\"use strict\";var r=U();t.exports=function(e){if(\"function\"!=typeof e)return!1;if(!hasOwnProperty.call(e,\"length\"))return!1;try{if(\"number\"!=typeof e.length)return!1;if(\"function\"!=typeof e.call)return!1;if(\"function\"!=typeof e.apply)return!1}catch(e){return!1}return!r(e)}}),H=n(function(e,t){\"use strict\";var r=V(),a=/^\\s*class[\\s{/}]/,n=Function.prototype.toString;t.exports=function(e){return!!r(e)&&!a.test(n.call(e))}}),z=n(function(e,t){\"use strict\";var r=\"razdwatrzy\";t.exports=function(){return\"function\"==typeof r.contains&&(!0===r.contains(\"dwa\")&&!1===r.contains(\"foo\"))}}),$=n(function(e,t){\"use strict\";var r=String.prototype.indexOf;t.exports=function(e){return-1<r.call(this,e,arguments[1])}}),W=n(function(e,t){\"use strict\";t.exports=z()()?String.prototype.contains:$()}),G=n(function(e,t){\"use strict\";var i=M(),o=H(),l=P(),s=g(),u=W();(t.exports=function(e,t){var r,a,n,o;return arguments.length<2||\"string\"!=typeof e?(n=t,t=e,e=null):n=arguments[2],i(e)?(r=u.call(e,\"c\"),a=u.call(e,\"e\"),o=u.call(e,\"w\")):a=!(r=o=!0),o={value:t,configurable:r,enumerable:a,writable:o},n?l(s(n),o):o}).gs=function(e,t,r){var a,n;return\"string\"!=typeof e?(n=r,r=t,t=e,e=null):n=arguments[3],i(t)?o(t)?i(r)?o(r)||(n=r,r=void 0):r=void 0:(n=t,t=r=void 0):t=void 0,e=i(e)?(a=u.call(e,\"c\"),u.call(e,\"e\")):!(a=!0),e={get:t,set:r,configurable:a,enumerable:e},n?l(s(n),e):e}}),Y=n(function(e,t){\"use strict\";var r=G(),i=k(),l=Function.prototype.apply,s=Function.prototype.call,a=Object.create,n=Object.defineProperty,o=Object.defineProperties,u=Object.prototype.hasOwnProperty,c={configurable:!0,enumerable:!1,writable:!0},d=function(e,t){var r;return i(t),u.call(this,\"__ee__\")?r=this.__ee__:(r=c.value=a(null),n(this,\"__ee__\",c),c.value=null),r[e]?\"object\"===Lu(r[e])?r[e].push(t):r[e]=[r[e],t]:r[e]=t,this},p=function(e,t){var r,a;return i(t),d.call(a=this,e,r=function(){f.call(a,e,r),l.call(t,this,arguments)}),r.__eeOnceListener__=t,this},f=function(e,t){var r,a,n,o;if(i(t),!u.call(this,\"__ee__\"))return this;if(!(r=this.__ee__)[e])return this;if(a=r[e],\"object\"===Lu(a))for(o=0;n=a[o];++o)n!==t&&n.__eeOnceListener__!==t||(2===a.length?r[e]=a[o?0:1]:a.splice(o,1));else a!==t&&a.__eeOnceListener__!==t||delete r[e];return this},m=function(e){var t,r,a,n,o;if(u.call(this,\"__ee__\")&&(n=this.__ee__[e]))if(\"object\"===Lu(n)){for(r=arguments.length,o=new Array(r-1),t=1;t<r;++t)o[t-1]=arguments[t];for(n=n.slice(),t=0;a=n[t];++t)l.call(a,this,o)}else switch(arguments.length){case 1:s.call(n,this);break;case 2:s.call(n,this,arguments[1]);break;case 3:s.call(n,this,arguments[1],arguments[2]);break;default:for(r=arguments.length,o=new Array(r-1),t=1;t<r;++t)o[t-1]=arguments[t];l.call(n,this,o)}},h={on:d,once:p,off:f,emit:m},g={on:r(d),once:r(p),off:r(f),emit:r(m)},b=o({},g);t.exports=e=function(e){return null==e?a(b):o(Object(e),g)},e.methods=h}),K=n(function(e,t){\"use strict\";t.exports=function(){var e,t=Array.from;return\"function\"==typeof t&&(t=t(e=[\"raz\",\"dwa\"]),Boolean(t&&t!==e&&\"dwa\"===t[1]))}}),X=n(function(e,t){\"use strict\";t.exports=function(){return\"object\"===(\"undefined\"==typeof globalThis?\"undefined\":Lu(globalThis))&&(!!globalThis&&globalThis.Array===Array)}}),J=n(function(e,t){function r(){if(\"object\"===(\"undefined\"==typeof self?\"undefined\":Lu(self))&&self)return self;if(\"object\"===(void 0===window?\"undefined\":Lu(window))&&window)return window;throw new Error(\"Unable to resolve global `this`\")}t.exports=function(){if(this)return this;try{Object.defineProperty(Object.prototype,\"__global__\",{get:function(){return this},configurable:!0})}catch(e){return r()}try{return __global__?__global__:r()}finally{delete Object.prototype.__global__}}()}),Q=n(function(e,t){\"use strict\";t.exports=X()()?globalThis:J()}),Z=n(function(e,t){\"use strict\";var r=Q(),a={object:!0,symbol:!0};t.exports=function(){var e,t=r.Symbol;if(\"function\"!=typeof t)return!1;e=t(\"test symbol\");try{String(e)}catch(e){return!1}return!!a[Lu(t.iterator)]&&(!!a[Lu(t.toPrimitive)]&&!!a[Lu(t.toStringTag)])}}),ee=n(function(e,t){\"use strict\";t.exports=function(e){return!!e&&(\"symbol\"===Lu(e)||!!e.constructor&&(\"Symbol\"===e.constructor.name&&\"Symbol\"===e[e.constructor.toStringTag]))}}),te=n(function(e,t){\"use strict\";var r=ee();t.exports=function(e){if(!r(e))throw new TypeError(e+\" is not a symbol\");return e}}),re=n(function(e,t){\"use strict\";var n=G(),r=Object.create,o=Object.defineProperty,i=Object.prototype,l=r(null);t.exports=function(e){for(var t,r,a=0;l[e+(a||\"\")];)++a;return l[e+=a||\"\"]=!0,o(i,t=\"@@\"+e,n.gs(null,function(e){r||(r=!0,o(this,t,n(e)),r=!1)})),t}}),ae=n(function(e,t){\"use strict\";var r=G(),a=Q().Symbol;t.exports=function(e){return Object.defineProperties(e,{hasInstance:r(\"\",a&&a.hasInstance||e(\"hasInstance\")),isConcatSpreadable:r(\"\",a&&a.isConcatSpreadable||e(\"isConcatSpreadable\")),iterator:r(\"\",a&&a.iterator||e(\"iterator\")),match:r(\"\",a&&a.match||e(\"match\")),replace:r(\"\",a&&a.replace||e(\"replace\")),search:r(\"\",a&&a.search||e(\"search\")),species:r(\"\",a&&a.species||e(\"species\")),split:r(\"\",a&&a.split||e(\"split\")),toPrimitive:r(\"\",a&&a.toPrimitive||e(\"toPrimitive\")),toStringTag:r(\"\",a&&a.toStringTag||e(\"toStringTag\")),unscopables:r(\"\",a&&a.unscopables||e(\"unscopables\"))})}}),ne=n(function(e,t){\"use strict\";var r=G(),a=te(),n=Object.create(null);t.exports=function(t){return Object.defineProperties(t,{for:r(function(e){return n[e]||(n[e]=t(String(e)))}),keyFor:r(function(e){for(var t in a(e),n)if(n[t]===e)return t})})}}),oe=n(function(e,t){\"use strict\";var r,a,n,o=G(),i=te(),l=Q().Symbol,s=re(),u=ae(),c=ne(),d=Object.create,p=Object.defineProperties,f=Object.defineProperty;if(\"function\"==typeof l)try{String(l()),n=!0}catch(e){}else l=null;a=function(e){if(this instanceof a)throw new TypeError(\"Symbol is not a constructor\");return r(e)},t.exports=r=function e(t){var r;if(this instanceof e)throw new TypeError(\"Symbol is not a constructor\");return n?l(t):(r=d(a.prototype),t=void 0===t?\"\":String(t),p(r,{__description__:o(\"\",t),__name__:o(\"\",s(t))}))},u(r),c(r),p(a.prototype,{constructor:o(r),toString:o(\"\",function(){return this.__name__})}),p(r.prototype,{toString:o(function(){return\"Symbol (\"+i(this).__description__+\")\"}),valueOf:o(function(){return i(this)})}),f(r.prototype,r.toPrimitive,o(\"\",function(){var e=i(this);return\"symbol\"===Lu(e)?e:e.toString()})),f(r.prototype,r.toStringTag,o(\"c\",\"Symbol\")),f(a.prototype,r.toStringTag,o(\"c\",r.prototype[r.toStringTag])),f(a.prototype,r.toPrimitive,o(\"c\",r.prototype[r.toPrimitive]))}),ie=n(function(e,t){\"use strict\";t.exports=Z()()?Q().Symbol:oe()}),le=n(function(e,t){\"use strict\";var r=Object.prototype.toString,a=r.call(function(){return arguments}());t.exports=function(e){return r.call(e)===a}}),se=n(function(e,t){\"use strict\";var r=Object.prototype.toString,a=RegExp.prototype.test.bind(/^[object [A-Za-z0-9]*Function]$/);t.exports=function(e){return\"function\"==typeof e&&a(r.call(e))}}),ue=n(function(e,t){\"use strict\";var r=Object.prototype.toString,a=r.call(\"\");t.exports=function(e){return\"string\"==typeof e||e&&\"object\"===Lu(e)&&(e instanceof String||r.call(e)===a)||!1}}),ce=n(function(e,t){\"use strict\";var f=ie().iterator,m=le(),h=se(),g=F(),b=k(),y=R(),v=C(),D=ue(),w=Array.isArray,x=Function.prototype.call,E={configurable:!0,enumerable:!0,writable:!0,value:null},A=Object.defineProperty;t.exports=function(e){var t,r,a,n,o,i,l,s,u,c,d=arguments[1],p=arguments[2];if(e=Object(y(e)),v(d)&&b(d),this&&this!==Array&&h(this))t=this;else{if(!d){if(m(e))return 1!==(o=e.length)?Array.apply(null,e):((n=new Array(1))[0]=e[0],n);if(w(e)){for(n=new Array(o=e.length),r=0;r<o;++r)n[r]=e[r];return n}}n=[]}if(!w(e))if(void 0!==(u=e[f])){for(l=b(u).call(e),t&&(n=new t),s=l.next(),r=0;!s.done;)c=d?x.call(d,p,s.value,r):s.value,t?(E.value=c,A(n,r,E)):n[r]=c,s=l.next(),++r;o=r}else if(D(e)){for(o=e.length,t&&(n=new t),a=r=0;r<o;++r)c=e[r],r+1<o&&55296<=(i=c.charCodeAt(0))&&i<=56319&&(c+=e[++r]),c=d?x.call(d,p,c,a):c,t?(E.value=c,A(n,a,E)):n[a]=c,++a;o=a}if(void 0===o)for(o=g(e.length),t&&(n=new t(o)),r=0;r<o;++r)c=d?x.call(d,p,e[r],r):e[r],t?(E.value=c,A(n,r,E)):n[r]=c;return t&&(E.value=null,n.length=o),n}}),de=n(function(e,t){\"use strict\";t.exports=K()()?Array.from:ce()}),pe=n(function(e,t){\"use strict\";var r=de(),a=Array.isArray;t.exports=function(e){return a(e)?e:r(e)}}),fe=n(function(e,t){\"use strict\";var r=pe(),a=C(),n=k(),o=Array.prototype.slice,i=function(r){return this.map(function(e,t){return e?e(r[t]):r[t]}).concat(o.call(r,this.length))};t.exports=function(e){return(e=r(e)).forEach(function(e){a(e)&&n(e)}),i.bind(e)}}),me=n(function(e,t){\"use strict\";var r=k();t.exports=function(e){var t;return\"function\"==typeof e?{set:e,get:e}:(t={get:r(e.get)},void 0!==e.set?(t.set=r(e.set),e.delete&&(t.delete=r(e.delete)),e.clear&&(t.clear=r(e.clear))):t.set=t.get,t)}}),he=n(function(e,t){\"use strict\";var g=B(),b=q(),y=G(),r=Y().methods,v=fe(),D=me(),w=Function.prototype.apply,x=Function.prototype.call,E=Object.create,A=Object.defineProperties,C=r.on,F=r.emit;t.exports=function(n,t,e){var o,i,l,r,a,s,u,c,d,p,f,m=E(null),h=!1!==t?t:isNaN(n.length)?1:n.length;return e.normalizer&&(s=D(e.normalizer),i=s.get,l=s.set,r=s.delete,a=s.clear),null!=e.resolvers&&(f=v(e.resolvers)),p=i?b(function(e){var t,r,a=arguments;if(f&&(a=f(a)),null!==(t=i(a))&&hasOwnProperty.call(m,t))return u&&o.emit(\"get\",t,a,this),m[t];if(r=1===a.length?x.call(n,this,a[0]):w.call(n,this,a),null===t){if(null!==(t=i(a)))throw g(\"Circular invocation\",\"CIRCULAR_INVOCATION\");t=l(a)}else if(hasOwnProperty.call(m,t))throw g(\"Circular invocation\",\"CIRCULAR_INVOCATION\");return m[t]=r,c&&o.emit(\"set\",t,null,r),r},h):0===t?function(){var e;if(hasOwnProperty.call(m,\"data\"))return u&&o.emit(\"get\",\"data\",arguments,this),m.data;if(e=arguments.length?w.call(n,this,arguments):x.call(n,this),hasOwnProperty.call(m,\"data\"))throw g(\"Circular invocation\",\"CIRCULAR_INVOCATION\");return m.data=e,c&&o.emit(\"set\",\"data\",null,e),e}:function(e){var t,r=arguments;if(f&&(r=f(arguments)),t=String(r[0]),hasOwnProperty.call(m,t))return u&&o.emit(\"get\",t,r,this),m[t];if(r=1===r.length?x.call(n,this,r[0]):w.call(n,this,r),hasOwnProperty.call(m,t))throw g(\"Circular invocation\",\"CIRCULAR_INVOCATION\");return m[t]=r,c&&o.emit(\"set\",t,null,r),r},o={original:n,memoized:p,profileName:e.profileName,get:function(e){return f&&(e=f(e)),i?i(e):String(e[0])},has:function(e){return hasOwnProperty.call(m,e)},delete:function(e){var t;hasOwnProperty.call(m,e)&&(r&&r(e),t=m[e],delete m[e],d&&o.emit(\"delete\",e,t))},clear:function(){var e=m;a&&a(),m=E(null),o.emit(\"clear\",e)},on:function(e,t){return\"get\"===e?u=!0:\"set\"===e?c=!0:\"delete\"===e&&(d=!0),C.call(this,e,t)},emit:F,updateEnv:function(){n=o.original}},s=i?b(function(e){var t=arguments;f&&(t=f(t)),null!==(t=i(t))&&o.delete(t)},h):0===t?function(){return o.delete(\"data\")}:function(e){return f&&(e=f(arguments)[0]),o.delete(e)},e=b(function(){var e=arguments;return 0===t?m.data:(f&&(e=f(e)),e=i?i(e):String(e[0]),m[e])}),h=b(function(){var e=arguments;return 0===t?o.has(\"data\"):(f&&(e=f(e)),null!==(e=i?i(e):String(e[0]))&&o.has(e))}),A(p,{__memoized__:y(!0),delete:y(s),clear:y(o.clear),_get:y(e),_has:y(h)}),o}}),ge=n(function(e,t){\"use strict\";var o=k(),i=E(),l=A(),s=he(),u=w();t.exports=function e(t){var r,a,n;if(o(t),(r=Object(arguments[1])).async&&r.promise)throw new Error(\"Options 'async' and 'promise' cannot be used together\");return hasOwnProperty.call(t,\"__memoized__\")&&!r.force?t:(a=u(r.length,t.length,r.async&&l.async),n=s(t,a,r),i(l,function(e,t){r[t]&&e(r[t],n,r)}),e.__profiler__&&e.__profiler__(n),n.updateEnv(),n.memoized)}}),be=n(function(e,t){\"use strict\";t.exports=function(e){var t,r,a=e.length;if(!a)return\"\u0002\";for(t=String(e[r=0]);--a;)t+=\"\u0001\"+e[++r];return t}}),ye=n(function(e,t){\"use strict\";t.exports=function(n){return n?function(e){for(var t=String(e[0]),r=0,a=n;--a;)t+=\"\u0001\"+e[++r];return t}:function(){return\"\"}}}),ve=n(function(e,t){\"use strict\";t.exports=function(){var e=Number.isNaN;return\"function\"==typeof e&&(!e({})&&e(NaN)&&!e(34))}}),De=n(function(e,t){\"use strict\";t.exports=function(e){return e!=e}}),we=n(function(e,t){\"use strict\";t.exports=ve()()?Number.isNaN:De()}),xe=n(function(e,t){\"use strict\";var n=we(),o=F(),i=R(),l=Array.prototype.indexOf,s=Object.prototype.hasOwnProperty,u=Math.abs,c=Math.floor;t.exports=function(e){var t,r,a;if(!n(e))return l.apply(this,arguments);for(r=o(i(this).length),e=arguments[1],t=e=isNaN(e)?0:0<=e?c(e):o(this.length)-c(u(e));t<r;++t)if(s.call(this,t)&&(a=this[t],n(a)))return t;return-1}}),Ee=n(function(e,t){\"use strict\";var u=xe(),r=Object.create;t.exports=function(){var o=0,l=[],s=r(null);return{get:function(e){var t,r=0,a=l,n=e.length;if(0===n)return a[n]||null;if(a=a[n]){for(;r<n-1;){if(-1===(t=u.call(a[0],e[r])))return null;a=a[1][t],++r}return-1===(t=u.call(a[0],e[r]))?null:a[1][t]||null}return null},set:function(e){var t,r=0,a=l,n=e.length;if(0===n)a[n]=++o;else{for(a[n]||(a[n]=[[],[]]),a=a[n];r<n-1;)-1===(t=u.call(a[0],e[r]))&&(t=a[0].push(e[r])-1,a[1].push([[],[]])),a=a[1][t],++r;-1===(t=u.call(a[0],e[r]))&&(t=a[0].push(e[r])-1),a[1][t]=++o}return s[o]=e,o},delete:function(e){var t,r=0,a=l,n=s[e],o=n.length,i=[];if(0===o)delete a[o];else if(a=a[o]){for(;r<o-1;){if(-1===(t=u.call(a[0],n[r])))return;i.push(a,t),a=a[1][t],++r}if(-1===(t=u.call(a[0],n[r])))return;for(e=a[1][t],a[0].splice(t,1),a[1].splice(t,1);!a[0].length&&i.length;)t=i.pop(),(a=i.pop())[0].splice(t,1),a[1].splice(t,1)}delete s[e]},clear:function(){l=[],s=r(null)}}}}),Ae=n(function(e,t){\"use strict\";var n=xe();t.exports=function(){var t=0,r=[],a=[];return{get:function(e){e=n.call(r,e[0]);return-1===e?null:a[e]},set:function(e){return r.push(e[0]),a.push(++t),t},delete:function(e){e=n.call(a,e);-1!==e&&(r.splice(e,1),a.splice(e,1))},clear:function(){r=[],a=[]}}}}),Ce=n(function(e,t){\"use strict\";var u=xe(),r=Object.create;t.exports=function(i){var n=0,l=[[],[]],s=r(null);return{get:function(e){for(var t,r=0,a=l;r<i-1;){if(-1===(t=u.call(a[0],e[r])))return null;a=a[1][t],++r}return-1!==(t=u.call(a[0],e[r]))&&a[1][t]||null},set:function(e){for(var t,r=0,a=l;r<i-1;)-1===(t=u.call(a[0],e[r]))&&(t=a[0].push(e[r])-1,a[1].push([[],[]])),a=a[1][t],++r;return-1===(t=u.call(a[0],e[r]))&&(t=a[0].push(e[r])-1),a[1][t]=++n,s[n]=e,n},delete:function(e){for(var t,r=0,a=l,n=[],o=s[e];r<i-1;){if(-1===(t=u.call(a[0],o[r])))return;n.push(a,t),a=a[1][t],++r}if(-1!==(t=u.call(a[0],o[r]))){for(e=a[1][t],a[0].splice(t,1),a[1].splice(t,1);!a[0].length&&n.length;)t=n.pop(),(a=n.pop())[0].splice(t,1),a[1].splice(t,1);delete s[e]}},clear:function(){l=[[],[]],s=r(null)}}}}),Fe=n(function(e,t){\"use strict\";var r=k(),a=E(),l=Function.prototype.call;t.exports=function(e,n){var o={},i=arguments[2];return r(n),a(e,function(e,t,r,a){o[t]=l.call(n,i,e,t,r,a)}),o}}),ke=n(function(e,t){\"use strict\";function o(e){if(\"function\"!=typeof e)throw new TypeError(e+\" is not a function\");return e}function r(e){var t,r,a=document.createTextNode(\"\"),n=0;return new e(function(){var e;if(t)r&&(t=r.concat(t));else{if(!r)return;t=r}if(r=t,t=null,\"function\"==typeof r)return e=r,r=null,void e();for(a.data=n=++n%2;r;)e=r.shift(),r.length||(r=null),e()}).observe(a,{characterData:!0}),function(e){o(e),t?\"function\"==typeof t?t=[t,e]:t.push(e):(t=e,a.data=n=++n%2)}}t.exports=function(){if(\"object\"===(\"undefined\"==typeof process?\"undefined\":Lu(process))&&process&&\"function\"==typeof process.nextTick)return process.nextTick;if(\"function\"==typeof queueMicrotask)return function(e){queueMicrotask(o(e))};if(\"object\"===(void 0===document?\"undefined\":Lu(document))&&document){if(\"function\"==typeof MutationObserver)return r(MutationObserver);if(\"function\"==typeof WebKitMutationObserver)return r(WebKitMutationObserver)}return\"function\"==typeof setImmediate?function(e){setImmediate(o(e))}:\"function\"==typeof setTimeout||\"object\"===(\"undefined\"==typeof setTimeout?\"undefined\":Lu(setTimeout))?function(e){setTimeout(o(e),0)}:null}()}),Re=n(function(){\"use strict\";var p=de(),t=Fe(),r=L(),n=q(),f=ke(),m=Array.prototype.slice,h=Function.prototype.apply,g=Object.create;A().async=function(e,i){var l,s,u,c=g(null),d=g(null),o=i.memoized,a=i.original;i.memoized=n(function(e){var t=arguments,r=t[t.length-1];return\"function\"==typeof r&&(l=r,t=m.call(t,0,-1)),o.apply(s=this,u=t)},o);try{r(i.memoized,o)}catch(e){}i.on(\"get\",function(t){var r,a,n;if(l){if(c[t])return\"function\"==typeof c[t]?c[t]=[c[t],l]:c[t].push(l),void(l=null);r=l,a=s,n=u,l=s=u=null,f(function(){var e;hasOwnProperty.call(d,t)?(e=d[t],i.emit(\"getasync\",t,n,a),h.call(r,e.context,e.args)):(l=r,s=a,u=n,o.apply(a,n))})}}),i.original=function(){var e,t,r,o;return l?(e=p(arguments),t=function e(t){var r,a,n=e.id;if(null!=n){if(delete e.id,r=c[n],delete c[n],r)return a=p(arguments),i.has(n)&&(t?i.delete(n):(d[n]={context:this,args:a},i.emit(\"setasync\",n,\"function\"==typeof r?1:r.length))),\"function\"==typeof r?o=h.call(r,this,a):r.forEach(function(e){o=h.call(e,this,a)},this),o}else f(h.bind(e,this,arguments))},r=l,l=s=u=null,e.push(t),o=h.call(a,this,e),t.cb=r,l=t,o):h.call(a,this,arguments)},i.on(\"set\",function(e){l?(c[e]?\"function\"==typeof c[e]?c[e]=[c[e],l.cb]:c[e].push(l.cb):c[e]=l.cb,delete l.cb,l.id=e,l=null):i.delete(e)}),i.on(\"delete\",function(e){var t;hasOwnProperty.call(c,e)||d[e]&&(t=d[e],delete d[e],i.emit(\"deleteasync\",e,m.call(t.args,1)))}),i.on(\"clear\",function(){var e=d;d=g(null),i.emit(\"clearasync\",t(e,function(e){return m.call(e.args,1)}))})}}),Te=n(function(e,t){\"use strict\";var r=Array.prototype.forEach,a=Object.create;t.exports=function(e){var t=a(null);return r.call(arguments,function(e){t[e]=!0}),t}}),Ne=n(function(e,t){\"use strict\";t.exports=function(e){return\"function\"==typeof e}}),_e=n(function(e,t){\"use strict\";var r=Ne();t.exports=function(e){try{return e&&r(e.toString)?e.toString():String(e)}catch(e){throw new TypeError(\"Passed argument cannot be stringifed\")}}}),Oe=n(function(e,t){\"use strict\";var r=R(),a=_e();t.exports=function(e){return a(r(e))}}),Se=n(function(e,t){\"use strict\";var r=Ne();t.exports=function(e){try{return e&&r(e.toString)?e.toString():String(e)}catch(e){return\"<Non-coercible to string value>\"}}}),Pe=n(function(e,t){\"use strict\";var r=Se(),a=/[\\n\\r\\u2028\\u2029]/g;t.exports=function(e){e=r(e);return e=(e=100<e.length?e.slice(0,99)+\"…\":e).replace(a,function(e){return JSON.stringify(e).slice(1,-1)})}}),Ie=n(function(e,t){function r(e){return!!e&&(\"object\"===Lu(e)||\"function\"==typeof e)&&\"function\"==typeof e.then}t.exports=r,t.exports.default=r}),Be=n(function(){\"use strict\";var t=Fe(),e=Te(),r=Oe(),a=Pe(),f=Ie(),m=ke(),n=Object.create,o=e(\"then\",\"then:finally\",\"done\",\"done:finally\");A().promise=function(s,u){var c=n(null),d=n(null),p=n(null);if(!0===s)s=null;else if(s=r(s),!o[s])throw new TypeError(\"'\"+a(s)+\"' is not valid promise mode\");u.on(\"set\",function(r,e,t){var a=!1;if(!f(t))return d[r]=t,void u.emit(\"setasync\",r,1);c[r]=1,p[r]=t;function n(e){var t=c[r];if(a)throw new Error(\"Memoizee error: Detected unordered then|done & finally resolution, which in turn makes proper detection of success/failure impossible (when in 'done:finally' mode)\\nConsider to rely on 'then' or 'done' mode instead.\");t&&(delete c[r],d[r]=e,u.emit(\"setasync\",r,t))}function o(){a=!0,c[r]&&(delete c[r],delete p[r],u.delete(r))}var i=s;if(\"then\"===(i=i||\"then\")){var l=function(){m(o)};\"function\"==typeof(t=t.then(function(e){m(n.bind(this,e))},l)).finally&&t.finally(l)}else if(\"done\"===i){if(\"function\"!=typeof t.done)throw new Error(\"Memoizee error: Retrieved promise does not implement 'done' in 'done' mode\");t.done(n,o)}else if(\"done:finally\"===i){if(\"function\"!=typeof t.done)throw new Error(\"Memoizee error: Retrieved promise does not implement 'done' in 'done:finally' mode\");if(\"function\"!=typeof t.finally)throw new Error(\"Memoizee error: Retrieved promise does not implement 'finally' in 'done:finally' mode\");t.done(n),t.finally(o)}}),u.on(\"get\",function(e,t,r){var a,n;c[e]?++c[e]:(a=p[e],n=function(){u.emit(\"getasync\",e,t,r)},f(a)?\"function\"==typeof a.done?a.done(n):a.then(function(){m(n)}):n())}),u.on(\"delete\",function(e){var t;delete p[e],c[e]?delete c[e]:hasOwnProperty.call(d,e)&&(t=d[e],delete d[e],u.emit(\"deleteasync\",e,[t]))}),u.on(\"clear\",function(){var e=d;d=n(null),c=n(null),p=n(null),u.emit(\"clearasync\",t(e,function(e){return[e]}))})}}),Le=n(function(){\"use strict\";var n=k(),o=E(),i=A(),l=Function.prototype.apply;i.dispose=function(r,e,t){var a;if(n(r),t.async&&i.async||t.promise&&i.promise)return e.on(\"deleteasync\",a=function(e,t){l.call(r,null,t)}),void e.on(\"clearasync\",function(e){o(e,function(e,t){a(t,e)})});e.on(\"delete\",a=function(e,t){r(t)}),e.on(\"clear\",function(e){o(e,function(e,t){a(t,e)})})}}),qe=n(function(e,t){\"use strict\";t.exports=2147483647}),Me=n(function(e,t){\"use strict\";var r=F(),a=qe();t.exports=function(e){if(e=r(e),a<e)throw new TypeError(e+\" exceeds maximum possible timeout\");return e}}),je=n(function(){\"use strict\";var l=de(),s=E(),u=ke(),c=Ie(),d=Me(),p=A(),f=Function.prototype,m=Math.max,h=Math.min,g=Object.create;p.maxAge=function(t,n,o){var r,e,a,i;(t=d(t))&&(r=g(null),e=o.async&&p.async||o.promise&&p.promise?\"async\":\"\",n.on(\"set\"+e,function(e){r[e]=setTimeout(function(){n.delete(e)},t),\"function\"==typeof r[e].unref&&r[e].unref(),i&&(i[e]&&\"nextTick\"!==i[e]&&clearTimeout(i[e]),i[e]=setTimeout(function(){delete i[e]},a),\"function\"==typeof i[e].unref&&i[e].unref())}),n.on(\"delete\"+e,function(e){clearTimeout(r[e]),delete r[e],i&&(\"nextTick\"!==i[e]&&clearTimeout(i[e]),delete i[e])}),o.preFetch&&(a=!0===o.preFetch||isNaN(o.preFetch)?.333:m(h(Number(o.preFetch),1),0))&&(i={},a=(1-a)*t,n.on(\"get\"+e,function(t,r,a){i[t]||(i[t]=\"nextTick\",u(function(){var e;\"nextTick\"===i[t]&&(delete i[t],n.delete(t),o.async&&(r=l(r)).push(f),e=n.memoized.apply(a,r),o.promise&&c(e)&&(\"function\"==typeof e.done?e.done(f,f):e.then(f,f)))}))})),n.on(\"clear\"+e,function(){s(r,function(e){clearTimeout(e)}),r={},i&&(s(i,function(e){\"nextTick\"!==e&&clearTimeout(e)}),i={})}))}}),Ue=n(function(e,t){\"use strict\";var r=F(),c=Object.create,d=Object.prototype.hasOwnProperty;t.exports=function(a){var n,o=0,i=1,l=c(null),s=c(null),u=0;return a=r(a),{hit:function(e){var t=s[e],r=++u;if(l[r]=e,s[e]=r,!t)return++o<=a?void 0:(e=l[i],n(e),e);if(delete l[t],i===t)for(;!d.call(l,++i););},delete:n=function(e){var t=s[e];if(t&&(delete l[t],delete s[e],--o,i===t)){if(!o)return u=0,void(i=1);for(;!d.call(l,++i););}},clear:function(){o=0,i=1,l=c(null),s=c(null),u=0}}}}),Ve=n(function(){\"use strict\";var n=F(),o=Ue(),i=A();i.max=function(e,t,r){var a;(e=n(e))&&(a=o(e),e=r.async&&i.async||r.promise&&i.promise?\"async\":\"\",t.on(\"set\"+e,r=function(e){void 0!==(e=a.hit(e))&&t.delete(e)}),t.on(\"get\"+e,r),t.on(\"delete\"+e,a.delete),t.on(\"clear\"+e,a.clear))}}),He=n(function(){\"use strict\";var n=G(),o=A(),i=Object.create,l=Object.defineProperties;o.refCounter=function(e,t,r){var a=i(null),r=r.async&&o.async||r.promise&&o.promise?\"async\":\"\";t.on(\"set\"+r,function(e,t){a[e]=t||1}),t.on(\"get\"+r,function(e){++a[e]}),t.on(\"delete\"+r,function(e){delete a[e]}),t.on(\"clear\"+r,function(){a={}}),l(t.memoized,{deleteRef:n(function(){var e=t.get(arguments);return null!==e&&a[e]?!--a[e]&&(t.delete(e),!0):null}),getRefCount:n(function(){var e=t.get(arguments);return null!==e&&a[e]||0})})}}),ze=n(function(e,t){\"use strict\";var a=g(),n=w(),o=ge();t.exports=function(e){var t,r=a(arguments[1]);return r.normalizer||0!==(t=r.length=n(r.length,e.length,r.async))&&(r.primitive?!1===t?r.normalizer=be():1<t&&(r.normalizer=ye()(t)):r.normalizer=!1===t?Ee()():1===t?Ae()():Ce()(t)),r.async&&Re(),r.promise&&Be(),r.dispose&&Le(),r.maxAge&&je(),r.max&&Ve(),r.refCounter&&He(),o(e,r)}}),$e=n(function(e,t){\"use strict\";t.exports=function(){return/\\uD83C\\uDFF4\\uDB40\\uDC67\\uDB40\\uDC62(?:\\uDB40\\uDC65\\uDB40\\uDC6E\\uDB40\\uDC67|\\uDB40\\uDC73\\uDB40\\uDC63\\uDB40\\uDC74|\\uDB40\\uDC77\\uDB40\\uDC6C\\uDB40\\uDC73)\\uDB40\\uDC7F|\\uD83D\\uDC68(?:\\uD83C\\uDFFC\\u200D(?:\\uD83E\\uDD1D\\u200D\\uD83D\\uDC68\\uD83C\\uDFFB|\\uD83C[\\uDF3E\\uDF73\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uD83E[\\uDDAF-\\uDDB3\\uDDBC\\uDDBD])|\\uD83C\\uDFFF\\u200D(?:\\uD83E\\uDD1D\\u200D\\uD83D\\uDC68(?:\\uD83C[\\uDFFB-\\uDFFE])|\\uD83C[\\uDF3E\\uDF73\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uD83E[\\uDDAF-\\uDDB3\\uDDBC\\uDDBD])|\\uD83C\\uDFFE\\u200D(?:\\uD83E\\uDD1D\\u200D\\uD83D\\uDC68(?:\\uD83C[\\uDFFB-\\uDFFD])|\\uD83C[\\uDF3E\\uDF73\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uD83E[\\uDDAF-\\uDDB3\\uDDBC\\uDDBD])|\\uD83C\\uDFFD\\u200D(?:\\uD83E\\uDD1D\\u200D\\uD83D\\uDC68(?:\\uD83C[\\uDFFB\\uDFFC])|\\uD83C[\\uDF3E\\uDF73\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uD83E[\\uDDAF-\\uDDB3\\uDDBC\\uDDBD])|\\u200D(?:\\u2764\\uFE0F\\u200D(?:\\uD83D\\uDC8B\\u200D)?\\uD83D\\uDC68|(?:\\uD83D[\\uDC68\\uDC69])\\u200D(?:\\uD83D\\uDC66\\u200D\\uD83D\\uDC66|\\uD83D\\uDC67\\u200D(?:\\uD83D[\\uDC66\\uDC67]))|\\uD83D\\uDC66\\u200D\\uD83D\\uDC66|\\uD83D\\uDC67\\u200D(?:\\uD83D[\\uDC66\\uDC67])|(?:\\uD83D[\\uDC68\\uDC69])\\u200D(?:\\uD83D[\\uDC66\\uDC67])|[\\u2695\\u2696\\u2708]\\uFE0F|\\uD83D[\\uDC66\\uDC67]|\\uD83C[\\uDF3E\\uDF73\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uD83E[\\uDDAF-\\uDDB3\\uDDBC\\uDDBD])|(?:\\uD83C\\uDFFB\\u200D[\\u2695\\u2696\\u2708]|\\uD83C\\uDFFF\\u200D[\\u2695\\u2696\\u2708]|\\uD83C\\uDFFE\\u200D[\\u2695\\u2696\\u2708]|\\uD83C\\uDFFD\\u200D[\\u2695\\u2696\\u2708]|\\uD83C\\uDFFC\\u200D[\\u2695\\u2696\\u2708])\\uFE0F|\\uD83C\\uDFFB\\u200D(?:\\uD83C[\\uDF3E\\uDF73\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uD83E[\\uDDAF-\\uDDB3\\uDDBC\\uDDBD])|\\uD83C[\\uDFFB-\\uDFFF])|(?:\\uD83E\\uDDD1\\uD83C\\uDFFB\\u200D\\uD83E\\uDD1D\\u200D\\uD83E\\uDDD1|\\uD83D\\uDC69\\uD83C\\uDFFC\\u200D\\uD83E\\uDD1D\\u200D\\uD83D\\uDC69)\\uD83C\\uDFFB|\\uD83E\\uDDD1(?:\\uD83C\\uDFFF\\u200D\\uD83E\\uDD1D\\u200D\\uD83E\\uDDD1(?:\\uD83C[\\uDFFB-\\uDFFF])|\\u200D\\uD83E\\uDD1D\\u200D\\uD83E\\uDDD1)|(?:\\uD83E\\uDDD1\\uD83C\\uDFFE\\u200D\\uD83E\\uDD1D\\u200D\\uD83E\\uDDD1|\\uD83D\\uDC69\\uD83C\\uDFFF\\u200D\\uD83E\\uDD1D\\u200D(?:\\uD83D[\\uDC68\\uDC69]))(?:\\uD83C[\\uDFFB-\\uDFFE])|(?:\\uD83E\\uDDD1\\uD83C\\uDFFC\\u200D\\uD83E\\uDD1D\\u200D\\uD83E\\uDDD1|\\uD83D\\uDC69\\uD83C\\uDFFD\\u200D\\uD83E\\uDD1D\\u200D\\uD83D\\uDC69)(?:\\uD83C[\\uDFFB\\uDFFC])|\\uD83D\\uDC69(?:\\uD83C\\uDFFE\\u200D(?:\\uD83E\\uDD1D\\u200D\\uD83D\\uDC68(?:\\uD83C[\\uDFFB-\\uDFFD\\uDFFF])|\\uD83C[\\uDF3E\\uDF73\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uD83E[\\uDDAF-\\uDDB3\\uDDBC\\uDDBD])|\\uD83C\\uDFFC\\u200D(?:\\uD83E\\uDD1D\\u200D\\uD83D\\uDC68(?:\\uD83C[\\uDFFB\\uDFFD-\\uDFFF])|\\uD83C[\\uDF3E\\uDF73\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uD83E[\\uDDAF-\\uDDB3\\uDDBC\\uDDBD])|\\uD83C\\uDFFB\\u200D(?:\\uD83E\\uDD1D\\u200D\\uD83D\\uDC68(?:\\uD83C[\\uDFFC-\\uDFFF])|\\uD83C[\\uDF3E\\uDF73\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uD83E[\\uDDAF-\\uDDB3\\uDDBC\\uDDBD])|\\uD83C\\uDFFD\\u200D(?:\\uD83E\\uDD1D\\u200D\\uD83D\\uDC68(?:\\uD83C[\\uDFFB\\uDFFC\\uDFFE\\uDFFF])|\\uD83C[\\uDF3E\\uDF73\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uD83E[\\uDDAF-\\uDDB3\\uDDBC\\uDDBD])|\\u200D(?:\\u2764\\uFE0F\\u200D(?:\\uD83D\\uDC8B\\u200D(?:\\uD83D[\\uDC68\\uDC69])|\\uD83D[\\uDC68\\uDC69])|\\uD83C[\\uDF3E\\uDF73\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uD83E[\\uDDAF-\\uDDB3\\uDDBC\\uDDBD])|\\uD83C\\uDFFF\\u200D(?:\\uD83C[\\uDF3E\\uDF73\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uD83E[\\uDDAF-\\uDDB3\\uDDBC\\uDDBD]))|\\uD83D\\uDC69\\u200D\\uD83D\\uDC69\\u200D(?:\\uD83D\\uDC66\\u200D\\uD83D\\uDC66|\\uD83D\\uDC67\\u200D(?:\\uD83D[\\uDC66\\uDC67]))|(?:\\uD83E\\uDDD1\\uD83C\\uDFFD\\u200D\\uD83E\\uDD1D\\u200D\\uD83E\\uDDD1|\\uD83D\\uDC69\\uD83C\\uDFFE\\u200D\\uD83E\\uDD1D\\u200D\\uD83D\\uDC69)(?:\\uD83C[\\uDFFB-\\uDFFD])|\\uD83D\\uDC69\\u200D\\uD83D\\uDC66\\u200D\\uD83D\\uDC66|\\uD83D\\uDC69\\u200D\\uD83D\\uDC69\\u200D(?:\\uD83D[\\uDC66\\uDC67])|(?:\\uD83D\\uDC41\\uFE0F\\u200D\\uD83D\\uDDE8|\\uD83D\\uDC69(?:\\uD83C\\uDFFF\\u200D[\\u2695\\u2696\\u2708]|\\uD83C\\uDFFE\\u200D[\\u2695\\u2696\\u2708]|\\uD83C\\uDFFC\\u200D[\\u2695\\u2696\\u2708]|\\uD83C\\uDFFB\\u200D[\\u2695\\u2696\\u2708]|\\uD83C\\uDFFD\\u200D[\\u2695\\u2696\\u2708]|\\u200D[\\u2695\\u2696\\u2708])|(?:(?:\\u26F9|\\uD83C[\\uDFCB\\uDFCC]|\\uD83D\\uDD75)\\uFE0F|\\uD83D\\uDC6F|\\uD83E[\\uDD3C\\uDDDE\\uDDDF])\\u200D[\\u2640\\u2642]|(?:\\u26F9|\\uD83C[\\uDFCB\\uDFCC]|\\uD83D\\uDD75)(?:\\uD83C[\\uDFFB-\\uDFFF])\\u200D[\\u2640\\u2642]|(?:\\uD83C[\\uDFC3\\uDFC4\\uDFCA]|\\uD83D[\\uDC6E\\uDC71\\uDC73\\uDC77\\uDC81\\uDC82\\uDC86\\uDC87\\uDE45-\\uDE47\\uDE4B\\uDE4D\\uDE4E\\uDEA3\\uDEB4-\\uDEB6]|\\uD83E[\\uDD26\\uDD37-\\uDD39\\uDD3D\\uDD3E\\uDDB8\\uDDB9\\uDDCD-\\uDDCF\\uDDD6-\\uDDDD])(?:(?:\\uD83C[\\uDFFB-\\uDFFF])\\u200D[\\u2640\\u2642]|\\u200D[\\u2640\\u2642])|\\uD83C\\uDFF4\\u200D\\u2620)\\uFE0F|\\uD83D\\uDC69\\u200D\\uD83D\\uDC67\\u200D(?:\\uD83D[\\uDC66\\uDC67])|\\uD83C\\uDFF3\\uFE0F\\u200D\\uD83C\\uDF08|\\uD83D\\uDC15\\u200D\\uD83E\\uDDBA|\\uD83D\\uDC69\\u200D\\uD83D\\uDC66|\\uD83D\\uDC69\\u200D\\uD83D\\uDC67|\\uD83C\\uDDFD\\uD83C\\uDDF0|\\uD83C\\uDDF4\\uD83C\\uDDF2|\\uD83C\\uDDF6\\uD83C\\uDDE6|[#\\*0-9]\\uFE0F\\u20E3|\\uD83C\\uDDE7(?:\\uD83C[\\uDDE6\\uDDE7\\uDDE9-\\uDDEF\\uDDF1-\\uDDF4\\uDDF6-\\uDDF9\\uDDFB\\uDDFC\\uDDFE\\uDDFF])|\\uD83C\\uDDF9(?:\\uD83C[\\uDDE6\\uDDE8\\uDDE9\\uDDEB-\\uDDED\\uDDEF-\\uDDF4\\uDDF7\\uDDF9\\uDDFB\\uDDFC\\uDDFF])|\\uD83C\\uDDEA(?:\\uD83C[\\uDDE6\\uDDE8\\uDDEA\\uDDEC\\uDDED\\uDDF7-\\uDDFA])|\\uD83E\\uDDD1(?:\\uD83C[\\uDFFB-\\uDFFF])|\\uD83C\\uDDF7(?:\\uD83C[\\uDDEA\\uDDF4\\uDDF8\\uDDFA\\uDDFC])|\\uD83D\\uDC69(?:\\uD83C[\\uDFFB-\\uDFFF])|\\uD83C\\uDDF2(?:\\uD83C[\\uDDE6\\uDDE8-\\uDDED\\uDDF0-\\uDDFF])|\\uD83C\\uDDE6(?:\\uD83C[\\uDDE8-\\uDDEC\\uDDEE\\uDDF1\\uDDF2\\uDDF4\\uDDF6-\\uDDFA\\uDDFC\\uDDFD\\uDDFF])|\\uD83C\\uDDF0(?:\\uD83C[\\uDDEA\\uDDEC-\\uDDEE\\uDDF2\\uDDF3\\uDDF5\\uDDF7\\uDDFC\\uDDFE\\uDDFF])|\\uD83C\\uDDED(?:\\uD83C[\\uDDF0\\uDDF2\\uDDF3\\uDDF7\\uDDF9\\uDDFA])|\\uD83C\\uDDE9(?:\\uD83C[\\uDDEA\\uDDEC\\uDDEF\\uDDF0\\uDDF2\\uDDF4\\uDDFF])|\\uD83C\\uDDFE(?:\\uD83C[\\uDDEA\\uDDF9])|\\uD83C\\uDDEC(?:\\uD83C[\\uDDE6\\uDDE7\\uDDE9-\\uDDEE\\uDDF1-\\uDDF3\\uDDF5-\\uDDFA\\uDDFC\\uDDFE])|\\uD83C\\uDDF8(?:\\uD83C[\\uDDE6-\\uDDEA\\uDDEC-\\uDDF4\\uDDF7-\\uDDF9\\uDDFB\\uDDFD-\\uDDFF])|\\uD83C\\uDDEB(?:\\uD83C[\\uDDEE-\\uDDF0\\uDDF2\\uDDF4\\uDDF7])|\\uD83C\\uDDF5(?:\\uD83C[\\uDDE6\\uDDEA-\\uDDED\\uDDF0-\\uDDF3\\uDDF7-\\uDDF9\\uDDFC\\uDDFE])|\\uD83C\\uDDFB(?:\\uD83C[\\uDDE6\\uDDE8\\uDDEA\\uDDEC\\uDDEE\\uDDF3\\uDDFA])|\\uD83C\\uDDF3(?:\\uD83C[\\uDDE6\\uDDE8\\uDDEA-\\uDDEC\\uDDEE\\uDDF1\\uDDF4\\uDDF5\\uDDF7\\uDDFA\\uDDFF])|\\uD83C\\uDDE8(?:\\uD83C[\\uDDE6\\uDDE8\\uDDE9\\uDDEB-\\uDDEE\\uDDF0-\\uDDF5\\uDDF7\\uDDFA-\\uDDFF])|\\uD83C\\uDDF1(?:\\uD83C[\\uDDE6-\\uDDE8\\uDDEE\\uDDF0\\uDDF7-\\uDDFB\\uDDFE])|\\uD83C\\uDDFF(?:\\uD83C[\\uDDE6\\uDDF2\\uDDFC])|\\uD83C\\uDDFC(?:\\uD83C[\\uDDEB\\uDDF8])|\\uD83C\\uDDFA(?:\\uD83C[\\uDDE6\\uDDEC\\uDDF2\\uDDF3\\uDDF8\\uDDFE\\uDDFF])|\\uD83C\\uDDEE(?:\\uD83C[\\uDDE8-\\uDDEA\\uDDF1-\\uDDF4\\uDDF6-\\uDDF9])|\\uD83C\\uDDEF(?:\\uD83C[\\uDDEA\\uDDF2\\uDDF4\\uDDF5])|(?:\\uD83C[\\uDFC3\\uDFC4\\uDFCA]|\\uD83D[\\uDC6E\\uDC71\\uDC73\\uDC77\\uDC81\\uDC82\\uDC86\\uDC87\\uDE45-\\uDE47\\uDE4B\\uDE4D\\uDE4E\\uDEA3\\uDEB4-\\uDEB6]|\\uD83E[\\uDD26\\uDD37-\\uDD39\\uDD3D\\uDD3E\\uDDB8\\uDDB9\\uDDCD-\\uDDCF\\uDDD6-\\uDDDD])(?:\\uD83C[\\uDFFB-\\uDFFF])|(?:\\u26F9|\\uD83C[\\uDFCB\\uDFCC]|\\uD83D\\uDD75)(?:\\uD83C[\\uDFFB-\\uDFFF])|(?:[\\u261D\\u270A-\\u270D]|\\uD83C[\\uDF85\\uDFC2\\uDFC7]|\\uD83D[\\uDC42\\uDC43\\uDC46-\\uDC50\\uDC66\\uDC67\\uDC6B-\\uDC6D\\uDC70\\uDC72\\uDC74-\\uDC76\\uDC78\\uDC7C\\uDC83\\uDC85\\uDCAA\\uDD74\\uDD7A\\uDD90\\uDD95\\uDD96\\uDE4C\\uDE4F\\uDEC0\\uDECC]|\\uD83E[\\uDD0F\\uDD18-\\uDD1C\\uDD1E\\uDD1F\\uDD30-\\uDD36\\uDDB5\\uDDB6\\uDDBB\\uDDD2-\\uDDD5])(?:\\uD83C[\\uDFFB-\\uDFFF])|(?:[\\u231A\\u231B\\u23E9-\\u23EC\\u23F0\\u23F3\\u25FD\\u25FE\\u2614\\u2615\\u2648-\\u2653\\u267F\\u2693\\u26A1\\u26AA\\u26AB\\u26BD\\u26BE\\u26C4\\u26C5\\u26CE\\u26D4\\u26EA\\u26F2\\u26F3\\u26F5\\u26FA\\u26FD\\u2705\\u270A\\u270B\\u2728\\u274C\\u274E\\u2753-\\u2755\\u2757\\u2795-\\u2797\\u27B0\\u27BF\\u2B1B\\u2B1C\\u2B50\\u2B55]|\\uD83C[\\uDC04\\uDCCF\\uDD8E\\uDD91-\\uDD9A\\uDDE6-\\uDDFF\\uDE01\\uDE1A\\uDE2F\\uDE32-\\uDE36\\uDE38-\\uDE3A\\uDE50\\uDE51\\uDF00-\\uDF20\\uDF2D-\\uDF35\\uDF37-\\uDF7C\\uDF7E-\\uDF93\\uDFA0-\\uDFCA\\uDFCF-\\uDFD3\\uDFE0-\\uDFF0\\uDFF4\\uDFF8-\\uDFFF]|\\uD83D[\\uDC00-\\uDC3E\\uDC40\\uDC42-\\uDCFC\\uDCFF-\\uDD3D\\uDD4B-\\uDD4E\\uDD50-\\uDD67\\uDD7A\\uDD95\\uDD96\\uDDA4\\uDDFB-\\uDE4F\\uDE80-\\uDEC5\\uDECC\\uDED0-\\uDED2\\uDED5\\uDEEB\\uDEEC\\uDEF4-\\uDEFA\\uDFE0-\\uDFEB]|\\uD83E[\\uDD0D-\\uDD3A\\uDD3C-\\uDD45\\uDD47-\\uDD71\\uDD73-\\uDD76\\uDD7A-\\uDDA2\\uDDA5-\\uDDAA\\uDDAE-\\uDDCA\\uDDCD-\\uDDFF\\uDE70-\\uDE73\\uDE78-\\uDE7A\\uDE80-\\uDE82\\uDE90-\\uDE95])|(?:[#\\*0-9\\xA9\\xAE\\u203C\\u2049\\u2122\\u2139\\u2194-\\u2199\\u21A9\\u21AA\\u231A\\u231B\\u2328\\u23CF\\u23E9-\\u23F3\\u23F8-\\u23FA\\u24C2\\u25AA\\u25AB\\u25B6\\u25C0\\u25FB-\\u25FE\\u2600-\\u2604\\u260E\\u2611\\u2614\\u2615\\u2618\\u261D\\u2620\\u2622\\u2623\\u2626\\u262A\\u262E\\u262F\\u2638-\\u263A\\u2640\\u2642\\u2648-\\u2653\\u265F\\u2660\\u2663\\u2665\\u2666\\u2668\\u267B\\u267E\\u267F\\u2692-\\u2697\\u2699\\u269B\\u269C\\u26A0\\u26A1\\u26AA\\u26AB\\u26B0\\u26B1\\u26BD\\u26BE\\u26C4\\u26C5\\u26C8\\u26CE\\u26CF\\u26D1\\u26D3\\u26D4\\u26E9\\u26EA\\u26F0-\\u26F5\\u26F7-\\u26FA\\u26FD\\u2702\\u2705\\u2708-\\u270D\\u270F\\u2712\\u2714\\u2716\\u271D\\u2721\\u2728\\u2733\\u2734\\u2744\\u2747\\u274C\\u274E\\u2753-\\u2755\\u2757\\u2763\\u2764\\u2795-\\u2797\\u27A1\\u27B0\\u27BF\\u2934\\u2935\\u2B05-\\u2B07\\u2B1B\\u2B1C\\u2B50\\u2B55\\u3030\\u303D\\u3297\\u3299]|\\uD83C[\\uDC04\\uDCCF\\uDD70\\uDD71\\uDD7E\\uDD7F\\uDD8E\\uDD91-\\uDD9A\\uDDE6-\\uDDFF\\uDE01\\uDE02\\uDE1A\\uDE2F\\uDE32-\\uDE3A\\uDE50\\uDE51\\uDF00-\\uDF21\\uDF24-\\uDF93\\uDF96\\uDF97\\uDF99-\\uDF9B\\uDF9E-\\uDFF0\\uDFF3-\\uDFF5\\uDFF7-\\uDFFF]|\\uD83D[\\uDC00-\\uDCFD\\uDCFF-\\uDD3D\\uDD49-\\uDD4E\\uDD50-\\uDD67\\uDD6F\\uDD70\\uDD73-\\uDD7A\\uDD87\\uDD8A-\\uDD8D\\uDD90\\uDD95\\uDD96\\uDDA4\\uDDA5\\uDDA8\\uDDB1\\uDDB2\\uDDBC\\uDDC2-\\uDDC4\\uDDD1-\\uDDD3\\uDDDC-\\uDDDE\\uDDE1\\uDDE3\\uDDE8\\uDDEF\\uDDF3\\uDDFA-\\uDE4F\\uDE80-\\uDEC5\\uDECB-\\uDED2\\uDED5\\uDEE0-\\uDEE5\\uDEE9\\uDEEB\\uDEEC\\uDEF0\\uDEF3-\\uDEFA\\uDFE0-\\uDFEB]|\\uD83E[\\uDD0D-\\uDD3A\\uDD3C-\\uDD45\\uDD47-\\uDD71\\uDD73-\\uDD76\\uDD7A-\\uDDA2\\uDDA5-\\uDDAA\\uDDAE-\\uDDCA\\uDDCD-\\uDDFF\\uDE70-\\uDE73\\uDE78-\\uDE7A\\uDE80-\\uDE82\\uDE90-\\uDE95])\\uFE0F|(?:[\\u261D\\u26F9\\u270A-\\u270D]|\\uD83C[\\uDF85\\uDFC2-\\uDFC4\\uDFC7\\uDFCA-\\uDFCC]|\\uD83D[\\uDC42\\uDC43\\uDC46-\\uDC50\\uDC66-\\uDC78\\uDC7C\\uDC81-\\uDC83\\uDC85-\\uDC87\\uDC8F\\uDC91\\uDCAA\\uDD74\\uDD75\\uDD7A\\uDD90\\uDD95\\uDD96\\uDE45-\\uDE47\\uDE4B-\\uDE4F\\uDEA3\\uDEB4-\\uDEB6\\uDEC0\\uDECC]|\\uD83E[\\uDD0F\\uDD18-\\uDD1F\\uDD26\\uDD30-\\uDD39\\uDD3C-\\uDD3E\\uDDB5\\uDDB6\\uDDB8\\uDDB9\\uDDBB\\uDDCD-\\uDDCF\\uDDD1-\\uDDDD])/g}}),We=n(function(e,t){!function(){\"use strict\";var l={name:\"doT\",version:\"1.1.1\",templateSettings:{evaluate:/\\{\\{([\\s\\S]+?(\\}?)+)\\}\\}/g,interpolate:/\\{\\{=([\\s\\S]+?)\\}\\}/g,encode:/\\{\\{!([\\s\\S]+?)\\}\\}/g,use:/\\{\\{#([\\s\\S]+?)\\}\\}/g,useParams:/(^|[^\\w$])def(?:\\.|\\[[\\'\\\"])([\\w$\\.]+)(?:[\\'\\\"]\\])?\\s*\\:\\s*([\\w$\\.]+|\\\"[^\\\"]+\\\"|\\'[^\\']+\\'|\\{[^\\}]+\\})/g,define:/\\{\\{##\\s*([\\w\\.$]+)\\s*(\\:|=)([\\s\\S]+?)#\\}\\}/g,defineParams:/^\\s*([\\w$]+):([\\s\\S]+)/,conditional:/\\{\\{\\?(\\?)?\\s*([\\s\\S]*?)\\s*\\}\\}/g,iterate:/\\{\\{~\\s*(?:\\}\\}|([\\s\\S]+?)\\s*\\:\\s*([\\w$]+)\\s*(?:\\:\\s*([\\w$]+))?\\s*\\}\\})/g,varname:\"it\",strip:!0,append:!0,selfcontained:!1,doNotSkipEncoded:!1},template:void 0,compile:void 0,log:!0};!function(){if(\"object\"!==(\"undefined\"==typeof globalThis?\"undefined\":Lu(globalThis)))try{Object.defineProperty(Object.prototype,\"__magic__\",{get:function(){return this},configurable:!0}),__magic__.globalThis=__magic__,delete Object.prototype.__magic__}catch(e){window.globalThis=function(){if(\"undefined\"!=typeof self)return self;if(void 0!==window)return window;if(void 0!==Bu)return Bu;if(void 0!==this)return this;throw new Error(\"Unable to locate global `this`\")}()}}(),l.encodeHTMLSource=function(e){var t={\"&\":\"&#38;\",\"<\":\"&#60;\",\">\":\"&#62;\",'\"':\"&#34;\",\"'\":\"&#39;\",\"/\":\"&#47;\"},r=e?/[&<>\"'\\/]/g:/&(?!#?\\w+;)|<|>|\"|'|\\//g;return function(e){return e?e.toString().replace(r,function(e){return t[e]||e}):\"\"}},void 0!==t&&t.exports?t.exports=l:\"function\"==typeof define&&define.amd?define(function(){return l}):globalThis.doT=l;var s={append:{start:\"'+(\",end:\")+'\",startencode:\"'+encodeHTML(\"},split:{start:\"';out+=(\",end:\");out+='\",startencode:\"';out+=encodeHTML(\"}},u=/$^/;function c(e){return e.replace(/\\\\('|\\\\)/g,\"$1\").replace(/[\\r\\t\\n]/g,\" \")}l.template=function(t,e,r){var a,n,o=(e=e||l.templateSettings).append?s.append:s.split,i=0,t=e.use||e.define?function r(n,e,o){return(\"string\"==typeof e?e:e.toString()).replace(n.define||u,function(e,a,t,r){return(a=0===a.indexOf(\"def.\")?a.substring(4):a)in o||(\":\"===t?(n.defineParams&&r.replace(n.defineParams,function(e,t,r){o[a]={arg:t,text:r}}),a in o||(o[a]=r)):new Function(\"def\",\"def['\"+a+\"']=\"+r)(o)),\"\"}).replace(n.use||u,function(e,t){return n.useParams&&(t=t.replace(n.useParams,function(e,t,r,a){if(o[r]&&o[r].arg&&a){var n=(r+\":\"+a).replace(/'|\\\\/g,\"_\");return o.__exp=o.__exp||{},o.__exp[n]=o[r].text.replace(new RegExp(\"(^|[^\\\\w$])\"+o[r].arg+\"([^\\\\w$])\",\"g\"),\"$1\"+a+\"$2\"),t+\"def.__exp['\"+n+\"']\"}})),(t=new Function(\"def\",\"return \"+t)(o))&&r(n,t,o)})}(e,t,r||{}):t,t=(\"var out='\"+(e.strip?t.replace(/(^|\\r|\\n)\\t* +| +\\t*(\\r|\\n|$)/g,\" \").replace(/\\r|\\n|\\t|\\/\\*[\\s\\S]*?\\*\\//g,\"\"):t).replace(/'|\\\\/g,\"\\\\$&\").replace(e.interpolate||u,function(e,t){return o.start+c(t)+o.end}).replace(e.encode||u,function(e,t){return a=!0,o.startencode+c(t)+o.end}).replace(e.conditional||u,function(e,t,r){return t?r?\"';}else if(\"+c(r)+\"){out+='\":\"';}else{out+='\":r?\"';if(\"+c(r)+\"){out+='\":\"';}out+='\"}).replace(e.iterate||u,function(e,t,r,a){return t?(i+=1,n=a||\"i\"+i,t=c(t),\"';var arr\"+i+\"=\"+t+\";if(arr\"+i+\"){var \"+r+\",\"+n+\"=-1,l\"+i+\"=arr\"+i+\".length-1;while(\"+n+\"<l\"+i+\"){\"+r+\"=arr\"+i+\"[\"+n+\"+=1];out+='\"):\"';} } out+='\"}).replace(e.evaluate||u,function(e,t){return\"';\"+c(t)+\"out+='\"})+\"';return out;\").replace(/\\n/g,\"\\\\n\").replace(/\\t/g,\"\\\\t\").replace(/\\r/g,\"\\\\r\").replace(/(\\s|;|\\}|^|\\{)out\\+='';/g,\"$1\").replace(/\\+''/g,\"\");a&&(e.selfcontained||!globalThis||globalThis._encodeHTML||(globalThis._encodeHTML=l.encodeHTMLSource(e.doNotSkipEncoded)),t=\"var encodeHTML = typeof _encodeHTML !== 'undefined' ? _encodeHTML : (\"+l.encodeHTMLSource.toString()+\"(\"+(e.doNotSkipEncoded||\"\")+\"));\"+t);try{return new Function(e.varname,t)}catch(e){throw\"undefined\"!=typeof console&&console.log(\"Could not create a template function: \"+t),e}},l.compile=function(e,t){return l.template(e,null,t)}}()}),Ge=n(function(e,t){var r;r=function(){\"use strict\";function s(e){return\"function\"==typeof e}var r=Array.isArray||function(e){return\"[object Array]\"===Object.prototype.toString.call(e)},a=0,t=void 0,n=void 0,i=function(e,t){d[a]=e,d[a+1]=t,2===(a+=2)&&(n?n(p):y())};var e=void 0!==window?window:void 0,o=e||{},l=o.MutationObserver||o.WebKitMutationObserver,u=\"undefined\"==typeof self&&\"undefined\"!=typeof process&&\"[object process]\"==={}.toString.call(process),o=\"undefined\"!=typeof Uint8ClampedArray&&\"undefined\"!=typeof importScripts&&\"undefined\"!=typeof MessageChannel;function c(){var e=setTimeout;return function(){return e(p,1)}}var d=new Array(1e3);function p(){for(var e=0;e<a;e+=2)(0,d[e])(d[e+1]),d[e]=void 0,d[e+1]=void 0;a=0}function f(){try{var e=Function(\"return this\")().require(\"vertx\");return void 0!==(t=e.runOnLoop||e.runOnContext)?function(){t(p)}:c()}catch(e){return c()}}var m,h,g,b,y=void 0;function v(e,t){var r=this,a=new this.constructor(x);void 0===a[w]&&B(a);var n,o=r._state;return o?(n=arguments[o-1],i(function(){return P(o,a,n,r._result)})):O(r,a,e,t),a}function D(e){if(e&&\"object\"===Lu(e)&&e.constructor===this)return e;var t=new this(x);return R(t,e),t}var y=u?function(){return process.nextTick(p)}:l?(h=0,g=new l(p),b=document.createTextNode(\"\"),g.observe(b,{characterData:!0}),function(){b.data=h=++h%2}):o?((m=new MessageChannel).port1.onmessage=p,function(){return m.port2.postMessage(0)}):(void 0===e?f:c)(),w=Math.random().toString(36).substring(2);function x(){}var E=void 0,A=1,C=2;function F(e,a,n){i(function(t){var r=!1,e=function(e,t,r,a){try{e.call(t,r,a)}catch(e){return e}}(n,a,function(e){r||(r=!0,(a!==e?R:N)(t,e))},function(e){r||(r=!0,_(t,e))},t._label);!r&&e&&(r=!0,_(t,e))},e)}function k(e,t,r){var a,n;t.constructor===e.constructor&&r===v&&t.constructor.resolve===D?(a=e,(n=t)._state===A?N(a,n._result):n._state===C?_(a,n._result):O(n,void 0,function(e){return R(a,e)},function(e){return _(a,e)})):void 0!==r&&s(r)?F(e,t,r):N(e,t)}function R(t,e){if(t===e)_(t,new TypeError(\"You cannot resolve a promise with itself\"));else if(a=Lu(r=e),null===r||\"object\"!==a&&\"function\"!==a)N(t,e);else{a=void 0;try{a=e.then}catch(e){return void _(t,e)}k(t,e,a)}var r,a}function T(e){e._onerror&&e._onerror(e._result),S(e)}function N(e,t){e._state===E&&(e._result=t,e._state=A,0!==e._subscribers.length&&i(S,e))}function _(e,t){e._state===E&&(e._state=C,e._result=t,i(T,e))}function O(e,t,r,a){var n=e._subscribers,o=n.length;e._onerror=null,n[o]=t,n[o+A]=r,n[o+C]=a,0===o&&e._state&&i(S,e)}function S(e){var t=e._subscribers,r=e._state;if(0!==t.length){for(var a,n=void 0,o=e._result,i=0;i<t.length;i+=3)a=t[i],n=t[i+r],a?P(r,a,n,o):n(o);e._subscribers.length=0}}function P(e,t,r,a){var n=s(r),o=void 0,i=void 0,l=!0;if(n){try{o=r(a)}catch(e){l=!1,i=e}if(t===o)return void _(t,new TypeError(\"A promises callback cannot return that same promise.\"))}else o=a;t._state!==E||(n&&l?R(t,o):!1===l?_(t,i):e===A?N(t,o):e===C&&_(t,o))}var I=0;function B(e){e[w]=I++,e._state=void 0,e._result=void 0,e._subscribers=[]}var L=(q.prototype._enumerate=function(e){for(var t=0;this._state===E&&t<e.length;t++)this._eachEntry(e[t],t)},q.prototype._eachEntry=function(t,e){var r=this._instanceConstructor,a=r.resolve;if(a===D){var n,o=void 0,i=void 0,l=!1;try{o=t.then}catch(e){l=!0,i=e}o===v&&t._state!==E?this._settledAt(t._state,e,t._result):\"function\"!=typeof o?(this._remaining--,this._result[e]=t):r===M?(n=new r(x),l?_(n,i):k(n,t,o),this._willSettleAt(n,e)):this._willSettleAt(new r(function(e){return e(t)}),e)}else this._willSettleAt(a(t),e)},q.prototype._settledAt=function(e,t,r){var a=this.promise;a._state===E&&(this._remaining--,e===C?_(a,r):this._result[t]=r),0===this._remaining&&N(a,this._result)},q.prototype._willSettleAt=function(e,t){var r=this;O(e,void 0,function(e){return r._settledAt(A,t,e)},function(e){return r._settledAt(C,t,e)})},q);function q(e,t){this._instanceConstructor=e,this.promise=new e(x),this.promise[w]||B(this.promise),r(t)?(this.length=t.length,this._remaining=t.length,this._result=new Array(this.length),0===this.length?N(this.promise,this._result):(this.length=this.length||0,this._enumerate(t),0===this._remaining&&N(this.promise,this._result))):_(this.promise,new Error(\"Array Methods must be provided an Array\"))}var M=(j.prototype.catch=function(e){return this.then(null,e)},j.prototype.finally=function(t){var r=this.constructor;return s(t)?this.then(function(e){return r.resolve(t()).then(function(){return e})},function(e){return r.resolve(t()).then(function(){throw e})}):this.then(t,t)},j);function j(e){this[w]=I++,this._result=this._state=void 0,this._subscribers=[],x!==e&&(\"function\"!=typeof e&&function(){throw new TypeError(\"You must pass a resolver function as the first argument to the promise constructor\")}(),this instanceof j?function(t,e){try{e(function(e){R(t,e)},function(e){_(t,e)})}catch(e){_(t,e)}}(this,e):function(){throw new TypeError(\"Failed to construct 'Promise': Please use the 'new' operator, this object constructor cannot be called as a function.\")}())}return M.prototype.then=v,M.all=function(e){return new L(this,e).promise},M.race=function(n){var o=this;return r(n)?new o(function(e,t){for(var r=n.length,a=0;a<r;a++)o.resolve(n[a]).then(e,t)}):new o(function(e,t){return t(new TypeError(\"You must pass an array to race.\"))})},M.resolve=D,M.reject=function(e){var t=new this(x);return _(t,e),t},M._setScheduler=function(e){n=e},M._setAsap=function(e){i=e},M._asap=i,M.polyfill=function(){var e=void 0;if(void 0!==Bu)e=Bu;else if(\"undefined\"!=typeof self)e=self;else try{e=Function(\"return this\")()}catch(e){throw new Error(\"polyfill failed because global object is unavailable in this environment\")}var t=e.Promise;if(t){var r=null;try{r=Object.prototype.toString.call(t.resolve())}catch(e){}if(\"[object Promise]\"===r&&!t.cast)return}e.Promise=M},M.Promise=M},\"object\"===Lu(e=e)&&void 0!==t?t.exports=r():\"function\"==typeof define&&define.amd?define(r):e.ES6Promise=r()}),Ye=n(function(p){var t,r,a=1e5,f=(t=Object.prototype.toString,r=Object.prototype.hasOwnProperty,{Class:function(e){return t.call(e).replace(/^\\[object *|\\]$/g,\"\")},HasProperty:function(e,t){return t in e},HasOwnProperty:function(e,t){return r.call(e,t)},IsCallable:function(e){return\"function\"==typeof e},ToInt32:function(e){return e>>0},ToUint32:function(e){return e>>>0}}),m=Math.LN2,h=Math.abs,g=Math.floor,b=Math.log,y=Math.min,v=Math.pow,n=Math.round;function D(e){if(i&&o)for(var t=i(e),r=0;r<t.length;r+=1)o(e,t[r],{value:e[t[r]],writable:!1,enumerable:!1,configurable:!1})}var l,e,o=Object.defineProperty&&function(){try{return Object.defineProperty({},\"x\",{}),1}catch(e){return}}()?Object.defineProperty:function(e,t,r){if(!e===Object(e))throw new TypeError(\"Object.defineProperty called on non-object\");return f.HasProperty(r,\"get\")&&Object.prototype.__defineGetter__&&Object.prototype.__defineGetter__.call(e,t,r.get),f.HasProperty(r,\"set\")&&Object.prototype.__defineSetter__&&Object.prototype.__defineSetter__.call(e,t,r.set),f.HasProperty(r,\"value\")&&(e[t]=r.value),e},i=Object.getOwnPropertyNames||function(e){if(e!==Object(e))throw new TypeError(\"Object.getOwnPropertyNames called on non-object\");var t,r=[];for(t in e)f.HasOwnProperty(e,t)&&r.push(t);return r};function w(r){if(o){if(r.length>a)throw new RangeError(\"Array too large for polyfill\");for(var e=0;e<r.length;e+=1)!function(t){o(r,t,{get:function(){return r._getter(t)},set:function(e){r._setter(t,e)},enumerable:!0,configurable:!1})}(e)}}function s(e,t){t=32-t;return e<<t>>t}function u(e,t){t=32-t;return e<<t>>>t}function x(e){return[255&e]}function E(e){return s(e[0],8)}function A(e){return[255&e]}function C(e){return u(e[0],8)}function F(e){return[(e=n(Number(e)))<0?0:255<e?255:255&e]}function k(e){return[e>>8&255,255&e]}function R(e){return s(e[0]<<8|e[1],16)}function T(e){return[e>>8&255,255&e]}function N(e){return u(e[0]<<8|e[1],16)}function _(e){return[e>>24&255,e>>16&255,e>>8&255,255&e]}function O(e){return s(e[0]<<24|e[1]<<16|e[2]<<8|e[3],32)}function S(e){return[e>>24&255,e>>16&255,e>>8&255,255&e]}function P(e){return u(e[0]<<24|e[1]<<16|e[2]<<8|e[3],32)}function c(e,t,r){var a,n,o,i,l,s,u,c=(1<<t-1)-1;function d(e){var t=g(e),e=e-t;return!(e<.5)&&(.5<e||t%2)?t+1:t}for(e!=e?(n=(1<<t)-1,o=v(2,r-1),a=0):e===1/0||e===-1/0?(n=(1<<t)-1,a=e<(o=0)?1:0):0===e?a=1/e==-1/(o=n=0)?1:0:(a=e<0,(e=h(e))>=v(2,1-c)?(n=y(g(b(e)/m),1023),2<=(o=d(e/v(2,n)*v(2,r)))/v(2,r)&&(n+=1,o=1),c<n?(n=(1<<t)-1,o=0):(n+=c,o-=v(2,r))):(n=0,o=d(e/v(2,1-c-r)))),l=[],i=r;i;--i)l.push(o%2?1:0),o=g(o/2);for(i=t;i;--i)l.push(n%2?1:0),n=g(n/2);for(l.push(a?1:0),l.reverse(),s=l.join(\"\"),u=[];s.length;)u.push(parseInt(s.substring(0,8),2)),s=s.substring(8);return u}function d(e,t,r){for(var a,n,o,i,l,s,u=[],c=e.length;c;--c)for(n=e[c-1],a=8;a;--a)u.push(n%2?1:0),n>>=1;return u.reverse(),s=u.join(\"\"),o=(1<<t-1)-1,i=parseInt(s.substring(0,1),2)?-1:1,l=parseInt(s.substring(1,1+t),2),s=parseInt(s.substring(1+t),2),l===(1<<t)-1?0!==s?NaN:1/0*i:0<l?i*v(2,l-o)*(1+s/v(2,r)):0!==s?i*v(2,-(o-1))*(s/v(2,r)):i<0?-0:0}function I(e){return d(e,11,52)}function B(e){return c(e,11,52)}function L(e){return d(e,8,23)}function q(e){return c(e,8,23)}function M(e,t){return f.IsCallable(e.get)?e.get(t):e[t]}function j(o){return function(e,t){if((e=f.ToUint32(e))+o.BYTES_PER_ELEMENT>this.byteLength)throw new RangeError(\"Array index out of range\");e+=this.byteOffset;for(var r=new p.Uint8Array(this.buffer,e,o.BYTES_PER_ELEMENT),a=[],n=0;n<o.BYTES_PER_ELEMENT;n+=1)a.push(M(r,n));return Boolean(t)===Boolean(l)&&a.reverse(),M(new o(new p.Uint8Array(a).buffer),0)}}function U(i){return function(e,t,r){if((e=f.ToUint32(e))+i.BYTES_PER_ELEMENT>this.byteLength)throw new RangeError(\"Array index out of range\");for(var t=new i([t]),a=new p.Uint8Array(t.buffer),n=[],o=0;o<i.BYTES_PER_ELEMENT;o+=1)n.push(M(a,o));Boolean(r)===Boolean(l)&&n.reverse(),new p.Uint8Array(this.buffer,e,i.BYTES_PER_ELEMENT).set(n)}}!function(){function s(e){if((e=f.ToInt32(e))<0)throw new RangeError(\"ArrayBuffer size is not a small enough positive integer\");var t;for(this.byteLength=e,this._bytes=[],this._bytes.length=e,t=0;t<this.byteLength;t+=1)this._bytes[t]=0;D(this)}p.ArrayBuffer=p.ArrayBuffer||s;function a(){}function e(e,t,r){var l=function(e,t,r){var a,n,o,i;if(arguments.length&&\"number\"!=typeof e)if(\"object\"===Lu(e)&&e.constructor===l)for(this.length=(a=e).length,this.byteLength=this.length*this.BYTES_PER_ELEMENT,this.buffer=new s(this.byteLength),o=this.byteOffset=0;o<this.length;o+=1)this._setter(o,a._getter(o));else if(\"object\"!==Lu(e)||(e instanceof s||\"ArrayBuffer\"===f.Class(e))){if(\"object\"!==Lu(e)||!(e instanceof s||\"ArrayBuffer\"===f.Class(e)))throw new TypeError(\"Unexpected argument type(s)\");if(this.buffer=e,this.byteOffset=f.ToUint32(t),this.byteOffset>this.buffer.byteLength)throw new RangeError(\"byteOffset out of range\");if(this.byteOffset%this.BYTES_PER_ELEMENT)throw new RangeError(\"ArrayBuffer length minus the byteOffset is not a multiple of the element size.\");if(arguments.length<3){if(this.byteLength=this.buffer.byteLength-this.byteOffset,this.byteLength%this.BYTES_PER_ELEMENT)throw new RangeError(\"length of buffer minus byteOffset not a multiple of the element size\");this.length=this.byteLength/this.BYTES_PER_ELEMENT}else this.length=f.ToUint32(r),this.byteLength=this.length*this.BYTES_PER_ELEMENT;if(this.byteOffset+this.byteLength>this.buffer.byteLength)throw new RangeError(\"byteOffset and length reference an area beyond the end of the buffer\")}else for(this.length=f.ToUint32((n=e).length),this.byteLength=this.length*this.BYTES_PER_ELEMENT,this.buffer=new s(this.byteLength),o=this.byteOffset=0;o<this.length;o+=1)i=n[o],this._setter(o,Number(i));else{if(this.length=f.ToInt32(e),r<0)throw new RangeError(\"ArrayBufferView size is not a small enough positive integer\");this.byteLength=this.length*this.BYTES_PER_ELEMENT,this.buffer=new s(this.byteLength),this.byteOffset=0}this.constructor=l,D(this),w(this)};return l.prototype=new a,l.prototype.BYTES_PER_ELEMENT=e,l.prototype._pack=t,l.prototype._unpack=r,l.BYTES_PER_ELEMENT=e,l.prototype._getter=function(e){if(arguments.length<1)throw new SyntaxError(\"Not enough arguments\");if(!((e=f.ToUint32(e))>=this.length)){for(var t=[],r=0,a=this.byteOffset+e*this.BYTES_PER_ELEMENT;r<this.BYTES_PER_ELEMENT;r+=1,a+=1)t.push(this.buffer._bytes[a]);return this._unpack(t)}},l.prototype.get=l.prototype._getter,l.prototype._setter=function(e,t){if(arguments.length<2)throw new SyntaxError(\"Not enough arguments\");if(!((e=f.ToUint32(e))>=this.length))for(var r=this._pack(t),a=0,n=this.byteOffset+e*this.BYTES_PER_ELEMENT;a<this.BYTES_PER_ELEMENT;a+=1,n+=1)this.buffer._bytes[n]=r[a]},l.prototype.set=function(e,t){if(arguments.length<1)throw new SyntaxError(\"Not enough arguments\");var r,a,n,o,i,l,s,u,c,d;if(\"object\"===Lu(e)&&e.constructor===this.constructor){if(r=e,(n=f.ToUint32(t))+r.length>this.length)throw new RangeError(\"Offset plus length of array is out of range\");if(u=this.byteOffset+n*this.BYTES_PER_ELEMENT,c=r.length*this.BYTES_PER_ELEMENT,r.buffer===this.buffer){for(d=[],i=0,l=r.byteOffset;i<c;i+=1,l+=1)d[i]=r.buffer._bytes[l];for(i=0,s=u;i<c;i+=1,s+=1)this.buffer._bytes[s]=d[i]}else for(i=0,l=r.byteOffset,s=u;i<c;i+=1,l+=1,s+=1)this.buffer._bytes[s]=r.buffer._bytes[l]}else{if(\"object\"!==Lu(e)||void 0===e.length)throw new TypeError(\"Unexpected argument type(s)\");if(o=f.ToUint32((a=e).length),(n=f.ToUint32(t))+o>this.length)throw new RangeError(\"Offset plus length of array is out of range\");for(i=0;i<o;i+=1)l=a[i],this._setter(n+i,Number(l))}},l.prototype.subarray=function(e,t){function r(e,t,r){return e<t?t:r<e?r:e}e=f.ToInt32(e),t=f.ToInt32(t),arguments.length<1&&(e=0),arguments.length<2&&(t=this.length),e<0&&(e=this.length+e),t<0&&(t=this.length+t),e=r(e,0,this.length);var a=(t=r(t,0,this.length))-e;return new this.constructor(this.buffer,this.byteOffset+e*this.BYTES_PER_ELEMENT,a=a<0?0:a)},l}var t=e(1,x,E),r=e(1,A,C),n=e(1,F,C),o=e(2,k,R),i=e(2,T,N),l=e(4,_,O),u=e(4,S,P),c=e(4,q,L),d=e(8,B,I);p.Int8Array=p.Int8Array||t,p.Uint8Array=p.Uint8Array||r,p.Uint8ClampedArray=p.Uint8ClampedArray||n,p.Int16Array=p.Int16Array||o,p.Uint16Array=p.Uint16Array||i,p.Int32Array=p.Int32Array||l,p.Uint32Array=p.Uint32Array||u,p.Float32Array=p.Float32Array||c,p.Float64Array=p.Float64Array||d}(),e=new p.Uint16Array([4660]),l=18===M(new p.Uint8Array(e.buffer),0),(e=function(e,t,r){if(0===arguments.length)e=new p.ArrayBuffer(0);else if(!(e instanceof p.ArrayBuffer||\"ArrayBuffer\"===f.Class(e)))throw new TypeError(\"TypeError\");if(this.buffer=e||new p.ArrayBuffer(0),this.byteOffset=f.ToUint32(t),this.byteOffset>this.buffer.byteLength)throw new RangeError(\"byteOffset out of range\");if(this.byteLength=arguments.length<3?this.buffer.byteLength-this.byteOffset:f.ToUint32(r),this.byteOffset+this.byteLength>this.buffer.byteLength)throw new RangeError(\"byteOffset and length reference an area beyond the end of the buffer\");D(this)}).prototype.getUint8=j(p.Uint8Array),e.prototype.getInt8=j(p.Int8Array),e.prototype.getUint16=j(p.Uint16Array),e.prototype.getInt16=j(p.Int16Array),e.prototype.getUint32=j(p.Uint32Array),e.prototype.getInt32=j(p.Int32Array),e.prototype.getFloat32=j(p.Float32Array),e.prototype.getFloat64=j(p.Float64Array),e.prototype.setUint8=U(p.Uint8Array),e.prototype.setInt8=U(p.Int8Array),e.prototype.setUint16=U(p.Uint16Array),e.prototype.setInt16=U(p.Int16Array),e.prototype.setUint32=U(p.Uint32Array),e.prototype.setInt32=U(p.Int32Array),e.prototype.setFloat32=U(p.Float32Array),e.prototype.setFloat64=U(p.Float64Array),p.DataView=p.DataView||e}),Ke=n(function(e){!function(e){\"use strict\";var r,a,n;function t(){if(void 0===this)throw new TypeError(\"Constructor WeakMap requires 'new'\");if(n(this,\"_id\",\"_WeakMap_\"+i()+\".\"+i()),0<arguments.length)throw new TypeError(\"WeakMap iterable is not supported\")}function o(e,t){if(!l(e)||!r.call(e,\"_id\"))throw new TypeError(t+\" method called on incompatible receiver \"+Lu(e))}function i(){return Math.random().toString().substring(2)}function l(e){return Object(e)===e}e.WeakMap||(r=Object.prototype.hasOwnProperty,a=Object.defineProperty&&function(){try{return 1===Object.defineProperty({},\"x\",{value:1}).x}catch(e){}}(),e.WeakMap=((n=function(e,t,r){a?Object.defineProperty(e,t,{configurable:!0,writable:!0,value:r}):e[t]=r})(t.prototype,\"delete\",function(e){if(o(this,\"delete\"),!l(e))return!1;var t=e[this._id];return!(!t||t[0]!==e)&&(delete e[this._id],!0)}),n(t.prototype,\"get\",function(e){if(o(this,\"get\"),l(e)){var t=e[this._id];return t&&t[0]===e?t[1]:void 0}}),n(t.prototype,\"has\",function(e){if(o(this,\"has\"),!l(e))return!1;var t=e[this._id];return!(!t||t[0]!==e)}),n(t.prototype,\"set\",function(e,t){if(o(this,\"set\"),!l(e))throw new TypeError(\"Invalid value used as weak map key\");var r=e[this._id];return r&&r[0]===e?r[1]=t:n(e,this._id,[e,t]),this}),n(t,\"_polyfill\",!0),t))}(\"undefined\"!=typeof globalThis?globalThis:\"undefined\"!=typeof self?self:void 0!==window?window:void 0!==Bu?Bu:e)}),Xe={helpUrlBase:\"https://dequeuniversity.com/rules/\",results:[],resultGroups:[],resultGroupMap:{},impact:Object.freeze([\"minor\",\"moderate\",\"serious\",\"critical\"]),preload:Object.freeze({assets:[\"cssom\",\"media\"],timeout:1e4}),allOrigins:\"<unsafe_all_origins>\",sameOrigin:\"<same_origin>\"};[{name:\"NA\",value:\"inapplicable\",priority:0,group:\"inapplicable\"},{name:\"PASS\",value:\"passed\",priority:1,group:\"passes\"},{name:\"CANTTELL\",value:\"cantTell\",priority:2,group:\"incomplete\"},{name:\"FAIL\",value:\"failed\",priority:3,group:\"violations\"}].forEach(function(e){var t=e.name,r=e.value,a=e.priority,e=e.group;Xe[t]=r,Xe[t+\"_PRIO\"]=a,Xe[t+\"_GROUP\"]=e,Xe.results[a]=r,Xe.resultGroups[a]=e,Xe.resultGroupMap[r]=e}),Object.freeze(Xe.results),Object.freeze(Xe.resultGroups),Object.freeze(Xe.resultGroupMap),Object.freeze(Xe);var Je=Xe;var Qe=function(){\"object\"===(\"undefined\"==typeof console?\"undefined\":Lu(console))&&console.log&&Function.prototype.apply.call(console.log,console,arguments)},Ze=/[\\t\\r\\n\\f]/g;function et(){Ju(this,et),this.parent=void 0}var tt=(Qu(et,[{key:\"props\",get:function(){throw new Error('VirtualNode class must have a \"props\" object consisting of \"nodeType\" and \"nodeName\" properties')}},{key:\"attrNames\",get:function(){throw new Error('VirtualNode class must have an \"attrNames\" property')}},{key:\"attr\",value:function(){throw new Error('VirtualNode class must have an \"attr\" function')}},{key:\"hasAttr\",value:function(){throw new Error('VirtualNode class must have a \"hasAttr\" function')}},{key:\"hasClass\",value:function(e){var t=this.attr(\"class\");if(!t)return!1;e=\" \"+e+\" \";return 0<=(\" \"+t+\" \").replace(Ze,\" \").indexOf(e)}}]),et),rt={};o(rt,{DqElement:function(){return xr},aggregate:function(){return Bt},aggregateChecks:function(){return Vt},aggregateNodeResults:function(){return zt},aggregateResult:function(){return Wt},areStylesSet:function(){return Gt},assert:function(){return it},checkHelper:function(){return Er},clone:function(){return Ar},closest:function(){return Ir},collectResultsFromFrames:function(){return Xr},contains:function(){return Jr},convertSelector:function(){return Or},cssParser:function(){return Fr},deepMerge:function(){return Qr},escapeSelector:function(){return Kt},extendMetaData:function(){return Zr},filterHtmlAttrs:function(){return xo},finalizeRuleResult:function(){return Ht},findBy:function(){return Gr},getAllChecks:function(){return Wr},getAncestry:function(){return gr},getBaseLang:function(){return xn},getCheckMessage:function(){return _n},getCheckOption:function(){return On},getFlattenedTree:function(){return wn},getFriendlyUriEnd:function(){return Qt},getNodeAttributes:function(){return er},getNodeFromTree:function(){return Dr},getPreloadConfig:function(){return ho},getRootNode:function(){return aa},getRule:function(){return Sn},getScroll:function(){return Pn},getScrollState:function(){return In},getSelector:function(){return mr},getSelectorData:function(){return cr},getShadowSelector:function(){return nr},getStandards:function(){return Bn},getStyleSheetFactory:function(){return qn},getXpath:function(){return br},injectStyle:function(){return Mn},isHidden:function(){return jn},isHtmlElement:function(){return Vn},isNodeInContext:function(){return zn},isShadowRoot:function(){return ta},isValidLang:function(){return To},isXHTML:function(){return rr},matches:function(){return Pr},matchesExpression:function(){return Sr},matchesSelector:function(){return tr},memoize:function(){return Wn},mergeResults:function(){return Kr},nodeSorter:function(){return Gn},parseCrossOriginStylesheet:function(){return Qn},parseSameOriginStylesheet:function(){return Yn},parseStylesheet:function(){return Kn},performanceTimer:function(){return ro},pollyfillElementsFromPoint:function(){return ao},preload:function(){return go},preloadCssom:function(){return uo},preloadMedia:function(){return fo},processMessage:function(){return Nn},publishMetaData:function(){return yo},querySelectorAll:function(){return vo},querySelectorAllFilter:function(){return so},queue:function(){return jr},respondable:function(){return Vr},ruleShouldRun:function(){return wo},select:function(){return Eo},sendCommandToFrame:function(){return $r},setScrollState:function(){return Ao},shouldPreload:function(){return mo},toArray:function(){return Yt},tokenList:function(){return Co},uniqueArray:function(){return io},uuid:function(){return Rt},validInputTypes:function(){return Fo},validLangs:function(){return Ro}});var at=Object.freeze([\"EvalError\",\"RangeError\",\"ReferenceError\",\"SyntaxError\",\"TypeError\",\"URIError\"]);function nt(e){var t;try{t=JSON.parse(e)}catch(e){return}if(\"object\"===Lu(n=t)&&\"string\"==typeof n.channelId&&n.source===ot()){var r=t,a=r.topic,e=r.channelId,n=r.messageId,r=r.keepalive;return{topic:a,message:\"object\"===Lu(t.error)?function(e){var t=e.message||\"Unknown error occurred\",r=at.includes(e.name)?e.name:\"Error\",r=window[r]||Error;e.stack&&(t+=\"\\n\"+e.stack.replace(e.message,\"\"));return new r(t)}(t.error):t.payload,messageId:n,channelId:e,keepalive:!!r}}}function ot(){var e=\"axeAPI\",t=\"\";return(e=void 0!==axe&&axe._audit&&axe._audit.application?axe._audit.application:e)+\".\"+(t=void 0!==axe?axe.version:t)}var it=function(e,t){if(!e)throw new Error(t)};function lt(e){ut(e),it(window.parent===e,\"Source of the response must be the parent window.\")}function st(e){ut(e),it(e.parent===window,\"Respondable target must be a frame in the current window\")}function ut(e){it(window!==e,\"Messages can not be sent to the same window.\")}var ct={};var dt,pt,ft,mt,ht=window.crypto||window.msCrypto;!pt&&ht&&ht.getRandomValues&&(dt=new Uint8Array(16),pt=function(){return ht.getRandomValues(dt),dt});try{pt||(ft=require(\"crypto\"),pt=function(){return ft.randomBytes(16)})}catch(e){}pt||(mt=new Array(16),pt=function(){for(var e,t=0;t<16;t++)0==(3&t)&&(e=4294967296*Math.random()),mt[t]=e>>>((3&t)<<3)&255;return mt});for(var gt=\"function\"==typeof window.Buffer?window.Buffer:Array,bt=[],yt={},vt=0;vt<256;vt++)bt[vt]=(vt+256).toString(16).substr(1),yt[bt[vt]]=vt;function Dt(e,t){t=t||0;return bt[e[t++]]+bt[e[t++]]+bt[e[t++]]+bt[e[t++]]+\"-\"+bt[e[t++]]+bt[e[t++]]+\"-\"+bt[e[t++]]+bt[e[t++]]+\"-\"+bt[e[t++]]+bt[e[t++]]+\"-\"+bt[e[t++]]+bt[e[t++]]+bt[e[t++]]+bt[e[t++]]+bt[e[t++]]+bt[e[t++]]}var wt=pt(),xt=[1|wt[0],wt[1],wt[2],wt[3],wt[4],wt[5]],Et=16383&(wt[6]<<8|wt[7]),At=0,Ct=0;function Ft(e,t,r){var a=t&&r||0,n=t||[],o=null!=(e=e||{}).clockseq?e.clockseq:Et,i=null!=e.msecs?e.msecs:(new Date).getTime(),l=null!=e.nsecs?e.nsecs:Ct+1,r=i-At+(l-Ct)/1e4;if(r<0&&null==e.clockseq&&(o=o+1&16383),1e4<=(l=(r<0||At<i)&&null==e.nsecs?0:l))throw new Error(\"uuid.v1(): Can't create more than 10M uuids/sec\");At=i,Et=o;l=(1e4*(268435455&(i+=122192928e5))+(Ct=l))%4294967296;n[a++]=l>>>24&255,n[a++]=l>>>16&255,n[a++]=l>>>8&255,n[a++]=255&l;i=i/4294967296*1e4&268435455;n[a++]=i>>>8&255,n[a++]=255&i,n[a++]=i>>>24&15|16,n[a++]=i>>>16&255,n[a++]=o>>>8|128,n[a++]=255&o;for(var s=e.node||xt,u=0;u<6;u++)n[a+u]=s[u];return t||Dt(n)}function kt(e,t,r){var a=t&&r||0;\"string\"==typeof e&&(t=\"binary\"==e?new gt(16):null,e=null);var n=(e=e||{}).random||(e.rng||pt)();if(n[6]=15&n[6]|64,n[8]=63&n[8]|128,t)for(var o=0;o<16;o++)t[a+o]=n[o];return t||Dt(n)}(Ls=kt).v1=Ft,Ls.v4=kt,Ls.parse=function(e,t,r){var a=t&&r||0,n=0;for(t=t||[],e.toLowerCase().replace(/[0-9a-f]{2}/g,function(e){n<16&&(t[a+n++]=yt[e])});n<16;)t[a+n++]=0;return t},Ls.unparse=Dt,Ls.BufferClass=gt,axe._uuid=Ft();var Rt=kt,Tt=[];function Nt(){var e=\"\".concat(kt(),\":\").concat(kt());return Tt.includes(e)?Nt():(Tt.push(e),e)}function _t(r,e,t,a){if(\"function\"==typeof a&&function(e,t,r){var a=!(2<arguments.length&&void 0!==r)||r;it(!ct[e],\"A replyHandler already exists for this message channel.\"),ct[e]={replyHandler:t,sendToParent:a}}(e.channelId,a,t),(t?lt:st)(r),e.message instanceof Error&&!t)return axe.log(e.message),!1;var n=(o=Xu({messageId:Nt()},e),a=o.topic,t=o.channelId,e=o.message,o={channelId:t,topic:a,messageId:o.messageId,keepalive:!!o.keepalive,source:ot()},e instanceof Error?o.error={name:e.name,message:e.message,stack:e.stack}:o.payload=e,JSON.stringify(o)),o=axe._audit.allowedOrigins;return!(!o||!o.length)&&(o.forEach(function(t){try{r.postMessage(n,t)}catch(e){if(e instanceof r.DOMException)throw new Error('allowedOrigins value \"'.concat(t,'\" is not a valid origin'));throw e}}),!0)}function Ot(a,n,e){var o=!(2<arguments.length&&void 0!==e)||e;return function(e,t,r){_t(a,{channelId:n,message:e,keepalive:t},o,r)}}function St(e,t){var r,a=e.origin,n=e.data,o=e.source,i=nt(n)||{},l=i.channelId,s=i.message,e=i.messageId;if(n=a,((a=axe._audit.allowedOrigins)&&a.includes(\"*\")||a.includes(n))&&(e=e,!Tt.includes(e)&&(Tt.push(e),1)))if(s instanceof Error&&o.parent!==window)axe.log(s);else try{i.topic?(r=Ot(o,l),lt(o),t(i,r)):function(e,t){var r=t.channelId,a=t.message,n=t.keepalive,o=function(e){return ct[e]}(r)||{},t=o.replyHandler,o=o.sendToParent;if(t){(o?lt:st)(e);o=Ot(e,r,o);!n&&r&&function(e){delete ct[e]}(r);try{t(a,n,o)}catch(e){axe.log(e),o(e,n)}}}(o,i)}catch(e){!function(e,t,r){if(!e.parent!==window)return axe.log(t);try{_t(e,{topic:null,channelId:r,message:t,messageId:Nt(),keepalive:!0},!0)}catch(e){return axe.log(e)}}(o,e,l)}}var Pt={open:function(t){if(\"function\"==typeof window.addEventListener){function e(e){St(e,t)}return window.addEventListener(\"message\",e,!1),function(){window.removeEventListener(\"message\",e,!1)}}},post:function(e,t,r){return\"function\"==typeof window.addEventListener&&_t(e,t,!1,r)}};function It(e){e.updateMessenger(Pt)}var Bt=function(t,e,r){return e=e.slice(),r&&e.push(r),e=e.map(function(e){return t.indexOf(e)}).sort(),t[e.pop()]},Lt=Je.CANTTELL_PRIO,qt=Je.FAIL_PRIO,Mt=[];Mt[Je.PASS_PRIO]=!0,Mt[Je.CANTTELL_PRIO]=null,Mt[Je.FAIL_PRIO]=!1;var jt=[\"any\",\"all\",\"none\"];function Ut(r,a){return jt.reduce(function(e,t){return e[t]=(r[t]||[]).map(function(e){return a(e,t)}),e},{})}var Vt=function(e){var r=Object.assign({},e);Ut(r,function(e,t){var r=void 0===e.result?-1:Mt.indexOf(e.result);e.priority=-1!==r?r:Je.CANTTELL_PRIO,\"none\"===t&&(e.priority===Je.PASS_PRIO?e.priority=Je.FAIL_PRIO:e.priority===Je.FAIL_PRIO&&(e.priority=Je.PASS_PRIO))});var a={all:r.all.reduce(function(e,t){return Math.max(e,t.priority)},0),none:r.none.reduce(function(e,t){return Math.max(e,t.priority)},0),any:r.any.reduce(function(e,t){return Math.min(e,t.priority)},4)%4};r.priority=Math.max(a.all,a.none,a.any);var n=[];return jt.forEach(function(t){r[t]=r[t].filter(function(e){return e.priority===r.priority&&e.priority===a[t]}),r[t].forEach(function(e){return n.push(e.impact)})}),[Lt,qt].includes(r.priority)?r.impact=Bt(Je.impact,n):r.impact=null,Ut(r,function(e){delete e.result,delete e.priority}),r.result=Je.results[r.priority],delete r.priority,r};var Ht=function(t){var r=axe._audit.rules.find(function(e){return e.id===t.id});return r&&r.impact&&t.nodes.forEach(function(t){[\"any\",\"all\",\"none\"].forEach(function(e){(t[e]||[]).forEach(function(e){e.impact=r.impact})})}),Object.assign(t,zt(t.nodes)),delete t.nodes,t};var zt=function(e){var t,r={};return(e=e.map(function(e){if(e.any&&e.all&&e.none)return Vt(e);if(Array.isArray(e.node))return Ht(e);throw new TypeError(\"Invalid Result type\")}))&&e.length?(t=e.map(function(e){return e.result}),r.result=Bt(Je.results,t,r.result)):r.result=\"inapplicable\",Je.resultGroups.forEach(function(e){return r[e]=[]}),e.forEach(function(e){var t=Je.resultGroupMap[e.result];r[t].push(e)}),e=Je.FAIL_GROUP,0===r[e].length&&(e=Je.CANTTELL_GROUP),0<r[e].length?(e=r[e].map(function(e){return e.impact}),r.impact=Bt(Je.impact,e)||null):r.impact=null,r};function $t(e,t,r){var a=Object.assign({},t);a.nodes=(a[r]||[]).concat(),Je.resultGroups.forEach(function(e){delete a[e]}),e[r].push(a)}var Wt=function(e){var r={};return Je.resultGroups.forEach(function(e){return r[e]=[]}),e.forEach(function(t){t.error?$t(r,t,Je.CANTTELL_GROUP):t.result===Je.NA?$t(r,t,Je.NA_GROUP):Je.resultGroups.forEach(function(e){Array.isArray(t[e])&&0<t[e].length&&$t(r,t,e)})}),r};var Gt=function e(t,r,a){var n=window.getComputedStyle(t,null);if(!n)return!1;for(var o=0;o<r.length;++o){var i=r[o];if(n.getPropertyValue(i.property)===i.value)return!0}return!(!t.parentNode||t.nodeName.toUpperCase()===a.toUpperCase())&&e(t.parentNode,r,a)};var Yt=function(e){return Array.prototype.slice.call(e)};var Kt=function(e){for(var t,r=String(e),a=r.length,n=-1,o=\"\",i=r.charCodeAt(0);++n<a;)0!=(t=r.charCodeAt(n))?o+=1<=t&&t<=31||127==t||0==n&&48<=t&&t<=57||1==n&&48<=t&&t<=57&&45==i?\"\\\\\"+t.toString(16)+\" \":(0!=n||1!=a||45!=t)&&(128<=t||45==t||95==t||48<=t&&t<=57||65<=t&&t<=90||97<=t&&t<=122)?r.charAt(n):\"\\\\\"+r.charAt(n):o+=\"�\";return o};function Xt(e,t){return[e.substring(0,t),e.substring(t)]}function Jt(e){return e.replace(/\\s+$/,\"\")}var Qt=function(){var e=0<arguments.length&&void 0!==arguments[0]?arguments[0]:\"\",t=1<arguments.length&&void 0!==arguments[1]?arguments[1]:{};if(!(e.length<=1||\"data:\"===e.substr(0,5)||\"javascript:\"===e.substr(0,11)||e.includes(\"?\"))){var r,a,n,o,i=t.currentDomain,l=t.maxLength,s=void 0===l?25:l,u=(d=c=u=o=n=\"\",(l=t=e).includes(\"#\")&&(t=(e=Ku(Xt(t,t.indexOf(\"#\")),2))[0],d=e[1]),t.includes(\"?\")&&(t=(r=Ku(Xt(t,t.indexOf(\"?\")),2))[0],c=r[1]),t.includes(\"://\")?(n=(r=Ku(t.split(\"://\"),2))[0],o=(r=Ku(Xt(t=r[1],t.indexOf(\"/\")),2))[0],t=r[1]):\"//\"===t.substr(0,2)&&(o=(a=Ku(Xt(t=t.substr(2),t.indexOf(\"/\")),2))[0],t=a[1]),(o=\"www.\"===o.substr(0,4)?o.substr(4):o)&&o.includes(\":\")&&(o=(a=Ku(Xt(o,o.indexOf(\":\")),2))[0],u=a[1]),{original:l,protocol:n,domain:o,port:u,path:t,query:c,hash:d}),t=u.path,c=u.domain,d=u.hash,u=t.substr(t.substr(0,t.length-2).lastIndexOf(\"/\")+1);if(d)return u&&(u+d).length<=s?Jt(u+d):u.length<2&&2<d.length&&d.length<=s?Jt(d):void 0;if(c&&c.length<s&&t.length<=1)return Jt(c+t);if(t===\"/\"+u&&c&&i&&c!==i&&(c+t).length<=s)return Jt(c+t);t=u.lastIndexOf(\".\");return(-1===t||1<t)&&(-1!==t||2<u.length)&&u.length<=s&&!u.match(/index(\\.[a-zA-Z]{2-4})?/)&&!function(e){var t=0<arguments.length&&void 0!==e?e:\"\";return 0!==t.length&&(t.match(/[0-9]/g)||\"\").length>=t.length/2}(u)?Jt(u):void 0}};var Zt,er=function(e){return(e.attributes instanceof window.NamedNodeMap?e:e.cloneNode(!1)).attributes},tr=function(e,t){return!!e[Zt=!Zt||!e[Zt]?function(e){for(var t,r=[\"matches\",\"matchesSelector\",\"mozMatchesSelector\",\"webkitMatchesSelector\",\"msMatchesSelector\"],a=r.length,n=0;n<a;n++)if(e[t=r[n]])return t}(e):Zt]&&e[Zt](t)};var rr=function(e){return!!e.createElement&&\"A\"===e.createElement(\"A\").localName};var ar,nr=function(r,e){var a=2<arguments.length&&void 0!==arguments[2]?arguments[2]:{};if(!e)return\"\";var t=e.getRootNode&&e.getRootNode()||document;if(11!==t.nodeType)return r(e,a,t);for(var n=[];11===t.nodeType;){if(!t.host)return\"\";n.unshift({elm:e,doc:t}),t=(e=t.host).getRootNode()}return n.unshift({elm:e,doc:t}),n.map(function(e){var t=e.elm,e=e.doc;return r(t,a,e)})},or=[\"class\",\"style\",\"id\",\"selected\",\"checked\",\"disabled\",\"tabindex\",\"aria-checked\",\"aria-selected\",\"aria-invalid\",\"aria-activedescendant\",\"aria-busy\",\"aria-disabled\",\"aria-expanded\",\"aria-grabbed\",\"aria-pressed\",\"aria-valuenow\"],ir=31;function lr(e,t){var r=t.name;if(-1!==r.indexOf(\"href\")||-1!==r.indexOf(\"src\")){var a=Qt(e.getAttribute(r));if(a){var n=encodeURI(a);if(!n)return;n=Kt(t.name)+'$=\"'+Kt(n)+'\"'}else n=Kt(t.name)+'=\"'+Kt(e.getAttribute(r))+'\"'}else n=Kt(r)+'=\"'+Kt(t.value)+'\"';return n}function sr(e,t){return e.count<t.count?-1:e.count===t.count?0:1}function ur(e){return!or.includes(e.name)&&-1===e.name.indexOf(\":\")&&(!e.value||e.value.length<ir)}function cr(e){for(var a={classes:{},tags:{},attributes:{}},n=(e=Array.isArray(e)?e:[e]).slice(),o=[];n.length;)!function(){var e,t=n.pop(),r=t.actualNode;for(r.querySelectorAll&&(e=r.nodeName,a.tags[e]?a.tags[e]++:a.tags[e]=1,r.classList&&Array.from(r.classList).forEach(function(e){e=Kt(e);a.classes[e]?a.classes[e]++:a.classes[e]=1}),r.hasAttributes()&&Array.from(er(r)).filter(ur).forEach(function(e){e=lr(r,e);e&&(a.attributes[e]?a.attributes[e]++:a.attributes[e]=1)})),t.children.length&&(o.push(n),n=t.children.slice());!n.length&&o.length;)n=o.pop()}();return a}function dr(e){return void 0===ar&&(ar=rr(document)),Kt(ar?e.localName:e.nodeName.toLowerCase())}function pr(e,t){var r,a,n,o,i,l,s,u,c,d=\"\",p=(a=e,n=[],o=t.classes,i=t.tags,a.classList&&Array.from(a.classList).forEach(function(e){e=Kt(e);o[e]<i[a.nodeName]&&n.push({name:e,count:o[e],species:\"class\"})}),n.sort(sr)),t=(l=e,s=[],u=t.attributes,c=t.tags,l.hasAttributes()&&Array.from(er(l)).filter(ur).forEach(function(e){e=lr(l,e);e&&u[e]<c[l.nodeName]&&s.push({name:e,count:u[e],species:\"attribute\"})}),s.sort(sr));return p.length&&1===p[0].count?r=[p[0]]:t.length&&1===t[0].count?(r=[t[0]],d=dr(e)):((r=p.concat(t)).sort(sr),(r=r.slice(0,3)).some(function(e){return\"class\"===e.species})?r.sort(function(e,t){return e.species!==t.species&&\"class\"===e.species?-1:e.species===t.species?0:1}):d=dr(e)),d+r.reduce(function(e,t){switch(t.species){case\"class\":return e+\".\"+t.name;case\"attribute\":return e+\"[\"+t.name+\"]\"}return e},\"\")}function fr(e,t,r){if(!axe._selectorData)throw new Error(\"Expect axe._selectorData to be set up\");var a,n,t=t.toRoot,o=void 0!==t&&t;do{var i=function(e){if(e.getAttribute(\"id\")){var t=e.getRootNode&&e.getRootNode()||document,e=\"#\"+Kt(e.getAttribute(\"id\")||\"\");return e.match(/player_uid_/)||1!==t.querySelectorAll(e).length?void 0:e}}(e);i||(i=pr(e,axe._selectorData),i+=function(t,r){var e=t.parentNode&&Array.from(t.parentNode.children||\"\")||[];return e.find(function(e){return e!==t&&tr(e,r)})?\":nth-child(\"+(1+e.indexOf(t))+\")\":\"\"}(e,i)),a=a?i+\" > \"+a:i,n=n?n.filter(function(e){return tr(e,a)}):Array.from(r.querySelectorAll(a)),e=e.parentElement}while((1<n.length||o)&&e&&11!==e.nodeType);return 1===n.length?a:-1!==a.indexOf(\" > \")?\":root\"+a.substring(a.indexOf(\" > \")):\":root\"}function mr(e,t){return nr(fr,e,t)}function hr(e){var t=e.nodeName.toLowerCase(),r=e.parentElement;if(!r)return t;var a=\"\";return\"head\"!==t&&\"body\"!==t&&1<r.children.length&&(e=Array.prototype.indexOf.call(r.children,e)+1,a=\":nth-child(\".concat(e,\")\")),hr(r)+\" > \"+t+a}function gr(e,t){return nr(hr,e,t)}var br=function(e){return function e(t,r){var a,n,o,i;if(!t)return[];if(!r&&9===t.nodeType)return r=[{str:\"html\"}];if(r=r||[],t.parentNode&&t.parentNode!==t&&(r=e(t.parentNode,r)),t.previousSibling){for(n=1,a=t.previousSibling;1===a.nodeType&&a.nodeName===t.nodeName&&n++,a=a.previousSibling;);1===n&&(n=null)}else if(t.nextSibling)for(a=t.nextSibling;a=1===a.nodeType&&a.nodeName===t.nodeName?(n=1,null):(n=null,a.previousSibling););return 1===t.nodeType&&((o={}).str=t.nodeName.toLowerCase(),(i=t.getAttribute&&Kt(t.getAttribute(\"id\")))&&1===t.ownerDocument.querySelectorAll(\"#\"+i).length&&(o.id=t.getAttribute(\"id\")),1<n&&(o.count=n),r.push(o)),r}(e).reduce(function(e,t){return t.id?\"/\".concat(t.str,\"[@id='\").concat(t.id,\"']\"):e+\"/\".concat(t.str)+(0<t.count?\"[\".concat(t.count,\"]\"):\"\")},\"\")},yr={},vr={set:function(e,t){yr[e]=t},get:function(e){return yr[e]},clear:function(){yr={}}};var Dr=function(e,t){return e=t||e,vr.get(\"nodeMap\")?vr.get(\"nodeMap\").get(e):null};function wr(e){var t,r,a,n=1<arguments.length&&void 0!==arguments[1]?arguments[1]:{};this.spec=2<arguments.length&&void 0!==arguments[2]?arguments[2]:{},e instanceof tt?(this._virtualNode=e,this._element=e.actualNode):(this._element=e,this._virtualNode=Dr(e)),this.fromFrame=1<(null===(t=this.spec.selector)||void 0===t?void 0:t.length),n.absolutePaths&&(this._options={toRoot:!0}),this.nodeIndexes=[],Array.isArray(this.spec.nodeIndexes)?this.nodeIndexes=this.spec.nodeIndexes:\"number\"==typeof(null===(r=this._virtualNode)||void 0===r?void 0:r.nodeIndex)&&(this.nodeIndexes=[this._virtualNode.nodeIndex]),this.source=null,axe._audit.noHtml||(this.source=null!==(n=this.spec.source)&&void 0!==n?n:null!=(r=this._element)&&r.outerHTML?((n=(n=!(n=r.outerHTML)&&\"function\"==typeof XMLSerializer?(new XMLSerializer).serializeToString(r):n)||\"\").length>(a=a||300)&&(a=n.indexOf(\">\"),n=n.substring(0,a+1)),n):\"\")}wr.prototype={get selector(){return this.spec.selector||[mr(this.element,this._options)]},get ancestry(){return this.spec.ancestry||[gr(this.element)]},get xpath(){return this.spec.xpath||[br(this.element)]},get element(){return this._element},toJSON:function(){return{selector:this.selector,source:this.source,xpath:this.xpath,ancestry:this.ancestry,nodeIndexes:this.nodeIndexes}}},wr.fromFrame=function(e,t,r){e=Xu({},e,{selector:[].concat(Yu(r.selector),Yu(e.selector)),ancestry:[].concat(Yu(r.ancestry),Yu(e.ancestry)),xpath:[].concat(Yu(r.xpath),Yu(e.xpath)),nodeIndexes:[].concat(Yu(r.nodeIndexes),Yu(e.nodeIndexes))});return new wr(r.element,t,e)};var xr=wr;var Er=function(t,r,a,n){return{isAsync:!1,async:function(){return this.isAsync=!0,function(e){e instanceof Error==!1?(t.result=e,a(t)):n(e)}},data:function(e){t.data=e},relatedNodes:function(e){e=e instanceof window.Node?[e]:Yt(e),t.relatedNodes=e.map(function(e){return new xr(e,r)})}}};var Ar=function e(t){var r,a,n=t;if(null!==t&&\"object\"===Lu(t))if(Array.isArray(t))for(n=[],r=0,a=t.length;r<a;r++)n[r]=e(t[r]);else for(r in n={},t)n[r]=e(t[r]);return n},Cr=new(c(m()).CssSelectorParser);Cr.registerSelectorPseudos(\"not\"),Cr.registerSelectorPseudos(\"is\"),Cr.registerNestingOperators(\">\"),Cr.registerAttrEqualityMods(\"^\",\"$\",\"*\",\"~\");var Fr=Cr;function kr(e,t){return s=t,1===(l=e).props.nodeType&&(\"*\"===s.tag||l.props.nodeName===s.tag)&&(o=e,!(i=t).classes||i.classes.every(function(e){return o.hasClass(e.value)}))&&(a=e,!(n=t).attributes||n.attributes.every(function(e){var t=a.attr(e.key);return null!==t&&(!e.value||e.test(t))}))&&(i=e,!(n=t).id||i.props.id===n.id)&&(r=e,!((t=t).pseudos&&!t.pseudos.every(function(e){if(\"not\"===e.name)return!e.expressions.some(function(e){return Sr(r,e)});if(\"is\"===e.name)return e.expressions.some(function(e){return Sr(r,e)});throw new Error(\"the pseudo selector \"+e.name+\" has not yet been implemented\")})));var r,a,n,o,i,l,s}var Rr,Tr=(Rr=/(?=[\\-\\[\\]{}()*+?.\\\\\\^$|,#\\s])/g,function(e){return e.replace(Rr,\"\\\\\")}),Nr=/\\\\/g;function _r(e){return e.map(function(e){for(var t=[],r=e.rule;r;)t.push({tag:r.tagName?r.tagName.toLowerCase():\"*\",combinator:r.nestingOperator||\" \",id:r.id,attributes:function(e){if(e)return e.map(function(e){var t,r,a=e.name.replace(Nr,\"\"),n=(e.value||\"\").replace(Nr,\"\");switch(e.operator){case\"^=\":r=new RegExp(\"^\"+Tr(n));break;case\"$=\":r=new RegExp(Tr(n)+\"$\");break;case\"~=\":r=new RegExp(\"(^|\\\\s)\"+Tr(n)+\"(\\\\s|$)\");break;case\"|=\":r=new RegExp(\"^\"+Tr(n)+\"(-|$)\");break;case\"=\":t=function(e){return n===e};break;case\"*=\":t=function(e){return e&&e.includes(n)};break;case\"!=\":t=function(e){return n!==e};break;default:t=function(e){return!!e}}return\"\"===n&&/^[*$^]=$/.test(e.operator)&&(t=function(){return!1}),{key:a,value:n,test:t=t||function(e){return e&&r.test(e)}}})}(r.attrs),classes:function(e){if(e)return e.map(function(e){return{value:e=e.replace(Nr,\"\"),regexp:new RegExp(\"(^|\\\\s)\"+Tr(e)+\"(\\\\s|$)\")}})}(r.classNames),pseudos:function(e){if(e)return e.map(function(e){var t;return[\"is\",\"not\"].includes(e.name)&&(t=_r(t=(t=e.value).selectors||[t])),{name:e.name,expressions:t,value:e.value}})}(r.pseudos)}),r=r.rule;return t})}function Or(e){e=Fr.parse(e);return _r(e=e.selectors||[e])}function Sr(e,t,r){for(var t=[].concat(t),a=t.pop(),n=kr(e,a);!n&&r&&e.parent;)n=kr(e=e.parent,a);if(t.length){if(!1===[\" \",\">\"].includes(a.combinator))throw new Error(\"axe.utils.matchesExpression does not support the combinator: \"+a.combinator);n=n&&Sr(e.parent,t,\" \"===a.combinator)}return n}var Pr=function(t,e){return Or(e).some(function(e){return Sr(t,e)})};var Ir=function(e,t){for(;e;){if(Pr(e,t))return e;if(void 0===e.parent)throw new TypeError(\"Cannot resolve parent for non-DOM nodes\");e=e.parent}return null};function Br(){}function Lr(e){if(\"function\"!=typeof e)throw new TypeError(\"Queue methods require functions as arguments\")}var qr,Mr,jr=function(){function t(e){a=e,setTimeout(function(){null!=a&&Qe(\"Uncaught error (of queue)\",a)},1)}var a,n=[],r=0,o=0,i=Br,l=!1,s=t;function u(e){return i=Br,s(e),n}function c(){for(var e=n.length;r<e;r++){var t=n[r];try{t.call(null,function(t){return function(e){n[t]=e,--o||i===Br||(l=!0,i(n))}}(r),u)}catch(e){u(e)}}}var d={defer:function(e){var r;if(\"object\"===Lu(e)&&e.then&&e.catch&&(r=e,e=function(e,t){r.then(e).catch(t)}),Lr(e),void 0===a){if(l)throw new Error(\"Queue already completed\");return n.push(e),++o,c(),d}},then:function(e){if(Lr(e),i!==Br)throw new Error(\"queue `then` already set\");return a||(i=e,o||(l=!0,i(n))),d},catch:function(e){if(Lr(e),s!==t)throw new Error(\"queue `catch` already set\");return a?(e(a),a=null):s=e,d},abort:u};return d},Ur={};function Vr(e,t,r,a,n){a={topic:t,message:r,channelId:\"\".concat(kt(),\":\").concat(kt()),keepalive:a};return Mr(e,a,n)}function Hr(t,r){var e=t.topic,a=t.message,t=t.keepalive,e=Ur[e];if(e)try{e(a,t,r)}catch(e){axe.log(e),r(e,t)}}function zr(e,t){var r;return axe._tree&&(r=mr(t)),new Error(e+\": \"+(r||t))}Vr.updateMessenger=function(e){var t=e.open,e=e.post;it(\"function\"==typeof t,\"open callback must be a function\"),it(\"function\"==typeof e,\"post callback must be a function\"),qr&&qr();t=t(Hr);qr=t?(it(\"function\"==typeof t,\"open callback must return a cleanup function\"),t):null,Mr=e},Vr.subscribe=function(e,t){it(\"function\"==typeof t,\"Subscriber callback must be a function\"),it(!Ur[e],\"Topic \".concat(e,\" is already registered to.\")),Ur[e]=t},Vr.isInFrame=function(){return!!(0<arguments.length&&void 0!==arguments[0]?arguments[0]:window).frameElement},It(Vr);var $r=function(t,r,a,n){var o=t.contentWindow;if(!o)return Qe(\"Frame does not have a content window\",t),void a(null);var i=setTimeout(function(){i=setTimeout(function(){r.debug?n(zr(\"No response from frame\",t)):a(null)},0)},500);Vr(o,\"axe.ping\",null,void 0,function(){clearTimeout(i);var e=r.options&&r.options.frameWaitTime||6e4;i=setTimeout(function(){n(zr(\"Axe in frame timed out\",t))},e),Vr(o,\"axe.start\",r,void 0,function(e){clearTimeout(i),(e instanceof Error==!1?a:n)(e)})})};var Wr=function(e){return[].concat(e.any||[]).concat(e.all||[]).concat(e.none||[])};var Gr=function(e,t,r){if(Array.isArray(e))return e.find(function(e){return\"object\"===Lu(e)&&e[t]===r})};function Yr(e,t){for(var r=0<arguments.length&&void 0!==e?e:[],a=1<arguments.length&&void 0!==t?t:[],n=Math.max(null==r?void 0:r.length,null==a?void 0:a.length),o=0;o<n;o++){var i=null==r?void 0:r[o],l=null==a?void 0:a[o];if(\"number\"!=typeof i||isNaN(i))return 0===o?1:-1;if(\"number\"!=typeof l||isNaN(l))return 0===o?-1:1;if(i!==l)return i-l}return 0}var Kr=function(e,o){var i=[];return e.forEach(function(e){var t,n,r=(t=e)&&t.results?Array.isArray(t.results)?t.results.length?t.results:null:[t.results]:null;r&&r.length&&(e.frameElement&&(t={selector:[e.frame]},n=new xr(e.frameElement,o,t)),r.forEach(function(e){var t,r;e.nodes&&n&&(a=e.nodes,t=n,r=o,a.forEach(function(e){e.node=xr.fromFrame(e.node,r,t),Wr(e).forEach(function(e){e.relatedNodes=e.relatedNodes.map(function(e){return xr.fromFrame(e,r,t)})})}));var a=Gr(i,\"id\",e.id);a?e.nodes.length&&function(e,t){for(var r=t[0].node,a=0;a<e.length;a++){var n=e[a].node,o=Yr(n.nodeIndexes,r.nodeIndexes);if(0<o||0===o&&r.selector.length<n.selector.length)return e.splice.apply(e,[a,0].concat(Yu(t)))}e.push.apply(e,Yu(t))}(a.nodes,e.nodes):i.push(e)}))}),i.forEach(function(e){e.nodes&&e.nodes.sort(function(e,t){return Yr(e.node.nodeIndexes,t.node.nodeIndexes)})}),i};var Xr=function(i,l,s,u,t,e){var c=jr();i.frames.forEach(function(a){var e=parseInt(a.node.getAttribute(\"tabindex\"),10),t=isNaN(e)||0<=e,r=a.node.getBoundingClientRect(),n=parseInt(a.node.getAttribute(\"width\"),10),e=parseInt(a.node.getAttribute(\"height\"),10),n=isNaN(n)?r.width:n,e=isNaN(e)?r.height:e,o={options:l,command:s,parameter:u,context:{initiator:!1,focusable:!1!==i.focusable&&t,boundingClientRect:{width:n,height:e},page:i.page,include:a.include||[],exclude:a.exclude||[]}};c.defer(function(t,e){var r=a.node;$r(r,o,function(e){return e?t({results:e,frameElement:r,frame:mr(r)}):void t(null)},e)})}),c.then(function(e){t(Kr(e,l))}).catch(e)};var Jr=function(e,t){if(e.shadowId||t.shadowId)return function t(e,r){return e.shadowId===r.shadowId||!!e.children.find(function(e){return t(e,r)})}(e,t);if(e.actualNode)return\"function\"==typeof e.actualNode.contains?e.actualNode.contains(t.actualNode):!!(16&e.actualNode.compareDocumentPosition(t.actualNode));do{if(t===e)return!0}while(t=t&&t.parent);return!1};var Qr=function n(){for(var o={},e=arguments.length,t=new Array(e),r=0;r<e;r++)t[r]=arguments[r];return t.forEach(function(e){if(e&&\"object\"===Lu(e)&&!Array.isArray(e))for(var t=0,r=Object.keys(e);t<r.length;t++){var a=r[t];!o.hasOwnProperty(a)||\"object\"!==Lu(e[a])||Array.isArray(o[a])?o[a]=e[a]:o[a]=n(o[a],e[a])}}),o};var Zr=function(t,r){Object.assign(t,r),Object.keys(r).filter(function(e){return\"function\"==typeof r[e]}).forEach(function(e){t[e]=null;try{t[e]=r[e](t)}catch(e){}})},ea=[\"article\",\"aside\",\"blockquote\",\"body\",\"div\",\"footer\",\"h1\",\"h2\",\"h3\",\"h4\",\"h5\",\"h6\",\"header\",\"main\",\"nav\",\"p\",\"section\",\"span\"];var ta=function(e){if(e.shadowRoot){e=e.nodeName.toLowerCase();if(ea.includes(e)||/^[a-z][a-z0-9_.-]*-[a-z0-9_.-]*$/.test(e))return!0}return!1},ra={};o(ra,{findElmsInContext:function(){return oa},findUp:function(){return la},findUpVirtual:function(){return ia},getComposedParent:function(){return sa},getElementByReference:function(){return ua},getElementCoordinates:function(){return da},getElementStack:function(){return Ca},getRootNode:function(){return na},getScrollOffset:function(){return ca},getTabbableElements:function(){return Fa},getTextElementStack:function(){return Ra},getViewportSize:function(){return pa},hasContent:function(){return Ba},hasContentVirtual:function(){return Ia},idrefs:function(){return _a},insertedIntoFocusOrder:function(){return Ha},isFocusable:function(){return Va},isHTML5:function(){return za},isHiddenWithCSS:function(){return Ma},isInTextBlock:function(){return Ga},isModalOpen:function(){return Ya},isNativelyFocusable:function(){return Ua},isNode:function(){return Ka},isOffscreen:function(){return fa},isOpaque:function(){return sn},isSkipLink:function(){return cn},isVisible:function(){return ba},isVisualContent:function(){return Na},reduceToElementsBelowFloating:function(){return dn},shadowElementsFromPoint:function(){return mn},urlPropsFromAttribute:function(){return hn},visuallyContains:function(){return fn},visuallyOverlaps:function(){return bn}});var aa=function(e){var t=e.getRootNode&&e.getRootNode()||document;return t=t===e?document:t},na=aa;var oa=function(e){var t=e.context,r=e.value,a=e.attr,e=void 0===(e=e.elm)?\"\":e,r=Kt(r),t=9===t.nodeType||11===t.nodeType?t:na(t);return Array.from(t.querySelectorAll(e+\"[\"+a+\"=\"+r+\"]\"))};var ia=function(e,t){var r=e.actualNode;if(!e.shadowId&&\"function\"==typeof e.actualNode.closest){e=e.actualNode.closest(t);return e?e:null}for(;(r=(r=r.assignedSlot||r.parentNode)&&11===r.nodeType?r.host:r)&&!tr(r,t)&&r!==document.documentElement;);return r&&tr(r,t)?r:null};var la=function(e,t){return ia(Dr(e),t)};var sa=function e(t){if(t.assignedSlot)return e(t.assignedSlot);if(t.parentNode){if(1===(t=t.parentNode).nodeType)return t;if(t.host)return t.host}return null};var ua=function(e,t){return(e=e.getAttribute(t))?(\"#\"===e.charAt(0)?e=decodeURIComponent(e.substring(1)):\"/#\"===e.substr(0,2)&&(e=decodeURIComponent(e.substring(2))),(t=document.getElementById(e))||((t=document.getElementsByName(e)).length?t[0]:null)):null};var ca=function(e){if(9!==(e=!e.nodeType&&e.document?e.document:e).nodeType)return{left:e.scrollLeft,top:e.scrollTop};var t=e.documentElement,e=e.body;return{left:t&&t.scrollLeft||e&&e.scrollLeft||0,top:t&&t.scrollTop||e&&e.scrollTop||0}};var da=function(e){var t=(r=ca(document)).left,r=r.top;return{top:(e=e.getBoundingClientRect()).top+r,right:e.right+t,bottom:e.bottom+r,left:e.left+t,width:e.right-e.left,height:e.bottom-e.top}};var pa=function(e){var t=e.document,r=t.documentElement;return e.innerWidth?{width:e.innerWidth,height:e.innerHeight}:r?{width:r.clientWidth,height:r.clientHeight}:{width:(t=t.body).clientWidth,height:t.clientHeight}};var fa=function(e){var t=document.documentElement,r=window.getComputedStyle(e),a=window.getComputedStyle(document.body||t).getPropertyValue(\"direction\"),n=da(e);if(n.bottom<0&&(function(e,t){for(e=sa(e);e&&\"html\"!==e.nodeName.toLowerCase();){if(e.scrollTop&&0<=(t+=e.scrollTop))return;e=sa(e)}return 1}(e,n.bottom)||\"absolute\"===r.position))return!0;if(0===n.left&&0===n.right)return!1;if(\"ltr\"===a){if(n.right<=0)return!0}else if(t=Math.max(t.scrollWidth,pa(window).width),n.left>=t)return!0;return!1},ma=/rect\\s*\\(([0-9]+)px,?\\s*([0-9]+)px,?\\s*([0-9]+)px,?\\s*([0-9]+)px\\s*\\)/,ha=/(\\w+)\\((\\d+)/;function ga(e,t,r){if(!e)throw new TypeError(\"Cannot determine if element is visible for non-DOM nodes\");var a=Dr(e),n=\"_isVisible\"+(t?\"ScreenReader\":\"\");if(9===e.nodeType)return!0;if(11===e.nodeType&&(e=e.host),a&&void 0!==a[n])return a[n];var o=window.getComputedStyle(e,null);if(null===o)return!1;var i,l,s,u=e.nodeName.toUpperCase();if(\"AREA\"===u)return l=t,s=r,!!(c=la(i=e,\"map\"))&&(!!(c=c.getAttribute(\"name\"))&&(!(!(i=na(i))||9!==i.nodeType)&&(!(!(c=vo(axe._tree,'img[usemap=\"#'.concat(Kt(c),'\"]')))||!c.length)&&c.some(function(e){return ga(e.actualNode,l,s)}))));if(\"none\"===o.getPropertyValue(\"display\")||[\"STYLE\",\"SCRIPT\",\"NOSCRIPT\",\"TEMPLATE\"].includes(u))return!1;if(t&&\"true\"===e.getAttribute(\"aria-hidden\"))return!1;var c=parseInt(o.getPropertyValue(\"height\")),u=Pn(e)&&0===c,c=\"absolute\"===o.getPropertyValue(\"position\")&&c<2&&\"hidden\"===o.getPropertyValue(\"overflow\");if(!t&&(function(e){var t=e.getPropertyValue(\"clip\").match(ma),e=e.getPropertyValue(\"clip-path\").match(ha);if(t&&5===t.length)return t[3]-t[1]<=0&&t[2]-t[4]<=0;if(e){var t=e[1],r=parseInt(e[2],10);switch(t){case\"inset\":return 50<=r;case\"circle\":return 0===r}}}(o)||\"0\"===o.getPropertyValue(\"opacity\")||u||c))return!1;if(!r&&(\"hidden\"===o.getPropertyValue(\"visibility\")||!t&&fa(e)))return!1;o=e.assignedSlot||e.parentNode,e=!1;return o&&(e=ga(o,t,!0)),a&&(a[n]=e),e}var ba=ga,ya=200;function va(e){return\"static\"===e.getComputedStylePropertyValue(\"position\")?-1!==e.getComputedStylePropertyValue(\"display\").indexOf(\"inline\")?2:function e(t){if(!t)return!1;if(void 0!==t._isFloated)return t._isFloated;if(\"none\"!==t.getComputedStylePropertyValue(\"float\"))return t._isFloated=!0;var r=e(t.parent);return t._isFloated=r}(e)?1:0:3}function Da(e,t){for(var r=0;r<e._stackingOrder.length;r++){if(void 0===t._stackingOrder[r])return-1;if(t._stackingOrder[r]>e._stackingOrder[r])return 1;if(t._stackingOrder[r]<e._stackingOrder[r])return-1}var a=e.actualNode,n=t.actualNode;if(a.getRootNode&&a.getRootNode()!==n.getRootNode()){for(var o=[];a;)o.push({root:a.getRootNode(),node:a}),a=a.getRootNode().host;for(;n&&!o.find(function(e){return e.root===n.getRootNode()});)n=n.getRootNode().host;if((a=o.find(function(e){return e.root===n.getRootNode()}).node)===n)return e.actualNode.getRootNode()!==a.getRootNode()?-1:1}var i=window.Node,l=i.DOCUMENT_POSITION_FOLLOWING,s=i.DOCUMENT_POSITION_CONTAINS,u=i.DOCUMENT_POSITION_CONTAINED_BY,i=a.compareDocumentPosition(n),l=i&l?1:-1,s=i&s||i&u,i=va(e),u=va(t);return i===u||s?l:u-i}function wa(e,t){var r=t._stackingOrder.slice(),a=e.getComputedStylePropertyValue(\"z-index\");return\"auto\"!==a&&(r[r.length-1]=parseInt(a)),function(e,t){var r=e.getComputedStylePropertyValue(\"position\"),a=e.getComputedStylePropertyValue(\"z-index\");if(\"fixed\"===r||\"sticky\"===r)return 1;if(\"auto\"!==a&&\"static\"!==r)return 1;if(\"1\"!==e.getComputedStylePropertyValue(\"opacity\"))return 1;if(\"none\"!==(e.getComputedStylePropertyValue(\"-webkit-transform\")||e.getComputedStylePropertyValue(\"-ms-transform\")||e.getComputedStylePropertyValue(\"transform\")||\"none\"))return 1;if((r=e.getComputedStylePropertyValue(\"mix-blend-mode\"))&&\"normal\"!==r)return 1;if((r=e.getComputedStylePropertyValue(\"filter\"))&&\"none\"!==r)return 1;if((r=e.getComputedStylePropertyValue(\"perspective\"))&&\"none\"!==r)return 1;if((r=e.getComputedStylePropertyValue(\"clip-path\"))&&\"none\"!==r)return 1;if(\"none\"!==(e.getComputedStylePropertyValue(\"-webkit-mask\")||e.getComputedStylePropertyValue(\"mask\")||\"none\"))return 1;if(\"none\"!==(e.getComputedStylePropertyValue(\"-webkit-mask-image\")||e.getComputedStylePropertyValue(\"mask-image\")||\"none\"))return 1;if(\"none\"!==(e.getComputedStylePropertyValue(\"-webkit-mask-border\")||e.getComputedStylePropertyValue(\"mask-border\")||\"none\"))return 1;if(\"isolate\"===e.getComputedStylePropertyValue(\"isolation\"))return 1;if(\"transform\"===(r=e.getComputedStylePropertyValue(\"will-change\"))||\"opacity\"===r)return 1;if(\"touch\"===e.getComputedStylePropertyValue(\"-webkit-overflow-scrolling\"))return 1;if(e=e.getComputedStylePropertyValue(\"contain\"),[\"layout\",\"paint\",\"strict\",\"content\"].includes(e))return 1;if(\"auto\"!==a&&t){t=t.getComputedStylePropertyValue(\"display\");if([\"flex\",\"inline-flex\",\"inline flex\",\"grid\",\"inline-grid\",\"inline grid\"].includes(t))return 1}}(e,t)&&r.push(0),r}function xa(s,u){u._grid=s,u.clientRects.forEach(function(e){for(var t=e.left,r=e.top,a=t/ya|0,n=(r+e.height)/ya|0,o=(t+e.width)/ya|0,i=r/ya|0;i<=n;i++){s.cells[i]=s.cells[i]||[];for(var l=a;l<=o;l++)s.cells[i][l]=s.cells[i][l]||[],s.cells[i][l].includes(u)||s.cells[i][l].push(u)}})}function Ea(e,t,r){var a,n=0<arguments.length&&void 0!==e?e:document.body,o=1<arguments.length&&void 0!==t?t:{container:null,cells:[]},i=2<arguments.length&&void 0!==r?r:null;i||((a=(a=Dr(document.documentElement))||new vn(document.documentElement))._stackingOrder=[0],xa(o,a),Pn(a.actualNode)&&(a._subGrid={container:a,cells:[]}));for(var l=document.createTreeWalker(n,window.NodeFilter.SHOW_ELEMENT,null,!1),s=i?l.nextNode():l.currentNode;s;){var u=Dr(s);s.parentElement?i=Dr(s.parentElement):s.parentNode&&Dr(s.parentNode)&&(i=Dr(s.parentNode)),(u=u||new axe.VirtualNode(s,i))._stackingOrder=wa(u,i);var c=function(e,t){for(var r=null,a=[e];t;){if(t._scrollRegionParent){r=t._scrollRegionParent;break}if(Pn(t.actualNode)){r=t;break}a.push(t),t=Dr(t.actualNode.parentElement||t.actualNode.parentNode)}return a.forEach(function(e){return e._scrollRegionParent=r}),r}(u,i),d=c?c._subGrid:o;Pn(u.actualNode)&&(u._subGrid={container:u,cells:[]});c=u.boundingClientRect;0!==c.width&&0!==c.height&&ba(s)&&xa(d,u),ta(s)&&Ea(s.shadowRoot,d,u),s=l.nextNode()}}function Aa(e,t,r){var a=2<arguments.length&&void 0!==r&&r,n=t.left+t.width/2,o=t.top+t.height/2,i=e.cells[o/ya|0][n/ya|0].filter(function(e){return e.clientRects.find(function(e){var t=e.left,r=e.top;return n<=t+e.width&&t<=n&&o<=r+e.height&&r<=o})}),l=e.container;return l&&(i=Aa(l._grid,l.boundingClientRect,!0).concat(i)),i=!a?i.sort(Da).map(function(e){return e.actualNode}).concat(document.documentElement).filter(function(e,t,r){return r.indexOf(e)===t}):i}var Ca=function(e){vr.get(\"gridCreated\")||(Ea(),vr.set(\"gridCreated\",!0));var t=Dr(e);return(e=t._grid)?Aa(e,t.boundingClientRect):[]};var Fa=function(e){return vo(e,\"*\").filter(function(e){var t=e.isFocusable,e=e.actualNode.getAttribute(\"tabindex\");return(e=e&&!isNaN(parseInt(e,10))?parseInt(e):null)?t&&0<=e:t})};var ka=function(e){return e?e.replace(/\\r\\n/g,\"\\n\").replace(/\\u00A0/g,\" \").replace(/[\\s]{2,}/g,\" \").trim():\"\"};var Ra=function(e){vr.get(\"gridCreated\")||(Ea(),vr.set(\"gridCreated\",!0));var t=Dr(e),r=t._grid;if(!r)return[];var o=t.boundingClientRect,i=[];return Array.from(e.childNodes).forEach(function(e){if(3===e.nodeType&&\"\"!==ka(e.textContent)){var t=document.createRange();t.selectNodeContents(e);var r=t.getClientRects();if(!Array.from(r).some(function(e){var t=e.left+e.width/2,e=e.top+e.height/2;return t<o.left||t>o.right||e<o.top||e>o.bottom}))for(var a=0;a<r.length;a++){var n=r[a];1<=n.width&&1<=n.height&&i.push(n)}}}),i.length?i.map(function(e){return Aa(r,e)}):[Ca(e)]},Ta=[\"checkbox\",\"img\",\"radio\",\"range\",\"slider\",\"spinbutton\",\"textbox\"];var Na=function(e){var t=e.getAttribute(\"role\");if(t)return-1!==Ta.indexOf(t);switch(e.nodeName.toUpperCase()){case\"IMG\":case\"IFRAME\":case\"OBJECT\":case\"VIDEO\":case\"AUDIO\":case\"CANVAS\":case\"SVG\":case\"MATH\":case\"BUTTON\":case\"SELECT\":case\"TEXTAREA\":case\"KEYGEN\":case\"PROGRESS\":case\"METER\":return!0;case\"INPUT\":return\"hidden\"!==e.type;default:return!1}};var _a=function(e,t){e=e.actualNode||e;try{var r=na(e),a=[];if(n=e.getAttribute(t))for(var n=Co(n),o=0;o<n.length;o++)a.push(r.getElementById(n[o]));return a}catch(e){throw new TypeError(\"Cannot resolve id references for non-DOM nodes\")}};var Oa=function a(e,n,o){var t=e instanceof tt?e:Dr(e),i=!e.actualNode||e.actualNode&&ba(e.actualNode,n),t=t.children.map(function(e){var t=(r=e.props).nodeType,r=r.nodeValue;if(3===t){if(r&&i)return r}else if(!o)return a(e,n)}).join(\"\");return ka(t)};var Sa=function(e){var t;return e.attr(\"aria-labelledby\")&&(t=_a(e.actualNode,\"aria-labelledby\").map(function(e){e=Dr(e);return e?Oa(e,!0):\"\"}).join(\" \").trim())||(t=(t=e.attr(\"aria-label\"))&&ka(t))?t:null},Pa=[\"HEAD\",\"TITLE\",\"TEMPLATE\",\"SCRIPT\",\"STYLE\",\"IFRAME\",\"OBJECT\",\"VIDEO\",\"AUDIO\",\"NOSCRIPT\"];var Ia=function t(e,r,a){return function(e){if(!Pa.includes(e.actualNode.nodeName.toUpperCase()))return e.children.some(function(e){return 3===(e=e.actualNode).nodeType&&e.nodeValue.trim()})}(e)||Na(e.actualNode)||!a&&!!Sa(e)||!r&&e.children.some(function(e){return 1===e.actualNode.nodeType&&t(e)})};var Ba=function(e,t,r){return e=Dr(e),Ia(e,t,r)};function La(e,t){var r=Dr(e);return r?(void 0===r._isHiddenWithCSS&&(r._isHiddenWithCSS=qa(e,t)),r._isHiddenWithCSS):qa(e,t)}function qa(e,t){if(9===e.nodeType)return!1;if(11===e.nodeType&&(e=e.host),[\"STYLE\",\"SCRIPT\"].includes(e.nodeName.toUpperCase()))return!1;var r=window.getComputedStyle(e,null);if(!r)throw new Error(\"Style does not exist for the given element.\");if(\"none\"===r.getPropertyValue(\"display\"))return!0;var a=[\"hidden\",\"collapse\"],r=r.getPropertyValue(\"visibility\");if(a.includes(r)&&!t)return!0;if(a.includes(r)&&t&&a.includes(t))return!0;e=sa(e);return!(!e||a.includes(r))&&La(e,r)}var Ma=La;var ja=function(e){return!!(e=e instanceof tt?e:Dr(e)).hasAttr(\"disabled\")||\"area\"!==e.props.nodeName&&(!!e.actualNode&&Ma(e.actualNode))};var Ua=function(e){var t=e instanceof tt?e:Dr(e);if(!t||ja(t))return!1;switch(t.props.nodeName){case\"a\":case\"area\":if(t.hasAttr(\"href\"))return!0;break;case\"input\":return\"hidden\"!==t.props.type;case\"textarea\":case\"select\":case\"summary\":case\"button\":return!0;case\"details\":return!vo(t,\"summary\").length}return!1};var Va=function(e){return 1===(e=e instanceof tt?e:Dr(e)).props.nodeType&&(!ja(e)&&(!!Ua(e)||!(!(e=e.attr(\"tabindex\"))||isNaN(parseInt(e,10)))))};var Ha=function(e){return-1<parseInt(e.getAttribute(\"tabindex\"),10)&&Va(e)&&!Ua(e)};var za=function(e){return null!==(e=e.doctype)&&(\"html\"===e.name&&!e.publicId&&!e.systemId)};var $a=[\"block\",\"list-item\",\"table\",\"flex\",\"grid\",\"inline-block\"];function Wa(e){e=window.getComputedStyle(e).getPropertyValue(\"display\");return $a.includes(e)||\"table-\"===e.substr(0,6)}var Ga=function(r){if(Wa(r))return!1;var e=function(e){for(var t=sa(e);t&&!Wa(t);)t=sa(t);return Dr(t)}(r),a=\"\",n=\"\",o=0;return function t(e,r){!1!==r(e.actualNode)&&e.children.forEach(function(e){return t(e,r)})}(e,function(e){if(2===o)return!1;if(3===e.nodeType&&(a+=e.nodeValue),1===e.nodeType){var t=(e.nodeName||\"\").toUpperCase();if(![\"BR\",\"HR\"].includes(t))return!(\"none\"===e.style.display||\"hidden\"===e.style.overflow||![\"\",null,\"none\"].includes(e.style.float)||![\"\",null,\"relative\"].includes(e.style.position))&&(\"A\"===t&&e.href||\"link\"===(e.getAttribute(\"role\")||\"\").toLowerCase()?(e===r&&(o=1),n+=e.textContent,!1):void 0);0===o?n=a=\"\":o=2}}),a=ka(a),n=ka(n),a.length>n.length};var Ya=function(e){var t=(e=e||{}).modalPercent||.75;if(vr.get(\"isModalOpen\"))return vr.get(\"isModalOpen\");if(so(axe._tree[0],\"dialog, [role=dialog], [aria-modal=true]\",function(e){return ba(e.actualNode)}).length)return vr.set(\"isModalOpen\",!0),!0;for(var r=pa(window),a=r.width*t,n=r.height*t,e=(r.width-a)/2,t=(r.height-n)/2,o=[{x:e,y:t},{x:r.width-e,y:t},{x:r.width/2,y:r.height/2},{x:e,y:r.height-t},{x:r.width-e,y:r.height-t}].map(function(e){return Array.from(document.elementsFromPoint(e.x,e.y))}),i=0;i<o.length;i++){var l=function(e){var t=o[e].find(function(e){e=window.getComputedStyle(e);return parseInt(e.width,10)>=a&&parseInt(e.height,10)>=n&&\"none\"!==e.getPropertyValue(\"pointer-events\")&&(\"absolute\"===e.position||\"fixed\"===e.position)});if(t&&o.every(function(e){return e.includes(t)}))return vr.set(\"isModalOpen\",!0),{v:!0}}(i);if(\"object\"===Lu(l))return l.v}vr.set(\"isModalOpen\",void 0)};var Ka=function(e){return e instanceof window.Node},Xa={},Ja={set:function(e,t){if(\"string\"!=typeof e)throw new Error(\"Incomplete data: key must be a string\");return t&&(Xa[e]=t),Xa[e]},get:function(e){return Xa[e]},clear:function(){Xa={}}};var Qa=function(e,t){var r=e.nodeName.toUpperCase();return[\"IMG\",\"CANVAS\",\"OBJECT\",\"IFRAME\",\"VIDEO\",\"SVG\"].includes(r)?(Ja.set(\"bgColor\",\"imgNode\"),!0):((t=\"none\"!==(e=(t=t||window.getComputedStyle(e)).getPropertyValue(\"background-image\")))&&(e=/gradient/.test(e),Ja.set(\"bgColor\",e?\"bgGradient\":\"bgImage\")),t)},Za={alert:{type:\"widget\",allowedAttrs:[\"aria-expanded\"],superclassRole:[\"section\"]},alertdialog:{type:\"widget\",allowedAttrs:[\"aria-expanded\",\"aria-modal\"],superclassRole:[\"alert\",\"dialog\"],accessibleNameRequired:!0},application:{type:\"landmark\",allowedAttrs:[\"aria-activedescendant\",\"aria-expanded\"],superclassRole:[\"structure\"],accessibleNameRequired:!0},article:{type:\"structure\",allowedAttrs:[\"aria-posinset\",\"aria-setsize\",\"aria-expanded\"],superclassRole:[\"document\"]},banner:{type:\"landmark\",allowedAttrs:[\"aria-expanded\"],superclassRole:[\"landmark\"]},blockquote:{type:\"structure\",superclassRole:[\"section\"]},button:{type:\"widget\",allowedAttrs:[\"aria-expanded\",\"aria-pressed\"],superclassRole:[\"command\"],accessibleNameRequired:!0,nameFromContent:!0,childrenPresentational:!0},caption:{type:\"structure\",requiredContext:[\"figure\",\"table\",\"grid\",\"treegrid\"],superclassRole:[\"section\"],prohibitedAttrs:[\"aria-label\",\"aria-labelledby\"]},cell:{type:\"structure\",requiredContext:[\"row\"],allowedAttrs:[\"aria-colindex\",\"aria-colspan\",\"aria-rowindex\",\"aria-rowspan\",\"aria-expanded\"],superclassRole:[\"section\"],nameFromContent:!0},checkbox:{type:\"widget\",allowedAttrs:[\"aria-checked\",\"aria-readonly\",\"aria-required\"],superclassRole:[\"input\"],accessibleNameRequired:!0,nameFromContent:!0,childrenPresentational:!0},code:{type:\"structure\",superclassRole:[\"section\"],prohibitedAttrs:[\"aria-label\",\"aria-labelledby\"]},columnheader:{type:\"structure\",requiredContext:[\"row\"],allowedAttrs:[\"aria-sort\",\"aria-colindex\",\"aria-colspan\",\"aria-expanded\",\"aria-readonly\",\"aria-required\",\"aria-rowindex\",\"aria-rowspan\",\"aria-selected\"],superclassRole:[\"cell\",\"gridcell\",\"sectionhead\"],accessibleNameRequired:!1,nameFromContent:!0},combobox:{type:\"composite\",requiredOwned:[\"listbox\",\"tree\",\"grid\",\"dialog\",\"textbox\"],requiredAttrs:[\"aria-expanded\"],allowedAttrs:[\"aria-controls\",\"aria-autocomplete\",\"aria-readonly\",\"aria-required\",\"aria-activedescendant\",\"aria-orientation\"],superclassRole:[\"select\"],accessibleNameRequired:!0},command:{type:\"abstract\",superclassRole:[\"widget\"]},complementary:{type:\"landmark\",allowedAttrs:[\"aria-expanded\"],superclassRole:[\"landmark\"]},composite:{type:\"abstract\",superclassRole:[\"widget\"]},contentinfo:{type:\"landmark\",allowedAttrs:[\"aria-expanded\"],superclassRole:[\"landmark\"]},definition:{type:\"structure\",allowedAttrs:[\"aria-expanded\"],superclassRole:[\"section\"]},deletion:{type:\"structure\",superclassRole:[\"section\"],prohibitedAttrs:[\"aria-label\",\"aria-labelledby\"]},dialog:{type:\"widget\",allowedAttrs:[\"aria-expanded\",\"aria-modal\"],superclassRole:[\"window\"],accessibleNameRequired:!0},directory:{type:\"structure\",allowedAttrs:[\"aria-expanded\"],superclassRole:[\"list\"],nameFromContent:!0},document:{type:\"structure\",allowedAttrs:[\"aria-expanded\"],superclassRole:[\"structure\"]},emphasis:{type:\"structure\",superclassRole:[\"section\"],prohibitedAttrs:[\"aria-label\",\"aria-labelledby\"]},feed:{type:\"structure\",requiredOwned:[\"article\"],allowedAttrs:[\"aria-expanded\"],superclassRole:[\"list\"]},figure:{type:\"structure\",allowedAttrs:[\"aria-expanded\"],superclassRole:[\"section\"],nameFromContent:!0},form:{type:\"landmark\",allowedAttrs:[\"aria-expanded\"],superclassRole:[\"landmark\"]},grid:{type:\"composite\",requiredOwned:[\"rowgroup\",\"row\"],allowedAttrs:[\"aria-level\",\"aria-multiselectable\",\"aria-readonly\",\"aria-activedescendant\",\"aria-colcount\",\"aria-expanded\",\"aria-rowcount\"],superclassRole:[\"composite\",\"table\"],accessibleNameRequired:!1},gridcell:{type:\"widget\",requiredContext:[\"row\"],allowedAttrs:[\"aria-readonly\",\"aria-required\",\"aria-selected\",\"aria-colindex\",\"aria-colspan\",\"aria-expanded\",\"aria-rowindex\",\"aria-rowspan\"],superclassRole:[\"cell\",\"widget\"],nameFromContent:!0},group:{type:\"structure\",allowedAttrs:[\"aria-activedescendant\",\"aria-expanded\"],superclassRole:[\"section\"]},heading:{type:\"structure\",requiredAttrs:[\"aria-level\"],allowedAttrs:[\"aria-expanded\"],superclassRole:[\"sectionhead\"],accessibleNameRequired:!1,nameFromContent:!0},img:{type:\"structure\",allowedAttrs:[\"aria-expanded\"],superclassRole:[\"section\"],accessibleNameRequired:!0,childrenPresentational:!0},input:{type:\"abstract\",superclassRole:[\"widget\"]},insertion:{type:\"structure\",superclassRole:[\"section\"],prohibitedAttrs:[\"aria-label\",\"aria-labelledby\"]},landmark:{type:\"abstract\",superclassRole:[\"section\"]},link:{type:\"widget\",allowedAttrs:[\"aria-expanded\"],superclassRole:[\"command\"],accessibleNameRequired:!0,nameFromContent:!0},list:{type:\"structure\",requiredOwned:[\"group\",\"listitem\"],allowedAttrs:[\"aria-expanded\"],superclassRole:[\"section\"]},listbox:{type:\"composite\",requiredOwned:[\"option\"],allowedAttrs:[\"aria-multiselectable\",\"aria-readonly\",\"aria-required\",\"aria-activedescendant\",\"aria-expanded\",\"aria-orientation\"],superclassRole:[\"select\"],accessibleNameRequired:!0},listitem:{type:\"structure\",requiredContext:[\"list\",\"group\"],allowedAttrs:[\"aria-level\",\"aria-posinset\",\"aria-setsize\",\"aria-expanded\"],superclassRole:[\"section\"],nameFromContent:!0},log:{type:\"widget\",allowedAttrs:[\"aria-expanded\"],superclassRole:[\"section\"]},main:{type:\"landmark\",allowedAttrs:[\"aria-expanded\"],superclassRole:[\"landmark\"]},marquee:{type:\"widget\",allowedAttrs:[\"aria-expanded\"],superclassRole:[\"section\"]},math:{type:\"structure\",allowedAttrs:[\"aria-expanded\"],superclassRole:[\"section\"],childrenPresentational:!0},menu:{type:\"composite\",requiredOwned:[\"group\",\"menuitemradio\",\"menuitem\",\"menuitemcheckbox\"],allowedAttrs:[\"aria-activedescendant\",\"aria-expanded\",\"aria-orientation\"],superclassRole:[\"select\"]},menubar:{type:\"composite\",requiredOwned:[\"group\",\"menuitemradio\",\"menuitem\",\"menuitemcheckbox\"],allowedAttrs:[\"aria-activedescendant\",\"aria-expanded\",\"aria-orientation\"],superclassRole:[\"menu\"]},menuitem:{type:\"widget\",requiredContext:[\"menu\",\"menubar\",\"group\"],allowedAttrs:[\"aria-posinset\",\"aria-setsize\",\"aria-expanded\"],superclassRole:[\"command\"],accessibleNameRequired:!0,nameFromContent:!0},menuitemcheckbox:{type:\"widget\",requiredContext:[\"menu\",\"menubar\",\"group\"],allowedAttrs:[\"aria-checked\",\"aria-posinset\",\"aria-readonly\",\"aria-setsize\"],superclassRole:[\"checkbox\",\"menuitem\"],accessibleNameRequired:!0,nameFromContent:!0,childrenPresentational:!0},menuitemradio:{type:\"widget\",requiredContext:[\"menu\",\"menubar\",\"group\"],allowedAttrs:[\"aria-checked\",\"aria-posinset\",\"aria-readonly\",\"aria-setsize\"],superclassRole:[\"menuitemcheckbox\",\"radio\"],accessibleNameRequired:!0,nameFromContent:!0,childrenPresentational:!0},meter:{type:\"structure\",allowedAttrs:[\"aria-valuetext\"],requiredAttrs:[\"aria-valuemax\",\"aria-valuemin\",\"aria-valuenow\"],superclassRole:[\"range\"],accessibleNameRequired:!0,childrenPresentational:!0},navigation:{type:\"landmark\",allowedAttrs:[\"aria-expanded\"],superclassRole:[\"landmark\"]},none:{type:\"structure\",superclassRole:[\"structure\"],prohibitedAttrs:[\"aria-label\",\"aria-labelledby\"]},note:{type:\"structure\",allowedAttrs:[\"aria-expanded\"],superclassRole:[\"section\"]},option:{type:\"widget\",requiredContext:[\"listbox\"],allowedAttrs:[\"aria-selected\",\"aria-checked\",\"aria-posinset\",\"aria-setsize\"],superclassRole:[\"input\"],accessibleNameRequired:!0,nameFromContent:!0,childrenPresentational:!0},paragraph:{type:\"structure\",superclassRole:[\"section\"],prohibitedAttrs:[\"aria-label\",\"aria-labelledby\"]},presentation:{type:\"structure\",superclassRole:[\"structure\"],prohibitedAttrs:[\"aria-label\",\"aria-labelledby\"]},progressbar:{type:\"widget\",allowedAttrs:[\"aria-expanded\",\"aria-valuemax\",\"aria-valuemin\",\"aria-valuenow\",\"aria-valuetext\"],superclassRole:[\"range\"],accessibleNameRequired:!0,childrenPresentational:!0},radio:{type:\"widget\",allowedAttrs:[\"aria-checked\",\"aria-posinset\",\"aria-setsize\",\"aria-required\"],superclassRole:[\"input\"],accessibleNameRequired:!0,nameFromContent:!0,childrenPresentational:!0},radiogroup:{type:\"composite\",requiredOwned:[\"radio\"],allowedAttrs:[\"aria-readonly\",\"aria-required\",\"aria-activedescendant\",\"aria-expanded\",\"aria-orientation\"],superclassRole:[\"select\"],accessibleNameRequired:!1},range:{type:\"abstract\",superclassRole:[\"widget\"]},region:{type:\"landmark\",allowedAttrs:[\"aria-expanded\"],superclassRole:[\"landmark\"],accessibleNameRequired:!1},roletype:{type:\"abstract\",superclassRole:[]},row:{type:\"structure\",requiredContext:[\"grid\",\"rowgroup\",\"table\",\"treegrid\"],requiredOwned:[\"cell\",\"columnheader\",\"gridcell\",\"rowheader\"],allowedAttrs:[\"aria-colindex\",\"aria-level\",\"aria-rowindex\",\"aria-selected\",\"aria-activedescendant\",\"aria-expanded\",\"aria-posinset\",\"aria-setsize\"],superclassRole:[\"group\",\"widget\"],nameFromContent:!0},rowgroup:{type:\"structure\",requiredContext:[\"grid\",\"table\",\"treegrid\"],requiredOwned:[\"row\"],superclassRole:[\"structure\"],nameFromContent:!0},rowheader:{type:\"structure\",requiredContext:[\"row\"],allowedAttrs:[\"aria-sort\",\"aria-colindex\",\"aria-colspan\",\"aria-expanded\",\"aria-readonly\",\"aria-required\",\"aria-rowindex\",\"aria-rowspan\",\"aria-selected\"],superclassRole:[\"cell\",\"gridcell\",\"sectionhead\"],accessibleNameRequired:!1,nameFromContent:!0},scrollbar:{type:\"widget\",requiredAttrs:[\"aria-valuenow\"],allowedAttrs:[\"aria-controls\",\"aria-orientation\",\"aria-valuemax\",\"aria-valuemin\",\"aria-valuetext\"],superclassRole:[\"range\"],childrenPresentational:!0},search:{type:\"landmark\",allowedAttrs:[\"aria-expanded\"],superclassRole:[\"landmark\"]},searchbox:{type:\"widget\",allowedAttrs:[\"aria-activedescendant\",\"aria-autocomplete\",\"aria-multiline\",\"aria-placeholder\",\"aria-readonly\",\"aria-required\"],superclassRole:[\"textbox\"],accessibleNameRequired:!0},section:{type:\"abstract\",superclassRole:[\"structure\"],nameFromContent:!0},sectionhead:{type:\"abstract\",superclassRole:[\"structure\"],nameFromContent:!0},select:{type:\"abstract\",superclassRole:[\"composite\",\"group\"]},separator:{type:\"structure\",allowedAttrs:[\"aria-valuemax\",\"aria-valuemin\",\"aria-valuenow\",\"aria-orientation\",\"aria-valuetext\"],superclassRole:[\"structure\",\"widget\"],childrenPresentational:!0},slider:{type:\"widget\",requiredAttrs:[\"aria-valuenow\"],allowedAttrs:[\"aria-valuemax\",\"aria-valuemin\",\"aria-orientation\",\"aria-readonly\",\"aria-valuetext\"],superclassRole:[\"input\",\"range\"],accessibleNameRequired:!0,childrenPresentational:!0},spinbutton:{type:\"widget\",requiredAttrs:[\"aria-valuenow\"],allowedAttrs:[\"aria-valuemax\",\"aria-valuemin\",\"aria-readonly\",\"aria-required\",\"aria-activedescendant\",\"aria-valuetext\"],superclassRole:[\"composite\",\"input\",\"range\"],accessibleNameRequired:!0},status:{type:\"widget\",allowedAttrs:[\"aria-expanded\"],superclassRole:[\"section\"]},strong:{type:\"structure\",superclassRole:[\"section\"],prohibitedAttrs:[\"aria-label\",\"aria-labelledby\"]},structure:{type:\"abstract\",superclassRole:[\"roletype\"]},subscript:{type:\"structure\",superclassRole:[\"section\"],prohibitedAttrs:[\"aria-label\",\"aria-labelledby\"]},superscript:{type:\"structure\",superclassRole:[\"section\"],prohibitedAttrs:[\"aria-label\",\"aria-labelledby\"]},switch:{type:\"widget\",requiredAttrs:[\"aria-checked\"],allowedAttrs:[\"aria-readonly\"],superclassRole:[\"checkbox\"],accessibleNameRequired:!0,nameFromContent:!0,childrenPresentational:!0},tab:{type:\"widget\",requiredContext:[\"tablist\"],allowedAttrs:[\"aria-posinset\",\"aria-selected\",\"aria-setsize\",\"aria-expanded\"],superclassRole:[\"sectionhead\",\"widget\"],nameFromContent:!0,childrenPresentational:!0},table:{type:\"structure\",requiredOwned:[\"rowgroup\",\"row\"],allowedAttrs:[\"aria-colcount\",\"aria-rowcount\",\"aria-expanded\"],superclassRole:[\"section\"],accessibleNameRequired:!1,nameFromContent:!0},tablist:{type:\"composite\",requiredOwned:[\"tab\"],allowedAttrs:[\"aria-level\",\"aria-multiselectable\",\"aria-orientation\",\"aria-activedescendant\",\"aria-expanded\"],superclassRole:[\"composite\"]},tabpanel:{type:\"widget\",allowedAttrs:[\"aria-expanded\"],superclassRole:[\"section\"],accessibleNameRequired:!1},term:{type:\"structure\",allowedAttrs:[\"aria-expanded\"],superclassRole:[\"section\"],nameFromContent:!0},text:{type:\"structure\",superclassRole:[\"section\"],nameFromContent:!0},textbox:{type:\"widget\",allowedAttrs:[\"aria-activedescendant\",\"aria-autocomplete\",\"aria-multiline\",\"aria-placeholder\",\"aria-readonly\",\"aria-required\"],superclassRole:[\"input\"],accessibleNameRequired:!0},time:{type:\"structure\",superclassRole:[\"section\"]},timer:{type:\"widget\",allowedAttrs:[\"aria-expanded\"],superclassRole:[\"status\"]},toolbar:{type:\"structure\",allowedAttrs:[\"aria-orientation\",\"aria-activedescendant\",\"aria-expanded\"],superclassRole:[\"group\"],accessibleNameRequired:!0},tooltip:{type:\"structure\",allowedAttrs:[\"aria-expanded\"],superclassRole:[\"section\"],nameFromContent:!0},tree:{type:\"composite\",requiredOwned:[\"group\",\"treeitem\"],allowedAttrs:[\"aria-multiselectable\",\"aria-required\",\"aria-activedescendant\",\"aria-expanded\",\"aria-orientation\"],superclassRole:[\"select\"],accessibleNameRequired:!1},treegrid:{type:\"composite\",requiredOwned:[\"rowgroup\",\"row\"],allowedAttrs:[\"aria-activedescendant\",\"aria-colcount\",\"aria-expanded\",\"aria-level\",\"aria-multiselectable\",\"aria-orientation\",\"aria-readonly\",\"aria-required\",\"aria-rowcount\"],superclassRole:[\"grid\",\"tree\"],accessibleNameRequired:!1},treeitem:{type:\"widget\",requiredContext:[\"group\",\"tree\"],allowedAttrs:[\"aria-checked\",\"aria-expanded\",\"aria-level\",\"aria-posinset\",\"aria-selected\",\"aria-setsize\"],superclassRole:[\"listitem\",\"option\"],accessibleNameRequired:!0,nameFromContent:!0},widget:{type:\"abstract\",superclassRole:[\"roletype\"]},window:{type:\"abstract\",superclassRole:[\"roletype\"]}},en={a:{variant:{href:{matches:\"[href]\",contentTypes:[\"interactive\",\"phrasing\",\"flow\"],allowedRoles:[\"button\",\"checkbox\",\"menuitem\",\"menuitemcheckbox\",\"menuitemradio\",\"option\",\"radio\",\"switch\",\"tab\",\"treeitem\",\"doc-backlink\",\"doc-biblioref\",\"doc-glossref\",\"doc-noteref\"],namingMethods:[\"subtreeText\"]},default:{contentTypes:[\"phrasing\",\"flow\"],allowedRoles:!0}}},abbr:{contentTypes:[\"phrasing\",\"flow\"],allowedRoles:!0},addres:{contentTypes:[\"flow\"],allowedRoles:!0},area:{contentTypes:[\"phrasing\",\"flow\"],allowedRoles:!1,namingMethods:[\"altText\"]},article:{contentTypes:[\"sectioning\",\"flow\"],allowedRoles:[\"feed\",\"presentation\",\"none\",\"document\",\"application\",\"main\",\"region\"],shadowRoot:!0},aside:{contentTypes:[\"sectioning\",\"flow\"],allowedRoles:[\"feed\",\"note\",\"presentation\",\"none\",\"region\",\"search\",\"doc-dedication\",\"doc-example\",\"doc-footnote\",\"doc-pullquote\",\"doc-tip\"]},audio:{variant:{controls:{matches:\"[controls]\",contentTypes:[\"interactive\",\"embedded\",\"phrasing\",\"flow\"]},default:{contentTypes:[\"embedded\",\"phrasing\",\"flow\"]}},allowedRoles:[\"application\"],chromiumRole:\"Audio\"},b:{contentTypes:[\"phrasing\",\"flow\"],allowedRoles:!1},base:{allowedRoles:!1,noAriaAttrs:!0},bdi:{contentTypes:[\"phrasing\",\"flow\"],allowedRoles:!0},bdo:{contentTypes:[\"phrasing\",\"flow\"],allowedRoles:!0},blockquote:{contentTypes:[\"flow\"],allowedRoles:!0,shadowRoot:!0},body:{allowedRoles:!1,shadowRoot:!0},br:{contentTypes:[\"phrasing\",\"flow\"],allowedRoles:[\"presentation\",\"none\"],namingMethods:[\"titleText\",\"singleSpace\"]},button:{contentTypes:[\"interactive\",\"phrasing\",\"flow\"],allowedRoles:[\"checkbox\",\"link\",\"menuitem\",\"menuitemcheckbox\",\"menuitemradio\",\"option\",\"radio\",\"switch\",\"tab\"],namingMethods:[\"subtreeText\"]},canvas:{allowedRoles:!0,contentTypes:[\"embedded\",\"phrasing\",\"flow\"],chromiumRole:\"Canvas\"},caption:{allowedRoles:!1},cite:{contentTypes:[\"phrasing\",\"flow\"],allowedRoles:!0},code:{contentTypes:[\"phrasing\",\"flow\"],allowedRoles:!0},col:{allowedRoles:!1,noAriaAttrs:!0},colgroup:{allowedRoles:!1,noAriaAttrs:!0},data:{contentTypes:[\"phrasing\",\"flow\"],allowedRoles:!0},datalist:{contentTypes:[\"phrasing\",\"flow\"],allowedRoles:!1,implicitAttrs:{\"aria-multiselectable\":\"false\"}},dd:{allowedRoles:!1},del:{contentTypes:[\"phrasing\",\"flow\"],allowedRoles:!0},dfn:{contentTypes:[\"phrasing\",\"flow\"],allowedRoles:!0},details:{contentTypes:[\"interactive\",\"flow\"],allowedRoles:!1},dialog:{contentTypes:[\"flow\"],allowedRoles:[\"alertdialog\"]},div:{contentTypes:[\"flow\"],allowedRoles:!0,shadowRoot:!0},dl:{contentTypes:[\"flow\"],allowedRoles:[\"group\",\"list\",\"presentation\",\"none\"],chromiumRole:\"DescriptionList\"},dt:{allowedRoles:[\"listitem\"]},em:{contentTypes:[\"phrasing\",\"flow\"],allowedRoles:!0},embed:{contentTypes:[\"interactive\",\"embedded\",\"phrasing\",\"flow\"],allowedRoles:[\"application\",\"document\",\"img\",\"presentation\",\"none\"],chromiumRole:\"EmbeddedObject\"},fieldset:{contentTypes:[\"flow\"],allowedRoles:[\"none\",\"presentation\",\"radiogroup\"],namingMethods:[\"fieldsetLegendText\"]},figcaption:{allowedRoles:[\"group\",\"none\",\"presentation\"]},figure:{contentTypes:[\"flow\"],allowedRoles:!0,namingMethods:[\"figureText\",\"titleText\"]},footer:{contentTypes:[\"flow\"],allowedRoles:[\"group\",\"none\",\"presentation\",\"doc-footnote\"],shadowRoot:!0},form:{contentTypes:[\"flow\"],allowedRoles:[\"search\",\"none\",\"presentation\"]},h1:{contentTypes:[\"heading\",\"flow\"],allowedRoles:[\"none\",\"presentation\",\"tab\",\"doc-subtitle\"],shadowRoot:!0,implicitAttrs:{\"aria-level\":\"1\"}},h2:{contentTypes:[\"heading\",\"flow\"],allowedRoles:[\"none\",\"presentation\",\"tab\",\"doc-subtitle\"],shadowRoot:!0,implicitAttrs:{\"aria-level\":\"2\"}},h3:{contentTypes:[\"heading\",\"flow\"],allowedRoles:[\"none\",\"presentation\",\"tab\",\"doc-subtitle\"],shadowRoot:!0,implicitAttrs:{\"aria-level\":\"3\"}},h4:{contentTypes:[\"heading\",\"flow\"],allowedRoles:[\"none\",\"presentation\",\"tab\",\"doc-subtitle\"],shadowRoot:!0,implicitAttrs:{\"aria-level\":\"4\"}},h5:{contentTypes:[\"heading\",\"flow\"],allowedRoles:[\"none\",\"presentation\",\"tab\",\"doc-subtitle\"],shadowRoot:!0,implicitAttrs:{\"aria-level\":\"5\"}},h6:{contentTypes:[\"heading\",\"flow\"],allowedRoles:[\"none\",\"presentation\",\"tab\",\"doc-subtitle\"],shadowRoot:!0,implicitAttrs:{\"aria-level\":\"6\"}},head:{allowedRoles:!1,noAriaAttrs:!0},header:{contentTypes:[\"flow\"],allowedRoles:[\"group\",\"none\",\"presentation\",\"doc-footnote\"],shadowRoot:!0},hgroup:{contentTypes:[\"heading\",\"flow\"],allowedRoles:!0},hr:{contentTypes:[\"flow\"],allowedRoles:[\"none\",\"presentation\",\"doc-pagebreak\"],namingMethods:[\"titleText\",\"singleSpace\"]},html:{allowedRoles:!1,noAriaAttrs:!0},i:{contentTypes:[\"phrasing\",\"flow\"],allowedRoles:!0},iframe:{contentTypes:[\"interactive\",\"embedded\",\"phrasing\",\"flow\"],allowedRoles:[\"application\",\"document\",\"img\",\"none\",\"presentation\"],chromiumRole:\"Iframe\"},img:{variant:{nonEmptyAlt:{matches:{attributes:{alt:\"/.+/\"}},allowedRoles:[\"button\",\"checkbox\",\"link\",\"menuitem\",\"menuitemcheckbox\",\"menuitemradio\",\"option\",\"progressbar\",\"scrollbar\",\"separator\",\"slider\",\"switch\",\"tab\",\"treeitem\",\"doc-cover\"]},usemap:{matches:\"[usemap]\",contentTypes:[\"interactive\",\"embedded\",\"phrasing\",\"flow\"]},default:{allowedRoles:[\"presentation\",\"none\"],contentTypes:[\"embedded\",\"phrasing\",\"flow\"]}},namingMethods:[\"altText\"]},input:{variant:{button:{matches:{properties:{type:\"button\"}},allowedRoles:[\"link\",\"menuitem\",\"menuitemcheckbox\",\"menuitemradio\",\"option\",\"radio\",\"switch\",\"tab\"]},buttonType:{matches:{properties:{type:[\"button\",\"submit\",\"reset\"]}},namingMethods:[\"valueText\",\"titleText\",\"buttonDefaultText\"]},checkboxPressed:{matches:{properties:{type:\"checkbox\"},attributes:{\"aria-pressed\":\"/.*/\"}},allowedRoles:[\"button\",\"menuitemcheckbox\",\"option\",\"switch\"],implicitAttrs:{\"aria-checked\":\"false\"}},checkbox:{matches:{properties:{type:\"checkbox\"},attributes:{\"aria-pressed\":null}},allowedRoles:[\"menuitemcheckbox\",\"option\",\"switch\"],implicitAttrs:{\"aria-checked\":\"false\"}},noRoles:{matches:{properties:{type:[\"color\",\"date\",\"datetime-local\",\"file\",\"month\",\"number\",\"password\",\"range\",\"reset\",\"submit\",\"time\",\"week\"]}},allowedRoles:!1},hidden:{matches:{properties:{type:\"hidden\"}},contentTypes:[\"flow\"],allowedRoles:!1,noAriaAttrs:!0},image:{matches:{properties:{type:\"image\"}},allowedRoles:[\"link\",\"menuitem\",\"menuitemcheckbox\",\"menuitemradio\",\"radio\",\"switch\"],namingMethods:[\"altText\",\"valueText\",\"labelText\",\"titleText\",\"buttonDefaultText\"]},radio:{matches:{properties:{type:\"radio\"}},allowedRoles:[\"menuitemradio\"],implicitAttrs:{\"aria-checked\":\"false\"}},textWithList:{matches:{properties:{type:\"text\"},attributes:{list:\"/.*/\"}},allowedRoles:!1},default:{contentTypes:[\"interactive\",\"flow\"],allowedRoles:[\"combobox\",\"searchbox\",\"spinbutton\"],implicitAttrs:{\"aria-valuenow\":\"\"},namingMethods:[\"labelText\",\"placeholderText\"]}}},ins:{contentTypes:[\"phrasing\",\"flow\"],allowedRoles:!0},kbd:{contentTypes:[\"phrasing\",\"flow\"],allowedRoles:!0},label:{contentTypes:[\"interactive\",\"phrasing\",\"flow\"],allowedRoles:!1,chromiumRole:\"Label\"},legend:{allowedRoles:!1},li:{allowedRoles:[\"menuitem\",\"menuitemcheckbox\",\"menuitemradio\",\"option\",\"none\",\"presentation\",\"radio\",\"separator\",\"tab\",\"treeitem\",\"doc-biblioentry\",\"doc-endnote\"],implicitAttrs:{\"aria-setsize\":\"1\",\"aria-posinset\":\"1\"}},link:{contentTypes:[\"phrasing\",\"flow\"],allowedRoles:!1,noAriaAttrs:!0},main:{contentTypes:[\"flow\"],allowedRoles:!1,shadowRoot:!0},map:{contentTypes:[\"phrasing\",\"flow\"],allowedRoles:!1,noAriaAttrs:!0},math:{contentTypes:[\"embedded\",\"phrasing\",\"flow\"],allowedRoles:!1},mark:{contentTypes:[\"phrasing\",\"flow\"],allowedRoles:!0},menu:{contentTypes:[\"flow\"],allowedRoles:[\"directory\",\"group\",\"listbox\",\"menu\",\"menubar\",\"none\",\"presentation\",\"radiogroup\",\"tablist\",\"toolbar\",\"tree\"]},meta:{variant:{itemprop:{matches:\"[itemprop]\",contentTypes:[\"phrasing\",\"flow\"]}},allowedRoles:!1,noAriaAttrs:!0},meter:{contentTypes:[\"phrasing\",\"flow\"],allowedRoles:!1,chromiumRole:\"progressbar\"},nav:{contentTypes:[\"sectioning\",\"flow\"],allowedRoles:[\"doc-index\",\"doc-pagelist\",\"doc-toc\"],shadowRoot:!0},noscript:{contentTypes:[\"phrasing\",\"flow\"],allowedRoles:!1,noAriaAttrs:!0},object:{variant:{usemap:{matches:\"[usemap]\",contentTypes:[\"interactive\",\"embedded\",\"phrasing\",\"flow\"]},default:{contentTypes:[\"embedded\",\"phrasing\",\"flow\"]}},allowedRoles:[\"application\",\"document\",\"img\"],chromiumRole:\"PluginObject\"},ol:{contentTypes:[\"flow\"],allowedRoles:[\"directory\",\"group\",\"listbox\",\"menu\",\"menubar\",\"none\",\"presentation\",\"radiogroup\",\"tablist\",\"toolbar\",\"tree\"]},optgroup:{allowedRoles:!1},option:{allowedRoles:!1,implicitAttrs:{\"aria-selected\":\"false\"}},output:{contentTypes:[\"phrasing\",\"flow\"],allowedRoles:!0,namingMethods:[\"subtreeText\"]},p:{contentTypes:[\"flow\"],allowedRoles:!0,shadowRoot:!0},param:{allowedRoles:!1,noAriaAttrs:!0},picture:{contentTypes:[\"phrasing\",\"flow\"],allowedRoles:!1,noAriaAttrs:!0},pre:{contentTypes:[\"flow\"],allowedRoles:!0},progress:{contentTypes:[\"phrasing\",\"flow\"],allowedRoles:!0,implicitAttrs:{\"aria-valuemax\":\"100\",\"aria-valuemin\":\"0\",\"aria-valuenow\":\"0\"}},q:{contentTypes:[\"phrasing\",\"flow\"],allowedRoles:!0},rp:{allowedRoles:!0},rt:{allowedRoles:!0},ruby:{contentTypes:[\"phrasing\",\"flow\"],allowedRoles:!0},s:{contentTypes:[\"phrasing\",\"flow\"],allowedRoles:!0},samp:{contentTypes:[\"phrasing\",\"flow\"],allowedRoles:!0},script:{contentTypes:[\"phrasing\",\"flow\"],allowedRoles:!1,noAriaAttrs:!0},section:{contentTypes:[\"sectioning\",\"flow\"],allowedRoles:[\"alert\",\"alertdialog\",\"application\",\"banner\",\"complementary\",\"contentinfo\",\"dialog\",\"document\",\"feed\",\"log\",\"main\",\"marquee\",\"navigation\",\"none\",\"note\",\"presentation\",\"search\",\"status\",\"tabpanel\",\"doc-abstract\",\"doc-acknowledgments\",\"doc-afterword\",\"doc-appendix\",\"doc-bibliography\",\"doc-chapter\",\"doc-colophon\",\"doc-conclusion\",\"doc-credit\",\"doc-credits\",\"doc-dedication\",\"doc-endnotes\",\"doc-epigraph\",\"doc-epilogue\",\"doc-errata\",\"doc-example\",\"doc-foreword\",\"doc-glossary\",\"doc-index\",\"doc-introduction\",\"doc-notice\",\"doc-pagelist\",\"doc-part\",\"doc-preface\",\"doc-prologue\",\"doc-pullquote\",\"doc-qna\",\"doc-toc\"],shadowRoot:!0},select:{variant:{combobox:{matches:{attributes:{multiple:null,size:[null,\"1\"]}},allowedRoles:[\"menu\"]},default:{allowedRoles:!1}},contentTypes:[\"interactive\",\"phrasing\",\"flow\"],implicitAttrs:{\"aria-valuenow\":\"\"},namingMethods:[\"labelText\"]},slot:{contentTypes:[\"phrasing\",\"flow\"],allowedRoles:!1,noAriaAttrs:!0},small:{contentTypes:[\"phrasing\",\"flow\"],allowedRoles:!0},source:{allowedRoles:!1,noAriaAttrs:!0},span:{contentTypes:[\"phrasing\",\"flow\"],allowedRoles:!0,shadowRoot:!0},strong:{contentTypes:[\"phrasing\",\"flow\"],allowedRoles:!0},style:{allowedRoles:!1,noAriaAttrs:!0},svg:{contentTypes:[\"embedded\",\"phrasing\",\"flow\"],allowedRoles:[\"application\",\"document\",\"img\"],chromiumRole:\"SVGRoot\",namingMethods:[\"svgTitleText\"]},sub:{contentTypes:[\"phrasing\",\"flow\"],allowedRoles:!0},summary:{allowedRoles:!1,namingMethods:[\"subtreeText\"]},sup:{contentTypes:[\"phrasing\",\"flow\"],allowedRoles:!0},table:{contentTypes:[\"flow\"],allowedRoles:!0,namingMethods:[\"tableCaptionText\",\"tableSummaryText\"]},tbody:{allowedRoles:!0},template:{contentTypes:[\"phrasing\",\"flow\"],allowedRoles:!1,noAriaAttrs:!0},textarea:{contentTypes:[\"interactive\",\"phrasing\",\"flow\"],allowedRoles:!1,implicitAttrs:{\"aria-valuenow\":\"\",\"aria-multiline\":\"true\"},namingMethods:[\"labelText\",\"placeholderText\"]},tfoot:{allowedRoles:!0},thead:{allowedRoles:!0},time:{contentTypes:[\"phrasing\",\"flow\"],allowedRoles:!0},title:{allowedRoles:!1,noAriaAttrs:!0},td:{allowedRoles:!0},th:{allowedRoles:!0},tr:{allowedRoles:!0},track:{allowedRoles:!1,noAriaAttrs:!0},u:{contentTypes:[\"phrasing\",\"flow\"],allowedRoles:!0},ul:{contentTypes:[\"flow\"],allowedRoles:[\"directory\",\"group\",\"listbox\",\"menu\",\"menubar\",\"none\",\"presentation\",\"radiogroup\",\"tablist\",\"toolbar\",\"tree\"]},var:{contentTypes:[\"phrasing\",\"flow\"],allowedRoles:!0},video:{variant:{controls:{matches:\"[controls]\",contentTypes:[\"interactive\",\"embedded\",\"phrasing\",\"flow\"]},default:{contentTypes:[\"embedded\",\"phrasing\",\"flow\"]}},allowedRoles:[\"application\"],chromiumRole:\"video\"},wbr:{contentTypes:[\"phrasing\",\"flow\"],allowedRoles:!0}},tn={aliceblue:[240,248,255],antiquewhite:[250,235,215],aqua:[0,255,255],aquamarine:[127,255,212],azure:[240,255,255],beige:[245,245,220],bisque:[255,228,196],black:[0,0,0],blanchedalmond:[255,235,205],blue:[0,0,255],blueviolet:[138,43,226],brown:[165,42,42],burlywood:[222,184,135],cadetblue:[95,158,160],chartreuse:[127,255,0],chocolate:[210,105,30],coral:[255,127,80],cornflowerblue:[100,149,237],cornsilk:[255,248,220],crimson:[220,20,60],cyan:[0,255,255],darkblue:[0,0,139],darkcyan:[0,139,139],darkgoldenrod:[184,134,11],darkgray:[169,169,169],darkgreen:[0,100,0],darkgrey:[169,169,169],darkkhaki:[189,183,107],darkmagenta:[139,0,139],darkolivegreen:[85,107,47],darkorange:[255,140,0],darkorchid:[153,50,204],darkred:[139,0,0],darksalmon:[233,150,122],darkseagreen:[143,188,143],darkslateblue:[72,61,139],darkslategray:[47,79,79],darkslategrey:[47,79,79],darkturquoise:[0,206,209],darkviolet:[148,0,211],deeppink:[255,20,147],deepskyblue:[0,191,255],dimgray:[105,105,105],dimgrey:[105,105,105],dodgerblue:[30,144,255],firebrick:[178,34,34],floralwhite:[255,250,240],forestgreen:[34,139,34],fuchsia:[255,0,255],gainsboro:[220,220,220],ghostwhite:[248,248,255],gold:[255,215,0],goldenrod:[218,165,32],gray:[128,128,128],green:[0,128,0],greenyellow:[173,255,47],grey:[128,128,128],honeydew:[240,255,240],hotpink:[255,105,180],indianred:[205,92,92],indigo:[75,0,130],ivory:[255,255,240],khaki:[240,230,140],lavender:[230,230,250],lavenderblush:[255,240,245],lawngreen:[124,252,0],lemonchiffon:[255,250,205],lightblue:[173,216,230],lightcoral:[240,128,128],lightcyan:[224,255,255],lightgoldenrodyellow:[250,250,210],lightgray:[211,211,211],lightgreen:[144,238,144],lightgrey:[211,211,211],lightpink:[255,182,193],lightsalmon:[255,160,122],lightseagreen:[32,178,170],lightskyblue:[135,206,250],lightslategray:[119,136,153],lightslategrey:[119,136,153],lightsteelblue:[176,196,222],lightyellow:[255,255,224],lime:[0,255,0],limegreen:[50,205,50],linen:[250,240,230],magenta:[255,0,255],maroon:[128,0,0],mediumaquamarine:[102,205,170],mediumblue:[0,0,205],mediumorchid:[186,85,211],mediumpurple:[147,112,219],mediumseagreen:[60,179,113],mediumslateblue:[123,104,238],mediumspringgreen:[0,250,154],mediumturquoise:[72,209,204],mediumvioletred:[199,21,133],midnightblue:[25,25,112],mintcream:[245,255,250],mistyrose:[255,228,225],moccasin:[255,228,181],navajowhite:[255,222,173],navy:[0,0,128],oldlace:[253,245,230],olive:[128,128,0],olivedrab:[107,142,35],orange:[255,165,0],orangered:[255,69,0],orchid:[218,112,214],palegoldenrod:[238,232,170],palegreen:[152,251,152],paleturquoise:[175,238,238],palevioletred:[219,112,147],papayawhip:[255,239,213],peachpuff:[255,218,185],peru:[205,133,63],pink:[255,192,203],plum:[221,160,221],powderblue:[176,224,230],purple:[128,0,128],rebeccapurple:[102,51,153],red:[255,0,0],rosybrown:[188,143,143],royalblue:[65,105,225],saddlebrown:[139,69,19],salmon:[250,128,114],sandybrown:[244,164,96],seagreen:[46,139,87],seashell:[255,245,238],sienna:[160,82,45],silver:[192,192,192],skyblue:[135,206,235],slateblue:[106,90,205],slategray:[112,128,144],slategrey:[112,128,144],snow:[255,250,250],springgreen:[0,255,127],steelblue:[70,130,180],tan:[210,180,140],teal:[0,128,128],thistle:[216,191,216],tomato:[255,99,71],turquoise:[64,224,208],violet:[238,130,238],wheat:[245,222,179],white:[255,255,255],whitesmoke:[245,245,245],yellow:[255,255,0],yellowgreen:[154,205,50]},rn={ariaAttrs:{\"aria-activedescendant\":{type:\"idref\",allowEmpty:!0},\"aria-atomic\":{type:\"boolean\",global:!0},\"aria-autocomplete\":{type:\"nmtoken\",values:[\"inline\",\"list\",\"both\",\"none\"]},\"aria-busy\":{type:\"boolean\",global:!0},\"aria-checked\":{type:\"nmtoken\",values:[\"false\",\"mixed\",\"true\",\"undefined\"]},\"aria-colcount\":{type:\"int\",minValue:-1},\"aria-colindex\":{type:\"int\",minValue:1},\"aria-colspan\":{type:\"int\",minValue:1},\"aria-controls\":{type:\"idrefs\",allowEmpty:!0,global:!0},\"aria-current\":{type:\"nmtoken\",allowEmpty:!0,values:[\"page\",\"step\",\"location\",\"date\",\"time\",\"true\",\"false\"],global:!0},\"aria-describedby\":{type:\"idrefs\",allowEmpty:!0,global:!0},\"aria-details\":{type:\"idref\",allowEmpty:!0,global:!0},\"aria-disabled\":{type:\"boolean\",global:!0},\"aria-dropeffect\":{type:\"nmtokens\",values:[\"copy\",\"execute\",\"link\",\"move\",\"none\",\"popup\"],global:!0},\"aria-errormessage\":{type:\"idref\",allowEmpty:!0,global:!0},\"aria-expanded\":{type:\"nmtoken\",values:[\"true\",\"false\",\"undefined\"]},\"aria-flowto\":{type:\"idrefs\",allowEmpty:!0,global:!0},\"aria-grabbed\":{type:\"nmtoken\",values:[\"true\",\"false\",\"undefined\"],global:!0},\"aria-haspopup\":{type:\"nmtoken\",allowEmpty:!0,values:[\"true\",\"false\",\"menu\",\"listbox\",\"tree\",\"grid\",\"dialog\"],global:!0},\"aria-hidden\":{type:\"nmtoken\",values:[\"true\",\"false\",\"undefined\"],global:!0},\"aria-invalid\":{type:\"nmtoken\",allowEmpty:!0,values:[\"grammar\",\"false\",\"spelling\",\"true\"],global:!0},\"aria-keyshortcuts\":{type:\"string\",allowEmpty:!0,global:!0},\"aria-label\":{type:\"string\",allowEmpty:!0,global:!0},\"aria-labelledby\":{type:\"idrefs\",allowEmpty:!0,global:!0},\"aria-level\":{type:\"int\",minValue:1},\"aria-live\":{type:\"nmtoken\",values:[\"assertive\",\"off\",\"polite\"],global:!0},\"aria-modal\":{type:\"boolean\"},\"aria-multiline\":{type:\"boolean\"},\"aria-multiselectable\":{type:\"boolean\"},\"aria-orientation\":{type:\"nmtoken\",values:[\"horizontal\",\"undefined\",\"vertical\"]},\"aria-owns\":{type:\"idrefs\",allowEmpty:!0,global:!0},\"aria-placeholder\":{type:\"string\",allowEmpty:!0},\"aria-posinset\":{type:\"int\",minValue:1},\"aria-pressed\":{type:\"nmtoken\",values:[\"false\",\"mixed\",\"true\",\"undefined\"]},\"aria-readonly\":{type:\"boolean\"},\"aria-relevant\":{type:\"nmtokens\",values:[\"additions\",\"all\",\"removals\",\"text\"],global:!0},\"aria-required\":{type:\"boolean\"},\"aria-roledescription\":{type:\"string\",allowEmpty:!0,global:!0},\"aria-rowcount\":{type:\"int\",minValue:-1},\"aria-rowindex\":{type:\"int\",minValue:1},\"aria-rowspan\":{type:\"int\",minValue:0},\"aria-selected\":{type:\"nmtoken\",values:[\"false\",\"true\",\"undefined\"]},\"aria-setsize\":{type:\"int\",minValue:-1},\"aria-sort\":{type:\"nmtoken\",values:[\"ascending\",\"descending\",\"none\",\"other\"]},\"aria-valuemax\":{type:\"decimal\"},\"aria-valuemin\":{type:\"decimal\"},\"aria-valuenow\":{type:\"decimal\"},\"aria-valuetext\":{type:\"string\"}},ariaRoles:Xu({},Za,{\"doc-abstract\":{type:\"section\",allowedAttrs:[\"aria-expanded\"],superclassRole:[\"section\"]},\"doc-acknowledgments\":{type:\"landmark\",allowedAttrs:[\"aria-expanded\"],superclassRole:[\"landmark\"]},\"doc-afterword\":{type:\"landmark\",allowedAttrs:[\"aria-expanded\"],superclassRole:[\"landmark\"]},\"doc-appendix\":{type:\"landmark\",allowedAttrs:[\"aria-expanded\"],superclassRole:[\"landmark\"]},\"doc-backlink\":{type:\"link\",allowedAttrs:[\"aria-expanded\"],nameFromContent:!0,superclassRole:[\"link\"]},\"doc-biblioentry\":{type:\"listitem\",requiredContext:[\"doc-bibliography\"],allowedAttrs:[\"aria-expanded\",\"aria-level\",\"aria-posinset\",\"aria-setsize\"],superclassRole:[\"listitem\"]},\"doc-bibliography\":{type:\"landmark\",requiredOwned:[\"doc-biblioentry\"],allowedAttrs:[\"aria-expanded\"],superclassRole:[\"landmark\"]},\"doc-biblioref\":{type:\"link\",allowedAttrs:[\"aria-expanded\"],nameFromContent:!0,superclassRole:[\"link\"]},\"doc-chapter\":{type:\"landmark\",allowedAttrs:[\"aria-expanded\"],superclassRole:[\"landmark\"]},\"doc-colophon\":{type:\"section\",allowedAttrs:[\"aria-expanded\"],superclassRole:[\"section\"]},\"doc-conclusion\":{type:\"landmark\",allowedAttrs:[\"aria-expanded\"],superclassRole:[\"landmark\"]},\"doc-cover\":{type:\"img\",allowedAttrs:[\"aria-expanded\"],superclassRole:[\"img\"]},\"doc-credit\":{type:\"section\",allowedAttrs:[\"aria-expanded\"],superclassRole:[\"section\"]},\"doc-credits\":{type:\"landmark\",allowedAttrs:[\"aria-expanded\"],superclassRole:[\"landmark\"]},\"doc-dedication\":{type:\"section\",allowedAttrs:[\"aria-expanded\"],superclassRole:[\"section\"]},\"doc-endnote\":{type:\"listitem\",requiredContext:[\"doc-endnotes\"],allowedAttrs:[\"aria-expanded\",\"aria-level\",\"aria-posinset\",\"aria-setsize\"],superclassRole:[\"listitem\"]},\"doc-endnotes\":{type:\"landmark\",requiredOwned:[\"doc-endnote\"],allowedAttrs:[\"aria-expanded\"],superclassRole:[\"landmark\"]},\"doc-epigraph\":{type:\"section\",allowedAttrs:[\"aria-expanded\"],superclassRole:[\"section\"]},\"doc-epilogue\":{type:\"landmark\",allowedAttrs:[\"aria-expanded\"],superclassRole:[\"landmark\"]},\"doc-errata\":{type:\"landmark\",allowedAttrs:[\"aria-expanded\"],superclassRole:[\"landmark\"]},\"doc-example\":{type:\"section\",allowedAttrs:[\"aria-expanded\"],superclassRole:[\"section\"]},\"doc-footnote\":{type:\"section\",allowedAttrs:[\"aria-expanded\"],superclassRole:[\"section\"]},\"doc-foreword\":{type:\"landmark\",allowedAttrs:[\"aria-expanded\"],superclassRole:[\"landmark\"]},\"doc-glossary\":{type:\"landmark\",requiredOwned:[\"definition\",\"term\"],allowedAttrs:[\"aria-expanded\"],superclassRole:[\"landmark\"]},\"doc-glossref\":{type:\"link\",allowedAttrs:[\"aria-expanded\"],nameFromContent:!0,superclassRole:[\"link\"]},\"doc-index\":{type:\"navigation\",allowedAttrs:[\"aria-expanded\"],superclassRole:[\"navigation\"]},\"doc-introduction\":{type:\"landmark\",allowedAttrs:[\"aria-expanded\"],superclassRole:[\"landmark\"]},\"doc-noteref\":{type:\"link\",allowedAttrs:[\"aria-expanded\"],nameFromContent:!0,superclassRole:[\"link\"]},\"doc-notice\":{type:\"note\",allowedAttrs:[\"aria-expanded\"],superclassRole:[\"note\"]},\"doc-pagebreak\":{type:\"separator\",allowedAttrs:[\"aria-expanded\",\"aria-orientation\"],superclassRole:[\"separator\"],childrenPresentational:!0},\"doc-pagelist\":{type:\"navigation\",allowedAttrs:[\"aria-expanded\"],superclassRole:[\"navigation\"]},\"doc-part\":{type:\"landmark\",allowedAttrs:[\"aria-expanded\"],superclassRole:[\"landmark\"]},\"doc-preface\":{type:\"landmark\",allowedAttrs:[\"aria-expanded\"],superclassRole:[\"landmark\"]},\"doc-prologue\":{type:\"landmark\",allowedAttrs:[\"aria-expanded\"],superclassRole:[\"landmark\"]},\"doc-pullquote\":{type:\"none\",superclassRole:[\"none\"]},\"doc-qna\":{type:\"section\",allowedAttrs:[\"aria-expanded\"],superclassRole:[\"section\"]},\"doc-subtitle\":{type:\"sectionhead\",allowedAttrs:[\"aria-expanded\"],superclassRole:[\"sectionhead\"]},\"doc-tip\":{type:\"note\",allowedAttrs:[\"aria-expanded\"],superclassRole:[\"note\"]},\"doc-toc\":{type:\"navigation\",allowedAttrs:[\"aria-expanded\"],superclassRole:[\"navigation\"]}},{\"graphics-document\":{type:\"structure\",superclassRole:[\"document\"],accessibleNameRequired:!0},\"graphics-object\":{type:\"structure\",superclassRole:[\"group\"],nameFromContent:!0},\"graphics-symbol\":{type:\"structure\",superclassRole:[\"img\"],accessibleNameRequired:!0,childrenPresentational:!0}}),htmlElms:en,cssColors:tn},an=Xu({},rn);var nn=an;var on=function(e,t,r,a){this.red=e,this.green=t,this.blue=r,this.alpha=a,this.toHexString=function(){var e=Math.round(this.red).toString(16),t=Math.round(this.green).toString(16),r=Math.round(this.blue).toString(16);return\"#\"+(15.5<this.red?e:\"0\"+e)+(15.5<this.green?t:\"0\"+t)+(15.5<this.blue?r:\"0\"+r)};var n=/^#[0-9a-f]{3,8}$/i,o=/^((?:rgb|hsl)a?)\\s*\\(([^\\)]*)\\)/i;this.parseString=function(e){if(nn.cssColors[e]||\"transparent\"===e){var t=Ku(nn.cssColors[e]||[0,0,0],3),r=t[0],a=t[1],t=t[2];return this.red=r,this.green=a,this.blue=t,void(this.alpha=\"transparent\"===e?0:1)}if(e.match(o))this.parseColorFnString(e);else{if(!e.match(n))throw new Error('Unable to parse color \"'.concat(e,'\"'));this.parseHexString(e)}},this.parseRgbString=function(e){if(\"transparent\"===e)return this.red=0,this.green=0,this.blue=0,void(this.alpha=0);this.parseColorFnString(e)},this.parseHexString=function(e){var t,r;e.match(n)&&![6,8].includes(e.length)&&((e=e.replace(\"#\",\"\")).length<6&&(e=(t=(r=Ku(e,4))[0])+t+(t=r[1])+t+(t=r[2])+t,(r=r[3])&&(e+=r+r)),e=e.match(/.{1,2}/g),this.red=parseInt(e[0],16),this.green=parseInt(e[1],16),this.blue=parseInt(e[2],16),e[3]?this.alpha=parseInt(e[3],16)/255:this.alpha=1)},this.parseColorFnString=function(e){var e=Ku(e.match(o)||[],3),r=e[1],e=e[2];r&&e&&(e=e.split(/\\s*[,\\/\\s]\\s*/).map(function(e){return e.replace(\",\",\"\").trim()}).filter(function(e){return\"\"!==e}).map(function(e,t){return function(e,t,r){if(/%$/.test(t))return 3===r?parseFloat(t)/100:255*parseFloat(t)/100;if(\"h\"===e[r]){if(/turn$/.test(t))return 360*parseFloat(t);if(/rad$/.test(t))return 57.3*parseFloat(t)}return parseFloat(t)}(r,e,t)}),\"hsl\"===r.substr(0,3)&&(e=function(e){var t=Ku(e,4),r=t[0],a=t[1],n=t[2],e=t[3];a/=255,n/=255;var a=(t=(1-Math.abs(2*n-1))*a)*(1-Math.abs(r/60%2-1)),o=n-t/2;return(a=r<60?[t,a,0]:r<120?[a,t,0]:r<180?[0,t,a]:r<240?[0,a,t]:r<300?[a,0,t]:[t,0,a]).map(function(e){return Math.round(255*(e+o))}).concat(e)}(e)),this.red=e[0],this.green=e[1],this.blue=e[2],this.alpha=\"number\"==typeof e[3]?e[3]:1)},this.getRelativeLuminance=function(){var e=this.red/255,t=this.green/255,r=this.blue/255;return.2126*(e<=.03928?e/12.92:Math.pow((.055+e)/1.055,2.4))+.7152*(t<=.03928?t/12.92:Math.pow((.055+t)/1.055,2.4))+.0722*(r<=.03928?r/12.92:Math.pow((.055+r)/1.055,2.4))}};var ln=function(e){var t=new on;return t.parseString(e.getPropertyValue(\"background-color\")),0!==t.alpha&&(e=e.getPropertyValue(\"opacity\"),t.alpha=t.alpha*e),t};var sn=function(e){var t=window.getComputedStyle(e);return Qa(e,t)||1===ln(t).alpha},un=/^\\/?#[^/!]/;var cn=function(e){return!!un.test(e.getAttribute(\"href\"))&&(void 0!==vr.get(\"firstPageLink\")?t=vr.get(\"firstPageLink\"):(t=vo(axe._tree,'a:not([href^=\"#\"]):not([href^=\"/#\"]):not([href^=\"javascript\"])')[0],vr.set(\"firstPageLink\",t||null)),!t||e.compareDocumentPosition(t.actualNode)===e.DOCUMENT_POSITION_FOLLOWING);var t};var dn=function(e,t){for(var r=[\"fixed\",\"sticky\"],a=[],n=!1,o=0;o<e.length;++o){var i=e[o];i===t&&(n=!0);var l=window.getComputedStyle(i);n||-1===r.indexOf(l.position)?a.push(i):a=[]}return a};function pn(e){for(var t=Dr(e).parent;t;){if(Pn(t.actualNode))return t.actualNode;t=t.parent}}var fn=function(e,t){var r,a,n,o,i,l,s,u,c,d,p,f=pn(t);do{var m=pn(e);if(m===f||m===t)return a=t,u=p=d=c=u=s=l=i=o=n=void 0,n=(p=(r=e).getBoundingClientRect()).top+.01,o=p.bottom-.01,i=p.left+.01,l=p.right-.01,s=a.getBoundingClientRect(),u=s.top,c=s.left,d=u-a.scrollTop,r=u-a.scrollTop+a.scrollHeight,p=c-a.scrollLeft,u=c-a.scrollLeft+a.scrollWidth,\"inline\"===(c=window.getComputedStyle(a)).getPropertyValue(\"display\")||!(i<p&&i<s.left||n<d&&n<s.top||u<l&&l>s.right||r<o&&o>s.bottom)&&(!(l>s.right||o>s.bottom)||(\"scroll\"===c.overflow||\"auto\"===c.overflow||\"hidden\"===c.overflow||a instanceof window.HTMLBodyElement||a instanceof window.HTMLHtmlElement))}while(e=m);return!1};var mn=function a(n,o){var t=2<arguments.length&&void 0!==arguments[2]?arguments[2]:document,i=3<arguments.length&&void 0!==arguments[3]?arguments[3]:0;if(999<i)throw new Error(\"Infinite loop detected\");return Array.from(t.elementsFromPoint(n,o)||[]).filter(function(e){return na(e)===t}).reduce(function(e,t){var r;return ta(t)?(r=a(n,o,t.shadowRoot,i+1),(e=e.concat(r)).length&&fn(e[0],t)&&e.push(t)):e.push(t),e},[])};var hn=function(e,t){if(e.hasAttribute(t)){var r=e.nodeName.toUpperCase(),a=e;[\"A\",\"AREA\"].includes(r)&&!e.ownerSVGElement||((a=document.createElement(\"a\")).href=e.getAttribute(t));r=[\"https:\",\"ftps:\"].includes(a.protocol)?a.protocol.replace(/s:$/,\":\"):a.protocol,e=/^\\//.test(a.pathname)?a.pathname:\"/\".concat(a.pathname),e=(e=(t=e).split(\"/\").pop())&&-1!==e.indexOf(\".\")?{pathname:t.replace(e,\"\"),filename:/index./.test(e)?\"\":e}:{pathname:t,filename:\"\"},t=e.pathname,e=e.filename;return{protocol:r,hostname:a.hostname,port:(r=a.port,[\"443\",\"80\"].includes(r)?\"\":r),pathname:/\\/$/.test(t)?t:\"\".concat(t,\"/\"),search:function(e){var t={};if(!e||!e.length)return t;var r=e.substring(1).split(\"&\");if(!r||!r.length)return t;for(var a=0;a<r.length;a++){var n=Ku(r[a].split(\"=\"),2),o=n[0],n=n[1],n=void 0===n?\"\":n;t[decodeURIComponent(o)]=decodeURIComponent(n)}return t}(a.search),hash:function(e){if(!e)return\"\";var t=e.match(/#!?\\/?/g);return t&&\"#\"!==Ku(t,1)[0]?e:\"\"}(a.hash),filename:e}}};var gn,bn=function(e,t){var r=t.getBoundingClientRect(),a=r.top,n=r.left,o=a-t.scrollTop,i=a-t.scrollTop+t.scrollHeight,a=n-t.scrollLeft,n=n-t.scrollLeft+t.scrollWidth;return!(e.left>n&&e.left>r.right||e.top>i&&e.top>r.bottom||e.right<a&&e.right<r.left||e.bottom<o&&e.bottom<r.top)&&(o=window.getComputedStyle(t),!(e.left>r.right||e.top>r.bottom)||(\"scroll\"===o.overflow||\"auto\"===o.overflow||t instanceof window.HTMLBodyElement||t instanceof window.HTMLHtmlElement))},yn=0,vn=function(){$u(o,tt);var n=Wu(o);function o(e,t,r){var a;return Ju(this,o),(a=n.call(this)).shadowId=r,a.children=[],a.actualNode=e,(a.parent=t)||(yn=0),a.nodeIndex=yn++,a._isHidden=null,a._cache={},void 0===gn&&(gn=rr(e.ownerDocument)),a._isXHTML=gn,\"input\"===e.nodeName.toLowerCase()&&(t=e.getAttribute(\"type\"),t=a._isXHTML?t:(t||\"\").toLowerCase(),Fo().includes(t)||(t=\"text\"),a._type=t),vr.get(\"nodeMap\")&&vr.get(\"nodeMap\").set(e,Gu(a)),a}return Qu(o,[{key:\"props\",get:function(){var e=this.actualNode,t=e.nodeType,r=e.nodeName,a=e.id,n=e.multiple,o=e.nodeValue,e=e.value;return{nodeType:t,nodeName:this._isXHTML?r:r.toLowerCase(),id:a,type:this._type,multiple:n,nodeValue:o,value:e}}},{key:\"attr\",value:function(e){return\"function\"!=typeof this.actualNode.getAttribute?null:this.actualNode.getAttribute(e)}},{key:\"hasAttr\",value:function(e){return\"function\"==typeof this.actualNode.hasAttribute&&this.actualNode.hasAttribute(e)}},{key:\"attrNames\",get:function(){var e;return this._cache.hasOwnProperty(\"attrNames\")||(e=(this.actualNode.attributes instanceof window.NamedNodeMap?this.actualNode:this.actualNode.cloneNode(!1)).attributes,this._cache.attrNames=Array.from(e).map(function(e){return e.name})),this._cache.attrNames}},{key:\"getComputedStylePropertyValue\",value:function(e){var t=\"computedStyle_\"+e;return this._cache.hasOwnProperty(t)||(this._cache.hasOwnProperty(\"computedStyle\")||(this._cache.computedStyle=window.getComputedStyle(this.actualNode)),this._cache[t]=this._cache.computedStyle.getPropertyValue(e)),this._cache[t]}},{key:\"isFocusable\",get:function(){return this._cache.hasOwnProperty(\"isFocusable\")||(this._cache.isFocusable=Va(this.actualNode)),this._cache.isFocusable}},{key:\"tabbableElements\",get:function(){return this._cache.hasOwnProperty(\"tabbableElements\")||(this._cache.tabbableElements=Fa(this)),this._cache.tabbableElements}},{key:\"clientRects\",get:function(){return this._cache.hasOwnProperty(\"clientRects\")||(this._cache.clientRects=Array.from(this.actualNode.getClientRects()).filter(function(e){return 0<e.width})),this._cache.clientRects}},{key:\"boundingClientRect\",get:function(){return this._cache.hasOwnProperty(\"boundingClientRect\")||(this._cache.boundingClientRect=this.actualNode.getBoundingClientRect()),this._cache.boundingClientRect}}]),o}();function Dn(e,a,r){var n,t,o;function i(e,t,r){r=Dn(t,a,r);return e=r?e.concat(r):e}if(o=(e=e.documentElement?e.documentElement:e).nodeName.toLowerCase(),ta(e))return n=new vn(e,r,a),a=\"a\"+Math.random().toString().substring(2),t=Array.from(e.shadowRoot.childNodes),n.children=t.reduce(function(e,t){return i(e,t,n)},[]),[n];if(\"content\"===o&&\"function\"==typeof e.getDistributedNodes)return(t=Array.from(e.getDistributedNodes())).reduce(function(e,t){return i(e,t,r)},[]);if(\"slot\"!==o||\"function\"!=typeof e.assignedNodes)return 1===e.nodeType?(n=new vn(e,r,a),t=Array.from(e.childNodes),n.children=t.reduce(function(e,t){return i(e,t,n)},[]),[n]):3===e.nodeType?[new vn(e,r)]:void 0;(t=Array.from(e.assignedNodes())).length||(t=function(e){var t=[];for(e=e.firstChild;e;)t.push(e),e=e.nextSibling;return t}(e));window.getComputedStyle(e);return t.reduce(function(e,t){return i(e,t,r)},[])}var wn=function(){var e=0<arguments.length&&void 0!==arguments[0]?arguments[0]:document.documentElement,t=1<arguments.length?arguments[1]:void 0;return vr.set(\"nodeMap\",new WeakMap),Dn(e,t,null)};var xn=function(e){return e?e.trim().split(\"-\")[0].toLowerCase():\"\"};var En=function(e){var r={};return r.none=e.none.concat(e.all),r.any=e.any,Object.keys(r).map(function(e){if(r[e].length){var t=axe._audit.data.failureSummaries[e];return t&&\"function\"==typeof t.failureMessage?t.failureMessage(r[e].map(function(e){return e.message||\"\"})):void 0}}).filter(function(e){return void 0!==e}).join(\"\\n\\n\")};var An=function(){var e=void 0===(r=(n=0<arguments.length&&void 0!==arguments[0]?arguments[0]:window).screen)?{}:r,t=n.navigator,r=void 0===(a=n.location)?{}:a,a=n.innerHeight,n=n.innerWidth,e=e.msOrientation||e.orientation||e.mozOrientation||{};return{testEngine:{name:\"axe-core\",version:axe.version},testRunner:{name:axe._audit.brand},testEnvironment:{userAgent:(void 0===t?{}:t).userAgent,windowWidth:n,windowHeight:a,orientationAngle:e.angle,orientationType:e.type},timestamp:(new Date).toISOString(),url:r.href}};var Cn=function(){return\"function\"==typeof axe._audit.data.incompleteFallbackMessage?axe._audit.data.incompleteFallbackMessage():axe._audit.data.incompleteFallbackMessage};var Fn=Je.resultGroups;var kn=function(e,a){var t=axe.utils.aggregateResult(e);return Fn.forEach(function(e){a.resultTypes&&!a.resultTypes.includes(e)&&(t[e]||[]).forEach(function(e){Array.isArray(e.nodes)&&0<e.nodes.length&&(e.nodes=[e.nodes[0]])}),t[e]=(t[e]||[]).map(function(t){return t=Object.assign({},t),Array.isArray(t.nodes)&&0<t.nodes.length&&(t.nodes=t.nodes.map(function(e){var t,r;return\"object\"===Lu(e.node)&&(e.html=e.node.source,a.elementRef&&!e.node.fromFrame&&(e.element=e.node.element),!1===a.selectors&&!e.node.fromFrame||(e.target=e.node.selector),a.ancestry&&(e.ancestry=e.node.ancestry),a.xpath&&(e.xpath=e.node.xpath)),delete e.result,delete e.node,t=e,r=a,[\"any\",\"all\",\"none\"].forEach(function(e){Array.isArray(t[e])&&t[e].filter(function(e){return Array.isArray(e.relatedNodes)}).forEach(function(e){e.relatedNodes=e.relatedNodes.map(function(e){var t={html:e.source};return r.elementRef&&!e.fromFrame&&(t.element=e.element),!1===r.selectors&&!e.fromFrame||(t.target=e.selector),r.ancestry&&(t.ancestry=e.ancestry),r.xpath&&(t.xpath=e.xpath),t})})}),e})),Fn.forEach(function(e){return delete t[e]}),delete t.pageLevel,delete t.result,t})}),t};axe._thisWillBeDeletedDoNotUse=axe._thisWillBeDeletedDoNotUse||{},axe._thisWillBeDeletedDoNotUse.helpers={failureSummary:En,getEnvironmentData:An,incompleteFallbackMessage:Cn,processAggregate:kn};var Rn=/\\$\\{\\s?data\\s?\\}/g;function Tn(e,t){if(\"string\"==typeof t)return e.replace(Rn,t);for(var r in t){var a;t.hasOwnProperty(r)&&(a=new RegExp(\"\\\\${\\\\s?data\\\\.\"+r+\"\\\\s?}\",\"g\"),r=void 0===t[r]?\"\":String(t[r]),e=e.replace(a,r))}return e}var Nn=function e(t,r){if(t){if(Array.isArray(r))return r.values=r.join(\", \"),\"string\"!=typeof t.singular||\"string\"!=typeof t.plural?Tn(t,r):Tn(1===r.length?t.singular:t.plural,r);if(\"string\"==typeof t)return Tn(t,r);if(\"string\"==typeof r)return Tn(t[r],r);var a=t.default||Cn();return e(a=r&&r.messageKey&&t[r.messageKey]?t[r.messageKey]:a,r)}};var _n=function(e,t,r){var a=axe._audit.data.checks[e];if(!a)throw new Error(\"Cannot get message for unknown check: \".concat(e,\".\"));if(!a.messages[t])throw new Error('Check \"'.concat(e,'\"\" does not have a \"').concat(t,'\" message.'));return Nn(a.messages[t],r)};var On=function(e,t,r){var a=((r.rules&&r.rules[t]||{}).checks||{})[e.id],n=(r.checks||{})[e.id],t=e.enabled,e=e.options;return n&&(n.hasOwnProperty(\"enabled\")&&(t=n.enabled),n.hasOwnProperty(\"options\")&&(e=n.options)),a&&(a.hasOwnProperty(\"enabled\")&&(t=a.enabled),a.hasOwnProperty(\"options\")&&(e=a.options)),{enabled:t,options:e,absolutePaths:r.absolutePaths}};var Sn=function(t){var e=axe._audit.rules.find(function(e){return e.id===t});if(!e)throw new Error(\"Cannot find rule by id: \".concat(t));return e};var Pn=function(e){var t=1<arguments.length&&void 0!==arguments[1]?arguments[1]:0,r=e.scrollWidth>e.clientWidth+t,a=e.scrollHeight>e.clientHeight+t;if(r||a){var n=window.getComputedStyle(e),t=n.getPropertyValue(\"overflow-x\"),n=n.getPropertyValue(\"overflow-y\");return r&&(\"visible\"!==t&&\"hidden\"!==t)||a&&(\"visible\"!==n&&\"hidden\"!==n)?{elm:e,top:e.scrollTop,left:e.scrollLeft}:void 0}};var In=function(){var e=0<arguments.length&&void 0!==arguments[0]?arguments[0]:window,t=e.document.documentElement;return[void 0!==e.pageXOffset?{elm:e,top:e.pageYOffset,left:e.pageXOffset}:{elm:t,top:t.scrollTop,left:t.scrollLeft}].concat(function a(e){return Array.from(e.children||e.childNodes||[]).reduce(function(e,t){var r=Pn(t);return r&&e.push(r),e.concat(a(t))},[])}(document.body))};function Bn(){return Ar(nn)}var Ln,qn=function(l){if(!l)throw new Error(\"axe.utils.getStyleSheetFactory should be invoked with an argument\");return function(e){var t=e.data,r=e.isCrossOrigin,a=void 0!==r&&r,n=e.shadowId,o=e.root,i=e.priority,r=e.isLink,e=void 0!==r&&r,r=l.createElement(\"style\");return e?(e=l.createTextNode('@import \"'.concat(t.href,'\"')),r.appendChild(e)):r.appendChild(l.createTextNode(t)),l.head.appendChild(r),{sheet:r.sheet,isCrossOrigin:a,shadowId:n,root:o,priority:i}}};var Mn=function(e){if(Ln&&Ln.parentNode)return void 0===Ln.styleSheet?Ln.appendChild(document.createTextNode(e)):Ln.styleSheet.cssText+=e,Ln;if(e){var t=document.head||document.getElementsByTagName(\"head\")[0];return(Ln=document.createElement(\"style\")).type=\"text/css\",void 0===Ln.styleSheet?Ln.appendChild(document.createTextNode(e)):Ln.styleSheet.cssText=e,t.appendChild(Ln),Ln}};var jn=function e(t,r){var a=Dr(t);if(9===t.nodeType)return!1;if(11===t.nodeType&&(t=t.host),a&&null!==a._isHidden)return a._isHidden;var n=window.getComputedStyle(t,null);if(!n||!t.parentNode||\"none\"===n.getPropertyValue(\"display\")||!r&&\"hidden\"===n.getPropertyValue(\"visibility\")||\"true\"===t.getAttribute(\"aria-hidden\"))return!0;t=e(t.assignedSlot||t.parentNode,!0);return a&&(a._isHidden=t),t},Un=[\"a\",\"abbr\",\"address\",\"area\",\"article\",\"aside\",\"audio\",\"b\",\"base\",\"bdi\",\"bdo\",\"blockquote\",\"body\",\"br\",\"button\",\"canvas\",\"caption\",\"cite\",\"code\",\"col\",\"colgroup\",\"data\",\"datalist\",\"dd\",\"del\",\"details\",\"dfn\",\"dialog\",\"div\",\"dl\",\"dt\",\"em\",\"embed\",\"fieldset\",\"figcaption\",\"figure\",\"footer\",\"form\",\"h1\",\"h2\",\"h3\",\"h4\",\"h5\",\"h6\",\"head\",\"header\",\"hgroup\",\"hr\",\"html\",\"i\",\"iframe\",\"img\",\"input\",\"ins\",\"kbd\",\"keygen\",\"label\",\"legend\",\"li\",\"link\",\"main\",\"map\",\"mark\",\"math\",\"menu\",\"menuitem\",\"meta\",\"meter\",\"nav\",\"noscript\",\"object\",\"ol\",\"optgroup\",\"option\",\"output\",\"p\",\"param\",\"picture\",\"pre\",\"progress\",\"q\",\"rb\",\"rp\",\"rt\",\"rtc\",\"ruby\",\"s\",\"samp\",\"script\",\"section\",\"select\",\"slot\",\"small\",\"source\",\"span\",\"strong\",\"style\",\"sub\",\"summary\",\"sup\",\"svg\",\"table\",\"tbody\",\"td\",\"template\",\"textarea\",\"tfoot\",\"th\",\"thead\",\"time\",\"title\",\"tr\",\"track\",\"u\",\"ul\",\"var\",\"video\",\"wbr\"];var Vn=function(e){return\"http://www.w3.org/2000/svg\"!==e.namespaceURI&&Un.includes(e.nodeName.toLowerCase())};function Hn(e){return e.sort(function(e,t){return Jr(e,t)?1:-1})[0]}var zn=function(t,e){var r=e.include&&Hn(e.include.filter(function(e){return Jr(e,t)}));return!!(!(e=e.exclude&&Hn(e.exclude.filter(function(e){return Jr(e,t)})))&&r||e&&Jr(e,r))},$n=c(ze());axe._memoizedFns=[];var Wn=function(e){return e=$n.default(e),axe._memoizedFns.push(e),e};var Gn=function(e,t){return(e=e.actualNode||e)===(t=t.actualNode||t)?0:4&e.compareDocumentPosition(t)?-1:1};var Yn=function(e,a,n,o){var t=4<arguments.length&&void 0!==arguments[4]&&arguments[4],r=Array.from(e.cssRules);if(!r)return Promise.resolve();var i=r.filter(function(e){return 3===e.type});return i.length?(i=i.filter(function(e){return e.href}).map(function(e){return e.href}).filter(function(e){return!o.includes(e)}).map(function(e,t){var r=[].concat(Yu(n),[t]),t=/^https?:\\/\\/|^\\/\\//i.test(e);return Qn(e,a,r,o,t)}),(r=r.filter(function(e){return 3!==e.type})).length&&i.push(Promise.resolve(a.convertDataToStylesheet({data:r.map(function(e){return e.cssText}).join(),isCrossOrigin:t,priority:n,root:a.rootNode,shadowId:a.shadowId}))),Promise.all(i)):Promise.resolve({isCrossOrigin:t,priority:n,root:a.rootNode,shadowId:a.shadowId,sheet:e})};var Kn=function(e,t,r,a){var n=4<arguments.length&&void 0!==arguments[4]&&arguments[4];return function(e){try{return!e.cssRules&&e.href?!1:!0}catch(e){return!1}}(e)?Yn(e,t,r,a,n):Qn(e.href,t,r,a,!0)};var Xn,Jn,Qn=function(e,t,r,a,n){return a.push(e),new Promise(function(t,r){var a=new XMLHttpRequest;a.open(\"GET\",e),a.timeout=Je.preload.timeout,a.addEventListener(\"error\",r),a.addEventListener(\"timeout\",r),a.addEventListener(\"loadend\",function(e){return e.loaded&&a.responseText?t(a.responseText):void r(a.responseText)}),a.send()}).then(function(e){e=t.convertDataToStylesheet({data:e,isCrossOrigin:n,priority:r,root:t.rootNode,shadowId:t.shadowId});return Kn(e.sheet,t,r,a,e.isCrossOrigin)})};function Zn(){if(window.performance&&window.performance)return window.performance.now()}var eo,to,ro=(Xn=null,Jn=Zn(),{start:function(){this.mark(\"mark_axe_start\")},end:function(){this.mark(\"mark_axe_end\"),this.measure(\"axe\",\"mark_axe_start\",\"mark_axe_end\"),this.logMeasures(\"axe\")},auditStart:function(){this.mark(\"mark_audit_start\")},auditEnd:function(){this.mark(\"mark_audit_end\"),this.measure(\"audit_start_to_end\",\"mark_audit_start\",\"mark_audit_end\"),this.logMeasures()},mark:function(e){window.performance&&void 0!==window.performance.mark&&window.performance.mark(e)},measure:function(e,t,r){window.performance&&void 0!==window.performance.measure&&window.performance.measure(e,t,r)},logMeasures:function(e){function t(e){Qe(\"Measure \"+e.name+\" took \"+e.duration+\"ms\")}if(window.performance&&void 0!==window.performance.getEntriesByType)for(var r=window.performance.getEntriesByName(\"mark_axe_start\")[0],a=window.performance.getEntriesByType(\"measure\").filter(function(e){return e.startTime>=r.startTime}),n=0;n<a.length;++n){var o=a[n];if(o.name===e)return void t(o);t(o)}},timeElapsed:function(){return Zn()-Jn},reset:function(){Xn=Xn||Zn(),Jn=Zn()}});function ao(){if(document.elementsFromPoint)return document.elementsFromPoint;if(document.msElementsFromPoint)return document.msElementsFromPoint;var e,e=((e=document.createElement(\"x\")).style.cssText=\"pointer-events:auto\",\"auto\"===e.style.pointerEvents),l=e?\"pointer-events\":\"visibility\",s=e?\"none\":\"hidden\",u=document.createElement(\"style\");return u.innerHTML=e?\"* { pointer-events: all }\":\"* { visibility: visible }\",function(e,t){var r,a,n,o=[],i=[];for(document.head.appendChild(u);(r=document.elementFromPoint(e,t))&&-1===o.indexOf(r);)o.push(r),i.push({value:r.style.getPropertyValue(l),priority:r.style.getPropertyPriority(l)}),r.style.setProperty(l,s,\"important\");for(o.indexOf(document.documentElement)<o.length-1&&(o.splice(o.indexOf(document.documentElement),1),o.push(document.documentElement)),a=i.length;n=i[--a];)o[a].style.setProperty(l,n.value||\"\",n.priority);return document.head.removeChild(u),o}}function no(e){return\"function\"==typeof e||\"[object Function]\"===eo.call(e)}function oo(e){return e=function(e){e=Number(e);return isNaN(e)?0:0!==e&&isFinite(e)?(0<e?1:-1)*Math.floor(Math.abs(e)):e}(e),Math.min(Math.max(e,0),to)}\"function\"!=typeof Object.assign&&(Object.assign=function(e){if(null==e)throw new TypeError(\"Cannot convert undefined or null to object\");for(var t=Object(e),r=1;r<arguments.length;r++){var a=arguments[r];if(null!=a)for(var n in a)a.hasOwnProperty(n)&&(t[n]=a[n])}return t}),Array.prototype.find||Object.defineProperty(Array.prototype,\"find\",{value:function(e){if(null===this)throw new TypeError(\"Array.prototype.find called on null or undefined\");if(\"function\"!=typeof e)throw new TypeError(\"predicate must be a function\");for(var t,r=Object(this),a=r.length>>>0,n=arguments[1],o=0;o<a;o++)if(t=r[o],e.call(n,t,o,r))return t}}),Array.prototype.findIndex||Object.defineProperty(Array.prototype,\"findIndex\",{value:function(e,t){if(null===this)throw new TypeError(\"Array.prototype.find called on null or undefined\");if(\"function\"!=typeof e)throw new TypeError(\"predicate must be a function\");for(var r,a=Object(this),n=a.length>>>0,o=0;o<n;o++)if(r=a[o],e.call(t,r,o,a))return o;return-1}}),\"function\"==typeof window.addEventListener&&(document.elementsFromPoint=ao()),Array.prototype.includes||Object.defineProperty(Array.prototype,\"includes\",{value:function(e){var t=Object(this),r=parseInt(t.length,10)||0;if(0===r)return!1;var a,n,o=parseInt(arguments[1],10)||0;for(0<=o?a=o:(a=r+o)<0&&(a=0);a<r;){if(e===(n=t[a])||e!=e&&n!=n)return!0;a++}return!1}}),Array.prototype.some||Object.defineProperty(Array.prototype,\"some\",{value:function(e){if(null==this)throw new TypeError(\"Array.prototype.some called on null or undefined\");if(\"function\"!=typeof e)throw new TypeError;for(var t=Object(this),r=t.length>>>0,a=2<=arguments.length?arguments[1]:void 0,n=0;n<r;n++)if(n in t&&e.call(a,t[n],n,t))return!0;return!1}}),Array.from||Object.defineProperty(Array,\"from\",{value:(eo=Object.prototype.toString,to=Math.pow(2,53)-1,function(e){var t=Object(e);if(null==e)throw new TypeError(\"Array.from requires an array-like object - not null or undefined\");var r,a=1<arguments.length?arguments[1]:void 0;if(void 0!==a){if(!no(a))throw new TypeError(\"Array.from: when provided, the second argument must be a function\");2<arguments.length&&(r=arguments[2])}for(var n,o=oo(t.length),i=no(this)?Object(new this(o)):new Array(o),l=0;l<o;)n=t[l],i[l]=a?void 0===r?a(n,l):a.call(r,n,l):n,l+=1;return i.length=o,i})}),String.prototype.includes||(String.prototype.includes=function(e,t){return!((t=\"number\"!=typeof t?0:t)+e.length>this.length)&&-1!==this.indexOf(e,t)}),Array.prototype.flat||Object.defineProperty(Array.prototype,\"flat\",{configurable:!0,value:function r(){var a=isNaN(arguments[0])?1:Number(arguments[0]);return a?Array.prototype.reduce.call(this,function(e,t){return Array.isArray(t)?e.push.apply(e,r.call(t,a-1)):e.push(t),e},[]):Array.prototype.slice.call(this)},writable:!0});var io=function(e,t){return e.concat(t).filter(function(e,t,r){return r.indexOf(e)===t})};function lo(e,t,r,a){a={vNodes:e.slice(),anyLevel:t,thisLevel:r,parentShadowId:a};return a.vNodes.reverse(),a}var so=function(e,t,r){return function(e,t,r){for(var a=[],n=lo(Array.isArray(e)?e:[e],t,[],e[0].shadowId),o=[];n.vNodes.length;){for(var i=n.vNodes.pop(),l=[],s=[],u=n.anyLevel.slice().concat(n.thisLevel),c=!1,d=0;d<u.length;d++){var p=u[d];if((!p[0].id||i.shadowId===n.parentShadowId)&&Sr(i,p[0]))if(1===p.length)c||r&&!r(i)||(o.push(i),c=!0);else{var f=p.slice(1);if(!1===[\" \",\">\"].includes(f[0].combinator))throw new Error(\"axe.utils.querySelectorAll does not support the combinator: \"+p[1].combinator);(\">\"===f[0].combinator?l:s).push(f)}p[0].id&&i.shadowId!==n.parentShadowId||!n.anyLevel.includes(p)||s.push(p)}for(i.children&&i.children.length&&(a.push(n),n=lo(i.children,s,l,i.shadowId));!n.vNodes.length&&a.length;)n=a.pop()}return o}(e=Array.isArray(e)?e:[e],Or(t),r)};var uo=function(e){var t,e=void 0===(r=e.treeRoot)?axe._tree[0]:r;if(!(e=(t=[],r=so(r=e,\"*\",function(e){return!t.includes(e.shadowId)&&(t.push(e.shadowId),!0)}).map(function(e){return{shadowId:e.shadowId,rootNode:aa(e.actualNode)}}),io(r,[]))).length)return Promise.resolve();var l,s,r=document.implementation.createHTMLDocument(\"Dynamic document for loading cssom\"),r=qn(r);return l=r,s=[],e.forEach(function(e,t){var r=e.rootNode,a=e.shadowId,e=function(e,t,r){e=11===e.nodeType&&t?function(a,n){return Array.from(a.children).filter(co).reduce(function(e,t){var r=t.nodeName.toUpperCase(),t=\"STYLE\"===r?t.textContent:t,r=n({data:t,isLink:\"LINK\"===r,root:a});return e.push(r.sheet),e},[])}(e,r):function(e){return Array.from(e.styleSheets).filter(function(e){return po(e.media.mediaText)})}(e);return function(e){var t=[];return e.filter(function(e){return!e.href||!t.includes(e.href)&&(t.push(e.href),!0)})}(e)}(r,a,l);if(!e)return Promise.all(s);var n=t+1,o={rootNode:r,shadowId:a,convertDataToStylesheet:l,rootIndex:n},i=[],e=Promise.all(e.map(function(e,t){return Kn(e,o,[n,t],i)}));s.push(e)}),Promise.all(s).then(function r(e){return e.reduce(function(e,t){return Array.isArray(t)?e.concat(r(t)):e.concat(t)},[])})};function co(e){var t=e.nodeName.toUpperCase(),r=e.getAttribute(\"href\"),a=e.getAttribute(\"rel\"),a=\"LINK\"===t&&r&&a&&e.rel.toUpperCase().includes(\"STYLESHEET\");return\"STYLE\"===t||a&&po(e.media)}function po(e){return!e||!e.toUpperCase().includes(\"PRINT\")}var fo=function(e){return e=void 0===(e=e.treeRoot)?axe._tree[0]:e,e=so(e,\"video, audio\",function(e){e=e.actualNode;return e.hasAttribute(\"src\")?!!e.getAttribute(\"src\"):!(Array.from(e.getElementsByTagName(\"source\")).filter(function(e){return!!e.getAttribute(\"src\")}).length<=0)}),Promise.all(e.map(function(e){var r,e=e.actualNode;return r=e,new Promise(function(t){0<r.readyState&&t(r),r.addEventListener(\"loadedmetadata\",function e(){r.removeEventListener(\"loadedmetadata\",e),t(r)})})}))};function mo(e){return!e||void 0===e.preload||null===e.preload||(\"boolean\"==typeof e.preload?e.preload:(e=e.preload,\"object\"===Lu(e)&&Array.isArray(e.assets)))}function ho(e){var t=Je.preload,r=t.assets,t=t.timeout,t={assets:r,timeout:t};if(!e.preload)return t;if(\"boolean\"==typeof e.preload)return t;if(!e.preload.assets.every(function(e){return r.includes(e.toLowerCase())}))throw new Error(\"Requested assets, not supported. Supported assets are: \".concat(r.join(\", \"),\".\"));return t.assets=io(e.preload.assets.map(function(e){return e.toLowerCase()}),[]),e.preload.timeout&&\"number\"==typeof e.preload.timeout&&!isNaN(e.preload.timeout)&&(t.timeout=e.preload.timeout),t}var go=function(o){var i={cssom:uo,media:fo};return mo(o)?new Promise(function(t,r){var e=ho(o),a=e.assets,e=e.timeout,n=setTimeout(function(){return r(new Error(\"Preload assets timed out.\"))},e);Promise.all(a.map(function(a){return i[a](o).then(function(e){return r=e,(t=a)in(e={})?Object.defineProperty(e,t,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[t]=r,e;var t,r})})).then(function(e){e=e.reduce(function(e,t){return Xu({},e,t)},{});clearTimeout(n),t(e)}).catch(function(e){clearTimeout(n),r(e)})}):Promise.resolve()};function bo(a,n,o){return function(e){var t=a[e.id]||{},r=t.messages||{},t=Object.assign({},t);delete t.messages,o.reviewOnFail||void 0!==e.result?t.message=e.result===n?r.pass:r.fail:(\"object\"!==Lu(r.incomplete)||Array.isArray(e.data)||(t.message=function(t,r){function a(e){return e.incomplete&&e.incomplete.default?e.incomplete.default:Cn()}if(!t||!t.missingData)return t&&t.messageKey?r.incomplete[t.messageKey]:a(r);try{var e=r.incomplete[t.missingData[0].reason];if(!e)throw new Error;return e}catch(e){return\"string\"==typeof t.missingData?r.incomplete[t.missingData]:a(r)}}(e.data,r)),t.message||(t.message=r.incomplete)),\"function\"!=typeof t.message&&(t.message=Nn(t.message,e.data)),Zr(e,t)}}var yo=function(e){var t=axe._audit.data.checks||{},r=axe._audit.data.rules||{},a=Gr(axe._audit.rules,\"id\",e.id)||{};e.tags=Ar(a.tags||[]);var n=bo(t,!0,a),o=bo(t,!1,a);e.nodes.forEach(function(e){e.any.forEach(n),e.all.forEach(n),e.none.forEach(o)}),Zr(e,Ar(r[e.id]||{}))};var vo=function(e,t){return so(e,t)};function Do(t,e){var r,a=axe._audit&&axe._audit.tagExclude?axe._audit.tagExclude:[],n=e.hasOwnProperty(\"include\")||e.hasOwnProperty(\"exclude\")?(r=e.include||[],r=Array.isArray(r)?r:[r],n=e.exclude||[],(n=Array.isArray(n)?n:[n]).concat(a.filter(function(e){return-1===r.indexOf(e)}))):(r=Array.isArray(e)?e:[e],a.filter(function(e){return-1===r.indexOf(e)}));return!!(r.some(function(e){return-1!==t.tags.indexOf(e)})||0===r.length&&!1!==t.enabled)&&n.every(function(e){return-1===t.tags.indexOf(e)})}var wo=function(e,t,r){var a=r.runOnly||{},r=(r.rules||{})[e.id];return!(e.pageLevel&&!t.page)&&(\"rule\"===a.type?-1!==a.values.indexOf(e.id):r&&\"boolean\"==typeof r.enabled?r.enabled:\"tag\"===a.type&&a.values?Do(e,a.values):Do(e,[]))};var xo=function t(n,o){if(!o)return n;var i=n.cloneNode(!1),e=i.outerHTML,r=er(i);return vr.get(e)?i=vr.get(e):r&&(i=document.createElement(i.nodeName),Array.from(r).forEach(function(e){var t,r,a;t=n,r=e.name,void 0!==(a=o)[r]&&(!0===a[r]||tr(t,a[r]))||i.setAttribute(e.name,e.value)}),vr.set(e,i)),Array.from(n.childNodes).forEach(function(e){i.appendChild(t(e,o))}),i};var Eo=function(e,t){var r,a=[];if(axe._selectCache)for(var n=0,o=axe._selectCache.length;n<o;n++){var i=axe._selectCache[n];if(i.selector===e)return i.result}function l(e){return zn(e,s)}for(var s,u=(s=t).include.reduce(function(e,t){return e.length&&Jr(e[e.length-1],t)||e.push(t),e},[]),c=0;c<u.length;c++)r=u[c],a=function(e,t){var r;if(0===e.length)return t;e.length<t.length&&(r=e,e=t,t=r);for(var a=0,n=t.length;a<n;a++)e.includes(t[a])||e.push(t[a]);return e}(a,so(r,e,l));return axe._selectCache&&axe._selectCache.push({selector:e,result:a}),a};var Ao=function(e){e.forEach(function(e){return function(e,t,r){if(e===window)return e.scroll(r,t);e.scrollTop=t,e.scrollLeft=r}(e.elm,e.top,e.left)})};var Co=function(e){return(e||\"\").trim().replace(/\\s{2,}/g,\" \").split(\" \")};var Fo=function(){return[\"hidden\",\"text\",\"search\",\"tel\",\"url\",\"email\",\"password\",\"date\",\"month\",\"week\",\"time\",\"datetime-local\",\"number\",\"range\",\"color\",\"checkbox\",\"radio\",\"file\",\"submit\",\"image\",\"reset\",\"button\"]},ko=[,[,[1,1,1,1,1,1,1,1,1,1,,1,1,1,1,1,1,1,,1,1,1,1,1,1,,1],[1,1,1,1,1,1,1,1,1,1,1,,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],[,1,1,,1,1,1,,1,1,,1,1,1,1,,1,1,1,1,1,1,1,1,1,1,1],[,1,1,,1,1,1,1,1,1,1,,1,,1,1,1,1,1,1,1,1,,1,1,1,1],[1,1,1,1,1,1,,,,,,1,1,1,1,,,1,1,1,,1,,1,,1,1],[1,1,1,,1,1,,1,1,1,,1,,,1,1,1,,,1,1,1,,,,,1],[,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],[,1,1,,,,,1,1,1,,1,1,1,1,1,1,,1,1,1],[,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,,,1,1,1],[,1,,,,,,1,,1,,,,,1,,1,,,,1,1,,1,,,1],[1,,1,1,1,1,1,1,1,1,1,1,1,1,,1,1,1,1,1,1,1,1,1,1,1,1],[,1,,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],[1,1,1,1,,1,1,1,,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],[,1,1,1,1,1,1,1,1,1,1,1,1,1,1,,,,1,1,1,1,,,1,,1],[,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],[,1,,1,1,,,1,,,,,1,1,1,,1,,1,,1,,,,,,1],[1,,1,1,1,1,,,1,1,1,1,1,,1,1,1,1,1,1,1,1,1,1,1,1,1],[1,1,1,1,1,1,1,1,1,1,1,1,1,,1,1,1,1,1,1,1,1,1,1,1,1,1],[,1,1,1,1,1,,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],[,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,,1,1,1,1],[1,,1,,1,,,,,1,,1,1,1,1,1,,,,1,1,1,1],[,1,1,1,1,1,,1,1,1,,1,,1,1,1,,,1,1,1,1,1,1,1,1],[,,1,,,1,,1,,,,1,1,1,,,,,,,,,,,1],[1,1,1,1,1,1,,1,1,1,,1,1,,1,1,1,1,1,1,1,1,,,1,1,1],[1,1,1,1,1,,,1,,,1,,,1,1,1,,,,,1,,,,,,1]],[,[1,1,1,1,1,1,1,1,1,1,1,,1,,1,1,1,,1,1,1,1,1,1,1,1,1],[,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],[,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,,1,1],[,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],[1,1,1,1,1,1,1,1,1,1,1,1,,1,,1,1,1,1,1,1,1,1,1,1,1,1],[,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,,1,1,1,1],[1,1,1,1,1,1,1,1,,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],[1,1,1,1,1,1,1,1,,,1,1,1,1,1,1,1,1,1,,1,1,1,1,1,1,1],[,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],[,1,1,1,1,,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],[,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,,1,1,1,1,1],[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],[1,1,1,1,1,1,1,1,,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],[1,1,1,,,1,1,1,1,1,1,1,1,1,1,1,1,1,1,,1,1,1,1,1,1,1],[,1,1,,1,,,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],[,1,1,1,1,,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],[1,1,1,1,1,,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],[1,1,1,1,,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],[,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],[,1,1,1,1,1,1,1,1,1,1,1,,1,1,1,1,1,,1,1,1,1,1,1,1,1],[,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,,1,1,1,1,1,1,1],[,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,,1,1,1,1],[,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,,1,1,1,1,,1],[,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,,1,1,1,1,1],[,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]],[,[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,,1,1,1,1,1,1],[,1,1,1,1,1,,1,1,1,1,1,1,,1,1,,1,1,1,1,1,1,1,,1],[,1,,1,1,1,,1,1,,1,,1,1,1,1,1,1,1,1],[,1,,1,1,1,1,1,1,1,1,,,1,1,1,,,1,1,,,,,,1,1],[1,1,1,,,,,1,,,,1,1,,1,,,,,,1,,,,,1],[,1,,,1,,,1,,,,,,1],[,1,,1,,,,1,,,,1],[1,,1,1,1,,1,1,1,,1,1,1,1,1,1,1,1,1,,1,,,1,1,1,1],[,1,1,1,1,1,,,1,,,1,,1,1,,1,,1,,,,,1,,1],[,1,,,,1,,,1,1,,1,,1,1,1,1,,1,1,,,1,,,1],[,1,1,,,,,,1,,,,1,1,1,1,,1,1,1,1,1,1,,1,1,1],[,1,,1,1,1,,,1,1,1,1,1,1,,1,,,,,1,1,,1,,1],[,1,,1,,1,,1,,1,,1,1,1,1,1,,,1,1,1],[,1,1,1,,,,1,1,1,,1,1,,,1,1,,1,1,1,1,,1,1],[1,1,1,1,1,1,1,1,1,,1,1,1,1,1,1,1,1,,,1,1,1,1,1,1,1],[,1,1,1,,1,1,1,,1,,,,,1,1,1,,,1,,1,,,1,1],[,,,,1,,,,,,,,,,,,,,,,,1],[1,1,1,1,1,,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,,1,1,1,1,1],[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,,1,1],[,1,,1,1,1,,1,1,,,,1,1,1,1,1,,,1,1,1,,,,,1],[1,1,1,1,,,,1,1,1,1,1,1,1,,1,1,1,1,1,1,1,1,1,1,1],[1,,,,,,,1,,,,,,,1],[,1,1,,1,1,,1,,,,,,,,,,,,,1],,[1,1,1,,,,,,,,,,,,,1],[,,,,,,,,1,,,1,,,1,1,,,,,1]],[,[1,1,,1,1,1,1,1,1,1,1,1,1,1,,1,1,1,1,1,,1,1,1,1,1,1],[,1,1,,1,1,1,1,,1,1,,1,1,1,1,1,1,1,,1,1,1,1,,1],[,,,1,,,,,,,,,,,,,,,1],[,1,,,1,1,,1,,1,1,,,,1,1,,,1,1,,,,1],[1,,,1,1,1,1,1,1,1,,1,1,1,1,,1,1,1,1,,,1,,,,1],,[,1,1,1,1,1,,1,1,1,,1,1,,1,1,,,1,1,1,1,,1,1,,1],[,1,,,1,,,1,,1,,,1,1,1,1,,,1,1,,1,1,1,1],[,1,1,1,1,,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,,1,1,1,1],[,1,1,1,1,1,1,,,1,1,1,1,1,1,1,,,1,,,1,,1],[,1,,,,,,,,,,1,1,,,,,,1,1,,,,,1],[,,,,,,,1,,,,1,,1,1],[,1,1,1,1,1,1,1,,,,1,1,1,1,1,,,1,1,,1,1,1,1,1],[,1,,,1,1,,1,,1,1,1,,,1,1,,,1,,1,1,1,1,,1],[,1,1,1,,1,1,,1,1,,1,1,,1,1,1,1,1,1,1,,1,1,1,1,1],[,,,,,,,,,,,,,,,,1],,[,1,1,1,1,1,,1,1,1,,,1,,1,1,,1,1,1,1,1,,1,,1],[,,1,,,1,,,1,1,,,1,,1,1,,1],[,1,1,,1,,,,1,1,,1,,1,1,1,1,,1,1,1,1,,,,1],[,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,,1,1,1,1,1,1],[1,1],[,1,,,,,,,,,,1,1,,,,,,1,1,,1,,1,,1,1],,[,1,1,,1,,,1,,1,,,,1,1,1,,,,,,1,,,,1],[1,1,,,1,1,,1,,,,,1,,1]],[,[,1],[,,,1,,,,1,,,,1,,,,1,,,1,,,1],[,,,,,,,,,,,,,,,,,,1,1,,,,,,1],,[1,,,,,1],[,1,,,,1,,,,1],[,1,,,,,,,,,,,1,,,1,,,,,,,,,1,1],[,,,,,,,,,,,,,,,,,,,,,1],[,,,,,,,,,,,,,,,,1,,,,1,,1],[,1],[,1,,1,,1,,1,,1,,1,1,1,,1,1,,1,,,,,,,1],[1,,,,,1,,,1,1,,1,,1,,1,1,,,,,1,,,1],[,1,1,,,1,,1,,1,,1,,1,1,1,1,,,1,,1,,1,1,1],[1,1,1,1,1,,1,,1,,,,1,1,1,1,,1,1,,,1,1,1,1],[1,,,,,,,,,,,,,,,,,,,,1],[,,,,,,,,,1],,[,1,,,,,,1,1,1,,1,,,,1,,,1,1,1,,,1],[1,,,,,1,,1,1,1,,1,1,1,1,1,,1,,1,,1,,,1,1],[1,,1,1,,,,,1,,,,,,1,1,,,1,1,1,1,,,1,,1],[1,,,,,,,,,,,,,,,,,1],[,,,,,1,,,1,,,,,,1],[,,,,,,,,,,,,,,,1],[,,,,,,,,,,,,,,,,,,,,1],[,1,,,,,,,,,,,,,,1],[,1,,,,1]],[,[1,1,1,,1,,1,1,1,1,1,1,1,1,1,,1,,1,,1,1,,,1,1,1],[,,,,,,,,,,,,1],[,,,,,,,,,,,,,,,,,,,1],,[,,,,,,,,,,,,,,,,,,1],[1,,,,,,,,,1,,,,1],[,,,,,,,,,,,,,,,,,,1],,[1,1,,,,1,1,,,,,,1,,,,1,,1,,1,1,,1],[1],[,,,,,,,,,,,1,,,,,,,,,,,1],[,1,,,,,,,1,1,,,1,,1,,,,1,,,,,,,1],[,,,,,,,,,,,,,,,,1,,,,,1],[,,1,,,,,1,,1],[1,,,,1,,,,,1,,,,1,1,,,,1,1,,,,,1],[,,,,,1],[,,,,,,,,,,,,,,,,,,,1],[1,,,1,1,,,,,,,1,,1,,1,1,1,1,1,1],[,,,,,1,,,,,,,1,,,,,,,1],,[,,1,1,1,1,1,,1,1,1,,,1,1,,,1,1,,1,1,1,,,1],[,,,,,,,,,,,,,,,,,,1],[,1,,,,1],,[1]],[,[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],[,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,,1,1,1,1,1,1],[,,,1,1,1,1,,,,,,1,,1,,,,1,,1],[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,,1,1,1,1,1,,,1],[,1,1,1,1,,1,1,1,1,1,1,1,1,,,,1,,1,,,1,1,1,1,1],[,,,,,,,,,,,1,,,,,,,,,1,,,,1],[,1,1,,1,1,,1,,,,1,1,,1,1,,,1,,1,1,,1],[,1,,1,,1,,,1,,,1,1,,1,1,,,1,1,1],[,1,1,1,1,1,,1,1,,,,1,1,1,1,1,1,1,1,1,1,,1,1,1,1],[,,,,,,,,,1,,1,,1,1,,,,1,,,1],[,1,,,1,1,,,,,,,,,1,1,1,,,,,1],[1,,,1,1,,,,1,1,1,1,1,,,1,,,1,,,1,,1,,1],[,1,1,,1,1,,1,1,,,,1,1,1,,,1,1,,,1,1,1,1,1,1],[1,1,1,1,1,1,,1,1,1,1,1,1,1,1,1,,1,1,,1,1,,1,,,1],[,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,,1,1,1,1],[,1,,,,1,,,,,,,,,1],[,1,,,,,,,,1,,,,,1,,,,1,,,1],[,1,1,1,1,,,1,1,1,1,1,,1,,1,,1,1,1,1,1,1,1,1,1,1],[,,,,,1,,1,,,,,1,1,1,1,1,,,1,,,,1],[,1,,,,,,,,1,,,,,,,,,,,,1],[1,1,1,1,1,1,1,1,1,1,,1,1,1,1,1,1,1,1,1,1,1,1,1,1,,1],[1,1,,1,,1,1,,,,1,,1,1,1,1,1,,1,1,,,,,,1],[,1,1,1,1,1,1,1,,1,1,,,1,1,,,,1,,1,1,,1,1],[,,,,,,,,,,,,,,,,,,,,,,,,1],[,1,1,,1,1,1,1,,1,,,1,1,1,1,,,1,,,,,,,1],[,1,,,,,,,,1,,,,,1]],[,[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,,,1,1,1,1,1],[,1,1,,,,,,,,,,,,1,1,,,,,,1],[,1,,,,,,,1],[,,,,,,,,,,,,,,1,,,,,1,,,,,,1],[1,1,,,1,,,1,1,1,,,,1],,[,,,,,,,,,,,,,1,,,,,,,,,,1],[,,,,,,,,,1,,,,,,,,,1,,,,,,,1],[1,1,1,,1,,1,1,1,1,1,1,1,1,,1,,,1,,1,,,1,1],[,,,,,,,,,1],[,1,,,,1,,,,,,1,,,1,,,,,1],[,1,1,,1,1,,,,,,,,,,,,,,,1,1],[,1,1,1,1,1,1,1,1,1,1,1,1,1,1,,1,1,1,1,1,1,1,1,1,1,1],[,1,,,1,1,,1,1,1,1,,,,1,1,,,,1,,1],[1,1,1,1,1,1,,,1,1,1,1,1,1,,1,1,,1,1,1,,1,1,,1,1],[,,,,,,,,,,,,,,,1,,,,1],,[1,1,,1,,1,,,,,,1,,1,,1,1,,1,,1,1,,1,1,,1],[,,1,,,,,,1,,,,1,,1,,,,,1],[1,,,,,,,,,1,,,,,,1,,,,1,,1,,,1],[1,,1,1,1,1,1,1,1,1,1,1,1,1,,1,1,1,1,1,1,1,1,1,1,1,1],[,,,1,,1,,,,,,1,,,1,,,,,,,,1],[,1,,1,,,,,,,,,,,,1],,[1,1,,,,,,,,,,,,,,,,,,,,,,1,1],[1]],[,[1,,,,,,,,,1,,,,,1,,1,,1],[,1,1,,1,1,,1,1,1,,,1,1,1,,,,1,,,1,,,,1],[,1,,,,,,,1,,,,1,,,,,,1],[1,1,1,1,1,1,,,,1,,,,,,,,,1,1,1,1],[1],[,1,1,,,1,1,,,,,1,,1,,,,,,,,1,,,,1],[1,,1,,,1,,1,,,,,1,1,1,1,,,,1,,,,1],[,,1,,,,,,,1,,,,,,,1,,,,,,,1],[1,,,,,,,,,,,,,,1,,,,1],[,,,1,,1,,,,,1,,,,1,1,,,,1],[1,,,,,1,,,,1,,1,1,,,1,1,,1,1,1,,1,1,1,,1],[,1,1,,,,,1,,1,,1,1,1,,1,1,,,1,,1,1,1],[,1,,,,1,,,,1,,,1,,1,1,,,1,1,,,,,,1],[1,,1,1,,1,,1,1,,1,,1,1,1,1,1,,,1,1,,,,,,1],[1,,,,,,,,,,,,,,,,,,1,,,1,,1],[,,,,,,,,,1,,,,,,1],[,,,,,,,,,,,,,,,,,,,,,1,,1],[,1,,,,1,,,1,1,,1,,,1,1,,,1,,,1,,,1,1],[1,1,,1,1,1,,1,1,1,,1,,1,1,1,,,1,,1,1],[1,,1,1,1,1,,,,1,,1,1,1,,1,,,1,1,1,,1,1,1,1,1],[1,,,,,,,,,,,,,1],[,,1,,,,,,,,,,,,,,,,,,,,1],[1,,,,,,,,,,,1,,1,,1,,,,1],[,,,1,,,,,,,,,1],[,1,,,,,,,,,,,,,,1,,,,,,,,,1],[,,,,,,,,1,1,,,,,,,,,1,,,,,,,,1]],[,[1,1,1,1,1,1,1,,1,,1,1,1,1,1,1,,1,1,1,1,1,,,1,1,1],[,,,,,1,,,,1,1,1,,,1,1,,,1,,1,1,,1],[,,,,,,,,,,,,,,,,,,,1,1],[,1,,,,,,1,,,,,,,,,,,,,1],[,,1,,,1,,1,1,1,,1,1,,1,,,,1,,1,1],,[,,1,,,1,,,,,,1,,,,1],[,,,,,,,,,1,,,,,,,,,,1],[1,1,1,1,1,1,,1,1,1,,,1,1,,1,,1,,,1,1,1,,,1],[,,,,,1,,,,,,,,,,,,,1],[,1,,,,,,,,,,,,1,,1,1,,1,,,1],[,,,,,1,,,,,,,,,,,,,,1],[,1,1,1,1,,,,,1,,,1,,1,,,,1,1,,,,1,1],[,1,,,1,,,1,,1,1,,1,,,,,,,1],[,,1,,1,,,1,,,,,,,,,,,1,1,,,,1],[,1,,,,,,,,,,,,,,,,,1,,,,,,1],[,,,,,,,,,,,,,,,,,,1],[,1,1,,,,,,,,,,,,,,,,1,,1,1],[,,,,,,,,,,,,1],,[,1,1,1,1,,,,1,1,,1,1,1,1,1,1,,1,1,1,1,,1,,1],[1,,,,1,,,,,,,,,,1],[1,,,,,,,,,1],,[,1,,,,1,,,,,,,,,,,,,,,,,,,,1]],[,[1,1,1,1,1,1,1,1,1,1,1,1,,1,,1,1,1,1,,,,1,1,1,1],[,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],[,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],[,1,,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,,1,1,1,1,1,1,1],[,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],[,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],[,1,1,1,1,1,1,1,1,1,1,1,1,,1,1,1,1,1,1,1,1,1,1,1,1,1],[1,1,1,1,1,1,1,1,1,1,1,,1,1,,1,1,1,,1,1,1,1,1,1,1,1],[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,,1,1,1],[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],[1,1,1,1,1,1,1,1,,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],[1,1,,1,1,1,1,1,1,1,1,1,1,,,1,1,1,,1,1,1,1,1,1,1,1],[,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],[,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],[1,1,1,1,1,1,1,,1,1,1,1,1,1,1,1,1,,1,1,1,1,1,1,1,1,1],[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],[,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],[1,,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,,1,1,1,1,1,1,1,1],[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],[,1,1,1,1,1,1,,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],[,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]],[,[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,,1,1,1,1,,1,,1,1,1,1],[1,1,1,1,,1,1,1,,1,1,1,1,1,1,1,,1,1,1,1,1,1,1,1,1,1],[,,,1,1,1,1,,1,,,,1,1,,,1,1,,1],[,1,1,,1,,,1,1,1,1,1,1,1,1,1,1,1],[,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],[,1,,,,,,,,,,,,,1],[1,1,1,,,,,1,1,1,,1,1,1,1,,,1,1,,1,1,,,,,1],[,1,,,,,,,1,1,,,1,1,1,,1,,,1,1,1],[1,1,1,1,1,1,1,1,1,1,1,1,1,,,1,1,1,1,1,,1,1,1,1,1,1],[,1,,,,1,,,,1,,,1,,,,1,,,,,,,1,1],[,1,1,1,1,1,,,1,1,1,,1,1,1,1,,,1,1,1,1,,,,1],[,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,,1,,1,,,1],[,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,,,1,1,1,1,1,1],[1,1,1,,1,,,1,1,1,1,,1,1,1,1,,,,1,,1,,1,,,1],[1,1,1,1,,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],[,1,,,,1,,,,,,,,,1,1,,,,,,,,,1],,[,1,,1,,1,,1,,1,,1,1,1,1,1,,,1,,1,,1,,,,1],[,1,,,1,1,,1,1,1,,,1,1,1,1,1,,1,1,1,,1,,,1],[1,,,1,,,,1,1,1,,,,,1,1,,,,1,,1],[1,1,,1,1,1,1,,,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,,1,1],[1,1,,,,,,,,1,,1,,,,,,,,1,,1],[,1,,,,1,,1,1,,,,1,1,,1,,,,1,1,1,,1],,[,1,,,,,,1,,,,,,,1],[,,,,,,,,1,,,,1,,1,,,,,,,,,,,,1]],[,[,1,1,,1,1,1,1,,1,1,1,,1,1,,1,1,,1,1,1,1,1,1,,1],[,1,1,1,1,1,1,,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],[,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],[,1,1,1,1,1,1,1,1,1,1,1,1,1,1,,1,1,1,1,1,1,1,1,1,1,1],[,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,,1,1],[,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,,1,1,1,1],[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,,1,1,1,1],[,1,1,1,1,1,,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],[1,1,1,1,,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],[1,1,1,1,1,1,1,,1,1,1,1,1,1,1,1,1,1,1,1,,1,1,1,1,,1],[,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,,1,1,1,1,1,1,1],[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],[1,1,,1,1,1,1,1,1,1,1,1,,1,,1,1,1,1,1,1,1,1,1,1,1,1],[,1,1,1,1,1,,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],[,1,1,1,,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],[1,1,1,1,1,1,1,1,1,,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],[1,,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],[,1,1,1,1,1,,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,,1,1,1],[,1,1,,1,1,1,1,1,1,,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],[,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],[,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],[1,,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],[,1,1,1,1,1,,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]],[,[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,,,1,1,1,1],[1,1,1,1,1,1,1,1,1,1,1,1,,1,1,1,1,1,1,1,1,1,1,1,1,1],[,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,,,1,,1],[1,1,1,1,1,,1,1,1,1,1,1,1,1,1,,1,1,1,1,1,1,1,1,1,1,1],[1,1,1,1,1,1,1,1,1,1,1,1,,1,1,1,,1,1,1,1,1,1,1,1,1,1],[,1,,,1,,,,,,,,1,,,,,,1,,,1],[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],[,1,1,1,1,1,1,1,1,1,,1,,1,1,1,1,1,1,,1,1,1,1,1,1,1],[,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,,1,1,1,1,1,1,1,1,1,1],[,1,1,,1,,,,1,1,1,,1,1,1,1,,,1,1,1,1,,,1,1,1],[,1,1,1,1,1,1,1,1,1,1,1,,1,1,1,1,1,1,1,1,1,1,1,1,,1],[1,1,,1,,1,,1,,1,1,1,1,1,1,1,,1,1,,,1,1,1,1,1,1],[,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,,1,1,1,1,1,1,1,1,1,1,1],[1,1,,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,,1,1,1,1,1,,1,1],[,1,1,,,,,1,1,1,,,1,,1,1,,,,1,,1,,,1,1],[,,,,,,,1,,,,1,1,1,1,1,,1,,,,,,,,1],[1,1,1,1,,1,1,1,,1,,1,1,1,1,,1,,1,,1,1,,,1,,1],[,1,1,1,1,1,1,1,1,1,,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],[,,,,1,1,,1,,1,1,1,,1,,1,1,,1,1,,1,,1,1,1,1],[,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],[1,,,,,,,,1,,,,,1,,1],[,1,1,1,,1,,1,,1,,,,1,,1,,,1,,,,,,1,1],[,1,,,1,1,,1,,1,,1,1,1,1,1,,1,1,,,1,,,1],[1,,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],[,1,1,,1,,,,,1,,1,,1,,,,,,1,,1,,,,1,1]],[,[,1,,1,,,,,,,,,,,,,,,1,,,,1],[,,,,,,,,,1,,1,1,1,,1,,,1,,1,1],[1,1,,,,,,,1,,,,,,,1,,,,,,1],[,1,,,,,,,,,,1,,,,,,,,,1,1],,[,,,,,,,,,,,,,,,1,,,,1,,1],[,,1,1,,1,,1,,,,,,,,1,,,,,,1],[,,,,,,,,,,,,,,,,,,,,1,1],[,1,,,,,,,,,,,,,1],[1,,1,1,,,,1,,,,,,,,,1,,,1,,,1,1],[,1,1,,1,1,,1,1,1,1,1,1,1,1,1,,,1,1,,1,1,,1],[,1,,,1,1,,,,,,1,,1,,1,,,1,,1,1],[1,1,1,1,,1,,1,,1,,1,1,,1,1,1,1,1,,1,1,1,1,1],[,1,1,,,1,,1,,1,1,1,,,1,1,1,,1,1,1,1,,1,1],[,,,,1,,,1,,,,,,,1,,,,1,1],[,1,,,,,,,,,,1,,1,,1,,,,,1,,,,,1],,[1,1,,1,,1,,1,1,,,,,,1,1,,,1,1,1,1,1,1,1,1,1],[1,1,,1,,,,,,1,,,,,,1,1,,,,1,1,,,1],[,1,1,,1,1,,,,1,,1,1,1,1,1,,1,1,1,1,1,,1,1,1,1],[,1,1,,,1,,,,1,,,,1,1],[,,,,1],[,,,,,,,,,1,,,1],,[,,1,,1,,,,,,,,,1,,,,,,,,,,,,1],[,,,,,,,,,,,,,1]],[,[1,1,1,1,1,1,1,1,1,1,,1,1,1,,1,1,1,1,1,1,1,1,1,1,1,1],[,,1,1,,1,1,1,1,1,,,1,1,1,1,1,,1,1,1,1,1,,,1,1],[,1,1,1,1,1,1,1,1,1,1,1,1,1,1,,1,,1,,,,,1],[,1,,1,,,,,,1,,,,,1,1,,,,,1,1],[,1,1,,1,1,1,1,1,1,1,1,1,1,,1,1,1,,1,,,1,,1,1,1],[,1,,,,1,,,,,,,1],[,1,,,1,,,1,,1,,1,1,,1,,,,,1,,1,,,,1,1],[,1,,,1,,,1,1,1,,1,1,1,1,1,,1,1,,1,1,1,1],[1,1,1,1,1,1,1,1,1,1,1,,1,1,1,1,1,,1,1,1,1,1,1,1,1,1],[,,,,,,,,,,,,,,,,,,,,1],[,1,1,1,,,,1,1,,,,,,1,1,1,,1,1,1,1],[1,1,1,1,1,1,1,1,1,,1,1,1,,1,1,1,1,1,1,1,1,1,1,,1,1],[,1,1,1,1,1,1,,1,1,1,1,1,1,1,1,,1,1,1,1,1,,1,1,1,1],[,1,1,1,1,1,,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],[,,,1,1,1,1,1,1,1,,1,,1,1,1,1,1,,1,1,,1,1,1,1,1],[,1,,,,1,,,,1,,1,1,1,1,1,1,1,1,1,1,1],[,1,,,,1,,,,,,,,1,,,,,,,,,,1],[,1,1,1,1,1,1,1,1,1,,1,1,1,1,1,1,1,1,1,1,1,,1,1,1,1],[1,1,,1,1,1,,1,1,1,,,1,1,1,1,1,1,1,1,1,1,,1,,1],[1,1,,,,,,,1,1,,,,,1,1,1,1,1,,1,1,1,1,,1],[,1,1,1,1,1,1,1,,1,1,1,,1,,1,1,1,1,,1,1,,1,1,1,1],,[,1,1,,,,,1,,1,,,,1,1,1,,,1,,,,,1],[,,,,,,,,,,,,,1],[,,,,,1,,,,,,,,1,1,,,,,1,,1,,,1,1],[,,,,,,,,,,,,,,1]],[,[,1],,,,,,,,,,,,,,,,,,,,[1,1,1,1,1,,1,1,1,1,,1,1,1,1,,1,1,1,1,,,1,1,1,1,1],[,1,,1,,1,,,1,1,1,,1,1,1,1,1,,,1,,,,1,,1,1],[,1,,1,,1,,,1,,,,,1,,,,,,1,1],[,1,,1,,,,,1,,,,1,,1,1,1,1,1,1,1,1,,1],[,1,,,,,,,,,,,,,,,1]],[,[,1,1,1,1,,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],[,,1,,,,,,,,,1,1,,,,1],[,,,,,,1],[,,1],[,1,1,,,1,,1,,1,1,,1,1,1,,,,1,1,1,,,,,1],,[,1,,,,1,,,,,,1,,,1,,,,1,1,,1],[,,,,,,,1,,,,,,,,,1],[,1,,,,1,1,,,,,,1,1,1,,,,1,,1,1],[,,,,,,,1,,1,,,,,,,,,,1],[,1,1,,,,,,1,1,,,,1,,,,,,,1,,,1],,[1,1,1,1,1,1,1,1,1,1,,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],[1,1,,,1,,,1,,,,,1,,1,,1,,1,,,,,1],[1,1,1,1,1,1,1,1,,,,,1,1,,1,1,,1,,,1,,1],[,,,,,,,,,,,,,,1,,,,,,1],,[,,,,,,,,,1,,,,,,1,,,,,1],[,,1,,,,,,,1,,,1,1],[,,,1,,,,,1,,,,,1,,,,,,1,,,,1],[1,,1,1,,1,1,1,1,1,,1,,,,1,1,1,,,1,1,,,,1,1],,[1,1,,,,,,,,,,1,,1,,1,,,1],[,,,,1,,,,,,,,,,,,,,,,,,,1],[,,,,,,,,,,,,,,1,,,,,1,,1],[,,,,,,,,1]],[,[1,1,1,1,1,1,1,,1,1,1,1,1,1,,1,1,1,1,1,1,1,1,1,1,1,1],[,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],[1,1,1,,,1,1,1,1,1,,1,1,,1,1,1,1,,1,1,1,1,1,1],[1,1,1,1,,1,1,1,1,,1,1,1,1,1,1,1,1,1,1,1,1,1,,1,,1],[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,,1,1],[,,1,,,1,,,,,,,,1,,,,,,1,,,,1],[1,1,1,1,1,1,,1,1,1,1,1,1,1,1,1,1,,1,1,1,1,,1,1,1,1],[1,1,1,1,1,1,,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],[1,1,1,,1,1,1,1,1,1,1,1,1,1,,1,1,1,1,1,1,1,1,1,1,1,1],[,1,1,,1,1,,1,,,,1,1,1,1,1,1,,1,1,1,1,,1],[1,1,1,1,1,1,1,1,1,1,1,1,,1,1,1,1,1,1,1,1,1,1,1,1,1,1],[1,1,,1,1,1,1,1,1,1,1,,1,1,1,,1,1,1,1,1,1,,1,1,1,1],[1,1,1,1,1,,1,1,1,1,1,1,1,1,1,,1,1,1,1,1,1,1,1,1,1,1],[1,,1,1,,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,,1,1,1,1,1,1],[1,1,1,1,1,1,,1,1,1,1,1,1,,1,1,1,1,1,1,,1,1,1,1,1,1],[,,1,1,1,1,,1,,1,,1,1,1,1,1,1,1,1,1,1,1,1,,1,1],[1,1,,,,,,,1,,1,1,,1,1,1,,1,1,1,1,1],[1,1,1,1,,1,1,1,1,1,,1,1,1,1,1,,1,1,1,1,1,1,1,1,1,1],[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,,1,1,1],[1,1,1,,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,,1],[1,1,1,1,,1,,1,,1,1,1,1,1,,,,1,1,1,1,,1,1,1,1,1],[1,1,1,1,,1,,,,,,1,,1,,,,,1,1,,,,,1],[1,,1,1,,,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],[,,1,1,,1,,1,,,,1,1,1,1,1,,,1,1,,1,,1],[,1,1,1,1,,,,,1,,1,1,1,1,1,,,1,1,,,,1,1,1],[,1,1,1,1,1,,1,,,,,1,,1,,1,,,1,,,1,1,,1]],[,[1,1,1,1,1,1,1,1,,1,1,1,1,,1,1,1,1,1,1,,1,1,1,1,1,1],[,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],[,1,1,1,1,1,1,1,1,1,,1,1,1,1,1,1,1,,1,1,1,,1,1,1,1],[,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,,1,1,1,1,1,1,,1,1],[1,1,1,1,1,1,1,1,1,1,,1,,1,1,1,1,1,1,1,1,1,1,1,1,1,1],[,,,,,,,,,1,,,,,1,1,,,1,,1],[1,1,1,1,1,1,1,1,1,1,1,,,,1,1,1,1,1,1,1,1,1,1,1,1,1],[1,,,1,1,1,1,,1,1,,1,1,1,1,,1,1,1,1,1,1,1,1,1,1,1],[1,1,,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,,1,1,1,1,1,1,1,1],[,1,,,,,,1,,1,1,,1,1,1,1,1,,,1,,1,,1],[1,1,1,,1,1,1,1,,,,1,1,1,1,,1,1,1,1,1,1,1,1,1,,1],[1,1,1,1,1,,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],[,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,,1,1],[1,1,1,1,1,1,1,1,1,1,,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],[1,,1,1,1,1,1,1,1,1,1,,1,1,,1,1,1,1,1,,1,1,1,1,1,1],[,1,,1,,1,1,1,,1,1,1,1,1,1,1,1,1,1,,1,1,1,1,1,1,1],[,,1,,,,,,,,,,1,1,1,1,1,1,1,,1,1,,1],[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],[1,1,1,1,1,1,1,1,1,1,1,1,1,1,,,1,1,1,1,1,1,1,1,1,1,1],[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,,1,1],[,1,1,1,1,1,1,1,1,1,1,,1,1,1,1,1,1,,1,1,1,1,1,1,1,1],[,1,,,1,1,,,,,,1,1,1,1,1,,,,1,1,1,,1,1,1],[1,1,1,1,1,1,1,1,1,,,,1,1,1,1,1,1,1,,1,1,,1,1,1],[,1,1,1,,1,,1,1,1,1,,,1,1,1,,1,1,1,1,1,,,1,1],[1,1,,,,1,,,1,1,1,,1,,1,,1,,1,1,1,1,1,,1,,1],[,1,,,,,,,1,,1,,1,1,1,1,,,,,,,,,1]],[,[,,,,,,,,,,,,,1,1,,,,1],[,1,,,,,,,,1,,,1,,,,,,1,,,1,,,,1],,[,1,,,,1,,1,,1,1,,1,1,,,,,,,,1],[,,,,,,,,,,,,,,,,,,,1],[,,,,,,,,,1],[1,1,1,,,1,,,,,,,,,1,1,,,,,,,,,,1],[,1,,,,,,,,,,,,,1],[,,,,,,,,,,,,,,,,,,,1,,,1],[,,,,,,,,,1],[1,1,,,,,,1,1,1,,1,1,,,,1,1,,1,,1,1,1,,1],[,1,1,1,,1,1,,,1,,1,1,1,1,,,,,,,1,,1],[,1,1,1,1,,,1,,1,,,,1,1,1,1,,1,1,,1],[,1,,,1,1,,1,,,,1,,1,1,,1,,1,,,1,,,1,,1],[,,,,,,,,,,,1],[,,,,,,,,,1,,,,,,,,,,,,,1],,[1,1,1,1,,1,1,1,1,1,1,1,1,1,1,1,1,,1,,1,1,1,1,1,1,1],[,1,,,,,,,1,1,,1,,,,,1,,,1,,1],[,1,,,,1,,,1,,,,,,,,1,,1,,,1],[,,,,,,,,,,,,,1,1,,,,1,,,1],[,,,,,1,,,1,,,,1],[,1],,[,1],[1,,,,,,,,,,,,,,1,,,,,1]],[,[,1,,,,1,1,1,1,1,1,,1,1,1,1,1,,1,1,,1,1,,,1],[,,1,,,,,,,,,1],,,[1,,,1,1,,,,,,,,1,1,,1,1,,1],,[,,,,,,,,,,,,,,,,,,1,,1],,[1,,,1,1,,1,1,,,,,1,,1,,,,,1,1,,1],,[,1,,,,,,,,1,1,1,1,1,,1,1,,,,1,1],[,,,,,,,,,,,,,,,,1,,,1],[,1,1,1,1,1,1,1,1,1,1,1,1,1,,,1,1,1,1,,1,1,1,1,1,1],[,,,,,,,,,,,1,,1,,,1],[1,,,,,,,,,,,,,,,,,,1,,1],,,[,1,,,,,,,,,,,,,,1,,,,1,1],[,,,,,,,,,1,,,1,,,,,,,,,,1],[,,,,,,,,,,,,,,,1],[,,,,,,,,,,,,,1,1,,,,,,1],,[,1]],[,[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],[,1,1,,,1,1,,1,1,1,1,1,1,,,1,1,1,1,1,,1,1],[,1,,,,,,,,1],[,,,,1,,,1,,,1,1,,,,,,,,,,1,,,,1],[,1,,1,1,,,1,1,1,,,,1,1,1,1,,1,1,1,1,,1],[,,,,,,,1],[,1,1,,,,,1,,1,,,,,,1,,,,,,1,,1,,1],[,1,,,,,,1,,,,1,,,,,,,,,,1],[,,1,1,,1,1,1,1,1,1,1,1,1,1,,,,1,,1,1,1,1,,1],[,1,,,,,,,,1],[,1,1,,1,,,,,,,,1,,,,,,1,,,1,,1,,1],[,1,,1,,1,,1,1,1,,1,1,1,,1,,,1,1,,1,1,1,1,1],[,1,1,1,1,1,,,1,1,,,,1,1,1,,,,1,1,,,1,1],[,,1,1,1,1,,1,,1,,1,,1,1,1,1,,,,,1,,1,,1],[1,1,1,1,1,1,1,1,,1,,1,,1,1,1,,,1,1,,,,1,,1],[,,,1],,[,1,1,,1,,,1,1,1,,1,1,1,1,1,1,,1,1,,1,1,1,1,1,1],[,1,,,,,,1,,1,,1,,,,,,,1,1,,1,1],[,,,,,,1,,1,1,,1,,1,,,,,,,,,,1],[,1,1,,1,,,,1,,,,1,1,1,,,,1,,1,1,1,,1,1],,[,1,1,,,,,,,,,,,,,1,,,1,,,,,1],[,1,,,,,,,,,,,,,,,,,,,,,,1],[,1,1,,,,,,,1,,,,1,,,,,1,,,,,,,1]],[,[,1,1,1,1,1,,1,,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,,1],[,1,1,1,1,1,,1,,1,1,,,1,1,1,1,,1,,,,,1,1,1],[,,1,1,,1,,1,1,,,,1,1,1,1,,,1,,1,1,1,1,,1],[,1,,1,,,,,,,,1,,1,,1,,,,,,,,,,1],[,,1,,1,,,1,,,,,1,1,,,1,,1,1,1,1],[,1],[,1,1,,1,,1,1,,1,,,1,1,1,,,,1,,,1,,1],[1,1,,1,1,1,,,,,,,,,,,,,1,,1,1,1],[,1,1,,,,,,,1,,,1,,1,,1,,1,1,,,1,,,1],[,,1,,,,,,,,,,,,,,,,,,1],[,1,1,1,1,1,1,1,1,1,1,1,1,,1,1,1,1,1,1,1,1,1,1,1,1,1],[,1,1,1,1,1,,1,,1,,,,,1,1,1,,,1,,1,,,,1],[,1,1,1,1,1,1,1,1,,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],[,1,1,,1,,,1,1,1,,1,,1,1,1,,,1,1,1,1,,,,1,1],[,,,1,1,,,1,,1,,1,,1,1,1,1,,1,,,,,1],[,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],[,1,,,,,,,,,,,,,,,,,,,1],[,1,1,,1,1,,1,,1,,,,1,1,,,1,1,,1,1,,1],[,1,1,1,1,1,,,1,1,1,,1,1,1,1,1,1,1,1,,1,1,,,1],[,1,1,1,1,1,,1,1,1,1,,1,1,1,1,1,1,1,1,1,1,1,1,,1,1],[,1,1,,1,,,1,,,1,,1,1,1,1,1,,1,,1,1],[,,,,,1,,,,1,,,,,1,1,,,,1],[,1,,1,1,1,,1,,,1,1,1,,,1,,,1,,1,,,1],[,,1,,,,,,,,,1,,1,,,,,1,,1],[,1,1,,,,,,,,1,1,1,,,,,,,,1,,,,,1],[,,,,,,,,1,,,,,1,,,1]],[,[,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],[,1,1,,1,1,,,1,1,1,1,1,1,1,1,,,,,,,,,1,1],[,,,,,,,,1,,,,1,,1,,1],[,1,,,1,1,,1,,,,1,,,,,,,,1],[,1,,1,,1,,,,1,1,,1,,1,,,,1,1,1,1,1,,,1],,[,1,,,,,,,,1,,,1,1,,,1,,1,1,,1,,1],[,1,,,1,,,,,,,,1,,,,,,,1],[1,1,,,,,1,1,1,1,1,1,1,1,1,,1,1,1,1,1,1,1,,1,1,1],,[,1,,,,,,1,,1,,1,1,1,1,1,,,1,,1,1,,,,1],[,1,1,,,1,,1,,1,,,1,1,1,1,,,1,,,1,,,,1],[,1,1,1,1,1,,1,1,1,,1,1,1,1,1,1,1,1,1,1,,,,1,,1],[,1,,,1,1,,1,1,,,1,1,,1,1,,1,,1,,1],[1,,1,,,,,1,,1,,1,1,1,1,,,,,1,1,,,,1,1],[,1,1,,,,,1,1,,,1,,1,1,1,1,,,,,,,,,,1],,[,1,1,,,1,,,,1,,1,1,1,1,1,,,,1,,,,1,,1],[,,,1,1,,,1,,,,,1,,1,1,1,,1,1,,,,,,1],[,1,,,,,,,,,,,1,,,,1,,,,,,,1,,1],[,1,1,1,1,1,1,1,,1,1,1,1,1,1,,1,1,1,,1,1,,1,1,1,1],[,1,,,,,,,,,,,,,,,,,,,1],[,1,,,,,,1,,,,,1,,1,,,1,1,,1,1,,1],[,1,,,,,,1,,,,,1,1,,,,,,,,1,,,,1],[,,,,,,,,,,,,,,,,,,1,,,1,,,,,1],[,,,,,,,1,,,,1]],[,[1,1,1,1,1,1,1,1,1,1,1,1,1,1,,1,1,1,1,1,1,1,1,1,1,1,1],[,1,,1,,1,,,,,,,1,,,,,,,,1,,,1],[,1,,,,,,,1],[,,,,,,,,,,1],[,1,,,,,,1,1,,,,,,1],,[,1,1,,,,,,1,,,,,1,1,,,,1],[1,,1,,1,,,,,1,,,,,1,,,,,,,,,1,1],[,1,1,,,,,,,,,1,1,1,1,,,,1,,,,,1,,,1],,[,1,1,,1,,,1,1,,,1,,,1,1,1,,1,,1,1,1,,,,1],[,,,,,1,,,,,1,,,1,1,,,1,,1,,,,1],[,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],[,1,,,1,1,,1,,,,1,,,,,,,,1],[,,,1,,,,,1,,,,,1,,1,,1,1,1],[,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],[,,,,,1],[,1,,,,,,1,,,,,,,1,1,1,,,1],[,1,,,,,,,,,,1,1,1,,,,,1,,,1],[,,,,,1,,1,,,,,1,1,1,,1,1,,1,1,1,,,1,1],[1,1,,,,,,,1,,,,,1,1,,,,,,,,,,,1],,[,1],[,,,,,,,,,,,,,,,,,,,,,,,,1],[,,1,,,,,1,,,1,,,,1,,1],[,1,,,,,,,,,1]]];function Ro(e){e=Array.isArray(e)?e:ko;var a=[];return e.forEach(function(e,t){var r=String.fromCharCode(t+96).replace(\"`\",\"\");Array.isArray(e)?a=a.concat(Ro(e).map(function(e){return r+e})):a.push(r)}),a}var To=function(e){for(var t=ko;e.length<3;)e+=\"`\";for(var r=0;r<=e.length-1;r++)if(!(t=t[e.charCodeAt(r)-96]))return!1;return!0};axe._thisWillBeDeletedDoNotUse=axe._thisWillBeDeletedDoNotUse||{},axe._thisWillBeDeletedDoNotUse.utils={setDefaultFrameMessenger:It};var No=function(){$u(o,tt);var r=Wu(o);function o(e){var t,a,n;return Ju(this,o),(t=r.call(this))._props=function(e){var t=e.nodeName,r=e.nodeType,a=void 0===r?1:r;it(\"number\"==typeof a,\"nodeType has to be a number, got '\".concat(a,\"'\")),it(\"string\"==typeof t,\"nodeName has to be a string, got '\".concat(t,\"'\")),t=t.toLowerCase();r=null;\"input\"===t&&(r=(e.type||e.attributes&&e.attributes.type||\"\").toLowerCase(),Fo().includes(r)||(r=\"text\"));t=Xu({},e,{nodeType:a,nodeName:t});r&&(t.type=r);return delete t.attributes,Object.freeze(t)}(e),t._attrs=(e=(e=e).attributes,a=void 0===e?{}:e,n={htmlFor:\"for\",className:\"class\"},Object.keys(a).reduce(function(e,t){var r=a[t];return it(\"object\"!==Lu(r)||null===r,\"expects attributes not to be an object, '\".concat(t,\"' was\")),void 0!==r&&(e[n[t]||t]=null!==r?String(r):null),e},{})),t}return Qu(o,[{key:\"props\",get:function(){return this._props}},{key:\"attr\",value:function(e){return this._attrs[e]||null}},{key:\"hasAttr\",value:function(e){return void 0!==this._attrs[e]}},{key:\"attrNames\",get:function(){return Object.keys(this._attrs)}}]),o}(),_o={};o(_o,{allowedAttr:function(){return So},arialabelText:function(){return Po},arialabelledbyText:function(){return Ui},getAccessibleRefs:function(){return il},getElementUnallowedRoles:function(){return cl},getExplicitRole:function(){return Lo},getImplicitRole:function(){return li},getOwnedVirtual:function(){return hi},getRole:function(){return di},getRoleType:function(){return ll},getRolesByType:function(){return pl},getRolesWithNameFromContents:function(){return ml},implicitNodes:function(){return vl},implicitRole:function(){return li},isAccessibleRef:function(){return Dl},isAriaRoleAllowedOnElement:function(){return sl},isUnsupportedRole:function(){return Io},isValidRole:function(){return Bo},label:function(){return wl},labelVirtual:function(){return Sa},lookupTable:function(){return yl},namedFromContents:function(){return mi},requiredAttr:function(){return xl},requiredContext:function(){return El},requiredOwned:function(){return Al},validateAttr:function(){return Fl},validateAttrValue:function(){return Cl}});var Oo=function(){if(vr.get(\"globalAriaAttrs\"))return vr.get(\"globalAriaAttrs\");var e=Object.keys(nn.ariaAttrs).filter(function(e){return nn.ariaAttrs[e].global});return vr.set(\"globalAriaAttrs\",e),e};var So=function(e){var t=nn.ariaRoles[e],e=Yu(Oo());return t&&(t.allowedAttrs&&e.push.apply(e,Yu(t.allowedAttrs)),t.requiredAttrs&&e.push.apply(e,Yu(t.requiredAttrs))),e};var Po=function(e){if(!(e instanceof tt)){if(1!==e.nodeType)return\"\";e=Dr(e)}return e.attr(\"aria-label\")||\"\"};var Io=function(e){return!!(e=nn.ariaRoles[e])&&!!e.unsupported};var Bo=function(e){var t=(a=1<arguments.length&&void 0!==arguments[1]?arguments[1]:{}).allowAbstract,r=void 0!==(n=a.flagUnsupported)&&n,a=nn.ariaRoles[e],n=Io(e);return!(!a||r&&n)&&(!!t||\"abstract\"!==a.type)};var Lo=function(e){var t=1<arguments.length&&void 0!==arguments[1]?arguments[1]:{},r=t.fallback,a=t.abstracts,n=t.dpub;return 1!==(e=e instanceof tt?e:Dr(e)).props.nodeType?null:(t=(e.attr(\"role\")||\"\").trim().toLowerCase(),(r?Co(t):[t]).find(function(e){return!(!n&&\"doc-\"===e.substr(0,4))&&Bo(e,{allowAbstract:a})})||null)};var qo=function(t){return Object.keys(nn.htmlElms).filter(function(e){e=nn.htmlElms[e];return e.contentTypes?e.contentTypes.includes(t):!!e.variant&&(!(!e.variant.default||!e.variant.default.contentTypes)&&e.variant.default.contentTypes.includes(t))})};var Mo=Wn(function(e){for(var t=[],r=e.rows,a=0,n=r.length;a<n;a++){var o=r[a].cells;t[a]=t[a]||[];for(var i=0,l=0,s=o.length;l<s;l++)for(var u=0;u<o[l].colSpan;u++){for(var c=o[l].getAttribute(\"rowspan\"),d=0===parseInt(c)||0===o[l].rowspan?r.length:o[l].rowSpan,p=0;p<d;p++){for(t[a+p]=t[a+p]||[];t[a+p][i];)i++;t[a+p][i]=o[l]}i++}}return t});var jo=Wn(function(e,t){var r,a;for(t=t||Mo(la(e,\"table\")),r=0;r<t.length;r++)if(t[r]&&-1!==(a=t[r].indexOf(e)))return{x:a,y:r}});var Uo=function(e){var t=e.getAttribute(\"scope\"),r=e.getAttribute(\"role\");if(e instanceof window.Element==!1||-1===[\"TD\",\"TH\"].indexOf(e.nodeName.toUpperCase()))throw new TypeError(\"Expected TD or TH element\");if(\"columnheader\"===r)return\"col\";if(\"rowheader\"===r)return\"row\";if(\"col\"===t||\"row\"===t)return t;if(\"TH\"!==e.nodeName.toUpperCase())return!1;var t=Mo(la(e,\"table\")),a=jo(e,t);return t[a.y].reduce(function(e,t){return e&&\"TH\"===t.nodeName.toUpperCase()},!0)?\"col\":t.map(function(e){return e[a.x]}).reduce(function(e,t){return e&&t&&\"TH\"===t.nodeName.toUpperCase()},!0)?\"row\":\"auto\"};var Vo=function(e){return-1!==[\"col\",\"auto\"].indexOf(Uo(e))};var Ho=function(e){return[\"row\",\"auto\"].includes(Uo(e))},zo=qo(\"sectioning\").map(function(e){return\"\".concat(e,\":not([role])\")}).join(\", \")+\" , main:not([role]), [role=article], [role=complementary], [role=main], [role=navigation], [role=region]\";function $o(e){var t=ka(Ui(e)),e=ka(Po(e));return t||e}var Wo={a:function(e){return e.hasAttr(\"href\")?\"link\":null},area:function(e){return e.hasAttr(\"href\")?\"link\":null},article:\"article\",aside:\"complementary\",body:\"document\",button:\"button\",datalist:\"listbox\",dd:\"definition\",dfn:\"term\",details:\"group\",dialog:\"dialog\",dt:\"term\",fieldset:\"group\",figure:\"figure\",footer:function(e){return Ir(e,zo)?null:\"contentinfo\"},form:function(e){return $o(e)?\"form\":null},h1:\"heading\",h2:\"heading\",h3:\"heading\",h4:\"heading\",h5:\"heading\",h6:\"heading\",header:function(e){return Ir(e,zo)?null:\"banner\"},hr:\"separator\",img:function(t){var e=t.hasAttr(\"alt\")&&!t.attr(\"alt\"),r=Oo().find(function(e){return t.hasAttr(e)});return!e||r||Va(t)?\"img\":\"presentation\"},input:function(e){var t,r;switch(e.hasAttr(\"list\")&&(r=(t=_a(e.actualNode,\"list\").filter(function(e){return!!e})[0])&&\"datalist\"===t.nodeName.toLowerCase()),e.props.type){case\"checkbox\":return\"checkbox\";case\"number\":return\"spinbutton\";case\"radio\":return\"radio\";case\"range\":return\"slider\";case\"search\":return r?\"combobox\":\"searchbox\";case\"button\":case\"image\":case\"reset\":case\"submit\":return\"button\";case\"text\":case\"tel\":case\"url\":case\"email\":case\"\":return r?\"combobox\":\"textbox\";default:return\"textbox\"}},li:\"listitem\",main:\"main\",math:\"math\",menu:\"list\",nav:\"navigation\",ol:\"list\",optgroup:\"group\",option:\"option\",output:\"status\",progress:\"progressbar\",section:function(e){return $o(e)?\"region\":null},select:function(e){return e.hasAttr(\"multiple\")||1<parseInt(e.attr(\"size\"))?\"listbox\":\"combobox\"},summary:\"button\",table:\"table\",tbody:\"rowgroup\",td:function(e){e=Ir(e,\"table\"),e=Lo(e);return[\"grid\",\"treegrid\"].includes(e)?\"gridcell\":\"cell\"},textarea:\"textbox\",tfoot:\"rowgroup\",th:function(e){return Vo(e.actualNode)?\"columnheader\":Ho(e.actualNode)?\"rowheader\":void 0},thead:\"rowgroup\",tr:\"row\",ul:\"list\"};var Go=function(e,t){var r=Lu(t);if(Array.isArray(t)&&void 0!==e)return t.includes(e);if(\"function\"===r)return!!t(e);if(null!=e){if(t instanceof RegExp)return t.test(e);if(/^\\/.*\\/$/.test(t)){r=t.substring(1,t.length-1);return new RegExp(r).test(e)}}return t===e};var Yo=function(t,r){if(\"object\"!==Lu(r)||Array.isArray(r)||r instanceof RegExp)throw new Error(\"Expect matcher to be an object\");return Object.keys(r).every(function(e){return Go(t(e),r[e])})};var Ko=function(t,e){return t instanceof tt||(t=Dr(t)),Yo(function(e){return t.attr(e)},e)};var Xo=function(e,t){return!!t(e)};var Jo=function(e,t){return Go(Lo(e),t)};var Qo=function(e,t){return Go(li(e),t)};var Zo=function(e,t){return e instanceof tt||(e=Dr(e)),Go(e.props.nodeName,t)};var ei=function(t,e){return t instanceof tt||(t=Dr(t)),Yo(function(e){return t.props[e]},e)};var ti=function(e,t){return Go(di(e),t)},ri={attributes:Ko,condition:Xo,explicitRole:Jo,implicitRole:Qo,nodeName:Zo,properties:ei,semanticRole:ti};var ai=function t(r,a){return r instanceof tt||(r=Dr(r)),Array.isArray(a)?a.some(function(e){return t(r,e)}):\"string\"==typeof a?Pr(r,a):Object.keys(a).every(function(e){if(!ri[e])throw new Error('Unknown matcher type \"'.concat(e,'\"'));var t=ri[e],e=a[e];return t(r,e)})};var ni=function(e,t){return ai(e,t)};ni.attributes=Ko,ni.condition=Xo,ni.explicitRole=Jo,ni.fromDefinition=ai,ni.fromFunction=Yo,ni.fromPrimative=Go,ni.implicitRole=Qo,ni.nodeName=Zo,ni.properties=ei,ni.semanticRole=ti;var oi=ni;var ii=function(e){var t=nn.htmlElms[e.props.nodeName];if(!t)return{};if(!t.variant)return t;var r,a,n=t.variant,o=zu(t,Mu);for(r in n)if(n.hasOwnProperty(r)&&\"default\"!==r){var i=n[r],l=i.matches,s=zu(i,ju);if(oi(e,l))for(var u in s)s.hasOwnProperty(u)&&(o[u]=s[u])}for(a in n.default)n.default.hasOwnProperty(a)&&void 0===o[a]&&(o[a]=n.default[a]);return o};var li=function(e){var t=(1<arguments.length&&void 0!==arguments[1]?arguments[1]:{}).chromium,r=e instanceof tt?e:Dr(e);if(e=r.actualNode,!r)throw new ReferenceError(\"Cannot get implicit role of a node outside the current scope.\");var a=r.props.nodeName;return(a=Wo[a])||!t?\"function\"==typeof a?a(r):a||null:ii(r).chromiumRole||null},si={td:[\"tr\"],th:[\"tr\"],tr:[\"thead\",\"tbody\",\"tfoot\",\"table\"],thead:[\"table\"],tbody:[\"table\"],tfoot:[\"table\"],li:[\"ol\",\"ul\"],dt:[\"dl\",\"div\"],dd:[\"dl\",\"div\"],div:[\"dl\"]};function ui(e,t){var r=t.chromium,t=zu(t,Uu),r=li(e,{chromium:r});if(!r)return null;t=function e(t,r){var a=si[t.props.nodeName];if(!a)return null;if(!t.parent)throw new ReferenceError(\"Cannot determine role presentational inheritance of a required parent outside the current scope.\");if(!a.includes(t.parent.props.nodeName))return null;a=Lo(t.parent,r);return[\"none\",\"presentation\"].includes(a)&&!ci(t.parent)?a:a?null:e(t.parent,r)}(e,t);return t||r}function ci(t){return Oo().some(function(e){return t.hasAttr(e)})||Va(t)}var di=function(e){var t=(r=1<arguments.length&&void 0!==arguments[1]?arguments[1]:{}).noPresentational,r=function(e,t){var r=1<arguments.length&&void 0!==t?t:{},a=r.noImplicit,n=zu(r,Vu),o=e instanceof tt?e:Dr(e);return 1!==o.props.nodeType?null:!(r=Lo(o,n))||[\"presentation\",\"none\"].includes(r)&&ci(o)?a?null:ui(o,n):r}(e,zu(r,Hu));return t&&[\"presentation\",\"none\"].includes(r)?null:r},pi=[\"iframe\"];var fi=function(e){var t=e instanceof tt?e:Dr(e);return 1!==t.props.nodeType||!e.hasAttr(\"title\")||!ni(t,pi)&&[\"none\",\"presentation\"].includes(di(t))?\"\":t.attr(\"title\")};var mi=function(e){var t=(1<arguments.length&&void 0!==arguments[1]?arguments[1]:{}).strict;if(1!==(e=e instanceof tt?e:Dr(e)).props.nodeType)return!1;var r=di(e),a=nn.ariaRoles[r];return!(!a||!a.nameFromContent)||!t&&(!a||[\"presentation\",\"none\"].includes(r))};var hi=function(e){var t=e.actualNode,r=e.children;if(!r)throw new Error(\"getOwnedVirtual requires a virtual node\");if(e.hasAttr(\"aria-owns\")){t=_a(t,\"aria-owns\").filter(function(e){return!!e}).map(function(e){return axe.utils.getNodeFromTree(e)});return[].concat(Yu(r),Yu(t))}return Yu(r)};var gi=qo(\"phrasing\").concat([\"#text\"]);var bi=function(e){var r=1<arguments.length&&void 0!==arguments[1]?arguments[1]:{},t=Mi.alreadyProcessed;r.startNode=r.startNode||e;var a=(i=r).strict,n=i.inControlContext,o=i.inLabelledByContext,i=ii(e).contentTypes;return!(t(e,r)||1!==e.props.nodeType||null!=i&&i.includes(\"embedded\"))&&(mi(e,{strict:a})||r.subtreeDescendant)?(a||(r=Xu({subtreeDescendant:!n&&!o},r)),hi(e).reduce(function(e,t){return function(e,t,r){var a=t.props.nodeName,r=Mi(t,r);if(!r)return e;gi.includes(a)||(\" \"!==r[0]&&(r+=\" \"),e&&\" \"!==e[e.length-1]&&(r=\" \"+r));return e+r}(e,t,r)},\"\")):\"\"};var yi=function(e){var t=1<arguments.length&&void 0!==arguments[1]?arguments[1]:{},r=Mi.alreadyProcessed;if(t.inControlContext||t.inLabelledByContext||r(e,t))return\"\";t.startNode||(t.startNode=e);var a,n=Xu({inControlContext:!0},t),r=function(e){if(!e.attr(\"id\"))return[];if(e.actualNode)return oa({elm:\"label\",attr:\"for\",value:e.attr(\"id\"),context:e.actualNode});throw new TypeError(\"Cannot resolve explicit label reference for non-DOM nodes\")}(e);return(t=Ir(e,\"label\"))?(a=[].concat(Yu(r),[t.actualNode])).sort(Gn):a=r,a.map(function(e){return ji(e,n)}).filter(function(e){return\"\"!==e}).join(\" \")},vi={submit:\"Submit\",image:\"Submit\",reset:\"Reset\",button:\"\"};function Di(e,t){return t.attr(e)||\"\"}function wi(e,t,r){var a=t.actualNode,t=[e=e.toLowerCase(),a.nodeName.toLowerCase()].join(\",\"),t=a.querySelector(t);return t&&t.nodeName.toLowerCase()===e?ji(t,r):\"\"}var xi={valueText:function(e){return e.actualNode.value||\"\"},buttonDefaultText:function(e){e=e.actualNode;return vi[e.type]||\"\"},tableCaptionText:wi.bind(null,\"caption\"),figureText:wi.bind(null,\"figcaption\"),svgTitleText:wi.bind(null,\"title\"),fieldsetLegendText:wi.bind(null,\"legend\"),altText:Di.bind(null,\"alt\"),tableSummaryText:Di.bind(null,\"summary\"),titleText:fi,subtreeText:bi,labelText:yi,singleSpace:function(){return\" \"},placeholderText:Di.bind(null,\"placeholder\")};function Ei(r){var a=1<arguments.length&&void 0!==arguments[1]?arguments[1]:{},e=r.actualNode;if(1!==r.props.nodeType||[\"presentation\",\"none\"].includes(di(r)))return\"\";var t=(ii(r).namingMethods||[]).map(function(e){return xi[e]}).reduce(function(e,t){return e||t(r,a)},\"\");return a.debug&&axe.log(t||\"{empty-value}\",e,a),t}var Ai={accessibleNameFromFieldValue:[\"combobox\",\"listbox\",\"progressbar\"]},Ci=[\"button\",\"checkbox\",\"color\",\"file\",\"hidden\",\"image\",\"password\",\"radio\",\"reset\",\"submit\"];var Fi=function(e){var t=(e=e instanceof tt?e:Dr(e)).props.nodeName;return\"textarea\"===t||\"input\"===t&&!Ci.includes((e.attr(\"type\")||\"\").toLowerCase())};var ki=function(e){return\"select\"===(e=e instanceof tt?e:Dr(e)).props.nodeName};var Ri=function(e){return\"textbox\"===Lo(e)};var Ti=function(e){return\"listbox\"===Lo(e)};var Ni=function(e){return\"combobox\"===Lo(e)},_i=[\"progressbar\",\"scrollbar\",\"slider\",\"spinbutton\"];var Oi=function(e){return e=Lo(e),_i.includes(e)},Si=[\"textbox\",\"progressbar\",\"scrollbar\",\"slider\",\"spinbutton\",\"combobox\",\"listbox\"],Pi={nativeTextboxValue:function(e){e=e instanceof tt?e:Dr(e);if(Fi(e))return e.props.value||\"\";return\"\"},nativeSelectValue:function(e){var t=e instanceof tt?e:Dr(e);if(!ki(t))return\"\";e=vo(t,\"option\"),t=e.filter(function(e){return e.hasAttr(\"selected\")});t.length||t.push(e[0]);return t.map(function(e){return Oa(e)}).join(\" \")||\"\"},ariaTextboxValue:function(e){var t=e instanceof tt?e:Dr(e),e=t.actualNode;if(!Ri(t))return\"\";return!e||e&&!Ma(e)?Oa(t,!0):e.textContent},ariaListboxValue:Ii,ariaComboboxValue:function(e,t){e=e instanceof tt?e:Dr(e);if(!Ni(e))return\"\";e=hi(e).filter(function(e){return\"listbox\"===di(e)})[0];return e?Ii(e,t):\"\"},ariaRangeValue:function(e){e=e instanceof tt?e:Dr(e);if(!Oi(e)||!e.hasAttr(\"aria-valuenow\"))return\"\";e=+e.attr(\"aria-valuenow\");return isNaN(e)?\"0\":String(e)}};function Ii(e,t){e=e instanceof tt?e:Dr(e);if(!Ti(e))return\"\";e=hi(e).filter(function(e){return\"option\"===di(e)&&\"true\"===e.attr(\"aria-selected\")});return 0===e.length?\"\":Mi(e[0],t)}function Bi(r){var a=1<arguments.length&&void 0!==arguments[1]?arguments[1]:{},e=r.actualNode,t=Ai.accessibleNameFromFieldValue||[],n=di(r);return a.startNode===r||!Si.includes(n)||t.includes(n)?\"\":(n=Object.keys(Pi).map(function(e){return Pi[e]}).reduce(function(e,t){return e||t(r,a)},\"\"),a.debug&&Qe(n||\"{empty-value}\",e,a),n)}function Li(r){var e=r.actualNode,a=function(e,t){var r=e.actualNode;t.startNode||(t=Xu({startNode:e},t));if(!r)return t;1===r.nodeType&&t.inLabelledByContext&&void 0===t.includeHidden&&(t=Xu({includeHidden:!ba(r,!0)},t));return t}(r,a=1<arguments.length&&void 0!==arguments[1]?arguments[1]:{});if(function(e,t){e=e.actualNode;if(!e)return!1;if(1!==e.nodeType||t.includeHidden)return!1;return!ba(e,!0)}(r,a))return\"\";var t=[Ui,Po,Ei,Bi,bi,qi,fi].reduce(function(e,t){return\"\"!==(e=a.startNode===r?ka(e):e)?e:t(r,a)},\"\");return a.debug&&axe.log(t||\"{empty-value}\",e,a),t}function qi(e){return 3!==e.props.nodeType?\"\":e.props.nodeValue}Li.alreadyProcessed=function(e,t){return t.processed=t.processed||[],!!t.processed.includes(e)||(t.processed.push(e),!1)};var Mi=Li;var ji=function(e,t){return e=Dr(e),Mi(e,t)};var Ui=function(r){var a=1<arguments.length&&void 0!==arguments[1]?arguments[1]:{};if(!(r instanceof tt)){if(1!==r.nodeType)return\"\";r=Dr(r)}return 1!==r.props.nodeType||a.inLabelledByContext||a.inControlContext||!r.attr(\"aria-labelledby\")?\"\":_a(r,\"aria-labelledby\").filter(function(e){return e}).reduce(function(e,t){t=ji(t,Xu({inLabelledByContext:!0,startNode:a.startNode||r},a));return e?\"\".concat(e,\" \").concat(t):t},\"\")},Vi={};function Hi(){return/[\\u1D00-\\u1D7F\\u1D80-\\u1DBF\\u1DC0-\\u1DFF\\u20A0-\\u20CF\\u20D0-\\u20FF\\u2100-\\u214F\\u2150-\\u218F\\u2190-\\u21FF\\u2200-\\u22FF\\u2300-\\u23FF\\u2400-\\u243F\\u2440-\\u245F\\u2460-\\u24FF\\u2500-\\u257F\\u2580-\\u259F\\u25A0-\\u25FF\\u2600-\\u26FF\\u2700-\\u27BF\\uE000-\\uF8FF]/g}function zi(){return/[\\u2000-\\u206F\\u2E00-\\u2E7F\\\\'!\"#$%&\\xa3\\xa2\\xa5\\xa7\\u20ac()*+,\\-.\\/:;<=>?@\\[\\]^_`{|}~\\xb1]/g}function $i(){return/[\\uDB80-\\uDBBF][\\uDC00-\\uDFFF]/g}o(Vi,{accessibleText:function(){return ji},accessibleTextVirtual:function(){return Mi},autocomplete:function(){return Qi},formControlValue:function(){return Bi},formControlValueMethods:function(){return Pi},hasUnicode:function(){return Gi},isHumanInterpretable:function(){return Xi},isIconLigature:function(){return Ji},isValidAutocomplete:function(){return Zi},label:function(){return rl},labelText:function(){return yi},labelVirtual:function(){return tl},nativeElementType:function(){return al},nativeTextAlternative:function(){return Ei},nativeTextMethods:function(){return xi},removeUnicode:function(){return Ki},sanitize:function(){return ka},subtreeText:function(){return bi},titleText:function(){return fi},unsupported:function(){return Ai},visible:function(){return el},visibleTextNodes:function(){return nl},visibleVirtual:function(){return Oa}});var Wi=c($e());var Gi=function(e,t){var r=t.emoji,a=t.nonBmp,t=t.punctuations;return r?Wi.default().test(e):a?Hi().test(e)||$i().test(e):!!t&&zi().test(e)},Yi=c($e());var Ki=function(e,t){var r=t.emoji,a=t.nonBmp,t=t.punctuations;return r&&(e=e.replace(Yi.default(),\"\")),a&&(e=(e=e.replace(Hi(),\"\")).replace($i(),\"\")),e=t?e.replace(zi(),\"\"):e};var Xi=function(e){return!e.length||[\"x\",\"i\"].includes(e)?0:(e=Ki(e,{emoji:!0,nonBmp:!0,punctuations:!0}),ka(e)?1:0)};var Ji=function(e){var t=1<arguments.length&&void 0!==arguments[1]?arguments[1]:.15,r=2<arguments.length&&void 0!==arguments[2]?arguments[2]:3,a=e.actualNode.nodeValue.trim();if(!ka(a)||Gi(a,{emoji:!0,nonBmp:!0}))return!1;vr.get(\"canvasContext\")||vr.set(\"canvasContext\",document.createElement(\"canvas\").getContext(\"2d\"));var n=vr.get(\"canvasContext\"),o=n.canvas;vr.get(\"fonts\")||vr.set(\"fonts\",{});var i=vr.get(\"fonts\"),l=window.getComputedStyle(e.parent.actualNode).getPropertyValue(\"font-family\");i[l]||(i[l]={occurances:0,numLigatures:0});var s=i[l];if(s.occurances>=r){if(s.numLigatures/s.occurances==1)return!0;if(0===s.numLigatures)return!1}s.occurances++;var u=30,c=\"\".concat(u,\"px \").concat(l);n.font=c;var d=a.charAt(0);if((i=n.measureText(d).width)<30&&(i*=r=30/i,c=\"\".concat(u*=r,\"px \").concat(l)),o.width=i,o.height=u,n.font=c,n.textAlign=\"left\",n.textBaseline=\"top\",n.fillText(d,0,0),!(d=new Uint32Array(n.getImageData(0,0,i,u).data.buffer)).some(function(e){return e}))return s.numLigatures++,!0;n.clearRect(0,0,i,u),n.fillText(a,0,0);var p=new Uint32Array(n.getImageData(0,0,i,u).data.buffer),i=d.reduce(function(e,t,r){return 0===t&&0===p[r]||0!==t&&0!==p[r]?e:++e},0),u=a.split(\"\").reduce(function(e,t){return e+n.measureText(t).width},0),a=n.measureText(a).width;return t<=i/d.length&&t<=1-a/u&&(s.numLigatures++,!0)},Qi={stateTerms:[\"on\",\"off\"],standaloneTerms:[\"name\",\"honorific-prefix\",\"given-name\",\"additional-name\",\"family-name\",\"honorific-suffix\",\"nickname\",\"username\",\"new-password\",\"current-password\",\"organization-title\",\"organization\",\"street-address\",\"address-line1\",\"address-line2\",\"address-line3\",\"address-level4\",\"address-level3\",\"address-level2\",\"address-level1\",\"country\",\"country-name\",\"postal-code\",\"cc-name\",\"cc-given-name\",\"cc-additional-name\",\"cc-family-name\",\"cc-number\",\"cc-exp\",\"cc-exp-month\",\"cc-exp-year\",\"cc-csc\",\"cc-type\",\"transaction-currency\",\"transaction-amount\",\"language\",\"bday\",\"bday-day\",\"bday-month\",\"bday-year\",\"sex\",\"url\",\"photo\",\"one-time-code\"],qualifiers:[\"home\",\"work\",\"mobile\",\"fax\",\"pager\"],qualifiedTerms:[\"tel\",\"tel-country-code\",\"tel-national\",\"tel-area-code\",\"tel-local\",\"tel-local-prefix\",\"tel-local-suffix\",\"tel-extension\",\"email\",\"impp\"],locations:[\"billing\",\"shipping\"]};var Zi=function(e){var t=void 0!==(a=(i=1<arguments.length&&void 0!==arguments[1]?arguments[1]:{}).looseTyped)&&a,r=void 0===(o=i.stateTerms)?[]:o,a=void 0===(n=i.locations)?[]:n,n=void 0===(o=i.qualifiers)?[]:o,o=void 0===(o=i.standaloneTerms)?[]:o,i=void 0===(i=i.qualifiedTerms)?[]:i;return e=e.toLowerCase().trim(),!(!(r=r.concat(Qi.stateTerms)).includes(e)&&\"\"!==e)||(n=n.concat(Qi.qualifiers),a=a.concat(Qi.locations),o=o.concat(Qi.standaloneTerms),i=i.concat(Qi.qualifiedTerms),r=e.split(/\\s+/g),!(!t&&(8<r[0].length&&\"section-\"===r[0].substr(0,8)&&r.shift(),a.includes(r[0])&&r.shift(),n.includes(r[0])&&(r.shift(),o=[]),1!==r.length))&&(r=r[r.length-1],o.includes(r)||i.includes(r)))};var el=function(e,t,r){return e=Dr(e),Oa(e,t,r)};var tl=function(e){if(t=Sa(e))return t;if(e.attr(\"id\")){if(!e.actualNode)throw new TypeError(\"Cannot resolve explicit label reference for non-DOM nodes\");var t,r=Kt(e.attr(\"id\"));if(t=(r=na(e.actualNode).querySelector('label[for=\"'+r+'\"]'))&&el(r,!0))return t}return(t=(r=Ir(e,\"label\"))&&Oa(r,!0))?t:null};var rl=function(e){return e=Dr(e),tl(e)},al=[{matches:[{nodeName:\"textarea\"},{nodeName:\"input\",properties:{type:[\"text\",\"password\",\"search\",\"tel\",\"email\",\"url\"]}}],namingMethods:\"labelText\"},{matches:{nodeName:\"input\",properties:{type:[\"button\",\"submit\",\"reset\"]}},namingMethods:[\"valueText\",\"titleText\",\"buttonDefaultText\"]},{matches:{nodeName:\"input\",properties:{type:\"image\"}},namingMethods:[\"altText\",\"valueText\",\"labelText\",\"titleText\",\"buttonDefaultText\"]},{matches:\"button\",namingMethods:\"subtreeText\"},{matches:\"fieldset\",namingMethods:\"fieldsetLegendText\"},{matches:\"OUTPUT\",namingMethods:\"subtreeText\"},{matches:[{nodeName:\"select\"},{nodeName:\"input\",properties:{type:/^(?!text|password|search|tel|email|url|button|submit|reset)/}}],namingMethods:\"labelText\"},{matches:\"summary\",namingMethods:\"subtreeText\"},{matches:\"figure\",namingMethods:[\"figureText\",\"titleText\"]},{matches:\"img\",namingMethods:\"altText\"},{matches:\"table\",namingMethods:[\"tableCaptionText\",\"tableSummaryText\"]},{matches:[\"hr\",\"br\"],namingMethods:[\"titleText\",\"singleSpace\"]}];var nl=function t(e){var r=ba(e.actualNode),a=[];return e.children.forEach(function(e){3===e.actualNode.nodeType?r&&a.push(e):a=a.concat(t(e))}),a},ol=/^idrefs?$/;var il=function(e){e=e.actualNode||e;var t=(t=na(e)).documentElement||t,r=vr.get(\"idRefsByRoot\");r||(r=new WeakMap,vr.set(\"idRefsByRoot\",r));var a=r.get(t);return a||(r.set(t,a={}),function e(t,r,a){if(t.hasAttribute){var n;\"LABEL\"===t.nodeName.toUpperCase()&&t.hasAttribute(\"for\")&&(r[n=t.getAttribute(\"for\")]=r[n]||[],r[n].push(t));for(var o=0;o<a.length;++o){var i=a[o];if(i=ka(t.getAttribute(i)||\"\"))for(var l=Co(i),s=0;s<l.length;++s)r[l[s]]=r[l[s]]||[],r[l[s]].push(t)}}for(var u=0;u<t.children.length;u++)e(t.children[u],r,a)}(t,a,Object.keys(nn.ariaAttrs).filter(function(e){e=nn.ariaAttrs[e].type;return ol.test(e)}))),a[e.id]||[]};var ll=function(e){return(e=nn.ariaRoles[e])?e.type:null};var sl=function(e,t){return e=e instanceof tt?e:Dr(e),t===li(e)||(e=ii(e),Array.isArray(e.allowedRoles)?e.allowedRoles.includes(t):!!e.allowedRoles)},ul=[\"doc-backlink\",\"doc-biblioentry\",\"doc-biblioref\",\"doc-cover\",\"doc-endnote\",\"doc-glossref\",\"doc-noteref\"];var cl=function(r){var a=!(1<arguments.length&&void 0!==arguments[1])||arguments[1],n=r.nodeName.toUpperCase();if(!Vn(r))return[];var e,t,o=(o=[],(e=r)?(e.hasAttribute(\"role\")&&(t=Co(e.getAttribute(\"role\").toLowerCase()),o=o.concat(t)),e.hasAttributeNS(\"http://www.idpf.org/2007/ops\",\"type\")&&(e=Co(e.getAttributeNS(\"http://www.idpf.org/2007/ops\",\"type\").toLowerCase()).map(function(e){return\"doc-\".concat(e)}),o=o.concat(e)),o=o.filter(function(e){return Bo(e)})):o),i=li(r);return o.filter(function(e){if(a&&e===i)return!1;if(a&&ul.includes(e)){var t=ll(e);if(i!==t)return!0}return!(a||\"row\"===e&&\"TR\"===n&&tr(r,'table[role=\"grid\"] > tr'))||!sl(r,e)})};var dl=function(t){return Object.keys(nn.ariaRoles).filter(function(e){return nn.ariaRoles[e].type===t})};var pl=function(e){return dl(e)};var fl=function(){if(vr.get(\"ariaRolesNameFromContent\"))return vr.get(\"ariaRolesNameFromContent\");var e=Object.keys(nn.ariaRoles).filter(function(e){return nn.ariaRoles[e].nameFromContent});return vr.set(\"ariaRolesNameFromContent\",e),e};var ml=function(){return fl()},hl=function(e){return null===e},gl=function(e){return null!==e},bl={attributes:{\"aria-activedescendant\":{type:\"idref\",allowEmpty:!0,unsupported:!1},\"aria-atomic\":{type:\"boolean\",values:[\"true\",\"false\"],unsupported:!1},\"aria-autocomplete\":{type:\"nmtoken\",values:[\"inline\",\"list\",\"both\",\"none\"],unsupported:!1},\"aria-busy\":{type:\"boolean\",values:[\"true\",\"false\"],unsupported:!1},\"aria-checked\":{type:\"nmtoken\",values:[\"true\",\"false\",\"mixed\",\"undefined\"],unsupported:!1},\"aria-colcount\":{type:\"int\",unsupported:!1},\"aria-colindex\":{type:\"int\",unsupported:!1},\"aria-colspan\":{type:\"int\",unsupported:!1},\"aria-controls\":{type:\"idrefs\",allowEmpty:!0,unsupported:!1},\"aria-current\":{type:\"nmtoken\",allowEmpty:!0,values:[\"page\",\"step\",\"location\",\"date\",\"time\",\"true\",\"false\"],unsupported:!1},\"aria-describedby\":{type:\"idrefs\",allowEmpty:!0,unsupported:!1},\"aria-describedat\":{unsupported:!0,unstandardized:!0},\"aria-details\":{type:\"idref\",allowEmpty:!0,unsupported:!1},\"aria-disabled\":{type:\"boolean\",values:[\"true\",\"false\"],unsupported:!1},\"aria-dropeffect\":{type:\"nmtokens\",values:[\"copy\",\"move\",\"reference\",\"execute\",\"popup\",\"none\"],unsupported:!1},\"aria-errormessage\":{type:\"idref\",allowEmpty:!0,unsupported:!1},\"aria-expanded\":{type:\"nmtoken\",values:[\"true\",\"false\",\"undefined\"],unsupported:!1},\"aria-flowto\":{type:\"idrefs\",allowEmpty:!0,unsupported:!1},\"aria-grabbed\":{type:\"nmtoken\",values:[\"true\",\"false\",\"undefined\"],unsupported:!1},\"aria-haspopup\":{type:\"nmtoken\",allowEmpty:!0,values:[\"true\",\"false\",\"menu\",\"listbox\",\"tree\",\"grid\",\"dialog\"],unsupported:!1},\"aria-hidden\":{type:\"boolean\",values:[\"true\",\"false\"],unsupported:!1},\"aria-invalid\":{type:\"nmtoken\",allowEmpty:!0,values:[\"true\",\"false\",\"spelling\",\"grammar\"],unsupported:!1},\"aria-keyshortcuts\":{type:\"string\",allowEmpty:!0,unsupported:!1},\"aria-label\":{type:\"string\",allowEmpty:!0,unsupported:!1},\"aria-labelledby\":{type:\"idrefs\",allowEmpty:!0,unsupported:!1},\"aria-level\":{type:\"int\",unsupported:!1},\"aria-live\":{type:\"nmtoken\",values:[\"off\",\"polite\",\"assertive\"],unsupported:!1},\"aria-modal\":{type:\"boolean\",values:[\"true\",\"false\"],unsupported:!1},\"aria-multiline\":{type:\"boolean\",values:[\"true\",\"false\"],unsupported:!1},\"aria-multiselectable\":{type:\"boolean\",values:[\"true\",\"false\"],unsupported:!1},\"aria-orientation\":{type:\"nmtoken\",values:[\"horizontal\",\"vertical\"],unsupported:!1},\"aria-owns\":{type:\"idrefs\",allowEmpty:!0,unsupported:!1},\"aria-placeholder\":{type:\"string\",allowEmpty:!0,unsupported:!1},\"aria-posinset\":{type:\"int\",unsupported:!1},\"aria-pressed\":{type:\"nmtoken\",values:[\"true\",\"false\",\"mixed\",\"undefined\"],unsupported:!1},\"aria-readonly\":{type:\"boolean\",values:[\"true\",\"false\"],unsupported:!1},\"aria-relevant\":{type:\"nmtokens\",values:[\"additions\",\"removals\",\"text\",\"all\"],unsupported:!1},\"aria-required\":{type:\"boolean\",values:[\"true\",\"false\"],unsupported:!1},\"aria-roledescription\":{type:\"string\",allowEmpty:!0,unsupported:!1},\"aria-rowcount\":{type:\"int\",unsupported:!1},\"aria-rowindex\":{type:\"int\",unsupported:!1},\"aria-rowspan\":{type:\"int\",unsupported:!1},\"aria-selected\":{type:\"nmtoken\",values:[\"true\",\"false\",\"undefined\"],unsupported:!1},\"aria-setsize\":{type:\"int\",unsupported:!1},\"aria-sort\":{type:\"nmtoken\",values:[\"ascending\",\"descending\",\"other\",\"none\"],unsupported:!1},\"aria-valuemax\":{type:\"decimal\",unsupported:!1},\"aria-valuemin\":{type:\"decimal\",unsupported:!1},\"aria-valuenow\":{type:\"decimal\",unsupported:!1},\"aria-valuetext\":{type:\"string\",unsupported:!1}},globalAttributes:[\"aria-atomic\",\"aria-busy\",\"aria-controls\",\"aria-current\",\"aria-describedby\",\"aria-details\",\"aria-disabled\",\"aria-dropeffect\",\"aria-flowto\",\"aria-grabbed\",\"aria-haspopup\",\"aria-hidden\",\"aria-invalid\",\"aria-keyshortcuts\",\"aria-label\",\"aria-labelledby\",\"aria-live\",\"aria-owns\",\"aria-relevant\",\"aria-roledescription\"]};bl.role={alert:{type:\"widget\",attributes:{allowed:[\"aria-expanded\",\"aria-errormessage\"]},owned:null,nameFrom:[\"author\"],context:null,unsupported:!1,allowedElements:[\"section\"]},alertdialog:{type:\"widget\",attributes:{allowed:[\"aria-expanded\",\"aria-modal\",\"aria-errormessage\"]},owned:null,nameFrom:[\"author\"],context:null,unsupported:!1,allowedElements:[\"dialog\",\"section\"]},application:{type:\"landmark\",attributes:{allowed:[\"aria-expanded\",\"aria-errormessage\",\"aria-activedescendant\"]},owned:null,nameFrom:[\"author\"],context:null,unsupported:!1,allowedElements:[\"article\",\"audio\",\"embed\",\"iframe\",\"object\",\"section\",\"svg\",\"video\"]},article:{type:\"structure\",attributes:{allowed:[\"aria-expanded\",\"aria-posinset\",\"aria-setsize\",\"aria-errormessage\"]},owned:null,nameFrom:[\"author\"],context:null,implicit:[\"article\"],unsupported:!1},banner:{type:\"landmark\",attributes:{allowed:[\"aria-expanded\",\"aria-errormessage\"]},owned:null,nameFrom:[\"author\"],context:null,implicit:[\"header\"],unsupported:!1,allowedElements:[\"section\"]},button:{type:\"widget\",attributes:{allowed:[\"aria-expanded\",\"aria-pressed\",\"aria-errormessage\"]},owned:null,nameFrom:[\"author\",\"contents\"],context:null,implicit:[\"button\",'input[type=\"button\"]','input[type=\"image\"]','input[type=\"reset\"]','input[type=\"submit\"]',\"summary\"],unsupported:!1,allowedElements:[{nodeName:\"a\",attributes:{href:gl}}]},cell:{type:\"structure\",attributes:{allowed:[\"aria-colindex\",\"aria-colspan\",\"aria-rowindex\",\"aria-rowspan\",\"aria-errormessage\"]},owned:null,nameFrom:[\"author\",\"contents\"],context:[\"row\"],implicit:[\"td\",\"th\"],unsupported:!1},checkbox:{type:\"widget\",attributes:{allowed:[\"aria-checked\",\"aria-required\",\"aria-readonly\",\"aria-errormessage\"]},owned:null,nameFrom:[\"author\",\"contents\"],context:null,implicit:['input[type=\"checkbox\"]'],unsupported:!1,allowedElements:[\"button\"]},columnheader:{type:\"structure\",attributes:{allowed:[\"aria-colindex\",\"aria-colspan\",\"aria-expanded\",\"aria-rowindex\",\"aria-rowspan\",\"aria-required\",\"aria-readonly\",\"aria-selected\",\"aria-sort\",\"aria-errormessage\"]},owned:null,nameFrom:[\"author\",\"contents\"],context:[\"row\"],implicit:[\"th\"],unsupported:!1},combobox:{type:\"composite\",attributes:{allowed:[\"aria-autocomplete\",\"aria-required\",\"aria-activedescendant\",\"aria-orientation\",\"aria-errormessage\"],required:[\"aria-expanded\"]},owned:{all:[\"listbox\",\"tree\",\"grid\",\"dialog\",\"textbox\"]},nameFrom:[\"author\"],context:null,unsupported:!1,allowedElements:[{nodeName:\"input\",properties:{type:[\"text\",\"search\",\"tel\",\"url\",\"email\"]}}]},command:{nameFrom:[\"author\"],type:\"abstract\",unsupported:!1},complementary:{type:\"landmark\",attributes:{allowed:[\"aria-expanded\",\"aria-errormessage\"]},owned:null,nameFrom:[\"author\"],context:null,implicit:[\"aside\"],unsupported:!1,allowedElements:[\"section\"]},composite:{nameFrom:[\"author\"],type:\"abstract\",unsupported:!1},contentinfo:{type:\"landmark\",attributes:{allowed:[\"aria-expanded\",\"aria-errormessage\"]},owned:null,nameFrom:[\"author\"],context:null,implicit:[\"footer\"],unsupported:!1,allowedElements:[\"section\"]},definition:{type:\"structure\",attributes:{allowed:[\"aria-expanded\",\"aria-errormessage\"]},owned:null,nameFrom:[\"author\"],context:null,implicit:[\"dd\",\"dfn\"],unsupported:!1},dialog:{type:\"widget\",attributes:{allowed:[\"aria-expanded\",\"aria-modal\",\"aria-errormessage\"]},owned:null,nameFrom:[\"author\"],context:null,implicit:[\"dialog\"],unsupported:!1,allowedElements:[\"section\"]},directory:{type:\"structure\",attributes:{allowed:[\"aria-expanded\",\"aria-errormessage\"]},owned:null,nameFrom:[\"author\",\"contents\"],context:null,unsupported:!1,allowedElements:[\"ol\",\"ul\"]},document:{type:\"structure\",attributes:{allowed:[\"aria-expanded\",\"aria-errormessage\"]},owned:null,nameFrom:[\"author\"],context:null,implicit:[\"body\"],unsupported:!1,allowedElements:[\"article\",\"embed\",\"iframe\",\"object\",\"section\",\"svg\"]},\"doc-abstract\":{type:\"section\",attributes:{allowed:[\"aria-expanded\",\"aria-errormessage\"]},owned:null,nameFrom:[\"author\"],context:null,unsupported:!1,allowedElements:[\"section\"]},\"doc-acknowledgments\":{type:\"landmark\",attributes:{allowed:[\"aria-expanded\",\"aria-errormessage\"]},owned:null,nameFrom:[\"author\"],context:null,unsupported:!1,allowedElements:[\"section\"]},\"doc-afterword\":{type:\"landmark\",attributes:{allowed:[\"aria-expanded\",\"aria-errormessage\"]},owned:null,nameFrom:[\"author\"],context:null,unsupported:!1,allowedElements:[\"section\"]},\"doc-appendix\":{type:\"landmark\",attributes:{allowed:[\"aria-expanded\",\"aria-errormessage\"]},owned:null,nameFrom:[\"author\"],context:null,unsupported:!1,allowedElements:[\"section\"]},\"doc-backlink\":{type:\"link\",attributes:{allowed:[\"aria-expanded\",\"aria-errormessage\"]},owned:null,nameFrom:[\"author\",\"contents\"],context:null,unsupported:!1,allowedElements:[{nodeName:\"a\",attributes:{href:gl}}]},\"doc-biblioentry\":{type:\"listitem\",attributes:{allowed:[\"aria-expanded\",\"aria-level\",\"aria-posinset\",\"aria-setsize\",\"aria-errormessage\"]},owned:null,nameFrom:[\"author\"],context:[\"doc-bibliography\"],unsupported:!1,allowedElements:[\"li\"]},\"doc-bibliography\":{type:\"landmark\",attributes:{allowed:[\"aria-expanded\",\"aria-errormessage\"]},owned:{one:[\"doc-biblioentry\"]},nameFrom:[\"author\"],context:null,unsupported:!1,allowedElements:[\"section\"]},\"doc-biblioref\":{type:\"link\",attributes:{allowed:[\"aria-expanded\",\"aria-errormessage\"]},owned:null,nameFrom:[\"author\",\"contents\"],context:null,unsupported:!1,allowedElements:[{nodeName:\"a\",attributes:{href:gl}}]},\"doc-chapter\":{type:\"landmark\",attributes:{allowed:[\"aria-expanded\",\"aria-errormessage\"]},owned:null,namefrom:[\"author\"],context:null,unsupported:!1,allowedElements:[\"section\"]},\"doc-colophon\":{type:\"section\",attributes:{allowed:[\"aria-expanded\",\"aria-errormessage\"]},owned:null,namefrom:[\"author\"],context:null,unsupported:!1,allowedElements:[\"section\"]},\"doc-conclusion\":{type:\"landmark\",attributes:{allowed:[\"aria-expanded\",\"aria-errormessage\"]},owned:null,namefrom:[\"author\"],context:null,unsupported:!1,allowedElements:[\"section\"]},\"doc-cover\":{type:\"img\",attributes:{allowed:[\"aria-expanded\",\"aria-errormessage\"]},owned:null,namefrom:[\"author\"],context:null,unsupported:!1},\"doc-credit\":{type:\"section\",attributes:{allowed:[\"aria-expanded\",\"aria-errormessage\"]},owned:null,namefrom:[\"author\"],context:null,unsupported:!1,allowedElements:[\"section\"]},\"doc-credits\":{type:\"landmark\",attributes:{allowed:[\"aria-expanded\",\"aria-errormessage\"]},owned:null,namefrom:[\"author\"],context:null,unsupported:!1,allowedElements:[\"section\"]},\"doc-dedication\":{type:\"section\",attributes:{allowed:[\"aria-expanded\",\"aria-errormessage\"]},owned:null,namefrom:[\"author\"],context:null,unsupported:!1,allowedElements:[\"section\"]},\"doc-endnote\":{type:\"listitem\",attributes:{allowed:[\"aria-expanded\",\"aria-level\",\"aria-posinset\",\"aria-setsize\",\"aria-errormessage\"]},owned:null,namefrom:[\"author\"],context:[\"doc-endnotes\"],unsupported:!1,allowedElements:[\"li\"]},\"doc-endnotes\":{type:\"landmark\",attributes:{allowed:[\"aria-expanded\",\"aria-errormessage\"]},owned:{one:[\"doc-endnote\"]},namefrom:[\"author\"],context:null,unsupported:!1,allowedElements:[\"section\"]},\"doc-epigraph\":{type:\"section\",attributes:{allowed:[\"aria-expanded\",\"aria-errormessage\"]},owned:null,namefrom:[\"author\"],context:null,unsupported:!1},\"doc-epilogue\":{type:\"landmark\",attributes:{allowed:[\"aria-expanded\",\"aria-errormessage\"]},owned:null,namefrom:[\"author\"],context:null,unsupported:!1,allowedElements:[\"section\"]},\"doc-errata\":{type:\"landmark\",attributes:{allowed:[\"aria-expanded\",\"aria-errormessage\"]},owned:null,namefrom:[\"author\"],context:null,unsupported:!1,allowedElements:[\"section\"]},\"doc-example\":{type:\"section\",attributes:{allowed:[\"aria-expanded\",\"aria-errormessage\"]},owned:null,namefrom:[\"author\"],context:null,unsupported:!1,allowedElements:[\"aside\",\"section\"]},\"doc-footnote\":{type:\"section\",attributes:{allowed:[\"aria-expanded\",\"aria-errormessage\"]},owned:null,namefrom:[\"author\"],context:null,unsupported:!1,allowedElements:[\"aside\",\"footer\",\"header\"]},\"doc-foreword\":{type:\"landmark\",attributes:{allowed:[\"aria-expanded\",\"aria-errormessage\"]},owned:null,namefrom:[\"author\"],context:null,unsupported:!1,allowedElements:[\"section\"]},\"doc-glossary\":{type:\"landmark\",attributes:{allowed:[\"aria-expanded\",\"aria-errormessage\"]},owned:[\"term\",\"definition\"],namefrom:[\"author\"],context:null,unsupported:!1,allowedElements:[\"dl\"]},\"doc-glossref\":{type:\"link\",attributes:{allowed:[\"aria-expanded\",\"aria-errormessage\"]},owned:null,namefrom:[\"author\",\"contents\"],context:null,unsupported:!1,allowedElements:[{nodeName:\"a\",attributes:{href:gl}}]},\"doc-index\":{type:\"navigation\",attributes:{allowed:[\"aria-expanded\",\"aria-errormessage\"]},owned:null,namefrom:[\"author\"],context:null,unsupported:!1,allowedElements:[\"nav\",\"section\"]},\"doc-introduction\":{type:\"landmark\",attributes:{allowed:[\"aria-expanded\",\"aria-errormessage\"]},owned:null,namefrom:[\"author\"],context:null,unsupported:!1,allowedElements:[\"section\"]},\"doc-noteref\":{type:\"link\",attributes:{allowed:[\"aria-expanded\"]},owned:null,namefrom:[\"author\",\"contents\"],context:null,unsupported:!1,allowedElements:[{nodeName:\"a\",attributes:{href:gl}}]},\"doc-notice\":{type:\"note\",attributes:{allowed:[\"aria-expanded\"]},owned:null,namefrom:[\"author\"],context:null,unsupported:!1,allowedElements:[\"section\"]},\"doc-pagebreak\":{type:\"separator\",attributes:{allowed:[\"aria-expanded\"]},owned:null,namefrom:[\"author\"],context:null,unsupported:!1,allowedElements:[\"hr\"]},\"doc-pagelist\":{type:\"navigation\",attributes:{allowed:[\"aria-expanded\"]},owned:null,namefrom:[\"author\"],context:null,unsupported:!1,allowedElements:[\"nav\",\"section\"]},\"doc-part\":{type:\"landmark\",attributes:{allowed:[\"aria-expanded\"]},owned:null,namefrom:[\"author\"],context:null,unsupported:!1,allowedElements:[\"section\"]},\"doc-preface\":{type:\"landmark\",attributes:{allowed:[\"aria-expanded\"]},owned:null,namefrom:[\"author\"],context:null,unsupported:!1,allowedElements:[\"section\"]},\"doc-prologue\":{type:\"landmark\",attributes:{allowed:[\"aria-expanded\",\"aria-errormessage\"]},owned:null,namefrom:[\"author\"],context:null,unsupported:!1,allowedElements:[\"section\"]},\"doc-pullquote\":{type:\"none\",attributes:{allowed:[\"aria-expanded\"]},owned:null,namefrom:[\"author\"],context:null,unsupported:!1,allowedElements:[\"aside\",\"section\"]},\"doc-qna\":{type:\"section\",attributes:{allowed:[\"aria-expanded\"]},owned:null,namefrom:[\"author\"],context:null,unsupported:!1,allowedElements:[\"section\"]},\"doc-subtitle\":{type:\"sectionhead\",attributes:{allowed:[\"aria-expanded\"]},owned:null,namefrom:[\"author\"],context:null,unsupported:!1,allowedElements:{nodeName:[\"h1\",\"h2\",\"h3\",\"h4\",\"h5\",\"h6\"]}},\"doc-tip\":{type:\"note\",attributes:{allowed:[\"aria-expanded\"]},owned:null,namefrom:[\"author\"],context:null,unsupported:!1,allowedElements:[\"aside\"]},\"doc-toc\":{type:\"navigation\",attributes:{allowed:[\"aria-expanded\",\"aria-errormessage\"]},owned:null,namefrom:[\"author\"],context:null,unsupported:!1,allowedElements:[\"nav\",\"section\"]},feed:{type:\"structure\",attributes:{allowed:[\"aria-expanded\",\"aria-errormessage\"]},owned:{one:[\"article\"]},nameFrom:[\"author\"],context:null,unsupported:!1,allowedElements:[\"article\",\"aside\",\"section\"]},figure:{type:\"structure\",attributes:{allowed:[\"aria-expanded\",\"aria-errormessage\"]},owned:null,nameFrom:[\"author\",\"contents\"],context:null,implicit:[\"figure\"],unsupported:!1},form:{type:\"landmark\",attributes:{allowed:[\"aria-expanded\",\"aria-errormessage\"]},owned:null,nameFrom:[\"author\"],context:null,implicit:[\"form\"],unsupported:!1},grid:{type:\"composite\",attributes:{allowed:[\"aria-activedescendant\",\"aria-expanded\",\"aria-colcount\",\"aria-level\",\"aria-multiselectable\",\"aria-readonly\",\"aria-rowcount\",\"aria-errormessage\"]},owned:{one:[\"rowgroup\",\"row\"]},nameFrom:[\"author\"],context:null,implicit:[\"table\"],unsupported:!1},gridcell:{type:\"widget\",attributes:{allowed:[\"aria-colindex\",\"aria-colspan\",\"aria-expanded\",\"aria-rowindex\",\"aria-rowspan\",\"aria-selected\",\"aria-readonly\",\"aria-required\",\"aria-errormessage\"]},owned:null,nameFrom:[\"author\",\"contents\"],context:[\"row\"],implicit:[\"td\",\"th\"],unsupported:!1},group:{type:\"structure\",attributes:{allowed:[\"aria-activedescendant\",\"aria-expanded\",\"aria-errormessage\"]},owned:null,nameFrom:[\"author\"],context:null,implicit:[\"details\",\"optgroup\"],unsupported:!1,allowedElements:[\"dl\",\"figcaption\",\"fieldset\",\"figure\",\"footer\",\"header\",\"ol\",\"ul\"]},heading:{type:\"structure\",attributes:{required:[\"aria-level\"],allowed:[\"aria-expanded\",\"aria-errormessage\"]},owned:null,nameFrom:[\"author\",\"contents\"],context:null,implicit:[\"h1\",\"h2\",\"h3\",\"h4\",\"h5\",\"h6\"],unsupported:!1},img:{type:\"structure\",attributes:{allowed:[\"aria-expanded\",\"aria-errormessage\"]},owned:null,nameFrom:[\"author\"],context:null,implicit:[\"img\"],unsupported:!1,allowedElements:[\"embed\",\"iframe\",\"object\",\"svg\"]},input:{nameFrom:[\"author\"],type:\"abstract\",unsupported:!1},landmark:{nameFrom:[\"author\"],type:\"abstract\",unsupported:!1},link:{type:\"widget\",attributes:{allowed:[\"aria-expanded\",\"aria-errormessage\"]},owned:null,nameFrom:[\"author\",\"contents\"],context:null,implicit:[\"a[href]\",\"area[href]\"],unsupported:!1,allowedElements:[\"button\",{nodeName:\"input\",properties:{type:[\"image\",\"button\"]}}]},list:{type:\"structure\",attributes:{allowed:[\"aria-expanded\",\"aria-errormessage\"]},owned:{all:[\"listitem\"]},nameFrom:[\"author\"],context:null,implicit:[\"ol\",\"ul\",\"dl\"],unsupported:!1},listbox:{type:\"composite\",attributes:{allowed:[\"aria-activedescendant\",\"aria-multiselectable\",\"aria-readonly\",\"aria-required\",\"aria-expanded\",\"aria-orientation\",\"aria-errormessage\"]},owned:{all:[\"option\"]},nameFrom:[\"author\"],context:null,implicit:[\"select\"],unsupported:!1,allowedElements:[\"ol\",\"ul\"]},listitem:{type:\"structure\",attributes:{allowed:[\"aria-level\",\"aria-posinset\",\"aria-setsize\",\"aria-expanded\",\"aria-errormessage\"]},owned:null,nameFrom:[\"author\",\"contents\"],context:[\"list\"],implicit:[\"li\",\"dt\"],unsupported:!1},log:{type:\"widget\",attributes:{allowed:[\"aria-expanded\",\"aria-errormessage\"]},owned:null,nameFrom:[\"author\"],context:null,unsupported:!1,allowedElements:[\"section\"]},main:{type:\"landmark\",attributes:{allowed:[\"aria-expanded\",\"aria-errormessage\"]},owned:null,nameFrom:[\"author\"],context:null,implicit:[\"main\"],unsupported:!1,allowedElements:[\"article\",\"section\"]},marquee:{type:\"widget\",attributes:{allowed:[\"aria-expanded\",\"aria-errormessage\"]},owned:null,nameFrom:[\"author\"],context:null,unsupported:!1,allowedElements:[\"section\"]},math:{type:\"structure\",attributes:{allowed:[\"aria-expanded\",\"aria-errormessage\"]},owned:null,nameFrom:[\"author\"],context:null,implicit:[\"math\"],unsupported:!1},menu:{type:\"composite\",attributes:{allowed:[\"aria-activedescendant\",\"aria-expanded\",\"aria-orientation\",\"aria-errormessage\"]},owned:{one:[\"menuitem\",\"menuitemradio\",\"menuitemcheckbox\"]},nameFrom:[\"author\"],context:null,implicit:['menu[type=\"context\"]'],unsupported:!1,allowedElements:[\"ol\",\"ul\"]},menubar:{type:\"composite\",attributes:{allowed:[\"aria-activedescendant\",\"aria-expanded\",\"aria-orientation\",\"aria-errormessage\"]},owned:{one:[\"menuitem\",\"menuitemradio\",\"menuitemcheckbox\"]},nameFrom:[\"author\"],context:null,unsupported:!1,allowedElements:[\"ol\",\"ul\"]},menuitem:{type:\"widget\",attributes:{allowed:[\"aria-posinset\",\"aria-setsize\",\"aria-expanded\",\"aria-errormessage\"]},owned:null,nameFrom:[\"author\",\"contents\"],context:[\"menu\",\"menubar\"],implicit:['menuitem[type=\"command\"]'],unsupported:!1,allowedElements:[\"button\",\"li\",{nodeName:\"iput\",properties:{type:[\"image\",\"button\"]}},{nodeName:\"a\",attributes:{href:gl}}]},menuitemcheckbox:{type:\"widget\",attributes:{allowed:[\"aria-checked\",\"aria-posinset\",\"aria-setsize\",\"aria-errormessage\"]},owned:null,nameFrom:[\"author\",\"contents\"],context:[\"menu\",\"menubar\"],implicit:['menuitem[type=\"checkbox\"]'],unsupported:!1,allowedElements:[{nodeName:[\"button\",\"li\"]},{nodeName:\"input\",properties:{type:[\"checkbox\",\"image\",\"button\"]}},{nodeName:\"a\",attributes:{href:gl}}]},menuitemradio:{type:\"widget\",attributes:{allowed:[\"aria-checked\",\"aria-selected\",\"aria-posinset\",\"aria-setsize\",\"aria-errormessage\"]},owned:null,nameFrom:[\"author\",\"contents\"],context:[\"menu\",\"menubar\"],implicit:['menuitem[type=\"radio\"]'],unsupported:!1,allowedElements:[{nodeName:[\"button\",\"li\"]},{nodeName:\"input\",properties:{type:[\"image\",\"button\",\"radio\"]}},{nodeName:\"a\",attributes:{href:gl}}]},navigation:{type:\"landmark\",attributes:{allowed:[\"aria-expanded\",\"aria-errormessage\"]},owned:null,nameFrom:[\"author\"],context:null,implicit:[\"nav\"],unsupported:!1,allowedElements:[\"section\"]},none:{type:\"structure\",attributes:null,owned:null,nameFrom:[\"author\"],context:null,unsupported:!1,allowedElements:[{nodeName:[\"article\",\"aside\",\"dl\",\"embed\",\"figcaption\",\"fieldset\",\"figure\",\"footer\",\"form\",\"h1\",\"h2\",\"h3\",\"h4\",\"h5\",\"h6\",\"header\",\"hr\",\"iframe\",\"li\",\"ol\",\"section\",\"ul\"]},{nodeName:\"img\",attributes:{alt:gl}}]},note:{type:\"structure\",attributes:{allowed:[\"aria-expanded\",\"aria-errormessage\"]},owned:null,nameFrom:[\"author\"],context:null,unsupported:!1,allowedElements:[\"aside\"]},option:{type:\"widget\",attributes:{allowed:[\"aria-selected\",\"aria-posinset\",\"aria-setsize\",\"aria-checked\",\"aria-errormessage\"]},owned:null,nameFrom:[\"author\",\"contents\"],context:[\"listbox\"],implicit:[\"option\"],unsupported:!1,allowedElements:[{nodeName:[\"button\",\"li\"]},{nodeName:\"input\",properties:{type:[\"checkbox\",\"button\"]}},{nodeName:\"a\",attributes:{href:gl}}]},presentation:{type:\"structure\",attributes:null,owned:null,nameFrom:[\"author\"],context:null,unsupported:!1,allowedElements:[{nodeName:[\"article\",\"aside\",\"dl\",\"embed\",\"figcaption\",\"fieldset\",\"figure\",\"footer\",\"form\",\"h1\",\"h2\",\"h3\",\"h4\",\"h5\",\"h6\",\"header\",\"hr\",\"iframe\",\"li\",\"ol\",\"section\",\"ul\"]},{nodeName:\"img\",attributes:{alt:gl}}]},progressbar:{type:\"widget\",attributes:{allowed:[\"aria-valuetext\",\"aria-valuenow\",\"aria-valuemax\",\"aria-valuemin\",\"aria-expanded\",\"aria-errormessage\"]},owned:null,nameFrom:[\"author\"],context:null,implicit:[\"progress\"],unsupported:!1},radio:{type:\"widget\",attributes:{allowed:[\"aria-selected\",\"aria-posinset\",\"aria-setsize\",\"aria-required\",\"aria-errormessage\",\"aria-checked\"]},owned:null,nameFrom:[\"author\",\"contents\"],context:null,implicit:['input[type=\"radio\"]'],unsupported:!1,allowedElements:[{nodeName:[\"button\",\"li\"]},{nodeName:\"input\",properties:{type:[\"image\",\"button\"]}}]},radiogroup:{type:\"composite\",attributes:{allowed:[\"aria-activedescendant\",\"aria-required\",\"aria-expanded\",\"aria-readonly\",\"aria-errormessage\",\"aria-orientation\"]},owned:{all:[\"radio\"]},nameFrom:[\"author\"],context:null,unsupported:!1,allowedElements:{nodeName:[\"ol\",\"ul\",\"fieldset\"]}},range:{nameFrom:[\"author\"],type:\"abstract\",unsupported:!1},region:{type:\"landmark\",attributes:{allowed:[\"aria-expanded\",\"aria-errormessage\"]},owned:null,nameFrom:[\"author\"],context:null,implicit:[\"section[aria-label]\",\"section[aria-labelledby]\",\"section[title]\"],unsupported:!1,allowedElements:{nodeName:[\"article\",\"aside\"]}},roletype:{type:\"abstract\",unsupported:!1},row:{type:\"structure\",attributes:{allowed:[\"aria-activedescendant\",\"aria-colindex\",\"aria-expanded\",\"aria-level\",\"aria-selected\",\"aria-rowindex\",\"aria-errormessage\"]},owned:{one:[\"cell\",\"columnheader\",\"rowheader\",\"gridcell\"]},nameFrom:[\"author\",\"contents\"],context:[\"rowgroup\",\"grid\",\"treegrid\",\"table\"],implicit:[\"tr\"],unsupported:!1},rowgroup:{type:\"structure\",attributes:{allowed:[\"aria-activedescendant\",\"aria-expanded\",\"aria-errormessage\"]},owned:{all:[\"row\"]},nameFrom:[\"author\",\"contents\"],context:[\"grid\",\"table\",\"treegrid\"],implicit:[\"tbody\",\"thead\",\"tfoot\"],unsupported:!1},rowheader:{type:\"structure\",attributes:{allowed:[\"aria-colindex\",\"aria-colspan\",\"aria-expanded\",\"aria-rowindex\",\"aria-rowspan\",\"aria-required\",\"aria-readonly\",\"aria-selected\",\"aria-sort\",\"aria-errormessage\"]},owned:null,nameFrom:[\"author\",\"contents\"],context:[\"row\"],implicit:[\"th\"],unsupported:!1},scrollbar:{type:\"widget\",attributes:{required:[\"aria-controls\",\"aria-valuenow\"],allowed:[\"aria-valuetext\",\"aria-orientation\",\"aria-errormessage\",\"aria-valuemax\",\"aria-valuemin\"]},owned:null,nameFrom:[\"author\"],context:null,unsupported:!1},search:{type:\"landmark\",attributes:{allowed:[\"aria-expanded\",\"aria-errormessage\"]},owned:null,nameFrom:[\"author\"],context:null,unsupported:!1,allowedElements:{nodeName:[\"aside\",\"form\",\"section\"]}},searchbox:{type:\"widget\",attributes:{allowed:[\"aria-activedescendant\",\"aria-autocomplete\",\"aria-multiline\",\"aria-readonly\",\"aria-required\",\"aria-placeholder\",\"aria-errormessage\"]},owned:null,nameFrom:[\"author\"],context:null,implicit:['input[type=\"search\"]'],unsupported:!1,allowedElements:{nodeName:\"input\",properties:{type:\"text\"}}},section:{nameFrom:[\"author\",\"contents\"],type:\"abstract\",unsupported:!1},sectionhead:{nameFrom:[\"author\",\"contents\"],type:\"abstract\",unsupported:!1},select:{nameFrom:[\"author\"],type:\"abstract\",unsupported:!1},separator:{type:\"structure\",attributes:{allowed:[\"aria-expanded\",\"aria-orientation\",\"aria-valuenow\",\"aria-valuemax\",\"aria-valuemin\",\"aria-valuetext\",\"aria-errormessage\"]},owned:null,nameFrom:[\"author\"],context:null,implicit:[\"hr\"],unsupported:!1,allowedElements:[\"li\"]},slider:{type:\"widget\",attributes:{allowed:[\"aria-valuetext\",\"aria-orientation\",\"aria-readonly\",\"aria-errormessage\",\"aria-valuemax\",\"aria-valuemin\"],required:[\"aria-valuenow\"]},owned:null,nameFrom:[\"author\"],context:null,implicit:['input[type=\"range\"]'],unsupported:!1},spinbutton:{type:\"widget\",attributes:{allowed:[\"aria-valuetext\",\"aria-required\",\"aria-readonly\",\"aria-errormessage\",\"aria-valuemax\",\"aria-valuemin\"],required:[\"aria-valuenow\"]},owned:null,nameFrom:[\"author\"],context:null,implicit:['input[type=\"number\"]'],unsupported:!1,allowedElements:{nodeName:\"input\",properties:{type:[\"text\",\"tel\"]}}},status:{type:\"widget\",attributes:{allowed:[\"aria-expanded\",\"aria-errormessage\"]},owned:null,nameFrom:[\"author\"],context:null,implicit:[\"output\"],unsupported:!1,allowedElements:[\"section\"]},structure:{type:\"abstract\",unsupported:!1},switch:{type:\"widget\",attributes:{allowed:[\"aria-errormessage\"],required:[\"aria-checked\"]},owned:null,nameFrom:[\"author\",\"contents\"],context:null,unsupported:!1,allowedElements:[\"button\",{nodeName:\"input\",properties:{type:[\"checkbox\",\"image\",\"button\"]}},{nodeName:\"a\",attributes:{href:gl}}]},tab:{type:\"widget\",attributes:{allowed:[\"aria-selected\",\"aria-expanded\",\"aria-setsize\",\"aria-posinset\",\"aria-errormessage\"]},owned:null,nameFrom:[\"author\",\"contents\"],context:[\"tablist\"],unsupported:!1,allowedElements:[{nodeName:[\"button\",\"h1\",\"h2\",\"h3\",\"h4\",\"h5\",\"h6\",\"li\"]},{nodeName:\"input\",properties:{type:\"button\"}},{nodeName:\"a\",attributes:{href:gl}}]},table:{type:\"structure\",attributes:{allowed:[\"aria-colcount\",\"aria-rowcount\",\"aria-errormessage\"]},owned:{one:[\"rowgroup\",\"row\"]},nameFrom:[\"author\",\"contents\"],context:null,implicit:[\"table\"],unsupported:!1},tablist:{type:\"composite\",attributes:{allowed:[\"aria-activedescendant\",\"aria-expanded\",\"aria-level\",\"aria-multiselectable\",\"aria-orientation\",\"aria-errormessage\"]},owned:{all:[\"tab\"]},nameFrom:[\"author\"],context:null,unsupported:!1,allowedElements:[\"ol\",\"ul\"]},tabpanel:{type:\"widget\",attributes:{allowed:[\"aria-expanded\",\"aria-errormessage\"]},owned:null,nameFrom:[\"author\"],context:null,unsupported:!1,allowedElements:[\"section\"]},term:{type:\"structure\",attributes:{allowed:[\"aria-expanded\",\"aria-errormessage\"]},owned:null,nameFrom:[\"author\",\"contents\"],context:null,implicit:[\"dt\"],unsupported:!1},textbox:{type:\"widget\",attributes:{allowed:[\"aria-activedescendant\",\"aria-autocomplete\",\"aria-multiline\",\"aria-readonly\",\"aria-required\",\"aria-placeholder\",\"aria-errormessage\"]},owned:null,nameFrom:[\"author\"],context:null,implicit:['input[type=\"text\"]','input[type=\"email\"]','input[type=\"password\"]','input[type=\"tel\"]','input[type=\"url\"]',\"input:not([type])\",\"textarea\"],unsupported:!1},timer:{type:\"widget\",attributes:{allowed:[\"aria-expanded\",\"aria-errormessage\"]},owned:null,nameFrom:[\"author\"],context:null,unsupported:!1},toolbar:{type:\"structure\",attributes:{allowed:[\"aria-activedescendant\",\"aria-expanded\",\"aria-orientation\",\"aria-errormessage\"]},owned:null,nameFrom:[\"author\"],context:null,implicit:['menu[type=\"toolbar\"]'],unsupported:!1,allowedElements:[\"ol\",\"ul\"]},tooltip:{type:\"structure\",attributes:{allowed:[\"aria-expanded\",\"aria-errormessage\"]},owned:null,nameFrom:[\"author\",\"contents\"],context:null,unsupported:!1},tree:{type:\"composite\",attributes:{allowed:[\"aria-activedescendant\",\"aria-multiselectable\",\"aria-required\",\"aria-expanded\",\"aria-orientation\",\"aria-errormessage\"]},owned:{all:[\"treeitem\"]},nameFrom:[\"author\"],context:null,unsupported:!1,allowedElements:[\"ol\",\"ul\"]},treegrid:{type:\"composite\",attributes:{allowed:[\"aria-activedescendant\",\"aria-colcount\",\"aria-expanded\",\"aria-level\",\"aria-multiselectable\",\"aria-readonly\",\"aria-required\",\"aria-rowcount\",\"aria-orientation\",\"aria-errormessage\"]},owned:{one:[\"rowgroup\",\"row\"]},nameFrom:[\"author\"],context:null,unsupported:!1},treeitem:{type:\"widget\",attributes:{allowed:[\"aria-checked\",\"aria-selected\",\"aria-expanded\",\"aria-level\",\"aria-posinset\",\"aria-setsize\",\"aria-errormessage\"]},owned:null,nameFrom:[\"author\",\"contents\"],context:[\"group\",\"tree\"],unsupported:!1,allowedElements:[\"li\",{nodeName:\"a\",attributes:{href:gl}}]},widget:{type:\"abstract\",unsupported:!1},window:{nameFrom:[\"author\"],type:\"abstract\",unsupported:!1}},bl.implicitHtmlRole=Wo,bl.elementsAllowedNoRole=[{nodeName:[\"base\",\"body\",\"caption\",\"col\",\"colgroup\",\"datalist\",\"dd\",\"details\",\"dt\",\"head\",\"html\",\"keygen\",\"label\",\"legend\",\"main\",\"map\",\"math\",\"meta\",\"meter\",\"noscript\",\"optgroup\",\"param\",\"picture\",\"progress\",\"script\",\"source\",\"style\",\"template\",\"textarea\",\"title\",\"track\"]},{nodeName:\"area\",attributes:{href:gl}},{nodeName:\"input\",properties:{type:[\"color\",\"data\",\"datatime\",\"file\",\"hidden\",\"month\",\"number\",\"password\",\"range\",\"reset\",\"submit\",\"time\",\"week\"]}},{nodeName:\"link\",attributes:{href:gl}},{nodeName:\"menu\",attributes:{type:\"context\"}},{nodeName:\"menuitem\",attributes:{type:[\"command\",\"checkbox\",\"radio\"]}},{nodeName:\"select\",condition:function(e){return e instanceof axe.AbstractVirtualNode||(e=axe.utils.getNodeFromTree(e)),1<Number(e.attr(\"size\"))},properties:{multiple:!0}},{nodeName:[\"clippath\",\"cursor\",\"defs\",\"desc\",\"feblend\",\"fecolormatrix\",\"fecomponenttransfer\",\"fecomposite\",\"feconvolvematrix\",\"fediffuselighting\",\"fedisplacementmap\",\"fedistantlight\",\"fedropshadow\",\"feflood\",\"fefunca\",\"fefuncb\",\"fefuncg\",\"fefuncr\",\"fegaussianblur\",\"feimage\",\"femerge\",\"femergenode\",\"femorphology\",\"feoffset\",\"fepointlight\",\"fespecularlighting\",\"fespotlight\",\"fetile\",\"feturbulence\",\"filter\",\"hatch\",\"hatchpath\",\"lineargradient\",\"marker\",\"mask\",\"meshgradient\",\"meshpatch\",\"meshrow\",\"metadata\",\"mpath\",\"pattern\",\"radialgradient\",\"solidcolor\",\"stop\",\"switch\",\"view\"]}],bl.elementsAllowedAnyRole=[{nodeName:\"a\",attributes:{href:hl}},{nodeName:\"img\",attributes:{alt:hl}},{nodeName:[\"abbr\",\"address\",\"canvas\",\"div\",\"p\",\"pre\",\"blockquote\",\"ins\",\"del\",\"output\",\"span\",\"table\",\"tbody\",\"thead\",\"tfoot\",\"td\",\"em\",\"strong\",\"small\",\"s\",\"cite\",\"q\",\"dfn\",\"abbr\",\"time\",\"code\",\"var\",\"samp\",\"kbd\",\"sub\",\"sup\",\"i\",\"b\",\"u\",\"mark\",\"ruby\",\"rt\",\"rp\",\"bdi\",\"bdo\",\"br\",\"wbr\",\"th\",\"tr\"]}],bl.evaluateRoleForElement={A:function(e){var t=e.node,e=e.out;return\"http://www.w3.org/2000/svg\"===t.namespaceURI||(!t.href.length||e)},AREA:function(e){return!e.node.href},BUTTON:function(e){var t=e.node,r=e.role,e=e.out;return\"menu\"===t.getAttribute(\"type\")?\"menuitem\"===r:e},IMG:function(e){var t=e.node,r=e.role,a=e.out;switch(t.alt){case null:return a;case\"\":return\"presentation\"===r||\"none\"===r;default:return\"presentation\"!==r&&\"none\"!==r}},INPUT:function(e){var t=e.node,r=e.role,a=e.out;switch(t.type){case\"button\":case\"image\":return a;case\"checkbox\":return\"button\"===r&&t.hasAttribute(\"aria-pressed\")?!0:a;case\"radio\":return\"menuitemradio\"===r;case\"text\":return\"combobox\"===r||\"searchbox\"===r||\"spinbutton\"===r;case\"tel\":return\"combobox\"===r||\"spinbutton\"===r;case\"url\":case\"search\":case\"email\":return\"combobox\"===r;default:return!1}},LI:function(e){var t=e.node,e=e.out;return!axe.utils.matchesSelector(t,\"ol li, ul li\")||e},MENU:function(e){return\"context\"!==e.node.getAttribute(\"type\")},OPTION:function(e){e=e.node;return!axe.utils.matchesSelector(e,\"select > option, datalist > option, optgroup > option\")},SELECT:function(e){var t=e.node,e=e.role;return!t.multiple&&t.size<=1&&\"menu\"===e},SVG:function(e){var t=e.node,e=e.out;return!(!t.parentNode||\"http://www.w3.org/2000/svg\"!==t.parentNode.namespaceURI)||e}},bl.rolesOfType={widget:[\"button\",\"checkbox\",\"dialog\",\"gridcell\",\"link\",\"log\",\"marquee\",\"menuitem\",\"menuitemcheckbox\",\"menuitemradio\",\"option\",\"progressbar\",\"radio\",\"scrollbar\",\"searchbox\",\"slider\",\"spinbutton\",\"status\",\"switch\",\"tab\",\"tabpanel\",\"textbox\",\"timer\",\"tooltip\",\"tree\",\"treeitem\"]};var yl=bl;var vl=function(e){var t=null,e=yl.role[e];return t=e&&e.implicit?Ar(e.implicit):t};var Dl=function(e){return!!il(e).length};var wl=function(e){return e=Dr(e),Sa(e)};var xl=function(e){return(e=nn.ariaRoles[e])&&Array.isArray(e.requiredAttrs)?Yu(e.requiredAttrs):[]};var El=function(e){return(e=nn.ariaRoles[e])&&Array.isArray(e.requiredContext)?Yu(e.requiredContext):null};var Al=function(e){return(e=nn.ariaRoles[e])&&Array.isArray(e.requiredOwned)?Yu(e.requiredOwned):null};var Cl=function(e,t){var r,a=e.getAttribute(t),n=nn.ariaAttrs[t],o=na(e);if(!n)return!0;if(n.allowEmpty&&(!a||\"\"===a.trim()))return!0;switch(n.type){case\"boolean\":return[\"true\",\"false\"].includes(a.toLowerCase());case\"nmtoken\":return\"string\"==typeof a&&n.values.includes(a.toLowerCase());case\"nmtokens\":return(r=Co(a)).reduce(function(e,t){return e&&n.values.includes(t)},0!==r.length);case\"idref\":return!(!a||!o.getElementById(a));case\"idrefs\":return(r=Co(a)).some(function(e){return o.getElementById(e)});case\"string\":return\"\"!==a.trim();case\"decimal\":return!(!(i=a.match(/^[-+]?([0-9]*)\\.?([0-9]*)$/))||!i[1]&&!i[2]);case\"int\":var i=void 0!==n.minValue?n.minValue:-1/0;return/^[-+]?[0-9]+$/.test(a)&&parseInt(a)>=i}};var Fl=function(e){return!!nn.ariaAttrs[e]};function kl(e,t,r){return 0<(r=Co(r.attr(\"role\")).filter(function(e){return\"abstract\"===ll(e)})).length&&(this.data(r),!0)}function Rl(e,t,r){var a=[],n=di(r),o=r.attrNames,i=So(n);if(Array.isArray(t[n])&&(i=io(t[n].concat(i))),n&&i)for(var l=0;l<o.length;l++){var s=o[l];Fl(s)&&!i.includes(s)&&a.push(s+'=\"'+r.attr(s)+'\"')}return!a.length||(this.data(a),!1)}function Tl(e){var t=void 0===(a=(r=1<arguments.length&&void 0!==arguments[1]?arguments[1]:{}).allowImplicit)||a,r=void 0===(a=r.ignoredTags)?[]:a,a=e.nodeName.toUpperCase();return!!r.map(function(e){return e.toUpperCase()}).includes(a)||(!(t=cl(e,t)).length||(this.data(t),!ba(e,!0)&&void 0))}function Nl(r,e){e=Array.isArray(e)?e:[];var t=r.getAttribute(\"aria-errormessage\"),a=r.hasAttribute(\"aria-errormessage\"),n=r.getAttribute(\"aria-invalid\");if(!r.hasAttribute(\"aria-invalid\")||\"false\"===n)return!0;var o=na(r);return-1!==e.indexOf(t)||!a||(this.data(Co(t)),function(e){if(\"\"===e.trim())return nn.ariaAttrs[\"aria-errormessage\"].allowEmpty;var t=e&&o.getElementById(e);return t?\"alert\"===t.getAttribute(\"role\")||\"assertive\"===t.getAttribute(\"aria-live\")||\"polite\"===t.getAttribute(\"aria-live\")||-1<Co(r.getAttribute(\"aria-describedby\")).indexOf(e):void 0}(t))}function _l(e,t,r){return\"true\"!==r.attr(\"aria-hidden\")}function Ol(e){var t=1<arguments.length&&void 0!==arguments[1]?arguments[1]:{},r=2<arguments.length?arguments[2]:void 0,t=t.elementsAllowedAriaLabel||[];return 0!==(t=function(e,t){var r=di(e,{chromium:!0}),a=nn.ariaRoles[r];if(a)return a.prohibitedAttrs||[];e=e.props.nodeName;return r||t.includes(e)?[]:[\"aria-label\",\"aria-labelledby\"]}(r,t).filter(function(e){return!!r.attrNames.includes(e)&&\"\"!==ka(r.attr(e))})).length&&(this.data(t),!(\"\"!==ka(bi(r)))||void 0)}var Sl={};o(Sl,{getAriaRolesByType:function(){return dl},getAriaRolesSupportingNameFromContent:function(){return fl},getElementSpec:function(){return ii},getElementsByContentType:function(){return qo},getGlobalAriaAttrs:function(){return Oo},implicitHtmlRoles:function(){return Wo}});function Pl(e){var t=1<arguments.length&&void 0!==arguments[1]?arguments[1]:{},r=2<arguments.length?arguments[2]:void 0,a=[];if(r.attrNames.length){var n=Lo(r),o=xl(n),i=ii(r);if(Array.isArray(t[n])&&(o=io(t[n],o)),n&&o)for(var l=0,s=o.length;l<s;l++){var u=o[l];r.attr(u)||i.implicitAttrs&&void 0!==i.implicitAttrs[u]||a.push(u)}}return!a.length||(this.data(a),!1)}function Il(e,r){for(var a=[],n=hi(e),t=0;t<n.length;t++)!function(e){var e=n[e],t=di(e,{noPresentational:!0});!t||[\"group\",\"rowgroup\"].includes(t)&&r.some(function(e){return e===t})?n.push.apply(n,Yu(e.children)):t&&a.push(t)}(t);return a}function Bl(e,t,r){var a=t&&Array.isArray(t.reviewEmpty)?t.reviewEmpty:[],n=Lo(r,{dpub:!0}),o=Al(n);return null===o||(t=Il(r,o),!(o=function(e,t,r,a){var n,o,i,l=\"combobox\"===t;l&&((\"input\"===e.props.nodeName&&[\"text\",\"search\",\"email\",\"url\",\"tel\"].includes(e.props.type)||a.includes(\"searchbox\"))&&(r=r.filter(function(e){return\"textbox\"!==e})),n=[\"listbox\",\"tree\",\"grid\",\"dialog\"],t=e.attr(\"aria-expanded\"),o=t&&\"false\"!==t.toLowerCase(),i=(e.attr(\"aria-haspopup\")||\"listbox\").toLowerCase(),r=r.filter(function(e){return!n.includes(e)||o&&e===i}));for(var s=0;s<a.length;s++){var u=a[s];if(r.includes(u)&&(r=r.filter(function(e){return e!==u}),!l))return null}return r.length?r:null}(r,n,o,t))||(this.data(o),!(!a.includes(n)||Ia(r,!1,!0)||t.length||r.hasAttr(\"aria-owns\")&&_a(e,\"aria-owns\").length)&&void 0))}function Ll(e,t,r,a){var n=Lo(e);if(!(r=r||El(n)))return null;for(var o=a?e:e.parent;o;){var i=di(o);if(r.includes(\"group\")&&\"group\"===i)t.includes(n)&&r.push(n),o=o.parent;else{if(r.includes(i))return null;if(i&&![\"presentation\",\"none\"].includes(i))return r;o=o.parent}}return r}function ql(e,t,r){var a=t&&Array.isArray(t.ownGroupRoles)?t.ownGroupRoles:[],n=Ll(r,a);if(!n)return!0;var o=function(e){for(var t,r=[],a=null;e;)e.getAttribute(\"id\")&&(t=Kt(e.getAttribute(\"id\")),(a=na(e).querySelector(\"[aria-owns~=\".concat(t,\"]\")))&&r.push(a)),e=e.parentElement;return r.length?r:null}(e);if(o)for(var i=0,l=o.length;i<l;i++)if(!(n=Ll(Dr(o[i]),a,n,!0)))return!0;return this.data(n),!1}function Ml(e){var t=1<arguments.length&&void 0!==arguments[1]?arguments[1]:{},r=di(e);return!!(t.supportedRoles||[]).includes(r)||!(!r||\"presentation\"===r||\"none\"===r)&&void 0}function jl(r,e,t){return!!(t=t.attrNames.filter(function(e){var t=nn.ariaAttrs[e];if(!Fl(e))return!1;t=t.unsupported;return\"object\"!==Lu(t)?!!t:!oi(r,t.exceptions)})).length&&(this.data(t),!0)}function Ul(e,t,r){t=Array.isArray(t.value)?t.value:[];var a=[],n=/^aria-/;return r.attrNames.forEach(function(e){-1===t.indexOf(e)&&n.test(e)&&!Fl(e)&&a.push(e)}),!a.length||(this.data(a),!1)}function Vl(e,t){t=Array.isArray(t.value)?t.value:[];for(var r=\"\",a=\"\",n=[],o=/^aria-/,i=er(e),l=[\"aria-errormessage\"],s={\"aria-controls\":function(){return\"false\"!==e.getAttribute(\"aria-expanded\")&&\"false\"!==e.getAttribute(\"aria-selected\")},\"aria-current\":function(){Cl(e,\"aria-current\")||(r='aria-current=\"'.concat(e.getAttribute(\"aria-current\"),'\"'),a=\"ariaCurrent\")},\"aria-owns\":function(){return\"false\"!==e.getAttribute(\"aria-expanded\")},\"aria-describedby\":function(){Cl(e,\"aria-describedby\")||(r='aria-describedby=\"'.concat(e.getAttribute(\"aria-describedby\"),'\"'),a=\"noId\")},\"aria-labelledby\":function(){Cl(e,\"aria-labelledby\")||(r='aria-labelledby=\"'.concat(e.getAttribute(\"aria-labelledby\"),'\"'),a=\"noId\")}},u=0,c=i.length;u<c;u++){var d=i[u],p=d.name;l.includes(p)||-1!==t.indexOf(p)||!o.test(p)||s[p]&&!s[p]()||Cl(e,p)||n.push(\"\".concat(p,'=\"').concat(d.nodeValue,'\"'))}if(!r)return!n.length||(this.data(n),!1);this.data({messageKey:a,needsReview:r})}function Hl(e,t,r){return 1<Co(r.attr(\"role\")).length}function zl(e,t,r){var a=Oo().filter(function(e){return r.hasAttr(e)});return this.data(a),0<a.length}function $l(e,t){return null!==li(t,{chromium:!0})}function Wl(e){return null!==(e=e.getAttribute(\"role\"))&&(\"widget\"===(e=ll(e))||\"composite\"===e)}function Gl(e,t,r){return!!(r=Co(r.attr(\"role\"))).every(function(e){return!Bo(e,{allowAbstract:!0})})&&(this.data(r),!0)}function Yl(e,t,r){return Va(r)}function Kl(e,t,r){var a,n,o=di(r,{noImplicit:!0});this.data(o);try{a=ka(yi(r)).toLowerCase(),n=ka(Mi(r)).toLowerCase()}catch(e){return}return!(!n&&!a)&&(!((n||!a)&&n.includes(a))&&void 0)}function Xl(e,t,r){return Io(di(r))}var Jl={ARTICLE:!0,ASIDE:!0,NAV:!0,SECTION:!0},Ql={application:!0,banner:!1,complementary:!0,contentinfo:!0,form:!0,main:!0,navigation:!0,region:!0,search:!1};function Zl(e,t){return r=t,(t=Lo(t=e))&&(Ql[t]||r.roles.includes(t))||!1||(t=(t=e).nodeName.toUpperCase(),Jl[t]||!1);var r}var es={};o(es,{getAllCells:function(){return ts},getCellPosition:function(){return jo},getHeaders:function(){return as},getScope:function(){return Uo},isColumnHeader:function(){return Vo},isDataCell:function(){return ns},isDataTable:function(){return os},isHeader:function(){return is},isRowHeader:function(){return Ho},toArray:function(){return Mo},toGrid:function(){return Mo},traverse:function(){return ls}});var ts=function(e){for(var t,r,a=[],n=0,o=e.rows.length;n<o;n++)for(t=0,r=e.rows[n].cells.length;t<r;t++)a.push(e.rows[n].cells[t]);return a};function rs(e,t,r){for(var a,n=\"row\"===e?\"_rowHeaders\":\"_colHeaders\",o=\"row\"===e?Ho:Vo,i=r[t.y][t.x],l=i.colSpan-1,s=i.getAttribute(\"rowspan\"),i=0===parseInt(s)||0===i.rowspan?r.length:i.rowSpan,i=t.y+(i-1),u=t.x+l,c=\"row\"===e?t.y:0,d=\"row\"===e?0:t.x,p=[],f=i;c<=f&&!a;f--)for(var m=u;d<=m;m--){var h=r[f]?r[f][m]:void 0;if(h){var g=axe.utils.getNodeFromTree(h);if(g[n]){a=g[n];break}p.push(h)}}return a=(a||[]).concat(p.filter(o)),p.forEach(function(e){axe.utils.getNodeFromTree(e)[n]=a}),a}var as=function(e,t){if(e.getAttribute(\"headers\")){var r=_a(e,\"headers\");if(r.filter(function(e){return e}).length)return r}return t=t||Mo(la(e,\"table\")),r=jo(e,t),e=rs(\"row\",r,t),t=rs(\"col\",r,t),[].concat(e,t).reverse()};var ns=function(e){if(!e.children.length&&!e.textContent.trim())return!1;var t=e.getAttribute(\"role\");return Bo(t)?[\"cell\",\"gridcell\"].includes(t):\"TD\"===e.nodeName.toUpperCase()};var os=function(e){var t=(e.getAttribute(\"role\")||\"\").toLowerCase();if((\"presentation\"===t||\"none\"===t)&&!Va(e))return!1;if(\"true\"===e.getAttribute(\"contenteditable\")||la(e,'[contenteditable=\"true\"]'))return!0;if(\"grid\"===t||\"treegrid\"===t||\"table\"===t)return!0;if(\"landmark\"===ll(t))return!0;if(\"0\"===e.getAttribute(\"datatable\"))return!1;if(e.getAttribute(\"summary\"))return!0;if(e.tHead||e.tFoot||e.caption)return!0;for(var r=0,a=e.children.length;r<a;r++)if(\"COLGROUP\"===e.children[r].nodeName.toUpperCase())return!0;for(var n,o,i,l=0,s=e.rows.length,u=!1,c=0;c<s;c++)for(var d,p=0,f=(d=e.rows[c]).cells.length;p<f;p++){if(\"TH\"===(n=d.cells[p]).nodeName.toUpperCase())return!0;if(u||n.offsetWidth===n.clientWidth&&n.offsetHeight===n.clientHeight||(u=!0),n.getAttribute(\"scope\")||n.getAttribute(\"headers\")||n.getAttribute(\"abbr\"))return!0;if([\"columnheader\",\"rowheader\"].includes((n.getAttribute(\"role\")||\"\").toLowerCase()))return!0;if(1===n.children.length&&\"ABBR\"===n.children[0].nodeName.toUpperCase())return!0;l++}if(e.getElementsByTagName(\"table\").length)return!1;if(s<2)return!1;if(1===(t=e.rows[Math.ceil(s/2)]).cells.length&&1===t.cells[0].colSpan)return!1;if(5<=t.cells.length)return!0;if(u)return!0;for(c=0;c<s;c++){if(d=e.rows[c],o&&o!==window.getComputedStyle(d).getPropertyValue(\"background-color\"))return!0;if(o=window.getComputedStyle(d).getPropertyValue(\"background-color\"),i&&i!==window.getComputedStyle(d).getPropertyValue(\"background-image\"))return!0;i=window.getComputedStyle(d).getPropertyValue(\"background-image\")}return 20<=s||!(da(e).width>.95*pa(window).width)&&(!(l<10)&&!e.querySelector(\"object, embed, iframe, applet\"))};var is=function(e){if(Vo(e)||Ho(e))return!0;if(e.getAttribute(\"id\")){e=Kt(e.getAttribute(\"id\"));return!!document.querySelector('[headers~=\"'.concat(e,'\"]'))}return!1};var ls=function(e,t,r,a){if(Array.isArray(t)&&(a=r,r=t,t={x:0,y:0}),\"string\"==typeof e)switch(e){case\"left\":e={x:-1,y:0};break;case\"up\":e={x:0,y:-1};break;case\"right\":e={x:1,y:0};break;case\"down\":e={x:0,y:1}}return function e(t,r,a,n){var o,i=a[r.y]?a[r.y][r.x]:void 0;return i?\"function\"==typeof n&&!0===(o=n(i,r,a))?[i]:((o=e(t,{x:r.x+t.x,y:r.y+t.y},a,n)).unshift(i),o):[]}(e,{x:t.x+e.x,y:t.y+e.y},r,a)};function ss(e){var t=Mo(e),a=t[0];return t.length<=1||a.length<=1||e.rows.length<=1||a.reduce(function(e,t,r){return e||t!==a[r+1]&&void 0!==a[r+1]},!1)}function us(e){return!za(document)||\"TH\"===e.nodeName.toUpperCase()}function cs(e){return!(!e.summary||!e.caption)&&e.summary.toLowerCase()===ji(e.caption).toLowerCase()}function ds(e,t){return e=e.getAttribute(\"scope\").toLowerCase(),-1!==t.values.indexOf(e)}function ps(e){var t=[],r=ts(e),a=Mo(e);return r.forEach(function(e){Ba(e)&&ns(e)&&!wl(e)&&(as(e,a).some(function(e){return null!==e&&!!Ba(e)})||t.push(e))}),!t.length||(this.relatedNodes(t),!1)}function fs(e){for(var t=[],n=[],o=[],r=0;r<e.rows.length;r++)for(var a=e.rows[r],i=0;i<a.cells.length;i++)t.push(a.cells[i]);var l=t.reduce(function(e,t){return t.getAttribute(\"id\")&&e.push(t.getAttribute(\"id\")),e},[]);return t.forEach(function(e){var t,r=!1;if(e.hasAttribute(\"headers\")){var a=e.getAttribute(\"headers\").trim();if(!a)return n.push(e);a=Co(a);0!==a.length&&(e.getAttribute(\"id\")&&(r=-1!==a.indexOf(e.getAttribute(\"id\").trim())),t=a.some(function(e){return!l.includes(e)}),(r||t)&&o.push(e))}}),0<o.length?(this.relatedNodes(o),!1):!n.length||void this.relatedNodes(n)}function ms(e){var t=ts(e),a=this,n=[];t.forEach(function(e){var t=e.getAttribute(\"headers\");t&&(n=n.concat(t.split(/\\s+/)));e=e.getAttribute(\"aria-labelledby\");e&&(n=n.concat(e.split(/\\s+/)))});var t=t.filter(function(e){return\"\"!==ka(e.textContent)&&(\"TH\"===e.nodeName.toUpperCase()||-1!==[\"rowheader\",\"columnheader\"].indexOf(e.getAttribute(\"role\")))}),o=Mo(e),i=!0;return t.forEach(function(t){var e,r;t.getAttribute(\"id\")&&n.includes(t.getAttribute(\"id\"))||(e=jo(t,o),r=!1,(r=!(r=Vo(t)?ls(\"down\",e,o).find(function(e){return!Vo(e)&&as(e,o).includes(t)}):r)&&Ho(t)?ls(\"right\",e,o).find(function(e){return!Ho(e)&&as(e,o).includes(t)}):r)||a.relatedNodes(t),i=i&&r)}),!!i||void 0}function hs(e,t,r){if(![\"SCRIPT\",\"HEAD\",\"TITLE\",\"NOSCRIPT\",\"STYLE\",\"TEMPLATE\"].includes(e.nodeName.toUpperCase())&&Ia(r)){r=window.getComputedStyle(e);if(\"none\"===r.getPropertyValue(\"display\"))return;if(\"hidden\"===r.getPropertyValue(\"visibility\")){e=sa(e),e=e&&window.getComputedStyle(e);if(!e||\"hidden\"!==e.getPropertyValue(\"visibility\"))return}}return!0}var gs={};o(gs,{Color:function(){return on},centerPointOfRect:function(){return bs},elementHasImage:function(){return Qa},elementIsDistinct:function(){return vs},filteredRectStack:function(){return ws},flattenColors:function(){return xs},getBackgroundColor:function(){return Fs},getBackgroundStack:function(){return As},getContrast:function(){return ks},getForegroundColor:function(){return Rs},getOwnBackgroundColor:function(){return ln},getRectStack:function(){return Ds},getTextShadowColors:function(){return Cs},hasValidContrastRatio:function(){return Ts},incompleteData:function(){return Ja}});var bs=function(e){if(!(e.left>window.innerWidth||e.top>window.innerHeight))return{x:Math.min(Math.ceil(e.left+e.width/2),window.innerWidth-1),y:Math.min(Math.ceil(e.top+e.height/2),window.innerHeight-1)}};function ys(e){return e.getPropertyValue(\"font-family\").split(/[,;]/g).map(function(e){return e.trim().toLowerCase()})}var vs=function(e,t){var a=window.getComputedStyle(e);if(\"none\"!==a.getPropertyValue(\"background-image\"))return!0;if([\"border-bottom\",\"border-top\",\"outline\"].reduce(function(e,t){var r=new on;return r.parseString(a.getPropertyValue(t+\"-color\")),e||\"none\"!==a.getPropertyValue(t+\"-style\")&&0<parseFloat(a.getPropertyValue(t+\"-width\"))&&0!==r.alpha},!1))return!0;var r=window.getComputedStyle(t);return ys(a)[0]!==ys(r)[0]||(e=[\"text-decoration-line\",\"text-decoration-style\",\"font-weight\",\"font-style\",\"font-size\"].reduce(function(e,t){return e||a.getPropertyValue(t)!==r.getPropertyValue(t)},!1),t=a.getPropertyValue(\"text-decoration\"),e=t.split(\" \").length<3?e||t!==r.getPropertyValue(\"text-decoration\"):e)};var Ds=function(e){var t=Ca(e);return!(e=Ra(e))||e.length<=1?[t]:e.some(function(e){return void 0===e})?null:(e.splice(0,0,t),e)};var ws=function(n){var o=Ds(n);if(o&&1===o.length)return o[0];if(o&&1<o.length){var i,l=o.shift();return o.forEach(function(e,t){var r,a;0!==t&&(r=o[t-1],a=o[t],i=r.every(function(e,t){return e===a[t]})||l.includes(n))}),i?o[0]:(Ja.set(\"bgColor\",\"elmPartiallyObscuring\"),null)}return Ja.set(\"bgColor\",\"outsideViewport\"),null};var xs=function(e,t){var r=(1-(n=e.alpha))*t.red+n*e.red,a=(1-n)*t.green+n*e.green,n=(1-n)*t.blue+n*e.blue,e=e.alpha+t.alpha*(1-e.alpha);return new on(r,a,n,e)};function Es(e,t,r){if(0<e)for(var a=e-1;0<=a;a--){if(function(e,t){var r=e.getClientRects()[0],a=mn(r.left,r.top);if(a)for(var n=0;n<a.length;n++)if(a[n]!==e&&a[n]===t)return 1}(r,t[a]))return 1;t.splice(a,1)}}var As=function(e){var t,r,a=ws(e);if(null===a)return null;a=dn(a,e),r=(t=a).indexOf(document.body),n=t,(1<r||-1===r)&&!Qa(document.documentElement)&&0===ln(window.getComputedStyle(document.documentElement)).alpha&&(1<r&&n.splice(r,1),n.splice(t.indexOf(document.documentElement),1),n.push(document.body));var n=(a=n).indexOf(e);return Es(n,a,e)?(Ja.set(\"bgColor\",\"bgOverlap\"),null):-1!==n?a:null};var Cs=function(e){var n=(r=1<arguments.length&&void 0!==arguments[1]?arguments[1]:{}).minRatio,o=r.maxRatio,i=window.getComputedStyle(e),t=i.getPropertyValue(\"text-shadow\");if(\"none\"===t)return[];var r=i.getPropertyValue(\"font-size\"),l=parseInt(r);it(!1===isNaN(l),\"Unable to determine font-size value \".concat(r));var s=[];return function(e){var t={pixels:[]},r=e.trim(),a=[t];if(!r)return[];for(;r;){var n=r.match(/^rgba?\\([0-9,.\\s]+\\)/i)||r.match(/^[a-z]+/i)||r.match(/^#[0-9a-f]+/i),o=r.match(/^([0-9.-]+)px/i)||r.match(/^(0)/);if(n)it(!t.colorStr,\"Multiple colors identified in text-shadow: \".concat(e)),r=r.replace(n[0],\"\").trim(),t.colorStr=n[0];else if(o){it(t.pixels.length<3,\"Too many pixel units in text-shadow: \".concat(e)),r=r.replace(o[0],\"\").trim();o=parseFloat((\".\"===o[1][0]?\"0\":\"\")+o[1]);t.pixels.push(o)}else{if(\",\"!==r[0])throw new Error(\"Unable to process text-shadows: \".concat(e));it(2<=t.pixels.length,\"Missing pixel value in text-shadow: \".concat(e)),t={pixels:[]},a.push(t),r=r.substr(1).trim()}}return a}(t).forEach(function(e){var t=e.colorStr,r=e.pixels,t=t||i.getPropertyValue(\"color\"),a=Ku(r,3),e=a[0],r=a[1],a=a[2],a=void 0===a?0:a;(!n||l*n<=a)&&(!o||a<l*o)&&(a=function(e){var t=e.colorStr,r=e.offsetX,a=e.offsetY,n=e.blurRadius,e=e.fontSize;if(n<r||n<a)return new on(0,0,0,0);a=new on;return a.parseString(t),a.alpha*=function(e,t){return.185/(e/t+.4)}(n,e),a}({colorStr:t,offsetY:e,offsetX:r,blurRadius:a,fontSize:l}),s.push(a))}),s};var Fs=function(i){var l=1<arguments.length&&void 0!==arguments[1]?arguments[1]:[],s=Cs(i,{minRatio:2<arguments.length&&void 0!==arguments[2]?arguments[2]:.1}),e=As(i);return(e||[]).some(function(e){var t,r,a,n=window.getComputedStyle(e),o=ln(n);return a=o,(a=(t=i)!==(r=e)&&!fn(t,r)&&0!==a.alpha)&&Ja.set(\"bgColor\",\"elmPartiallyObscured\"),a||Qa(e,n)?(s=null,l.push(e),!0):0!==o.alpha&&(l.push(e),s.push(o),1===o.alpha)}),null===s||null===e?null:(s.push(new on(255,255,255,1)),s.reduce(xs))};var ks=function(e,t){return t&&e?(t.alpha<1&&(t=xs(t,e)),e=e.getRelativeLuminance(),t=t.getRelativeLuminance(),(Math.max(t,e)+.05)/(Math.min(t,e)+.05)):null};var Rs=function(e,t,r){var a=window.getComputedStyle(e),n=new on;return n.parseString(a.getPropertyValue(\"color\")),a=function e(t){if(!t)return 1;var r=Dr(t);if(r&&void 0!==r._opacity&&null!==r._opacity)return r._opacity;t=window.getComputedStyle(t).getPropertyValue(\"opacity\")*e(t.parentElement);return r&&(r._opacity=t),t}(e),n.alpha=n.alpha*a,1===n.alpha?n:null!==(r=r||Fs(e,[]))?xs(n,r):(r=Ja.get(\"bgColor\"),Ja.set(\"fgColor\",r),null)};var Ts=function(e,t,r,a){return t=ks(e,t),{isValid:(r=a&&Math.ceil(72*r)/96<14||!a&&Math.ceil(72*r)/96<18?4.5:3)<t,contrastRatio:t,expectedContrastRatio:r}},Ns=Wn(function(e,t){e=window.getComputedStyle(e,t),t=ln(e);return\"none\"!==e.getPropertyValue(\"content\")&&\"absolute\"===e.getPropertyValue(\"position\")&&0!==parseInt(e.getPropertyValue(\"width\"))&&0!==parseInt(e.getPropertyValue(\"height\"))&&(0!==t.alpha||\"none\"!==e.getPropertyValue(\"background-image\"))});function _s(e,t,r){if(!ba(e,!1))return!0;var a=t.ignoreUnicode,n=t.ignoreLength,o=t.boldValue,i=t.boldTextPt,l=t.largeTextPt,s=t.contrastRatio,u=t.shadowOutlineEmMax,c=Oa(r,!1,!0);if(!Gi(c,{nonBmp:!0})||\"\"!==ka(Ki(c,{nonBmp:!0}))||!a){var d=[],p=Fs(e,d,u),t=Rs(e,!1,p),r=Cs(e,{maxRatio:u}),a=window.getComputedStyle(e),u=parseFloat(a.getPropertyValue(\"font-size\")),a=a.getPropertyValue(\"font-weight\"),o=parseFloat(a)>=o||\"bold\"===a,a=null;0===r.length?a=ks(p,t):t&&p&&(f=[].concat(Yu(r),[p]).reduce(xs),r=ks(p,f),f=ks(f,t),a=Math.max(r,f));for(var f=Math.ceil(72*u)/96,i=o&&f<i||!o&&f<l?s.normal:s.large,f=i.expected,l=i.minThreshold,s=i.maxThreshold,i=f<a,m=e;m;){if(Ns(m,\":before\")||Ns(m,\":after\"))return this.data({messageKey:\"pseudoContent\"}),void this.relatedNodes(m);m=m.parentElement}if(\"number\"==typeof l&&a<l||\"number\"==typeof s&&s<a)return!0;var h,s=Math.floor(100*a)/100;null===p&&(h=Ja.get(\"bgColor\"));a=1==s,c=1===c.length;a?h=Ja.set(\"bgColor\",\"equalRatio\"):c&&!n&&(h=\"shortTextContent\");f={fgColor:t?t.toHexString():void 0,bgColor:p?p.toHexString():void 0,contrastRatio:s,fontSize:\"\".concat((72*u/96).toFixed(1),\"pt (\").concat(u,\"px)\"),fontWeight:o?\"bold\":\"normal\",messageKey:h,expectedContrastRatio:f+\":1\"};return(this.data(f),null===t||null===p||a||c&&!n&&!i)?(h=null,Ja.clear(),void this.relatedNodes(d)):(i||this.relatedNodes(d),i)}this.data({messageKey:\"nonBmp\"})}function Os(e,t){e=e.getRelativeLuminance(),t=t.getRelativeLuminance();return(Math.max(e,t)+.05)/(Math.min(e,t)+.05)}var Ss=[\"block\",\"list-item\",\"table\",\"flex\",\"grid\",\"inline-block\"];function Ps(e){e=window.getComputedStyle(e).getPropertyValue(\"display\");return-1!==Ss.indexOf(e)||\"table-\"===e.substr(0,6)}function Is(e){if(Ps(e))return!1;for(var t=sa(e);1===t.nodeType&&!Ps(t);)t=sa(t);if(this.relatedNodes([t]),vs(e,t))return!0;var r=Rs(e),a=Rs(t);if(r&&a){var n=Os(r,a);if(1===n)return!0;if(3<=n)return Ja.set(\"fgColor\",\"bgContrast\"),this.data({messageKey:Ja.get(\"fgColor\")}),void Ja.clear();if(r=Fs(e),a=Fs(t),!r||!a||3<=Os(r,a)){a=r&&a?\"bgContrast\":Ja.get(\"bgColor\");return Ja.set(\"fgColor\",a),this.data({messageKey:Ja.get(\"fgColor\")}),void Ja.clear()}return!1}}function Bs(e,t,r){if(\"input\"!==r.props.nodeName)return!0;var a=[\"text\",\"search\",\"number\",\"tel\"],n=[\"text\",\"search\",\"url\"],o={bday:[\"text\",\"search\",\"date\"],email:[\"text\",\"search\",\"email\"],username:[\"text\",\"search\",\"email\"],\"street-address\":[\"text\"],tel:[\"text\",\"search\",\"tel\"],\"tel-country-code\":[\"text\",\"search\",\"tel\"],\"tel-national\":[\"text\",\"search\",\"tel\"],\"tel-area-code\":[\"text\",\"search\",\"tel\"],\"tel-local\":[\"text\",\"search\",\"tel\"],\"tel-local-prefix\":[\"text\",\"search\",\"tel\"],\"tel-local-suffix\":[\"text\",\"search\",\"tel\"],\"tel-extension\":[\"text\",\"search\",\"tel\"],\"cc-number\":a,\"cc-exp\":[\"text\",\"search\",\"month\",\"tel\"],\"cc-exp-month\":a,\"cc-exp-year\":a,\"cc-csc\":a,\"transaction-amount\":a,\"bday-day\":a,\"bday-month\":a,\"bday-year\":a,\"new-password\":[\"text\",\"search\",\"password\"],\"current-password\":[\"text\",\"search\",\"password\"],url:n,photo:n,impp:n};return\"object\"===Lu(t)&&Object.keys(t).forEach(function(e){o[e]||(o[e]=[]),o[e]=o[e].concat(t[e])}),n=(n=r.attr(\"autocomplete\").split(/\\s+/g).map(function(e){return e.toLowerCase()}))[n.length-1],!!Qi.stateTerms.includes(n)||(n=o[n],r=r.hasAttr(\"type\")?ka(r.attr(\"type\")).toLowerCase():\"text\",r=Fo().includes(r)?r:\"text\",void 0===n?\"text\"===r:n.includes(r))}n=function(e,t,r){return r=r.attr(\"autocomplete\")||\"\",Zi(r,t)};wt=function(e){var t=1<arguments.length&&void 0!==arguments[1]?arguments[1]:{},r=2<arguments.length?arguments[2]:void 0;if(!t.attribute||\"string\"!=typeof t.attribute)throw new TypeError(\"attr-non-space-content requires options.attribute to be a string\");return r.hasAttr(t.attribute)?(t=r.attr(t.attribute),!!ka(t)||(this.data({messageKey:\"emptyAttr\"}),!1)):(this.data({messageKey:\"noAttr\"}),!1)};var Ls=function(e){return e.some(function(e){return!0===e.result})&&e.forEach(function(e){e.result=!0}),e};Cr=function(e,t,r){if(!t||!t.selector||\"string\"!=typeof t.selector)throw new TypeError(\"has-descendant requires options.selector to be a string\");return t=so(r,t.selector,function(e){return ba(e.actualNode,!0)}),this.relatedNodes(t.map(function(e){return e.actualNode})),0<t.length};en=function(e,t,r){try{return\"\"!==ka(bi(r))}catch(e){return}};tn=function(e,t,r){return oi(r,t.matcher)};Ko=function(e){return e.filter(function(e){return\"ignored\"!==e.data})};Xo=function(e,t,r){if(!t||!t.selector||\"string\"!=typeof t.selector)throw new TypeError(\"page-no-duplicate requires options.selector to be a string\");var a=\"page-no-duplicate;\"+t.selector;if(!vr.get(a)){vr.set(a,!0);a=so(axe._tree[0],t.selector,function(e){return ba(e.actualNode)});return\"string\"==typeof t.nativeScopeFilter&&(a=a.filter(function(e){return e.actualNode.hasAttribute(\"role\")||!ia(e,t.nativeScopeFilter)})),this.relatedNodes(a.filter(function(e){return e!==r}).map(function(e){return e.actualNode})),a.length<=1}this.data(\"ignored\")};function qs(e,t){var r=null===(r=t.data)||void 0===r?void 0:r.headingOrder,a=js(t.node.ancestry,1);if(!r)return e;t=r.map(function(e){return function(e,t){t=t.concat(e.ancestry);return Xu({},e,{ancestry:t})}(e,a)}),r=function(e,t){for(;t.length;){var r=Ms(e,t);if(-1!==r)return r;t=js(t,1)}return-1}(e,a);return-1===r?e.push.apply(e,Yu(t)):e.splice.apply(e,[r,0].concat(Yu(t))),e}function Ms(e,t){return e.findIndex(function(e){return e=e.ancestry,a=t,e.length===a.length&&e.every(function(e,t){var r=a[t];return Array.isArray(e)?e.length===r.length&&e.every(function(e,t){return r[t]===e}):e===r});var a})}function js(e,t){return e.slice(0,e.length-t)}Jo=function(){if(t=vr.get(\"headingOrder\"))return!0;var e=so(axe._tree[0],\"h1, h2, h3, h4, h5, h6, [role=heading], iframe, frame\",function(e){return ba(e.actualNode,!0)}),t=e.map(function(e){return{ancestry:[gr(e.actualNode)],level:function(e){var t=e.attr(\"role\");if(t&&t.includes(\"heading\")){t=e.attr(\"aria-level\"),t=parseInt(t,10);return isNaN(t)||t<1||6<t?2:t}return(e=e.props.nodeName.match(/h(\\d)/))?parseInt(e[1],10):-1}(e)}});return this.data({headingOrder:t}),vr.set(\"headingOrder\",e),!0};Qo=function(e){if(e.length<2)return e;function t(r){var e=i[r],a=(o=e.data).name,t=o.urlProps;if(s[a])return\"continue\";var n=i.filter(function(e,t){return e.data.name===a&&t!==r}),o=n.every(function(e){return function r(a,n){if(!a||!n)return!1;var e=Object.getOwnPropertyNames(a),t=Object.getOwnPropertyNames(n);return e.length===t.length&&e.every(function(e){var t=a[e],e=n[e];return Lu(t)===Lu(e)&&(\"object\"==typeof t||\"object\"==typeof e?r(t,e):t===e)})}(e.data.urlProps,t)});n.length&&!o&&(e.result=void 0),e.relatedNodes=[],(o=e.relatedNodes).push.apply(o,Yu(n.map(function(e){return e.relatedNodes[0]}))),s[a]=n,l.push(e)}for(var i=e.filter(function(e){return void 0!==e.result}),l=[],s={},r=0;r<i.length;r++)t(r);return l},Zo={};o(Zo,{aria:function(){return _o},color:function(){return gs},dom:function(){return ra},forms:function(){return Us},matches:function(){return oi},standards:function(){return Sl},table:function(){return es},text:function(){return Vi},utils:function(){return rt}});var Us={};o(Us,{isAriaCombobox:function(){return Ni},isAriaListbox:function(){return Ti},isAriaRange:function(){return Oi},isAriaTextbox:function(){return Ri},isDisabled:function(){return Hs},isNativeSelect:function(){return ki},isNativeTextbox:function(){return Fi}});var Vs=[\"fieldset\",\"button\",\"select\",\"input\",\"textarea\"];var Hs=function e(t){if(\"boolean\"==typeof(n=t._isDisabled))return n;var r=t.props.nodeName,a=t.attr(\"aria-disabled\"),n=!(!Vs.includes(r)||!t.hasAttr(\"disabled\"))||(a?\"true\"===a.toLowerCase():!!t.parent&&e(t.parent));return t._isDisabled=n};ei=function(e,t,r){if(r=Vi.accessibleTextVirtual(r),r=Vi.sanitize(Vi.removeUnicode(r,{emoji:!0,nonBmp:!0,punctuations:!0})).toLowerCase()){r={name:r,urlProps:ra.urlPropsFromAttribute(e,\"href\")};return this.data(r),this.relatedNodes([e]),!0}};ti=function(e,t,r){return vo(r,\"a[href]\").some(function(e){return/^#[^/!]/.test(e.actualNode.getAttribute(\"href\"))})};gl=function(e,t,r){var a=r.attr(\"content\")||\"\",r=a.split(/[;,]/);return\"\"===a||\"0\"===r[0]};function zs(e){e=window.getComputedStyle(function(e){for(var t=e,r=e.textContent.trim(),a=r;a===r&&void 0!==t;){var n=-1;if(0===(e=t).children.length)return e;for(;n++,\"\"===(a=e.children[n].textContent.trim())&&n+1<e.children.length;);t=e.children[n]}return e}(e));return{fontWeight:function(e){switch(e){case\"lighter\":return 100;case\"normal\":return 400;case\"bold\":return 700;case\"bolder\":return 900}return e=parseInt(e),isNaN(e)?400:e}(e.getPropertyValue(\"font-weight\")),fontSize:parseInt(e.getPropertyValue(\"font-size\")),isItalic:\"italic\"===e.getPropertyValue(\"font-style\")}}function $s(r,a,e){return e.reduce(function(e,t){return e||(!t.size||r.fontSize/t.size>a.fontSize)&&(!t.weight||r.fontWeight-t.weight>a.fontWeight)&&(!t.italic||r.isItalic&&!a.isItalic)},!1)}var hl=function(e,t,r){var a=Array.from(e.parentNode.children),n=a.indexOf(e),o=(t=t||{}).margins||[],t=a.slice(n+1).find(function(e){return\"P\"===e.nodeName.toUpperCase()}),n=a.slice(0,n).reverse().find(function(e){return\"P\"===e.nodeName.toUpperCase()}),e=zs(e),t=t?zs(t):null,n=n?zs(n):null;return!t||!$s(e,t,o)||!!((r=ia(r,\"blockquote\"))&&\"BLOCKQUOTE\"===r.nodeName.toUpperCase()||n&&!$s(e,n,o))&&void 0},Ws=dl(\"landmark\"),Gs=[\"alert\",\"log\",\"status\"];function Ys(e,t){var r,a,n,o,i=e.actualNode;if(a=t,n=(r=e).actualNode,o=di(r),n=(n.getAttribute(\"aria-live\")||\"\").toLowerCase().trim(),[\"assertive\",\"polite\"].includes(n)||Gs.includes(o)||(Ws.includes(o)||!(!a.regionMatcher||!oi(r,a.regionMatcher)))||cn(e.actualNode)&&ua(e.actualNode,\"href\")||!ba(i,!0)){for(var l=e;l;)l._hasRegionDescendant=!0,l=l.parent;return[]}return i!==document.body&&Ba(i,!0)?[e]:e.children.filter(function(e){return 1===e.actualNode.nodeType}).map(function(e){return Ys(e,t)}).reduce(function(e,t){return e.concat(t)},[])}function Ks(e,t){t=Xs(t),e=Xs(e);return!(!t||!e)&&t.includes(e)}function Xs(e){e=Ki(e,{emoji:!0,nonBmp:!0,punctuations:!0});return ka(e)}function Js(e){return\"\"!==(e||\"\").trim()}var Qs=function(e,t,r){return r.initiator};var Zs=function(e,t){try{return\"svg\"===t.props.nodeName?!0:!!Ir(t,\"svg\")}catch(e){return!1}};bl=function(e,t){var r=ii(t).namingMethods;return(!r||0===r.length)&&(\"combobox\"!==Lo(t)||!vo(t,'input:not([type=\"hidden\"])').length)};var eu={\"abstractrole-evaluate\":kl,\"aria-allowed-attr-evaluate\":Rl,\"aria-allowed-role-evaluate\":Tl,\"aria-errormessage-evaluate\":Nl,\"aria-hidden-body-evaluate\":_l,\"aria-prohibited-attr-evaluate\":Ol,\"aria-required-attr-evaluate\":Pl,\"aria-required-children-evaluate\":Bl,\"aria-required-parent-evaluate\":ql,\"aria-roledescription-evaluate\":Ml,\"aria-unsupported-attr-evaluate\":jl,\"aria-valid-attr-evaluate\":Ul,\"aria-valid-attr-value-evaluate\":Vl,\"fallbackrole-evaluate\":Hl,\"has-global-aria-attribute-evaluate\":zl,\"has-implicit-chromium-role-matches\":$l,\"has-widget-role-evaluate\":Wl,\"invalidrole-evaluate\":Gl,\"is-element-focusable-evaluate\":Yl,\"no-implicit-explicit-label-evaluate\":Kl,\"unsupportedrole-evaluate\":Xl,\"valid-scrollable-semantics-evaluate\":Zl,\"caption-faked-evaluate\":ss,\"html5-scope-evaluate\":us,\"same-caption-summary-evaluate\":cs,\"scope-value-evaluate\":ds,\"td-has-header-evaluate\":ps,\"td-headers-attr-evaluate\":fs,\"th-has-data-cells-evaluate\":ms,\"hidden-content-evaluate\":hs,\"color-contrast-evaluate\":_s,\"link-in-text-block-evaluate\":Is,\"autocomplete-appropriate-evaluate\":Bs,\"autocomplete-valid-evaluate\":n,\"attr-non-space-content-evaluate\":wt,\"has-descendant-after\":Ls,\"has-descendant-evaluate\":Cr,\"has-text-content-evaluate\":en,\"matches-definition-evaluate\":tn,\"page-no-duplicate-after\":Ko,\"page-no-duplicate-evaluate\":Xo,\"heading-order-after\":function(e){var t,r=((t=Yu(t=e)).sort(function(e,t){e=e.node,t=t.node;return e.ancestry.length-t.ancestry.length}),t.reduce(qs,[]).filter(function(e){return-1!==e.level}));return e.forEach(function(e){e.result=function(e,t){var r=Ms(t,e.node.ancestry),e=null!==(e=null===(e=t[r])||void 0===e?void 0:e.level)&&void 0!==e?e:-1,t=null!==(t=null===(t=t[r-1])||void 0===t?void 0:t.level)&&void 0!==t?t:-1;if(0===r)return!0;if(-1!==e)return e-t<=1}(e,r)}),e},\"heading-order-evaluate\":Jo,\"identical-links-same-purpose-after\":Qo,\"identical-links-same-purpose-evaluate\":ei,\"internal-link-present-evaluate\":ti,\"meta-refresh-evaluate\":gl,\"p-as-heading-evaluate\":hl,\"region-evaluate\":function(e,t,r){if(a=vr.get(\"regionlessNodes\"))return!a.includes(r);var a=Ys(axe._tree[0],t).map(function(e){for(;e.parent&&!e.parent._hasRegionDescendant&&e.parent.actualNode!==document.body;)e=e.parent;return e}).filter(function(e,t,r){return r.indexOf(e)===t});return vr.set(\"regionlessNodes\",a),!a.includes(r)},\"skip-link-evaluate\":function(e){return!!(e=ua(e,\"href\"))&&(ba(e,!0)||void 0)},\"unique-frame-title-after\":function(e){var t={};return e.forEach(function(e){t[e.data]=void 0!==t[e.data]?++t[e.data]:0}),e.forEach(function(e){e.result=!!t[e.data]}),e},\"unique-frame-title-evaluate\":function(e,t,r){return r=ka(r.attr(\"title\")).toLowerCase(),this.data(r),!0},\"aria-label-evaluate\":function(e,t,r){return!!ka(Po(r))},\"aria-labelledby-evaluate\":function(e,t,r){try{return!!ka(Ui(r))}catch(e){return}},\"avoid-inline-spacing-evaluate\":function(t,e){return!(0<(e=e.cssProperties.filter(function(e){if(\"important\"===t.style.getPropertyPriority(e))return e})).length)||(this.data(e),!1)},\"doc-has-title-evaluate\":function(){var e=document.title;return!!ka(e)},\"exists-evaluate\":function(){},\"has-alt-evaluate\":function(e,t,r){var a=r.props.nodeName;return!![\"img\",\"input\",\"area\"].includes(a)&&r.hasAttr(\"alt\")},\"is-on-screen-evaluate\":function(e){return ba(e,!1)&&!fa(e)},\"non-empty-if-present-evaluate\":function(e,t,r){var a=r.props.nodeName,n=(r.attr(\"type\")||\"\").toLowerCase();return(r=r.attr(\"value\"))&&this.data({messageKey:\"has-label\"}),!(\"input\"!==a||![\"submit\",\"reset\"].includes(n))&&null===r},\"presentational-role-evaluate\":function(e,t,r){var a=di(r),n=Lo(r);if([\"presentation\",\"none\"].includes(a))return this.data({role:a}),!0;if(![\"presentation\",\"none\"].includes(n))return!1;var o=Oo().some(function(e){return r.hasAttr(e)}),n=Va(r),n=o&&!n?\"globalAria\":!o&&n?\"focusable\":\"both\";return this.data({messageKey:n,role:a}),!1},\"svg-non-empty-title-evaluate\":function(e,t,r){if(r.children){r=r.children.find(function(e){return\"title\"===e.props.nodeName});if(!r)return this.data({messageKey:\"noTitle\"}),!1;try{if(\"\"===Oa(r))return this.data({messageKey:\"emptyTitle\"}),!1}catch(e){return}return!0}},\"css-orientation-lock-evaluate\":function(e,t,r,a){var a=void 0===(a=(a||{}).cssom)?void 0:a,n=void 0===(t=(t||{}).degreeThreshold)?0:t;if(a&&a.length){function o(){var e=c[u],e=s[e],r=e.root,e=e.rules.filter(d);if(!e.length)return\"continue\";e.forEach(function(e){e=e.cssRules;Array.from(e).forEach(function(e){var t=function(e){var t=e.selectorText,e=e.style;if(!t||e.length<=0)return!1;t=e.transform||e.webkitTransform||e.msTransform||!1;if(!t)return!1;e=t.match(/(rotate|rotateZ|rotate3d|matrix|matrix3d)\\(([^)]+)\\)(?!.*(rotate|rotateZ|rotate3d|matrix|matrix3d))/);if(!e)return!1;t=Ku(e,3),e=t[1],t=t[2],t=function(e,t){switch(e){case\"rotate\":case\"rotateZ\":return p(t);case\"rotate3d\":var r=Ku(t.split(\",\").map(function(e){return e.trim()}),4),a=r[2],r=r[3];return 0===parseInt(a)?void 0:p(r);case\"matrix\":case\"matrix3d\":return function(e){var t=e.split(\",\");if(t.length<=6){var e=Ku(t,2),r=e[0],e=e[1];return f(Math.atan2(parseFloat(e),parseFloat(r)))}r=parseFloat(t[8]),r=Math.asin(r),r=Math.cos(r);return f(Math.acos(parseFloat(t[0])/r))}(t);default:return}}(e,t);if(!t)return!1;if(t=Math.abs(t),Math.abs(t-180)%180<=n)return!1;return Math.abs(t-90)%90<=n}(e);t&&\"HTML\"!==e.selectorText.toUpperCase()&&(e=Array.from(r.querySelectorAll(e.selectorText))||[],l=l.concat(e)),i=i||t})})}for(var i=!1,l=[],s=a.reduce(function(e,t){var r=t.sheet,a=t.root,t=t.shadowId,t=t||\"topDocument\";if(e[t]||(e[t]={root:a,rules:[]}),!r||!r.cssRules)return e;r=Array.from(r.cssRules);return e[t].rules=e[t].rules.concat(r),e},{}),u=0,c=Object.keys(s);u<c.length;u++)o();return i?(l.length&&this.relatedNodes(l),!1):!0}function d(e){var t=e.type,e=e.cssText;return 4===t&&(/orientation:\\s*landscape/i.test(e)||/orientation:\\s*portrait/i.test(e))}function p(e){var t=Ku(e.match(/(deg|grad|rad|turn)/)||[],1)[0];if(t){var r=parseFloat(e.replace(t,\"\"));switch(t){case\"rad\":return f(r);case\"grad\":return function(e){(e%=400)<0&&(e+=400);return Math.round(e/400*360)}(r);case\"turn\":return Math.round(360/(1/r));case\"deg\":default:return parseInt(r)}}}function f(e){return Math.round(e*(180/Math.PI))}},\"meta-viewport-scale-evaluate\":function(e,t,r){var a=(n=t||{}).scaleMinimum,t=void 0===a?2:a,n=void 0!==(a=n.lowerBound)&&a;return!(a=r.attr(\"content\")||\"\")||(r=a.split(/[;,]/).reduce(function(e,t){var r=t.trim();if(!r)return e;t=Ku(r.split(\"=\"),2),r=t[0],t=t[1];if(!r||!t)return e;r=r.toLowerCase().trim(),t=t.toLowerCase().trim();return\"maximum-scale\"===r&&\"yes\"===t&&(t=1),\"maximum-scale\"===r&&parseFloat(t)<0||(e[r]=t),e},{}),!!(n&&r[\"maximum-scale\"]&&parseFloat(r[\"maximum-scale\"])<n)||(n||\"no\"!==r[\"user-scalable\"]?(a=parseFloat(r[\"user-scalable\"]),!n&&r[\"user-scalable\"]&&(a||0===a)&&-1<a&&a<1?(this.data(\"user-scalable\"),!1):!(r[\"maximum-scale\"]&&parseFloat(r[\"maximum-scale\"])<t)||(this.data(\"maximum-scale\"),!1)):(this.data(\"user-scalable=no\"),!1)))},\"duplicate-id-after\":function(e){var t=[];return e.filter(function(e){return-1===t.indexOf(e.data)&&(t.push(e.data),!0)})},\"duplicate-id-evaluate\":function(t){var e=t.getAttribute(\"id\").trim();if(!e)return!0;var r=na(t);return(r=Array.from(r.querySelectorAll('[id=\"'.concat(Kt(e),'\"]'))).filter(function(e){return e!==t})).length&&this.relatedNodes(r),this.data(e),0===r.length},\"accesskeys-after\":function(e){var r={};return e.filter(function(e){if(!e.data)return!1;var t=e.data.toUpperCase();return r[t]?(r[t].relatedNodes.push(e.relatedNodes[0]),!1):((r[t]=e).relatedNodes=[],!0)}).map(function(e){return e.result=!!e.relatedNodes.length,e})},\"accesskeys-evaluate\":function(e){return ba(e,!1)&&(this.data(e.getAttribute(\"accesskey\")),this.relatedNodes([e])),!0},\"focusable-content-evaluate\":function(e,t,r){var a=r.tabbableElements;return!!a&&0<a.filter(function(e){return e!==r}).length},\"focusable-disabled-evaluate\":function(e,t,r){var a=[\"BUTTON\",\"FIELDSET\",\"INPUT\",\"SELECT\",\"TEXTAREA\"];return!(r=r.tabbableElements)||!r.length||(r=r.reduce(function(e,t){var r=t.actualNode,t=r.nodeName.toUpperCase();return a.includes(t)&&e.push(r),e},[]),this.relatedNodes(r),!(!r.length||!Ya())||0===r.length)},\"focusable-element-evaluate\":function(e,t,r){if(r.hasAttr(\"contenteditable\")&&function e(t){var t=t.attr(\"contenteditable\");if(\"true\"===t||\"\"===t)return!0;if(\"false\"===t)return!1;t=Ir(r.parent,\"[contenteditable]\");if(!t)return!1;return e(t)}(r))return!0;var a=r.isFocusable,n=parseInt(r.attr(\"tabindex\"),10);return(n=isNaN(n)?null:n)?a&&0<=n:a},\"focusable-modal-open-evaluate\":function(e,t,r){return!(r=r.tabbableElements.map(function(e){return e.actualNode}))||!r.length||(!Ya()||void this.relatedNodes(r))},\"focusable-no-name-evaluate\":function(e,t,r){var a=r.attr(\"tabindex\");if(!(Va(r)&&-1<a))return!1;try{return!Mi(r)}catch(e){return}},\"focusable-not-tabbable-evaluate\":function(e,t,r){var a=[\"BUTTON\",\"FIELDSET\",\"INPUT\",\"SELECT\",\"TEXTAREA\"];return!(r=r.tabbableElements)||!r.length||(r=r.reduce(function(e,t){var r=t.actualNode,t=r.nodeName.toUpperCase();return a.includes(t)||e.push(r),e},[]),this.relatedNodes(r),!!(0<r.length&&Ya())||0===r.length)},\"landmark-is-top-level-evaluate\":function(e){var t=dl(\"landmark\"),r=sa(e),a=di(e);for(this.data({role:a});r;){var n=r.getAttribute(\"role\");if((n=!n&&\"FORM\"!==r.nodeName.toUpperCase()?li(r):n)&&t.includes(n)&&(\"main\"!==n||\"complementary\"!==a))return!1;r=sa(r)}return!0},\"no-focusable-content-evaluate\":function(e,t,r){if(r.children)try{return!r.children.some(function e(t){if(Va(t))return!0;if(t.children)return t.children.some(e);if(1===t.props.nodeType)throw new Error(\"Cannot determine children\");return!1})}catch(e){return}},\"tabindex-evaluate\":function(e,t,r){return r=parseInt(r.attr(\"tabindex\"),10),!!isNaN(r)||r<=0},\"alt-space-value-evaluate\":function(e,t,r){return\"string\"==typeof(r=r.attr(\"alt\"))&&/^\\s+$/.test(r)},\"duplicate-img-label-evaluate\":function(e,t,r){return![\"none\",\"presentation\"].includes(di(r))&&(!!(t=Ir(r,t.parentSelector))&&(\"\"!==(t=Oa(t,!0).toLowerCase())&&t===Mi(r).toLowerCase()))},\"explicit-evaluate\":function(e,t,r){if(r.attr(\"id\")){if(!r.actualNode)return;var a=na(r.actualNode),r=Kt(r.attr(\"id\")),r=Array.from(a.querySelectorAll('label[for=\"'.concat(r,'\"]')));if(r.length)try{return r.some(function(e){return!ba(e)||!!ji(e)})}catch(e){return}}return!1},\"help-same-as-label-evaluate\":function(e,t,r){var a=tl(r),r=e.getAttribute(\"title\");return!!a&&(r||(r=\"\",e.getAttribute(\"aria-describedby\")&&(r=_a(e,\"aria-describedby\").map(function(e){return e?ji(e):\"\"}).join(\"\"))),ka(r)===ka(a))},\"hidden-explicit-label-evaluate\":function(e,t,r){if(r.hasAttr(\"id\")){if(!r.actualNode)return;var a,n=na(e),e=Kt(e.getAttribute(\"id\")),e=n.querySelector('label[for=\"'.concat(e,'\"]'));if(e&&!ba(e,!0)){try{a=Mi(r).trim()}catch(e){return}return\"\"===a}}return!1},\"implicit-evaluate\":function(e,t,r){try{var a=Ir(r,\"label\");return a?!!Mi(a,{inControlContext:!0}):!1}catch(e){return}},\"label-content-name-mismatch-evaluate\":function(e,t,r){var a=(t=t||{}).pixelThreshold,n=t.occuranceThreshold,e=ji(e).toLowerCase();if(!(Xi(e)<1)){r=nl(r).filter(function(e){return!Ji(e,a,n)}).map(function(e){return e.actualNode.nodeValue}).join(\"\"),r=ka(r).toLowerCase();return!r||(Xi(r)<1?!!Ks(r,e)||void 0:Ks(r,e))}},\"multiple-label-evaluate\":function(e){var t=Kt(e.getAttribute(\"id\")),r=e.parentNode,a=(a=na(e)).documentElement||a,n=Array.from(a.querySelectorAll('label[for=\"'.concat(t,'\"]')));for(n.length&&(n=n.filter(function(e){return ba(e)}));r;)\"LABEL\"===r.nodeName.toUpperCase()&&-1===n.indexOf(r)&&n.push(r),r=r.parentNode;if(this.relatedNodes(n),1<n.length){t=n.filter(function(e){return ba(e,!0)});return 1<t.length?void 0:!_a(e,\"aria-labelledby\").includes(t[0])&&void 0}return!1},\"title-only-evaluate\":function(e,t,r){var a=tl(r),n=fi(r),r=r.attr(\"aria-describedby\");return!(a||!n&&!r)},\"landmark-is-unique-after\":function(e){var r=[];return e.filter(function(t){var e=r.find(function(e){return t.data.role===e.data.role&&t.data.accessibleText===e.data.accessibleText});return e?(e.result=!1,e.relatedNodes.push(t.relatedNodes[0]),!1):(r.push(t),t.relatedNodes=[],!0)})},\"landmark-is-unique-evaluate\":function(e,t,r){var a=di(e),r=(r=Mi(r))?r.toLowerCase():null;return this.data({role:a,accessibleText:r}),this.relatedNodes([e]),!0},\"has-lang-evaluate\":function(e,t,r){var a=void 0!==document&&rr(document);return t.attributes.includes(\"xml:lang\")&&t.attributes.includes(\"lang\")&&Js(r.attr(\"xml:lang\"))&&!Js(r.attr(\"lang\"))&&!a?(this.data({messageKey:\"noXHTML\"}),!1):!!t.attributes.some(function(e){return Js(r.attr(e))})||(this.data({messageKey:\"noLang\"}),!1)},\"valid-lang-evaluate\":function(e,n,o){var i=[];return n.attributes.forEach(function(e){var t,r,a=o.attr(e);\"string\"==typeof a&&(t=xn(a),r=n.value?!n.value.map(xn).includes(t):!To(t),(\"\"!==t&&r||\"\"!==a&&!ka(a))&&i.push(e+'=\"'+o.attr(e)+'\"'))}),!!i.length&&(this.data(i),!0)},\"xml-lang-mismatch-evaluate\":function(e,t,r){return xn(r.attr(\"lang\"))===xn(r.attr(\"xml:lang\"))},\"dlitem-evaluate\":function(e){var t=sa(e),r=t.nodeName.toUpperCase(),e=Lo(t);return\"DIV\"===r&&[\"presentation\",\"none\",null].includes(e)&&(r=(t=sa(t)).nodeName.toUpperCase(),e=Lo(t)),\"DL\"===r&&!(e&&![\"presentation\",\"none\",\"list\"].includes(e))},\"listitem-evaluate\":function(e){var t=sa(e);if(t){e=t.nodeName.toUpperCase(),t=(t.getAttribute(\"role\")||\"\").toLowerCase();return!![\"presentation\",\"none\",\"list\"].includes(t)||(t&&Bo(t)?(this.data({messageKey:\"roleNotValid\"}),!1):[\"UL\",\"OL\"].includes(e))}},\"only-dlitems-evaluate\":function(e,t,r){var n=[\"definition\",\"term\",\"list\"];return(r=r.children.reduce(function(e,t){var r=t.actualNode;return\"DIV\"===r.nodeName.toUpperCase()&&null===di(r)?e.concat(t.children):e.concat(t)},[]).reduce(function(e,t){var r=t.actualNode,a=r.nodeName.toUpperCase();return 1===r.nodeType&&ba(r,!0,!1)?(t=Lo(r),(\"DT\"!==a&&\"DD\"!==a||t)&&(n.includes(t)||e.badNodes.push(r))):3===r.nodeType&&\"\"!==r.nodeValue.trim()&&(e.hasNonEmptyTextNode=!0),e},{badNodes:[],hasNonEmptyTextNode:!1})).badNodes.length&&this.relatedNodes(r.badNodes),!!r.badNodes.length||r.hasNonEmptyTextNode},\"only-listitems-evaluate\":function(e,t,r){var n=!1,o=!1,i=!0,l=[],s=[],u=[];return r.children.forEach(function(e){var t,r,a=e.actualNode;3!==a.nodeType||\"\"===a.nodeValue.trim()?1===a.nodeType&&ba(a,!0,!1)&&(i=!1,t=\"LI\"===a.nodeName.toUpperCase(),e=\"listitem\"===(r=di(e)),t||e||l.push(a),t&&!e&&(s.push(a),u.includes(r)||u.push(r)),e&&(o=!0)):n=!0}),n||l.length?(this.relatedNodes(l),!0):!i&&!o&&(this.relatedNodes(s),this.data({messageKey:\"roleNotValid\",roles:u.join(\", \")}),!0)},\"structured-dlitems-evaluate\":function(e,t,r){var a=r.children;if(!a||!a.length)return!1;for(var n,o=!1,i=!1,l=0;l<a.length;l++){if((o=\"DT\"===(n=a[l].props.nodeName.toUpperCase())?!0:o)&&\"DD\"===n)return!1;\"DD\"===n&&(i=!0)}return o||i},\"caption-evaluate\":function(e,t,r){return!vo(r,\"track\").some(function(e){return\"captions\"===(e.attr(\"kind\")||\"\").toLowerCase()})&&void 0},\"frame-tested-evaluate\":function(e,t){return!t.isViolation&&void 0},\"frame-tested-after\":function(e){var r={};return e.filter(function(e){if(\"html\"!==e.node.ancestry[e.node.ancestry.length-1]){var t=e.node.ancestry.flat(1/0).join(\" > \");return r[t]=e,!0}e=e.node.ancestry.slice(0,e.node.ancestry.length-1).flat(1/0).join(\" > \");return r[e]&&(r[e].result=!0),!1})},\"no-autoplay-audio-evaluate\":function(e,t){if(e.duration){t=t.allowedDuration,t=void 0===t?3:t;return function(e){if(!e.currentSrc)return 0;var t=function(e){e=e.match(/#t=(.*)/);if(e)return Ku(e,2)[1].split(\",\").map(function(e){return(/:/.test(e)?function(e){var t=e.split(\":\"),r=0,a=1;for(;0<t.length;)r+=a*parseInt(t.pop(),10),a*=60;return parseFloat(r)}:parseFloat)(e)})}(e.currentSrc);return t?1!==t.length?Math.abs(t[1]-t[0]):Math.abs(e.duration-t[0]):Math.abs(e.duration-(e.currentTime||0))}(e)<=t&&!e.hasAttribute(\"loop\")||!!e.hasAttribute(\"controls\")}console.warn(\"axe.utils.preloadMedia did not load metadata\")},\"aria-allowed-attr-matches\":function(e,t){var r=/^aria-/,a=t.attrNames;if(a.length)for(var n=0,o=a.length;n<o;n++)if(r.test(a[n]))return!0;return!1},\"aria-allowed-role-matches\":function(e){return null!==Lo(e,{dpub:!0,fallback:!0})},\"aria-form-field-name-matches\":bl,\"aria-has-attr-matches\":function(e,t){var r=/^aria-/;return t.attrNames.some(function(e){return r.test(e)})},\"aria-hidden-focus-matches\":function(e){return function e(t){return!t||\"true\"!==t.getAttribute(\"aria-hidden\")&&e(sa(t))}(sa(e))},\"aria-required-children-matches\":function(e,t){return t=Lo(t,{dpub:!0}),!!Al(t)},\"aria-required-parent-matches\":function(e,t){return t=Lo(t),!!El(t)},\"autocomplete-matches\":function(e,t){var r=t.attr(\"autocomplete\");if(!r||\"\"===ka(r))return!1;var a=t.props.nodeName;if(!1===[\"textarea\",\"input\",\"select\"].includes(a))return!1;if(\"input\"===a&&[\"submit\",\"reset\",\"button\",\"hidden\"].includes(t.props.type))return!1;if(r=t.attr(\"aria-disabled\")||\"false\",t.hasAttr(\"disabled\")||\"true\"===r.toLowerCase())return!1;if(a=t.attr(\"role\"),\"-1\"===(r=t.attr(\"tabindex\"))&&a){a=nn.ariaRoles[a];if(void 0===a||\"widget\"!==a.type)return!1}return!(\"-1\"===r&&t.actualNode&&!ba(t.actualNode,!1)&&!ba(t.actualNode,!0))},\"bypass-matches\":function(e,t,r){return!Qs(e,t,r)||!!e.querySelector(\"a[href]\")},\"color-contrast-matches\":function(e,t){var r=(a=t.props).nodeName,a=a.type;if(\"option\"===r)return!1;if(\"select\"===r&&!e.options.length)return!1;if(\"input\"===r&&[\"hidden\",\"range\",\"color\",\"checkbox\",\"radio\",\"image\"].includes(a))return!1;if(Hs(t))return!1;if([\"input\",\"select\",\"textarea\"].includes(r)){a=window.getComputedStyle(e),a=parseInt(a.getPropertyValue(\"text-indent\"),10);if(a){var n={top:(n=e.getBoundingClientRect()).top,bottom:n.bottom,left:n.left+a,right:n.right+a};if(!bn(n,e))return!1}return!0}if(n=ia(t,\"label\"),\"label\"===r||n){var r=n||e,o=n?Dr(n):t;if(r.htmlFor){r=na(r).getElementById(r.htmlFor),r=r&&Dr(r);if(r&&Hs(r))return!1}o=vo(o,'input:not([type=\"hidden\"],[type=\"image\"],[type=\"button\"],[type=\"submit\"],[type=\"reset\"]), select, textarea')[0];if(o&&Hs(o))return!1}for(var i,l=[],s=t;s;)s.props.id&&(i=il(s).filter(function(e){return Co(e.getAttribute(\"aria-labelledby\")||\"\").includes(s.props.id)}).map(function(e){return Dr(e)}),l.push.apply(l,Yu(i))),s=s.parent;if(0<l.length&&l.every(Hs))return!1;if(!(o=Oa(t,!1,!0))||!Ki(o,{emoji:!0,nonBmp:!1,punctuations:!0}))return!1;for(var u=document.createRange(),c=t.children,d=0;d<c.length;d++){var p=c[d];3===p.actualNode.nodeType&&\"\"!==ka(p.actualNode.nodeValue)&&u.selectNodeContents(p.actualNode)}for(var f=u.getClientRects(),m=0;m<f.length;m++)if(bn(f[m],e))return!0;return!1},\"data-table-large-matches\":function(e){if(os(e)){e=Mo(e);return 3<=e.length&&3<=e[0].length&&3<=e[1].length&&3<=e[2].length}return!1},\"data-table-matches\":function(e){return os(e)},\"duplicate-id-active-matches\":function(e){var t=e.getAttribute(\"id\").trim(),t='*[id=\"'.concat(Kt(t),'\"]'),t=Array.from(na(e).querySelectorAll(t));return!Dl(e)&&t.some(Va)},\"duplicate-id-aria-matches\":function(e){return Dl(e)},\"duplicate-id-misc-matches\":function(e){var t=e.getAttribute(\"id\").trim(),t='*[id=\"'.concat(Kt(t),'\"]'),t=Array.from(na(e).querySelectorAll(t));return!Dl(e)&&t.every(function(e){return!Va(e)})},\"frame-focusable-content-matches\":function(e,t,r){return!r.initiator&&!r.focusable&&1<r.boundingClientRect.width*r.boundingClientRect.height},\"frame-title-has-text-matches\":function(e){return e=e.getAttribute(\"title\"),!!ka(e)},\"heading-matches\":function(e){var t;return(t=e.hasAttribute(\"role\")?e.getAttribute(\"role\").split(/\\s+/i).filter(axe.commons.aria.isValidRole):t)&&0<t.length?t.includes(\"heading\"):\"heading\"===axe.commons.aria.implicitRole(e)},\"html-namespace-matches\":function(e,t){return!Zs(e,t)},\"identical-links-same-purpose-matches\":function(e,t){return!!Mi(t)&&(!(e=di(e))||\"link\"===e)},\"inserted-into-focus-order-matches\":function(e){return Ha(e)},\"is-initiator-matches\":Qs,\"label-content-name-mismatch-matches\":function(e,t){var r=di(e);return!!r&&(!!dl(\"widget\").includes(r)&&(!!fl().includes(r)&&(!(!ka(Po(t))&&!ka(Ui(e)))&&!!ka(Oa(t)))))},\"label-matches\":function(e,t){return\"input\"!==t.props.nodeName||!1===t.hasAttr(\"type\")||(t=t.attr(\"type\").toLowerCase(),!1===[\"hidden\",\"image\",\"button\",\"submit\",\"reset\"].includes(t))},\"landmark-has-body-context-matches\":function(e,t){return e.hasAttribute(\"role\")||!ia(t,\"article, aside, main, nav, section\")},\"landmark-unique-matches\":function(e,t){var r,a,n,o=[\"article\",\"aside\",\"main\",\"nav\",\"section\"].join(\",\");return a=(r=t).actualNode,n=dl(\"landmark\"),!!(t=di(a))&&(\"HEADER\"===(a=a.nodeName.toUpperCase())||\"FOOTER\"===a?!ia(r,o):\"SECTION\"!==a&&\"FORM\"!==a?0<=n.indexOf(t)||\"region\"===t:!!Mi(r))&&ba(e,!0)},\"layout-table-matches\":function(e){return!os(e)&&!Va(e)},\"link-in-text-block-matches\":function(e){var t=ka(e.textContent),r=e.getAttribute(\"role\");return(!r||\"link\"===r)&&(!!t&&(!!ba(e,!1)&&Ga(e)))},\"nested-interactive-matches\":function(e,t){return!!(t=di(t))&&!!nn.ariaRoles[t].childrenPresentational},\"no-autoplay-audio-matches\":function(e){return!!e.currentSrc&&(!e.hasAttribute(\"paused\")&&!e.hasAttribute(\"muted\"))},\"no-empty-role-matches\":function(e,t){return!!t.hasAttr(\"role\")&&!!t.attr(\"role\").trim()},\"no-explicit-name-required-matches\":function(e,t){var r=Lo(t);return!(r&&![\"none\",\"presentation\"].includes(r))||!(!(Za[r]||{}).accessibleNameRequired&&!Va(t))},\"no-naming-method-matches\":bl,\"no-role-matches\":function(e){return!e.getAttribute(\"role\")},\"not-html-matches\":function(e,t){return\"html\"!==t.props.nodeName},\"p-as-heading-matches\":function(e){var t=Array.from(e.parentNode.childNodes),r=e.textContent.trim();return!(0===r.length||2<=(r.match(/[.!?:;](?![.!?:;])/g)||[]).length)&&0!==t.slice(t.indexOf(e)+1).filter(function(e){return\"P\"===e.nodeName.toUpperCase()&&\"\"!==e.textContent.trim()}).length},\"scrollable-region-focusable-matches\":function(e,t){if(!1==!!Pn(e,13))return!1;var r=Lo(t);if(nn.ariaRoles.combobox.requiredOwned.includes(r)){if(Ir(t,'[role~=\"combobox\"]'))return!1;r=t.attr(\"id\");if(r){e=aa(e);if(Array.from(e.querySelectorAll('[aria-owns~=\"'.concat(r,'\"], [aria-controls~=\"').concat(r,'\"]'))).some(function(e){return Co(e.getAttribute(\"role\")).includes(\"combobox\")}))return!1}}return!!vo(t,\"*\").some(function(e){return Ia(e,!0,!0)})},\"skip-link-matches\":function(e){return cn(e)&&fa(e)},\"svg-namespace-matches\":Zs,\"window-is-top-matches\":function(e){return e.ownerDocument.defaultView.self===e.ownerDocument.defaultView.top},\"xml-lang-mismatch-matches\":function(e){var t=xn(e.getAttribute(\"lang\")),e=xn(e.getAttribute(\"xml:lang\"));return To(t)&&To(e)}};var tu=function(e){this.id=e.id,this.data=null,this.relatedNodes=[],this.result=null};function ru(e){if(\"string\"!=typeof e)return e;if(eu[e])return eu[e];if(/^\\s*function[\\s\\w]*\\(/.test(e))return new Function(\"return \"+e+\";\")();throw new ReferenceError(\"Function ID does not exist in the metadata-function-map: \".concat(e))}function au(e){var t=0<arguments.length&&void 0!==e?e:{};return t=Array.isArray(t)||\"object\"!==Lu(t)?{value:t}:t}function nu(e){e&&(this.id=e.id,this.configure(e))}nu.prototype.enabled=!0,nu.prototype.run=function(t,e,r,a,n){var o=((e=e||{}).hasOwnProperty(\"enabled\")?e:this).enabled,i=this.getOptions(e.options);if(o){var l,o=new tu(this),e=Er(o,e,a,n);try{l=this.evaluate.call(e,t.actualNode,i,t,r)}catch(e){return t&&t.actualNode&&(e.errorNode=new xr(t).toJSON()),void n(e)}e.isAsync||(o.result=l,a(o))}else a(null)},nu.prototype.runSync=function(t,e,r){var a=(e=e||{}).enabled;if(!(void 0===a?this.enabled:a))return null;var n,o=this.getOptions(e.options),a=new tu(this),e=Er(a,e);e.async=function(){throw new Error(\"Cannot run async check while in a synchronous run\")};try{n=this.evaluate.call(e,t.actualNode,o,t,r)}catch(e){throw t&&t.actualNode&&(e.errorNode=new xr(t).toJSON()),e}return a.result=n,a},nu.prototype.configure=function(t){var r=this;t.evaluate&&!eu[t.evaluate]||(this._internalCheck=!0),t.hasOwnProperty(\"enabled\")&&(this.enabled=t.enabled),t.hasOwnProperty(\"options\")&&(this._internalCheck?this.options=au(t.options):this.options=t.options),[\"evaluate\",\"after\"].filter(function(e){return t.hasOwnProperty(e)}).forEach(function(e){return r[e]=ru(t[e])})},nu.prototype.getOptions=function(e){return this._internalCheck?Qr(this.options,au(e||{})):e||this.options};var ou=nu;var iu=function(e){this.id=e.id,this.result=Je.NA,this.pageLevel=e.pageLevel,this.impact=null,this.nodes=[]};function lu(e,t){this._audit=t,this.id=e.id,this.selector=e.selector||\"*\",e.impact&&(it(Je.impact.includes(e.impact),\"Impact \".concat(e.impact,\" is not a valid impact\")),this.impact=e.impact),this.excludeHidden=\"boolean\"!=typeof e.excludeHidden||e.excludeHidden,this.enabled=\"boolean\"!=typeof e.enabled||e.enabled,this.pageLevel=\"boolean\"==typeof e.pageLevel&&e.pageLevel,this.reviewOnFail=\"boolean\"==typeof e.reviewOnFail&&e.reviewOnFail,this.any=e.any||[],this.all=e.all||[],this.none=e.none||[],this.tags=e.tags||[],this.preload=!!e.preload,e.matches&&(this.matches=ru(e.matches))}function su(e){if(e.length){var r=!1,a={};return e.forEach(function(e){var t=e.results.filter(function(e){return e});(a[e.type]=t).length&&(r=!0)}),r?a:null}}lu.prototype.matches=function(){return!0},lu.prototype.gather=function(e){var t=1<arguments.length&&void 0!==arguments[1]?arguments[1]:{},r=\"mark_gather_start_\"+this.id,a=\"mark_gather_end_\"+this.id,n=\"mark_isHidden_start_\"+this.id,o=\"mark_isHidden_end_\"+this.id;t.performanceTimer&&ro.mark(r);var i=Eo(this.selector,e);return this.excludeHidden&&(t.performanceTimer&&ro.mark(n),i=i.filter(function(e){return!jn(e.actualNode)}),t.performanceTimer&&(ro.mark(o),ro.measure(\"rule_\"+this.id+\"#gather_axe.utils.isHidden\",n,o))),t.performanceTimer&&(ro.mark(a),ro.measure(\"rule_\"+this.id+\"#gather\",r,a)),i},lu.prototype.runChecks=function(t,n,o,i,r,e){var l=this,s=jr();this[t].forEach(function(e){var r=l._audit.checks[e.id||e],a=On(r,l.id,o);s.defer(function(e,t){r.run(n,a,i,e,t)})}),s.then(function(e){e=e.filter(function(e){return e}),r({type:t,results:e})}).catch(e)},lu.prototype.runChecksSync=function(e,r,a,n){var o=this,i=[];return this[e].forEach(function(e){var t=o._audit.checks[e.id||e],e=On(t,o.id,a);i.push(t.runSync(r,e,n))}),{type:e,results:i=i.filter(function(e){return e})}},lu.prototype.run=function(n){var o=this,i=1<arguments.length&&void 0!==arguments[1]?arguments[1]:{},e=2<arguments.length?arguments[2]:void 0,t=3<arguments.length?arguments[3]:void 0;i.performanceTimer&&this._trackPerformance();var r,l=jr(),s=new iu(this);try{r=this.gatherAndMatchNodes(n,i)}catch(e){return void t(new qu({cause:e,ruleId:this.id}))}i.performanceTimer&&this._logGatherPerformance(r),r.forEach(function(a){l.defer(function(r,t){var e=jr();[\"any\",\"all\",\"none\"].forEach(function(r){e.defer(function(e,t){o.runChecks(r,a,i,n,e,t)})}),e.then(function(e){var t=su(e);t&&(t.node=new xr(a,i),s.nodes.push(t),o.reviewOnFail&&([\"any\",\"all\"].forEach(function(e){t[e].forEach(function(e){!1===e.result&&(e.result=void 0)})}),t.none.forEach(function(e){!0===e.result&&(e.result=void 0)}))),r()}).catch(function(e){return t(e)})})}),l.defer(function(e){return setTimeout(e,0)}),i.performanceTimer&&this._logRulePerformance(),l.then(function(){return e(s)}).catch(function(e){return t(e)})},lu.prototype.runSync=function(n){var o=this,i=1<arguments.length&&void 0!==arguments[1]?arguments[1]:{};i.performanceTimer&&this._trackPerformance();var e,l=new iu(this);try{e=this.gatherAndMatchNodes(n,i)}catch(e){throw new qu({cause:e,ruleId:this.id})}return i.performanceTimer&&this._logGatherPerformance(e),e.forEach(function(t){var r=[];[\"any\",\"all\",\"none\"].forEach(function(e){r.push(o.runChecksSync(e,t,i,n))});var a=su(r);a&&(a.node=t.actualNode?new xr(t,i):null,l.nodes.push(a),o.reviewOnFail&&([\"any\",\"all\"].forEach(function(e){a[e].forEach(function(e){!1===e.result&&(e.result=void 0)})}),a.none.forEach(function(e){!0===e.result&&(e.result=void 0)})))}),i.performanceTimer&&this._logRulePerformance(),l},lu.prototype._trackPerformance=function(){this._markStart=\"mark_rule_start_\"+this.id,this._markEnd=\"mark_rule_end_\"+this.id,this._markChecksStart=\"mark_runchecks_start_\"+this.id,this._markChecksEnd=\"mark_runchecks_end_\"+this.id},lu.prototype._logGatherPerformance=function(e){Qe(\"gather (\",e.length,\"):\",ro.timeElapsed()+\"ms\"),ro.mark(this._markChecksStart)},lu.prototype._logRulePerformance=function(){ro.mark(this._markChecksEnd),ro.mark(this._markEnd),ro.measure(\"runchecks_\"+this.id,this._markChecksStart,this._markChecksEnd),ro.measure(\"rule_\"+this.id,this._markStart,this._markEnd)},lu.prototype.gatherAndMatchNodes=function(t,e){var r=this,a=\"mark_matches_start_\"+this.id,n=\"mark_matches_end_\"+this.id,o=this.gather(t,e);return e.performanceTimer&&ro.mark(a),o=o.filter(function(e){return r.matches(e.actualNode,e,t)}),e.performanceTimer&&(ro.mark(n),ro.measure(\"rule_\"+this.id+\"#matches\",a,n)),o},lu.prototype.after=function(i,l){var t,e,a,r=Wr(t=this).map(function(e){e=t._audit.checks[e.id||e];return e&&\"function\"==typeof e.after?e:null}).filter(Boolean),s=this.id;return r.forEach(function(e){var r,a,t=(n=i.nodes,r=e.id,a=[],n.forEach(function(t){Wr(t).forEach(function(e){e.id===r&&(e.node=t.node,a.push(e))})}),a),n=On(e,s,l),o=e.after(t,n);t.forEach(function(e){delete e.node,-1===o.indexOf(e)&&(e.filtered=!0)})}),i.nodes=(a=[\"any\",\"all\",\"none\"],r=(e=i).nodes.filter(function(t){var r=0;return a.forEach(function(e){t[e]=t[e].filter(function(e){return!0!==e.filtered}),r+=t[e].length}),0<r}),r=e.pageLevel&&r.length?[r.reduce(function(t,r){if(t)return a.forEach(function(e){t[e].push.apply(t[e],r[e])}),t})]:r),i},lu.prototype.configure=function(e){e.hasOwnProperty(\"selector\")&&(this.selector=e.selector),e.hasOwnProperty(\"excludeHidden\")&&(this.excludeHidden=\"boolean\"!=typeof e.excludeHidden||e.excludeHidden),e.hasOwnProperty(\"enabled\")&&(this.enabled=\"boolean\"!=typeof e.enabled||e.enabled),e.hasOwnProperty(\"pageLevel\")&&(this.pageLevel=\"boolean\"==typeof e.pageLevel&&e.pageLevel),e.hasOwnProperty(\"reviewOnFail\")&&(this.reviewOnFail=\"boolean\"==typeof e.reviewOnFail&&e.reviewOnFail),e.hasOwnProperty(\"any\")&&(this.any=e.any),e.hasOwnProperty(\"all\")&&(this.all=e.all),e.hasOwnProperty(\"none\")&&(this.none=e.none),e.hasOwnProperty(\"tags\")&&(this.tags=e.tags),e.hasOwnProperty(\"matches\")&&(this.matches=ru(e.matches)),e.impact&&(it(Je.impact.includes(e.impact),\"Impact \".concat(e.impact,\" is not a valid impact\")),this.impact=e.impact)};var uu=lu,cu=c(We()),du=/\\{\\{.+?\\}\\}/g;function pu(){return window.origin||(window.location&&window.location.origin?window.location.origin:void 0)}function fu(e,t,r){for(var a=0,n=e.length;a<n;a++)t[r](e[a])}function mu(e){Ju(this,mu),this.lang=\"en\",this.defaultConfig=e,this.standards=nn,this._init(),this._defaultLocale=null}function hu(a,e,n){return n.performanceTimer&&ro.mark(\"mark_rule_start_\"+a.id),function(t,r){a.run(e,n,function(e){t(e)},function(e){n.debug?r(e):(e=Object.assign(new iu(a),{result:Je.CANTTELL,description:\"An error occured while running this rule\",message:e.message,stack:e.stack,error:e,errorNode:e.errorNode}),t(e))})}}function gu(e,t,r){var a=e.brand,n=e.application,e=e.lang;return Je.helpUrlBase+a+\"/\"+(r||axe.version.substring(0,axe.version.lastIndexOf(\".\")))+\"/\"+t+\"?application=\"+encodeURIComponent(n)+(e&&\"en\"!==e?\"&lang=\"+encodeURIComponent(e):\"\")}var bu=(Qu(mu,[{key:\"_setDefaultLocale\",value:function(){if(!this._defaultLocale){for(var e={checks:{},rules:{},failureSummaries:{},incompleteFallbackMessage:\"\",lang:this.lang},t=Object.keys(this.data.checks),r=0;r<t.length;r++){var a=t[r],n=this.data.checks[a].messages,o=n.pass,i=n.fail,n=n.incomplete;e.checks[a]={pass:o,fail:i,incomplete:n}}for(var l=Object.keys(this.data.rules),s=0;s<l.length;s++){var u=l[s],c=this.data.rules[u],d=c.description,c=c.help;e.rules[u]={description:d,help:c}}for(var p=Object.keys(this.data.failureSummaries),f=0;f<p.length;f++){var m=p[f],h=this.data.failureSummaries[m].failureMessage;e.failureSummaries[m]={failureMessage:h}}e.incompleteFallbackMessage=this.data.incompleteFallbackMessage,this._defaultLocale=e}}},{key:\"_resetLocale\",value:function(){var e=this._defaultLocale;e&&this.applyLocale(e)}},{key:\"_applyCheckLocale\",value:function(e){for(var t,r,a,n=Object.keys(e),o=0;o<n.length;o++){var i=n[o];if(!this.data.checks[i])throw new Error('Locale provided for unknown check: \"'.concat(i,'\"'));this.data.checks[i]=(t=this.data.checks[i],r=e[i],i=a=void 0,a=r.pass,i=r.fail,\"string\"==typeof a&&du.test(a)&&(a=cu.default.compile(a)),\"string\"==typeof i&&du.test(i)&&(i=cu.default.compile(i)),Xu({},t,{messages:{pass:a||t.messages.pass,fail:i||t.messages.fail,incomplete:\"object\"===Lu(t.messages.incomplete)?Xu({},t.messages.incomplete,r.incomplete):r.incomplete}}))}}},{key:\"_applyRuleLocale\",value:function(e){for(var t,r,a=Object.keys(e),n=0;n<a.length;n++){var o=a[n];if(!this.data.rules[o])throw new Error('Locale provided for unknown rule: \"'.concat(o,'\"'));this.data.rules[o]=(t=this.data.rules[o],r=e[o],o=void 0,o=r.help,r=r.description,\"string\"==typeof o&&du.test(o)&&(o=cu.default.compile(o)),\"string\"==typeof r&&du.test(r)&&(r=cu.default.compile(r)),Xu({},t,{help:o||t.help,description:r||t.description}))}}},{key:\"_applyFailureSummaries\",value:function(e){for(var t=Object.keys(e),r=0;r<t.length;r++){var a=t[r];if(!this.data.failureSummaries[a])throw new Error('Locale provided for unknown failureMessage: \"'.concat(a,'\"'));this.data.failureSummaries[a]=function(e,t){t=t.failureMessage;return Xu({},e,{failureMessage:(t=\"string\"==typeof t&&du.test(t)?cu.default.compile(t):t)||e.failureMessage})}(this.data.failureSummaries[a],e[a])}}},{key:\"applyLocale\",value:function(e){var t,r;this._setDefaultLocale(),e.checks&&this._applyCheckLocale(e.checks),e.rules&&this._applyRuleLocale(e.rules),e.failureSummaries&&this._applyFailureSummaries(e.failureSummaries,\"failureSummaries\"),e.incompleteFallbackMessage&&(this.data.incompleteFallbackMessage=(t=this.data.incompleteFallbackMessage,(r=\"string\"==typeof(r=e.incompleteFallbackMessage)&&du.test(r)?cu.default.compile(r):r)||t)),e.lang&&(this.lang=e.lang)}},{key:\"setAllowedOrigins\",value:function(e){var t=pu();this.allowedOrigins=[];var r,a=Zu(e);try{for(a.s();!(r=a.n()).done;){var n=r.value;if(n===Je.allOrigins)return void(this.allowedOrigins=[\"*\"]);n!==Je.sameOrigin?this.allowedOrigins.push(n):t&&this.allowedOrigins.push(t)}}catch(e){a.e(e)}finally{a.f()}}},{key:\"_init\",value:function(){var e,t,t=((e=this.defaultConfig)?(t=Ar(e)).commons=e.commons:t={},t.reporter=t.reporter||null,t.noHtml=t.noHtml||!1,t.allowedOrigins||(e=pu(),t.allowedOrigins=e?[e]:[]),t.rules=t.rules||[],t.checks=t.checks||[],t.data=Xu({checks:{},rules:{}},t.data),t);this.lang=t.lang||\"en\",this.reporter=t.reporter,this.commands={},this.rules=[],this.checks={},this.brand=\"axe\",this.application=\"axeAPI\",this.tagExclude=[\"experimental\"],this.noHtml=t.noHtml,this.allowedOrigins=t.allowedOrigins,fu(t.rules,this,\"addRule\"),fu(t.checks,this,\"addCheck\"),this.data={},this.data.checks=t.data&&t.data.checks||{},this.data.rules=t.data&&t.data.rules||{},this.data.failureSummaries=t.data&&t.data.failureSummaries||{},this.data.incompleteFallbackMessage=t.data&&t.data.incompleteFallbackMessage||\"\",this._constructHelpUrls()}},{key:\"registerCommand\",value:function(e){this.commands[e.id]=e.callback}},{key:\"addRule\",value:function(e){e.metadata&&(this.data.rules[e.id]=e.metadata);var t=this.getRule(e.id);t?t.configure(e):this.rules.push(new uu(e,this))}},{key:\"addCheck\",value:function(e){var t=e.metadata;\"object\"===Lu(t)&&(this.data.checks[e.id]=t,\"object\"===Lu(t.messages)&&Object.keys(t.messages).filter(function(e){return t.messages.hasOwnProperty(e)&&\"string\"==typeof t.messages[e]}).forEach(function(e){0===t.messages[e].indexOf(\"function\")&&(t.messages[e]=new Function(\"return \"+t.messages[e]+\";\")())})),this.checks[e.id]?this.checks[e.id].configure(e):this.checks[e.id]=new ou(e)}},{key:\"run\",value:function(n,o,i,l){this.normalizeOptions(o),axe._selectCache=[];var r,a,e=(t=this.rules,r=n,a=o,t.reduce(function(e,t){return wo(t,r,a)&&(t.preload?e.later:e.now).push(t),e},{now:[],later:[]})),t=e.now,s=e.later,u=jr();t.forEach(function(e){u.defer(hu(e,n,o))});e=jr();s.length&&e.defer(function(t){go(o).then(function(e){return t(e)}).catch(function(e){console.warn(\"Couldn't load preload assets: \",e),t(void 0)})});t=jr();t.defer(u),t.defer(e),t.then(function(e){var t=e.pop();t&&t.length&&((t=t[0])&&(n=Xu({},n,t)));var r=e[0];if(!s.length)return axe._selectCache=void 0,void i(r.filter(function(e){return!!e}));var a=jr();s.forEach(function(e){e=hu(e,n,o);a.defer(e)}),a.then(function(e){axe._selectCache=void 0,i(r.concat(e).filter(function(e){return!!e}))}).catch(l)}).catch(l)}},{key:\"after\",value:function(e,r){var a=this.rules;return e.map(function(e){var t=Gr(a,\"id\",e.id);if(!t)throw new Error(\"Result for unknown rule. You may be running mismatch axe-core versions\");return t.after(e,r)})}},{key:\"getRule\",value:function(t){return this.rules.find(function(e){return e.id===t})}},{key:\"normalizeOptions\",value:function(e){var t=[],r=[];if(this.rules.forEach(function(e){r.push(e.id),e.tags.forEach(function(e){t.includes(e)||t.push(e)})}),\"object\"===Lu(e.runOnly)){if(Array.isArray(e.runOnly)){var a=e.runOnly.find(function(e){return t.includes(e)}),n=e.runOnly.find(function(e){return r.includes(e)});if(a&&n)throw new Error(\"runOnly cannot be both rules and tags\");e.runOnly=n?{type:\"rule\",values:e.runOnly}:{type:\"tag\",values:e.runOnly}}n=e.runOnly;if(n.value&&!n.values&&(n.values=n.value,delete n.value),!Array.isArray(n.values)||0===n.values.length)throw new Error(\"runOnly.values must be a non-empty array\");if([\"rule\",\"rules\"].includes(n.type))n.type=\"rule\",n.values.forEach(function(e){if(!r.includes(e))throw new Error(\"unknown rule `\"+e+\"` in options.runOnly\")});else{if(![\"tag\",\"tags\",void 0].includes(n.type))throw new Error(\"Unknown runOnly type '\".concat(n.type,\"'\"));n.type=\"tag\";n=n.values.filter(function(e){return!t.includes(e)});0!==n.length&&Qe(\"Could not find tags `\"+n.join(\"`, `\")+\"`\")}}return\"object\"===Lu(e.rules)&&Object.keys(e.rules).forEach(function(e){if(!r.includes(e))throw new Error(\"unknown rule `\"+e+\"` in options.rules\")}),e}},{key:\"setBranding\",value:function(e){var t={brand:this.brand,application:this.application};e&&e.hasOwnProperty(\"brand\")&&e.brand&&\"string\"==typeof e.brand&&(this.brand=e.brand),e&&e.hasOwnProperty(\"application\")&&e.application&&\"string\"==typeof e.application&&(this.application=e.application),this._constructHelpUrls(t)}},{key:\"_constructHelpUrls\",value:function(){var r=this,a=0<arguments.length&&void 0!==arguments[0]?arguments[0]:null,n=(axe.version.match(/^[1-9][0-9]*\\.[0-9]+/)||[\"x.y\"])[0];this.rules.forEach(function(e){r.data.rules[e.id]||(r.data.rules[e.id]={});var t=r.data.rules[e.id];(\"string\"!=typeof t.helpUrl||a&&t.helpUrl===gu(a,e.id,n))&&(t.helpUrl=gu(r,e.id,n))})}},{key:\"resetRulesAndChecks\",value:function(){this._init(),this._resetLocale()}}]),mu);function yu(e,t){for(var r,a,n=[],o=0,i=e[t].length;o<i;o++){if(\"string\"==typeof(r=e[t][o])){a=Array.from(document.querySelectorAll(r)),n=n.concat(a.map(function(e){return Dr(e)}));break}!r||!r.length||r instanceof window.Node?r instanceof window.Node&&(r.documentElement instanceof window.Node?n.push(e.flatTree[0]):n.push(Dr(r))):1<r.length?function(e,t,r){var a;e.frames=e.frames||[];var n=document.querySelectorAll(r.shift());e:for(var o=0,i=n.length;o<i;o++){for(var l=n[o],s=0,u=e.frames.length;s<u;s++)if(e.frames[s].node===l){e.frames[s][t].push(r);break e}a={node:l,include:[],exclude:[]},r&&a[t].push(r),e.frames.push(a)}}(e,t,r):(a=Array.from(document.querySelectorAll(r[0])),n=n.concat(a.map(function(e){return Dr(e)})))}return n.filter(function(e){return e})}var vu=function(e){var r=this;if(this.frames=[],this.initiator=!e||\"boolean\"!=typeof e.initiator||e.initiator,this.focusable=!e||\"boolean\"!=typeof e.focusable||e.focusable,this.boundingClientRect=e&&\"object\"===Lu(e.boundingClientRect)?e.boundingClientRect:{},this.page=!1,e=function(e){if(e&&\"object\"===Lu(e)||e instanceof window.NodeList){if(e instanceof window.Node)return{include:[e],exclude:[]};if(e.hasOwnProperty(\"include\")||e.hasOwnProperty(\"exclude\"))return{include:e.include&&+e.include.length?e.include:[document],exclude:e.exclude||[]};if(e.length===+e.length)return{include:e,exclude:[]}}return\"string\"==typeof e?{include:[e],exclude:[]}:{include:[document],exclude:[]}}(e),this.flatTree=wn(function(e){for(var t=e.include,e=e.exclude,r=Array.from(t).concat(Array.from(e)),a=0;a<r.length;++a){var n=r[a];if(n instanceof window.Element)return n.ownerDocument.documentElement;if(n instanceof window.Document)return n.documentElement}return document.documentElement}(e)),this.exclude=e.exclude,this.include=e.include,this.include=yu(this,\"include\"),this.exclude=yu(this,\"exclude\"),Eo(\"frame, iframe\",this).forEach(function(e){var t;zn(e,r)&&(t=r.frames,e=e.actualNode,jn(e)||Gr(t,\"node\",e)||t.push({node:e,include:[],exclude:[]}))}),1===this.include.length&&this.include[0].actualNode===document.documentElement&&(this.page=!0),(e=function(e){if(0===e.include.length){if(0===e.frames.length){var t=Vr.isInFrame()?\"frame\":\"page\";return new Error(\"No elements found for include in \"+t+\" Context\")}e.frames.forEach(function(e,t){if(0===e.include.length)return new Error(\"No elements found for include in Context of frame \"+t)})}}(this))instanceof Error)throw e;Array.isArray(this.include)||(this.include=Array.from(this.include)),this.include.sort(Gn)},ei={};o(ei,{CssSelectorParser:function(){return Du.CssSelectorParser},doT:function(){return wu.default},emojiRegexText:function(){return xu.default},memoize:function(){return Eu.default}});var Du=c(m()),wu=c(We()),xu=c($e()),Eu=c(ze()),ti=c(Ge()),gl=c(Ye());c(Ke());\"Promise\"in window||ti.default.polyfill(),\"Uint32Array\"in window||(window.Uint32Array=gl.Uint32Array),window.Uint32Array&&(\"some\"in window.Uint32Array.prototype||Object.defineProperty(window.Uint32Array.prototype,\"some\",{value:Array.prototype.some}),\"reduce\"in window.Uint32Array.prototype||Object.defineProperty(window.Uint32Array.prototype,\"reduce\",{value:Array.prototype.reduce}));var Au,Cu=function(t,r){if(t=t||function(){},r=r||axe.log,!axe._audit)throw new Error(\"No audit configured\");var a=axe.utils.queue(),n=[];Object.keys(axe.plugins).forEach(function(e){a.defer(function(t){function r(e){n.push(e),t()}try{axe.plugins[e].cleanup(t,r)}catch(e){r(e)}})});var e=axe.utils.getFlattenedTree(document.body);axe.utils.querySelectorAll(e,\"iframe, frame\").forEach(function(r){a.defer(function(e,t){return axe.utils.sendCommandToFrame(r.actualNode,{command:\"cleanup-plugin\"},e,t)})}),a.then(function(e){0===n.length?t(e):r(n)}).catch(r)},Fu={};function ku(e){return Fu.hasOwnProperty(e)}function Ru(e){return\"string\"==typeof e&&Fu[e]?Fu[e]:\"function\"==typeof e?e:Au}hl=function(e){var t=axe._audit;if(!t)throw new Error(\"No audit configured\");if(e.axeVersion||e.ver){var r=e.axeVersion||e.ver;if(!/^\\d+\\.\\d+\\.\\d+(-canary)?/.test(r))throw new Error(\"Invalid configured version \".concat(r));var a=Ku(r.split(\"-\"),2),n=a[0],o=a[1],i=Ku(n.split(\".\").map(Number),3),l=i[0],s=i[1],u=i[2],c=Ku(axe.version.split(\"-\"),2),a=c[0],n=c[1],i=Ku(a.split(\".\").map(Number),3),c=i[0],a=i[1],i=i[2];if(l!==c||a<s||a===s&&i<u||l===c&&s===a&&u===i&&o&&o!==n)throw new Error(\"Configured version \".concat(r,\" is not compatible with current axe version \").concat(axe.version))}if(e.reporter&&(\"function\"==typeof e.reporter||ku(e.reporter))&&(t.reporter=e.reporter),e.checks){if(!Array.isArray(e.checks))throw new TypeError(\"Checks property must be an array\");e.checks.forEach(function(e){if(!e.id)throw new TypeError(\"Configured check \".concat(JSON.stringify(e),\" is invalid. Checks must be an object with at least an id property\"));t.addCheck(e)})}var d,p=[];if(e.rules){if(!Array.isArray(e.rules))throw new TypeError(\"Rules property must be an array\");e.rules.forEach(function(e){if(!e.id)throw new TypeError(\"Configured rule \".concat(JSON.stringify(e),\" is invalid. Rules must be an object with at least an id property\"));p.push(e.id),t.addRule(e)})}if(e.disableOtherRules&&t.rules.forEach(function(e){!1===p.includes(e.id)&&(e.enabled=!1)}),void 0!==e.branding?t.setBranding(e.branding):t._constructHelpUrls(),e.tagExclude&&(t.tagExclude=e.tagExclude),e.locale&&t.applyLocale(e.locale),e.standards&&(d=e.standards,Object.keys(an).forEach(function(e){d[e]&&(an[e]=Qr(an[e],d[e]))})),e.noHtml&&(t.noHtml=!0),e.allowedOrigins){if(!Array.isArray(e.allowedOrigins))throw new TypeError(\"Allowed origins property must be an array\");if(e.allowedOrigins.includes(\"*\"))throw new Error('\"*\" is not allowed. Use \"'.concat(Je.allOrigins,'\" instead'));t.setAllowedOrigins(e.allowedOrigins)}};bl=function(e){var t=(e=e||[]).length?axe._audit.rules.filter(function(t){return!!e.filter(function(e){return-1!==t.tags.indexOf(e)}).length}):axe._audit.rules,r=axe._audit.data.rules||{};return t.map(function(e){var t=r[e.id]||{};return{ruleId:e.id,description:t.description,help:t.help,helpUrl:t.helpUrl,tags:e.tags}})};var Tu=function(){vr.get(\"globalDocumentSet\")&&(document=null),vr.get(\"globalWindowSet\")&&(window=null),axe._memoizedFns.forEach(function(e){return e.clear()}),vr.clear(),axe._tree=void 0,axe._selectorData=void 0,axe._selectCache=void 0};var Nu=function(r,a,n,o){try{r=new vu(r),axe._tree=r.flatTree,axe._selectorData=cr(r.flatTree)}catch(e){return Tu(),o(e)}var e=jr(),i=axe._audit;a.performanceTimer&&ro.auditStart(),r.frames.length&&!1!==a.iframes&&e.defer(function(e,t){Xr(r,a,\"rules\",null,e,t)}),e.defer(function(e,t){i.run(r,a,e,t)}),e.then(function(e){try{a.performanceTimer&&ro.auditEnd();var t=Kr(e.map(function(e){return{results:e}}));r.initiator&&((t=i.after(t,a)).forEach(yo),t=t.map(Ht));try{n(t,Tu)}catch(e){Tu(),Qe(e)}}catch(e){Tu(),o(e)}}).catch(function(e){Tu(),o(e)})};function _u(e,t,r){function a(e){e instanceof Error==!1&&(e=new Error(e)),r(e)}var n=r,o=e&&e.context||{};o.hasOwnProperty(\"include\")&&!o.include.length&&(o.include=[document]);var i=e&&e.options||{};switch(e.command){case\"rules\":return Nu(o,i,function(e,t){n(e),t()},a);case\"cleanup-plugin\":return Cu(n,a);default:if(axe._audit&&axe._audit.commands&&axe._audit.commands[e.command])return axe._audit.commands[e.command](e,r)}}window.top!==window&&(Vr.subscribe(\"axe.start\",_u),Vr.subscribe(\"axe.ping\",function(e,t,r){r({axe:!0})}));o=function(e){axe._audit=new bu(e)};function Ou(e){this._run=e.run,this._collect=e.collect,this._registry={},e.commands.forEach(function(e){axe._audit.registerCommand(e)})}Ou.prototype.run=function(){return this._run.apply(this,arguments)},Ou.prototype.collect=function(){return this._collect.apply(this,arguments)},Ou.prototype.cleanup=function(e){var r=axe.utils.queue(),a=this;Object.keys(this._registry).forEach(function(t){r.defer(function(e){a._registry[t].cleanup(e)})}),r.then(e)},Ou.prototype.add=function(e){this._registry[e.id]=e};m=function(e){axe.plugins[e.id]=new Ou(e)};We=function(){var e=axe._audit;if(!e)throw new Error(\"No audit configured\");e.resetRulesAndChecks(),Object.keys(an).forEach(function(e){an[e]=rn[e]})};$e=function(e,t){var r=2<arguments.length&&void 0!==arguments[2]?arguments[2]:{};r.reporter=r.reporter||axe._audit.reporter||\"v1\",axe._selectorData={},t instanceof tt||(t=new No(t));var a=Sn(e);if(!a)throw new Error(\"unknown rule `\"+e+\"`\");return a=(a=Object.create(a,{excludeHidden:{value:!1}})).runSync({initiator:!0,include:[t]},r),yo(a),Ht(a),(a=Wt([a])).violations.forEach(function(e){return e.nodes.forEach(function(e){e.failureSummary=En(e)})}),Xu({},An(),a,{toolOptions:r})};var Su=function(){};function Pu(e,t,r){var a=new TypeError(\"axe.run arguments are invalid\");if(!function(e){switch(!0){case\"string\"==typeof e:case Array.isArray(e):case window.Node&&e instanceof window.Node:case window.NodeList&&e instanceof window.NodeList:return 1;case\"object\"!==Lu(e):return;case void 0!==e.include:case void 0!==e.exclude:case\"number\"==typeof e.length:return 1;default:return}}(e)){if(void 0!==r)throw a;r=t,t=e,e=document}if(\"object\"!==Lu(t)){if(void 0!==r)throw a;r=t,t={}}if(\"function\"!=typeof r&&void 0!==r)throw a;return{context:e,options:t,callback:r||Su}}ze=function(e,n,o){if(!axe._audit)throw new Error(\"No audit configured\");var t=window&&\"Node\"in window&&\"NodeList\"in window,r=!!document;if(!t||!r){if(!e||!e.ownerDocument)throw new Error('Required \"window\" or \"document\" globals not defined and cannot be deduced from the context. Either set the globals before running or pass in a valid Element.');r||(vr.set(\"globalDocumentSet\",!0),document=e.ownerDocument),t||(vr.set(\"globalWindowSet\",!0),window=document.defaultView)}var a,t=Pu(e,n,o);e=t.context,n=t.options,o=t.callback,n.reporter=n.reporter||axe._audit.reporter||\"v1\",n.performanceTimer&&axe.utils.performanceTimer.start();var i=Su,l=Su;if(\"function\"==typeof Promise&&o===Su&&(a=new Promise(function(e,t){i=t,l=e})),axe._running){t=\"Axe is already running. Use `await axe.run()` to wait for the previous run to finish before starting a new run.\";return o(t),i(t),a}return axe._running=!0,axe._runRules(e,n,function(e,t){function r(e){axe._running=!1,t();try{o(null,e)}catch(e){axe.log(e)}l(e)}n.performanceTimer&&axe.utils.performanceTimer.end();try{var a=Ru(n.reporter)(e,n,r);void 0!==a&&r(a)}catch(e){axe._running=!1,t(),o(e),i(e)}},function(e){axe._running=!1,o(e),i(e)}),a};var Ge=function(e){if(axe._tree)throw new Error(\"Axe is already setup. Call `axe.teardown()` before calling `axe.setup` again.\");return axe._tree=wn(e),axe._selectorData=cr(axe._tree),axe._tree[0]},Ye=function(e,t,r){console.warn('\"na\" reporter will be deprecated in axe v4.0. Use the \"v2\" reporter instead.'),\"function\"==typeof t&&(r=t,t={});e=kn(e,t);r(Xu({},An(),{toolOptions:t,violations:e.violations,passes:e.passes,incomplete:e.incomplete,inapplicable:e.inapplicable}))},c=function(e,t,r){\"function\"==typeof t&&(r=t,t={}),t.resultTypes=[\"violations\"];e=kn(e,t);r(Xu({},An(),{toolOptions:t,violations:e.violations}))},Iu=function(e,t,r){if(\"function\"==typeof t&&(r=t,t={}),!e||!Array.isArray(e))return r(e);r(e.map(function(e){for(var t=Xu({},e),r=0,a=[\"passes\",\"violations\",\"incomplete\",\"inapplicable\"];r<a.length;r++){var n=a[r];t[n]&&Array.isArray(t[n])&&(t[n]=t[n].map(function(e){return Xu({},e,{node:e.node.toJSON()})}))}return t}))},Ke=function(e,t,r){\"function\"==typeof t&&(r=t,t={}),Iu(e,t,function(e){var t=An();r({raw:e,env:t})})},ti=function(e,t,r){\"function\"==typeof t&&(r=t,t={});var a=kn(e,t),e=function(e){e.nodes.forEach(function(e){e.failureSummary=En(e)})};a.incomplete.forEach(e),a.violations.forEach(e),r(Xu({},An(),{toolOptions:t,violations:a.violations,passes:a.passes,incomplete:a.incomplete,inapplicable:a.inapplicable}))},gl=function(e,t,r){\"function\"==typeof t&&(r=t,t={});e=kn(e,t);r(Xu({},An(),{toolOptions:t,violations:e.violations,passes:e.passes,incomplete:e.incomplete,inapplicable:e.inapplicable}))};axe.constants=Je,axe.log=Qe,axe.AbstractVirtualNode=tt,axe.SerialVirtualNode=No,axe.VirtualNode=vn,axe._cache=vr,axe._thisWillBeDeletedDoNotUse=axe._thisWillBeDeletedDoNotUse||{},axe._thisWillBeDeletedDoNotUse.base={Audit:bu,CheckResult:tu,Check:ou,Context:vu,RuleResult:iu,Rule:uu,metadataFunctionMap:eu},axe.imports=ei,axe.cleanup=Cu,axe.configure=hl,axe.frameMessenger=function(e){Vr.updateMessenger(e)},axe.getRules=bl,axe._load=o,axe.plugins={},axe.registerPlugin=m,axe.hasReporter=ku,axe.getReporter=Ru,axe.addReporter=function(e,t,r){Fu[e]=t,r&&(Au=t)},axe.reset=We,axe._runRules=Nu,axe.runVirtualRule=$e,axe.run=ze,axe.setup=Ge,axe.teardown=Tu,axe.commons=Zo,axe.utils=rt,axe.addReporter(\"na\",Ye),axe.addReporter(\"no-passes\",c),axe.addReporter(\"rawEnv\",Ke),axe.addReporter(\"raw\",Iu),axe.addReporter(\"v1\",ti),axe.addReporter(\"v2\",gl,!0)}(),axe._load({lang:\"en\",data:{rules:{accesskeys:{description:\"Ensures every accesskey attribute value is unique\",help:\"accesskey attribute value should be unique\"},\"area-alt\":{description:\"Ensures <area> elements of image maps have alternate text\",help:\"Active <area> elements must have alternate text\"},\"aria-allowed-attr\":{description:\"Ensures ARIA attributes are allowed for an element's role\",help:\"Elements must only use allowed ARIA attributes\"},\"aria-allowed-role\":{description:\"Ensures role attribute has an appropriate value for the element\",help:\"ARIA role should be appropriate for the element\"},\"aria-command-name\":{description:\"Ensures every ARIA button, link and menuitem has an accessible name\",help:\"ARIA commands must have an accessible name\"},\"aria-dialog-name\":{description:\"Ensures every ARIA dialog and alertdialog node has an accessible name\",help:\"ARIA dialog and alertdialog nodes should have an accessible name\"},\"aria-hidden-body\":{description:\"Ensures aria-hidden='true' is not present on the document body.\",help:\"aria-hidden='true' must not be present on the document body\"},\"aria-hidden-focus\":{description:\"Ensures aria-hidden elements do not contain focusable elements\",help:\"ARIA hidden element must not contain focusable elements\"},\"aria-input-field-name\":{description:\"Ensures every ARIA input field has an accessible name\",help:\"ARIA input fields must have an accessible name\"},\"aria-meter-name\":{description:\"Ensures every ARIA meter node has an accessible name\",help:\"ARIA meter nodes must have an accessible name\"},\"aria-progressbar-name\":{description:\"Ensures every ARIA progressbar node has an accessible name\",help:\"ARIA progressbar nodes must have an accessible name\"},\"aria-required-attr\":{description:\"Ensures elements with ARIA roles have all required ARIA attributes\",help:\"Required ARIA attributes must be provided\"},\"aria-required-children\":{description:\"Ensures elements with an ARIA role that require child roles contain them\",help:\"Certain ARIA roles must contain particular children\"},\"aria-required-parent\":{description:\"Ensures elements with an ARIA role that require parent roles are contained by them\",help:\"Certain ARIA roles must be contained by particular parents\"},\"aria-roledescription\":{description:\"Ensure aria-roledescription is only used on elements with an implicit or explicit role\",help:\"Use aria-roledescription on elements with a semantic role\"},\"aria-roles\":{description:\"Ensures all elements with a role attribute use a valid value\",help:\"ARIA roles used must conform to valid values\"},\"aria-text\":{description:'Ensures \"role=text\" is used on elements with no focusable descendants',help:'\"role=text\" should have no focusable descendants'},\"aria-toggle-field-name\":{description:\"Ensures every ARIA toggle field has an accessible name\",help:\"ARIA toggle fields have an accessible name\"},\"aria-tooltip-name\":{description:\"Ensures every ARIA tooltip node has an accessible name\",help:\"ARIA tooltip nodes must have an accessible name\"},\"aria-treeitem-name\":{description:\"Ensures every ARIA treeitem node has an accessible name\",help:\"ARIA treeitem nodes should have an accessible name\"},\"aria-valid-attr-value\":{description:\"Ensures all ARIA attributes have valid values\",help:\"ARIA attributes must conform to valid values\"},\"aria-valid-attr\":{description:\"Ensures attributes that begin with aria- are valid ARIA attributes\",help:\"ARIA attributes must conform to valid names\"},\"audio-caption\":{description:\"Ensures <audio> elements have captions\",help:\"<audio> elements must have a captions track\"},\"autocomplete-valid\":{description:\"Ensure the autocomplete attribute is correct and suitable for the form field\",help:\"autocomplete attribute must be used correctly\"},\"avoid-inline-spacing\":{description:\"Ensure that text spacing set through style attributes can be adjusted with custom stylesheets\",help:\"Inline text spacing must be adjustable with custom stylesheets\"},blink:{description:\"Ensures <blink> elements are not used\",help:\"<blink> elements are deprecated and must not be used\"},\"button-name\":{description:\"Ensures buttons have discernible text\",help:\"Buttons must have discernible text\"},bypass:{description:\"Ensures each page has at least one mechanism for a user to bypass navigation and jump straight to the content\",help:\"Page must have means to bypass repeated blocks\"},\"color-contrast\":{description:\"Ensures the contrast between foreground and background colors meets WCAG 2 AA contrast ratio thresholds\",help:\"Elements must have sufficient color contrast\"},\"css-orientation-lock\":{description:\"Ensures content is not locked to any specific display orientation, and the content is operable in all display orientations\",help:\"CSS Media queries are not used to lock display orientation\"},\"definition-list\":{description:\"Ensures <dl> elements are structured correctly\",help:\"<dl> elements must only directly contain properly-ordered <dt> and <dd> groups, <script>, <template> or <div> elements\"},dlitem:{description:\"Ensures <dt> and <dd> elements are contained by a <dl>\",help:\"<dt> and <dd> elements must be contained by a <dl>\"},\"document-title\":{description:\"Ensures each HTML document contains a non-empty <title> element\",help:\"Documents must have <title> element to aid in navigation\"},\"duplicate-id-active\":{description:\"Ensures every id attribute value of active elements is unique\",help:\"IDs of active elements must be unique\"},\"duplicate-id-aria\":{description:\"Ensures every id attribute value used in ARIA and in labels is unique\",help:\"IDs used in ARIA and labels must be unique\"},\"duplicate-id\":{description:\"Ensures every id attribute value is unique\",help:\"id attribute value must be unique\"},\"empty-heading\":{description:\"Ensures headings have discernible text\",help:\"Headings should not be empty\"},\"empty-table-header\":{description:\"Ensures table headers have discernible text\",help:\"Table header text must not be empty\"},\"focus-order-semantics\":{description:\"Ensures elements in the focus order have an appropriate role\",help:\"Elements in the focus order need a role appropriate for interactive content\"},\"form-field-multiple-labels\":{description:\"Ensures form field does not have multiple label elements\",help:\"Form field must not have multiple label elements\"},\"frame-focusable-content\":{description:\"Ensures <frame> and <iframe> elements with focusable content do not have tabindex=-1\",help:\"Frames with focusable content must not have tabindex=-1\"},\"frame-tested\":{description:\"Ensures <iframe> and <frame> elements contain the axe-core script\",help:\"Frames should be tested with axe-core\"},\"frame-title-unique\":{description:\"Ensures <iframe> and <frame> elements contain a unique title attribute\",help:\"Frames should have a unique title attribute\"},\"frame-title\":{description:\"Ensures <iframe> and <frame> elements have an accessible name\",help:\"Frames must have an accessible name\"},\"heading-order\":{description:\"Ensures the order of headings is semantically correct\",help:\"Heading levels should only increase by one\"},\"hidden-content\":{description:\"Informs users about hidden content.\",help:\"Hidden content on the page cannot be analyzed\"},\"html-has-lang\":{description:\"Ensures every HTML document has a lang attribute\",help:\"<html> element must have a lang attribute\"},\"html-lang-valid\":{description:\"Ensures the lang attribute of the <html> element has a valid value\",help:\"<html> element must have a valid value for the lang attribute\"},\"html-xml-lang-mismatch\":{description:\"Ensure that HTML elements with both valid lang and xml:lang attributes agree on the base language of the page\",help:\"HTML elements with lang and xml:lang must have the same base language\"},\"identical-links-same-purpose\":{description:\"Ensure that links with the same accessible name serve a similar purpose\",help:\"Links with the same name have a similar purpose\"},\"image-alt\":{description:\"Ensures <img> elements have alternate text or a role of none or presentation\",help:\"Images must have alternate text\"},\"image-redundant-alt\":{description:\"Ensure image alternative is not repeated as text\",help:\"Alternative text of images should not be repeated as text\"},\"input-button-name\":{description:\"Ensures input buttons have discernible text\",help:\"Input buttons must have discernible text\"},\"input-image-alt\":{description:'Ensures <input type=\"image\"> elements have alternate text',help:\"Image buttons must have alternate text\"},\"label-content-name-mismatch\":{description:\"Ensures that elements labelled through their content must have their visible text as part of their accessible name\",help:\"Elements must have their visible text as part of their accessible name\"},\"label-title-only\":{description:\"Ensures that every form element is not solely labeled using the title or aria-describedby attributes\",help:\"Form elements should have a visible label\"},label:{description:\"Ensures every form element has a label\",help:\"Form elements must have labels\"},\"landmark-banner-is-top-level\":{description:\"Ensures the banner landmark is at top level\",help:\"Banner landmark should not be contained in another landmark\"},\"landmark-complementary-is-top-level\":{description:\"Ensures the complementary landmark or aside is at top level\",help:\"Aside should not be contained in another landmark\"},\"landmark-contentinfo-is-top-level\":{description:\"Ensures the contentinfo landmark is at top level\",help:\"Contentinfo landmark should not be contained in another landmark\"},\"landmark-main-is-top-level\":{description:\"Ensures the main landmark is at top level\",help:\"Main landmark should not be contained in another landmark\"},\"landmark-no-duplicate-banner\":{description:\"Ensures the document has at most one banner landmark\",help:\"Document should not have more than one banner landmark\"},\"landmark-no-duplicate-contentinfo\":{description:\"Ensures the document has at most one contentinfo landmark\",help:\"Document should not have more than one contentinfo landmark\"},\"landmark-no-duplicate-main\":{description:\"Ensures the document has at most one main landmark\",help:\"Document should not have more than one main landmark\"},\"landmark-one-main\":{description:\"Ensures the document has a main landmark\",help:\"Document should have one main landmark\"},\"landmark-unique\":{help:\"Ensures landmarks are unique\",description:\"Landmarks should have a unique role or role/label/title (i.e. accessible name) combination\"},\"link-in-text-block\":{description:\"Links can be distinguished without relying on color\",help:\"Links must be distinguished from surrounding text in a way that does not rely on color\"},\"link-name\":{description:\"Ensures links have discernible text\",help:\"Links must have discernible text\"},list:{description:\"Ensures that lists are structured correctly\",help:\"<ul> and <ol> must only directly contain <li>, <script> or <template> elements\"},listitem:{description:\"Ensures <li> elements are used semantically\",help:\"<li> elements must be contained in a <ul> or <ol>\"},marquee:{description:\"Ensures <marquee> elements are not used\",help:\"<marquee> elements are deprecated and must not be used\"},\"meta-refresh\":{description:'Ensures <meta http-equiv=\"refresh\"> is not used',help:\"Timed refresh must not exist\"},\"meta-viewport-large\":{description:'Ensures <meta name=\"viewport\"> can scale a significant amount',help:\"Users should be able to zoom and scale the text up to 500%\"},\"meta-viewport\":{description:'Ensures <meta name=\"viewport\"> does not disable text scaling and zooming',help:\"Zooming and scaling should not be disabled\"},\"nested-interactive\":{description:\"Nested interactive controls are not announced by screen readers\",help:\"Ensure interactive controls are not nested\"},\"no-autoplay-audio\":{description:\"Ensures <video> or <audio> elements do not autoplay audio for more than 3 seconds without a control mechanism to stop or mute the audio\",help:\"<video> or <audio> elements do not autoplay audio\"},\"object-alt\":{description:\"Ensures <object> elements have alternate text\",help:\"<object> elements must have alternate text\"},\"p-as-heading\":{description:\"Ensure p elements are not used to style headings\",help:\"Bold, italic text and font-size are not used to style p elements as a heading\"},\"page-has-heading-one\":{description:\"Ensure that the page, or at least one of its frames contains a level-one heading\",help:\"Page should contain a level-one heading\"},\"presentation-role-conflict\":{description:\"Flags elements whose role is none or presentation and which cause the role conflict resolution to trigger.\",help:\"Elements of role none or presentation should be flagged\"},region:{description:\"Ensures all page content is contained by landmarks\",help:\"All page content should be contained by landmarks\"},\"role-img-alt\":{description:\"Ensures [role='img'] elements have alternate text\",help:\"[role='img'] elements have an alternative text\"},\"scope-attr-valid\":{description:\"Ensures the scope attribute is used correctly on tables\",help:\"scope attribute should be used correctly\"},\"scrollable-region-focusable\":{description:\"Elements that have scrollable content must be accessible by keyboard\",help:\"Ensure that scrollable region has keyboard access\"},\"select-name\":{description:\"Ensures select element has an accessible name\",help:\"Select element must have an accessible name\"},\"server-side-image-map\":{description:\"Ensures that server-side image maps are not used\",help:\"Server-side image maps must not be used\"},\"skip-link\":{description:\"Ensure all skip links have a focusable target\",help:\"The skip-link target should exist and be focusable\"},\"svg-img-alt\":{description:\"Ensures svg elements with an img, graphics-document or graphics-symbol role have an accessible text\",help:\"svg elements with an img role have an alternative text\"},tabindex:{description:\"Ensures tabindex attribute values are not greater than 0\",help:\"Elements should not have tabindex greater than zero\"},\"table-duplicate-name\":{description:\"Ensure that tables do not have the same summary and caption\",help:\"The <caption> element should not contain the same text as the summary attribute\"},\"table-fake-caption\":{description:\"Ensure that tables with a caption use the <caption> element.\",help:\"Data or header cells must not be used to give caption to a data table.\"},\"td-has-header\":{description:\"Ensure that each non-empty data cell in a large table has one or more table headers\",help:\"All non-empty td element in table larger than 3 by 3 must have an associated table header\"},\"td-headers-attr\":{description:\"Ensure that each cell in a table using the headers refers to another cell in that table\",help:\"All cells in a table element that use the headers attribute must only refer to other cells of that same table\"},\"th-has-data-cells\":{description:\"Ensure that each table header in a data table refers to data cells\",help:\"All th elements and elements with role=columnheader/rowheader must have data cells they describe\"},\"valid-lang\":{description:\"Ensures lang attributes have valid values\",help:\"lang attribute must have a valid value\"},\"video-caption\":{description:\"Ensures <video> elements have captions\",help:\"<video> elements must have captions\"}},checks:{abstractrole:{impact:\"serious\",messages:{pass:\"Abstract roles are not used\",fail:{singular:\"Abstract role cannot be directly used: ${data.values}\",plural:\"Abstract roles cannot be directly used: ${data.values}\"}}},\"aria-allowed-attr\":{impact:\"critical\",messages:{pass:\"ARIA attributes are used correctly for the defined role\",fail:{singular:\"ARIA attribute is not allowed: ${data.values}\",plural:\"ARIA attributes are not allowed: ${data.values}\"}}},\"aria-allowed-role\":{impact:\"minor\",messages:{pass:\"ARIA role is allowed for given element\",fail:{singular:\"ARIA role ${data.values} is not allowed for given element\",plural:\"ARIA roles ${data.values} are not allowed for given element\"},incomplete:{singular:\"ARIA role ${data.values} must be removed when the element is made visible, as it is not allowed for the element\",plural:\"ARIA roles ${data.values} must be removed when the element is made visible, as they are not allowed for the element\"}}},\"aria-errormessage\":{impact:\"critical\",messages:{pass:\"aria-errormessage exists and references elements visible to screen readers that use a supported aria-errormessage technique\",fail:{singular:\"aria-errormessage value `${data.values}` must use a technique to announce the message (e.g., aria-live, aria-describedby, role=alert, etc.)\",plural:\"aria-errormessage values `${data.values}` must use a technique to announce the message (e.g., aria-live, aria-describedby, role=alert, etc.)\"},incomplete:{singular:\"ensure aria-errormessage value `${data.values}` references an existing element\",plural:\"ensure aria-errormessage values `${data.values}` reference existing elements\"}}},\"aria-hidden-body\":{impact:\"critical\",messages:{pass:\"No aria-hidden attribute is present on document body\",fail:\"aria-hidden=true should not be present on the document body\"}},\"aria-prohibited-attr\":{impact:\"serious\",messages:{pass:\"ARIA attribute is allowed\",fail:\"ARIA attribute cannot be used, add a role attribute or use a different element: ${data.values}\",incomplete:\"ARIA attribute is not well supported on the element and the text content will be used instead: ${data.values}\"}},\"aria-required-attr\":{impact:\"critical\",messages:{pass:\"All required ARIA attributes are present\",fail:{singular:\"Required ARIA attribute not present: ${data.values}\",plural:\"Required ARIA attributes not present: ${data.values}\"}}},\"aria-required-children\":{impact:\"critical\",messages:{pass:\"Required ARIA children are present\",fail:{singular:\"Required ARIA child role not present: ${data.values}\",plural:\"Required ARIA children role not present: ${data.values}\"},incomplete:{singular:\"Expecting ARIA child role to be added: ${data.values}\",plural:\"Expecting ARIA children role to be added: ${data.values}\"}}},\"aria-required-parent\":{impact:\"critical\",messages:{pass:\"Required ARIA parent role present\",fail:{singular:\"Required ARIA parent role not present: ${data.values}\",plural:\"Required ARIA parents role not present: ${data.values}\"}}},\"aria-roledescription\":{impact:\"serious\",messages:{pass:\"aria-roledescription used on a supported semantic role\",incomplete:\"Check that the aria-roledescription is announced by supported screen readers\",fail:\"Give the element a role that supports aria-roledescription\"}},\"aria-unsupported-attr\":{impact:\"critical\",messages:{pass:\"ARIA attribute is supported\",fail:\"ARIA attribute is not widely supported in screen readers and assistive technologies: ${data.values}\"}},\"aria-valid-attr-value\":{impact:\"critical\",messages:{pass:\"ARIA attribute values are valid\",fail:{singular:\"Invalid ARIA attribute value: ${data.values}\",plural:\"Invalid ARIA attribute values: ${data.values}\"},incomplete:{noId:\"ARIA attribute element ID does not exist on the page: ${data.needsReview}\",ariaCurrent:'ARIA attribute value is invalid and will be treated as \"aria-current=true\": ${data.needsReview}'}}},\"aria-valid-attr\":{impact:\"critical\",messages:{pass:\"ARIA attribute name is valid\",fail:{singular:\"Invalid ARIA attribute name: ${data.values}\",plural:\"Invalid ARIA attribute names: ${data.values}\"}}},fallbackrole:{impact:\"serious\",messages:{pass:\"Only one role value used\",fail:\"Use only one role value, since fallback roles are not supported in older browsers\"}},\"has-global-aria-attribute\":{impact:\"minor\",messages:{pass:{singular:\"Element has global ARIA attribute: ${data.values}\",plural:\"Element has global ARIA attributes: ${data.values}\"},fail:\"Element does not have global ARIA attribute\"}},\"has-widget-role\":{impact:\"minor\",messages:{pass:\"Element has a widget role.\",fail:\"Element does not have a widget role.\"}},invalidrole:{impact:\"critical\",messages:{pass:\"ARIA role is valid\",fail:{singular:\"Role must be one of the valid ARIA roles: ${data.values}\",plural:\"Roles must be one of the valid ARIA roles: ${data.values}\"}}},\"is-element-focusable\":{impact:\"minor\",messages:{pass:\"Element is focusable.\",fail:\"Element is not focusable.\"}},\"no-implicit-explicit-label\":{impact:\"moderate\",messages:{pass:\"There is no mismatch between a <label> and accessible name\",incomplete:\"Check that the <label> does not need be part of the ARIA ${data} field's name\"}},unsupportedrole:{impact:\"critical\",messages:{pass:\"ARIA role is supported\",fail:\"The role used is not widely supported in screen readers and assistive technologies: ${data.values}\"}},\"valid-scrollable-semantics\":{impact:\"minor\",messages:{pass:\"Element has valid semantics for an element in the focus order.\",fail:\"Element has invalid semantics for an element in the focus order.\"}},\"color-contrast\":{impact:\"serious\",messages:{pass:\"Element has sufficient color contrast of ${data.contrastRatio}\",fail:\"Element has insufficient color contrast of ${data.contrastRatio} (foreground color: ${data.fgColor}, background color: ${data.bgColor}, font size: ${data.fontSize}, font weight: ${data.fontWeight}). Expected contrast ratio of ${data.expectedContrastRatio}\",incomplete:{default:\"Unable to determine contrast ratio\",bgImage:\"Element's background color could not be determined due to a background image\",bgGradient:\"Element's background color could not be determined due to a background gradient\",imgNode:\"Element's background color could not be determined because element contains an image node\",bgOverlap:\"Element's background color could not be determined because it is overlapped by another element\",fgAlpha:\"Element's foreground color could not be determined because of alpha transparency\",elmPartiallyObscured:\"Element's background color could not be determined because it's partially obscured by another element\",elmPartiallyObscuring:\"Element's background color could not be determined because it partially overlaps other elements\",outsideViewport:\"Element's background color could not be determined because it's outside the viewport\",equalRatio:\"Element has a 1:1 contrast ratio with the background\",shortTextContent:\"Element content is too short to determine if it is actual text content\",nonBmp:\"Element content contains only non-text characters\",pseudoContent:\"Element's background color could not be determined due to a pseudo element\"}}},\"link-in-text-block\":{impact:\"serious\",messages:{pass:\"Links can be distinguished from surrounding text in some way other than by color\",fail:\"Links need to be distinguished from surrounding text in some way other than by color\",incomplete:{default:\"Unable to determine contrast ratio\",bgContrast:\"Element's contrast ratio could not be determined. Check for a distinct hover/focus style\",bgImage:\"Element's contrast ratio could not be determined due to a background image\",bgGradient:\"Element's contrast ratio could not be determined due to a background gradient\",imgNode:\"Element's contrast ratio could not be determined because element contains an image node\",bgOverlap:\"Element's contrast ratio could not be determined because of element overlap\"}}},\"autocomplete-appropriate\":{impact:\"serious\",messages:{pass:\"the autocomplete value is on an appropriate element\",fail:\"the autocomplete value is inappropriate for this type of input\"}},\"autocomplete-valid\":{impact:\"serious\",messages:{pass:\"the autocomplete attribute is correctly formatted\",fail:\"the autocomplete attribute is incorrectly formatted\"}},accesskeys:{impact:\"serious\",messages:{pass:\"Accesskey attribute value is unique\",fail:\"Document has multiple elements with the same accesskey\"}},\"focusable-content\":{impact:\"moderate\",messages:{pass:\"Element contains focusable elements\",fail:\"Element should have focusable content\"}},\"focusable-disabled\":{impact:\"serious\",messages:{pass:\"No focusable elements contained within element\",fail:\"Focusable content should be disabled or be removed from the DOM\"}},\"focusable-element\":{impact:\"moderate\",messages:{pass:\"Element is focusable\",fail:\"Element should be focusable\"}},\"focusable-modal-open\":{impact:\"serious\",messages:{pass:\"No focusable elements while a modal is open\",incomplete:\"Check that focusable elements are not tabbable in the current state\"}},\"focusable-no-name\":{impact:\"serious\",messages:{pass:\"Element is not in tab order or has accessible text\",fail:\"Element is in tab order and does not have accessible text\",incomplete:\"Unable to determine if element has an accessible name\"}},\"focusable-not-tabbable\":{impact:\"serious\",messages:{pass:\"No focusable elements contained within element\",fail:\"Focusable content should have tabindex='-1' or be removed from the DOM\"}},\"frame-focusable-content\":{impact:\"serious\",messages:{pass:\"Element does not have focusable descendants\",fail:\"Element has focusable descendants\",incomplete:\"Could not determine if element has descendants\"}},\"landmark-is-top-level\":{impact:\"moderate\",messages:{pass:\"The ${data.role} landmark is at the top level.\",fail:\"The ${data.role} landmark is contained in another landmark.\"}},\"no-focusable-content\":{impact:\"serious\",messages:{pass:\"Element does not have focusable descendants\",fail:\"Element has focusable descendants\",incomplete:\"Could not determine if element has descendants\"}},\"page-has-heading-one\":{impact:\"moderate\",messages:{pass:\"Page has at least one level-one heading\",fail:\"Page must have a level-one heading\"}},\"page-has-main\":{impact:\"moderate\",messages:{pass:\"Document has at least one main landmark\",fail:\"Document does not have a main landmark\"}},\"page-no-duplicate-banner\":{impact:\"moderate\",messages:{pass:\"Document does not have more than one banner landmark\",fail:\"Document has more than one banner landmark\"}},\"page-no-duplicate-contentinfo\":{impact:\"moderate\",messages:{pass:\"Document does not have more than one contentinfo landmark\",fail:\"Document has more than one contentinfo landmark\"}},\"page-no-duplicate-main\":{impact:\"moderate\",messages:{pass:\"Document does not have more than one main landmark\",fail:\"Document has more than one main landmark\"}},tabindex:{impact:\"serious\",messages:{pass:\"Element does not have a tabindex greater than 0\",fail:\"Element has a tabindex greater than 0\"}},\"alt-space-value\":{impact:\"critical\",messages:{pass:\"Element has a valid alt attribute value\",fail:\"Element has an alt attribute containing only a space character, which is not ignored by all screen readers\"}},\"duplicate-img-label\":{impact:\"minor\",messages:{pass:\"Element does not duplicate existing text in <img> alt text\",fail:\"Element contains <img> element with alt text that duplicates existing text\"}},\"explicit-label\":{impact:\"critical\",messages:{pass:\"Form element has an explicit <label>\",fail:\"Form element does not have an explicit <label>\",incomplete:\"Unable to determine if form element has an explicit <label>\"}},\"help-same-as-label\":{impact:\"minor\",messages:{pass:\"Help text (title or aria-describedby) does not duplicate label text\",fail:\"Help text (title or aria-describedby) text is the same as the label text\"}},\"hidden-explicit-label\":{impact:\"critical\",messages:{pass:\"Form element has a visible explicit <label>\",fail:\"Form element has explicit <label> that is hidden\",incomplete:\"Unable to determine if form element has explicit <label> that is hidden\"}},\"implicit-label\":{impact:\"critical\",messages:{pass:\"Form element has an implicit (wrapped) <label>\",fail:\"Form element does not have an implicit (wrapped) <label>\",incomplete:\"Unable to determine if form element has an implicit (wrapped} <label>\"}},\"label-content-name-mismatch\":{impact:\"serious\",messages:{pass:\"Element contains visible text as part of it's accessible name\",fail:\"Text inside the element is not included in the accessible name\"}},\"multiple-label\":{impact:\"moderate\",messages:{pass:\"Form field does not have multiple label elements\",incomplete:\"Multiple label elements is not widely supported in assistive technologies. Ensure the first label contains all necessary information.\"}},\"title-only\":{impact:\"serious\",messages:{pass:\"Form element does not solely use title attribute for its label\",fail:\"Only title used to generate label for form element\"}},\"landmark-is-unique\":{impact:\"moderate\",messages:{pass:\"Landmarks must have a unique role or role/label/title (i.e. accessible name) combination\",fail:\"The landmark must have a unique aria-label, aria-labelledby, or title to make landmarks distinguishable\"}},\"has-lang\":{impact:\"serious\",messages:{pass:\"The <html> element has a lang attribute\",fail:{noXHTML:\"The xml:lang attribute is not valid on HTML pages, use the lang attribute.\",noLang:\"The <html> element does not have a lang attribute\"}}},\"valid-lang\":{impact:\"serious\",messages:{pass:\"Value of lang attribute is included in the list of valid languages\",fail:\"Value of lang attribute not included in the list of valid languages\"}},\"xml-lang-mismatch\":{impact:\"moderate\",messages:{pass:\"Lang and xml:lang attributes have the same base language\",fail:\"Lang and xml:lang attributes do not have the same base language\"}},dlitem:{impact:\"serious\",messages:{pass:\"Description list item has a <dl> parent element\",fail:\"Description list item does not have a <dl> parent element\"}},listitem:{impact:\"serious\",messages:{pass:'List item has a <ul>, <ol> or role=\"list\" parent element',fail:{default:\"List item does not have a <ul>, <ol> parent element\",roleNotValid:'List item does not have a <ul>, <ol> parent element without a role, or a role=\"list\"'}}},\"only-dlitems\":{impact:\"serious\",messages:{pass:\"List element only has direct children that are allowed inside <dt> or <dd> elements\",fail:\"List element has direct children that are not allowed inside <dt> or <dd> elements\"}},\"only-listitems\":{impact:\"serious\",messages:{pass:\"List element only has direct children that are allowed inside <li> elements\",fail:{default:\"List element has direct children that are not allowed inside <li> elements\",roleNotValid:\"List element has direct children with a role that is not allowed: ${data.roles}\"}}},\"structured-dlitems\":{impact:\"serious\",messages:{pass:\"When not empty, element has both <dt> and <dd> elements\",fail:\"When not empty, element does not have at least one <dt> element followed by at least one <dd> element\"}},caption:{impact:\"critical\",messages:{pass:\"The multimedia element has a captions track\",incomplete:\"Check that captions is available for the element\"}},\"frame-tested\":{impact:\"critical\",messages:{pass:\"The iframe was tested with axe-core\",fail:\"The iframe could not be tested with axe-core\",incomplete:\"The iframe still has to be tested with axe-core\"}},\"no-autoplay-audio\":{impact:\"moderate\",messages:{pass:\"<video> or <audio> does not output audio for more than allowed duration or has controls mechanism\",fail:\"<video> or <audio> outputs audio for more than allowed duration and does not have a controls mechanism\",incomplete:\"Check that the <video> or <audio> does not output audio for more than allowed duration or provides a controls mechanism\"}},\"css-orientation-lock\":{impact:\"serious\",messages:{pass:\"Display is operable, and orientation lock does not exist\",fail:\"CSS Orientation lock is applied, and makes display inoperable\",incomplete:\"CSS Orientation lock cannot be determined\"}},\"meta-viewport-large\":{impact:\"minor\",messages:{pass:\"<meta> tag does not prevent significant zooming on mobile devices\",fail:\"<meta> tag limits zooming on mobile devices\"}},\"meta-viewport\":{impact:\"critical\",messages:{pass:\"<meta> tag does not disable zooming on mobile devices\",fail:\"${data} on <meta> tag disables zooming on mobile devices\"}},\"header-present\":{impact:\"serious\",messages:{pass:\"Page has a heading\",fail:\"Page does not have a heading\"}},\"heading-order\":{impact:\"moderate\",messages:{pass:\"Heading order valid\",fail:\"Heading order invalid\",incomplete:\"Unable to determine previous heading\"}},\"identical-links-same-purpose\":{impact:\"minor\",messages:{pass:\"There are no other links with the same name, that go to a different URL\",incomplete:\"Check that links have the same purpose, or are intentionally ambiguous.\"}},\"internal-link-present\":{impact:\"serious\",messages:{pass:\"Valid skip link found\",fail:\"No valid skip link found\"}},landmark:{impact:\"serious\",messages:{pass:\"Page has a landmark region\",fail:\"Page does not have a landmark region\"}},\"meta-refresh\":{impact:\"critical\",messages:{pass:\"<meta> tag does not immediately refresh the page\",fail:\"<meta> tag forces timed refresh of page\"}},\"p-as-heading\":{impact:\"serious\",messages:{pass:\"<p> elements are not styled as headings\",fail:\"Heading elements should be used instead of styled p elements\"}},region:{impact:\"moderate\",messages:{pass:\"All page content is contained by landmarks\",fail:\"Some page content is not contained by landmarks\"}},\"skip-link\":{impact:\"moderate\",messages:{pass:\"Skip link target exists\",incomplete:\"Skip link target should become visible on activation\",fail:\"No skip link target\"}},\"unique-frame-title\":{impact:\"serious\",messages:{pass:\"Element's title attribute is unique\",fail:\"Element's title attribute is not unique\"}},\"duplicate-id-active\":{impact:\"serious\",messages:{pass:\"Document has no active elements that share the same id attribute\",fail:\"Document has active elements with the same id attribute: ${data}\"}},\"duplicate-id-aria\":{impact:\"critical\",messages:{pass:\"Document has no elements referenced with ARIA or labels that share the same id attribute\",fail:\"Document has multiple elements referenced with ARIA with the same id attribute: ${data}\"}},\"duplicate-id\":{impact:\"minor\",messages:{pass:\"Document has no static elements that share the same id attribute\",fail:\"Document has multiple static elements with the same id attribute: ${data}\"}},\"aria-label\":{impact:\"serious\",messages:{pass:\"aria-label attribute exists and is not empty\",fail:\"aria-label attribute does not exist or is empty\"}},\"aria-labelledby\":{impact:\"serious\",messages:{pass:\"aria-labelledby attribute exists and references elements that are visible to screen readers\",fail:\"aria-labelledby attribute does not exist, references elements that do not exist or references elements that are empty\",incomplete:\"ensure aria-labelledby references an existing element\"}},\"avoid-inline-spacing\":{impact:\"serious\",messages:{pass:\"No inline styles with '!important' that affect text spacing has been specified\",fail:{singular:\"Remove '!important' from inline style ${data.values}, as overriding this is not supported by most browsers\",plural:\"Remove '!important' from inline styles ${data.values}, as overriding this is not supported by most browsers\"}}},\"button-has-visible-text\":{impact:\"critical\",messages:{pass:\"Element has inner text that is visible to screen readers\",fail:\"Element does not have inner text that is visible to screen readers\",incomplete:\"Unable to determine if element has children\"}},\"doc-has-title\":{impact:\"serious\",messages:{pass:\"Document has a non-empty <title> element\",fail:\"Document does not have a non-empty <title> element\"}},exists:{impact:\"minor\",messages:{pass:\"Element does not exist\",incomplete:\"Element exists\"}},\"has-alt\":{impact:\"critical\",messages:{pass:\"Element has an alt attribute\",fail:\"Element does not have an alt attribute\"}},\"has-visible-text\":{impact:\"minor\",messages:{pass:\"Element has text that is visible to screen readers\",fail:\"Element does not have text that is visible to screen readers\",incomplete:\"Unable to determine if element has children\"}},\"is-on-screen\":{impact:\"serious\",messages:{pass:\"Element is not visible\",fail:\"Element is visible\"}},\"non-empty-alt\":{impact:\"critical\",messages:{pass:\"Element has a non-empty alt attribute\",fail:{noAttr:\"Element has no alt attribute\",emptyAttr:\"Element has an empty alt attribute\"}}},\"non-empty-if-present\":{impact:\"critical\",messages:{pass:{default:\"Element does not have a value attribute\",\"has-label\":\"Element has a non-empty value attribute\"},fail:\"Element has a value attribute and the value attribute is empty\"}},\"non-empty-placeholder\":{impact:\"serious\",messages:{pass:\"Element has a placeholder attribute\",fail:{noAttr:\"Element has no placeholder attribute\",emptyAttr:\"Element has an empty placeholder attribute\"}}},\"non-empty-title\":{impact:\"serious\",messages:{pass:\"Element has a title attribute\",fail:{noAttr:\"Element has no title attribute\",emptyAttr:\"Element has an empty title attribute\"}}},\"non-empty-value\":{impact:\"critical\",messages:{pass:\"Element has a non-empty value attribute\",fail:{noAttr:\"Element has no value attribute\",emptyAttr:\"Element has an empty value attribute\"}}},\"presentational-role\":{impact:\"minor\",messages:{pass:'Element\\'s default semantics were overriden with role=\"${data.role}\"',fail:{default:'Element\\'s default semantics were not overridden with role=\"none\" or role=\"presentation\"',globalAria:\"Element's role is not presentational because it has a global ARIA attribute\",focusable:\"Element's role is not presentational because it is focusable\",both:\"Element's role is not presentational because it has a global ARIA attribute and is focusable\"}}},\"role-none\":{impact:\"minor\",messages:{pass:'Element\\'s default semantics were overriden with role=\"none\"',fail:'Element\\'s default semantics were not overridden with role=\"none\"'}},\"role-presentation\":{impact:\"minor\",messages:{pass:'Element\\'s default semantics were overriden with role=\"presentation\"',fail:'Element\\'s default semantics were not overridden with role=\"presentation\"'}},\"svg-non-empty-title\":{impact:\"serious\",messages:{pass:\"Element has a child that is a title\",fail:{noTitle:\"Element has no child that is a title\",emptyTitle:\"Element child title is empty\"},incomplete:\"Unable to determine element has a child that is a title\"}},\"caption-faked\":{impact:\"serious\",messages:{pass:\"The first row of a table is not used as a caption\",fail:\"The first child of the table should be a caption instead of a table cell\"}},\"html5-scope\":{impact:\"moderate\",messages:{pass:\"Scope attribute is only used on table header elements (<th>)\",fail:\"In HTML 5, scope attributes may only be used on table header elements (<th>)\"}},\"same-caption-summary\":{impact:\"minor\",messages:{pass:\"Content of summary attribute and <caption> are not duplicated\",fail:\"Content of summary attribute and <caption> element are identical\"}},\"scope-value\":{impact:\"critical\",messages:{pass:\"Scope attribute is used correctly\",fail:\"The value of the scope attribute may only be 'row' or 'col'\"}},\"td-has-header\":{impact:\"critical\",messages:{pass:\"All non-empty data cells have table headers\",fail:\"Some non-empty data cells do not have table headers\"}},\"td-headers-attr\":{impact:\"serious\",messages:{pass:\"The headers attribute is exclusively used to refer to other cells in the table\",incomplete:\"The headers attribute is empty\",fail:\"The headers attribute is not exclusively used to refer to other cells in the table\"}},\"th-has-data-cells\":{impact:\"serious\",messages:{pass:\"All table header cells refer to data cells\",fail:\"Not all table header cells refer to data cells\",incomplete:\"Table data cells are missing or empty\"}},\"hidden-content\":{impact:\"minor\",messages:{pass:\"All content on the page has been analyzed.\",fail:\"There were problems analyzing the content on this page.\",incomplete:\"There is hidden content on the page that was not analyzed. You will need to trigger the display of this content in order to analyze it.\"}}},failureSummaries:{any:{failureMessage:function(e){var t=\"Fix any of the following:\",r=e;if(r)for(var a=-1,n=r.length-1;a<n;)t+=\"\\n  \"+r[a+=1].split(\"\\n\").join(\"\\n  \");return t}},none:{failureMessage:function(e){var t=\"Fix all of the following:\",r=e;if(r)for(var a=-1,n=r.length-1;a<n;)t+=\"\\n  \"+r[a+=1].split(\"\\n\").join(\"\\n  \");return t}}},incompleteFallbackMessage:{}},rules:[{id:\"accesskeys\",selector:\"[accesskey]\",excludeHidden:!1,tags:[\"cat.keyboard\",\"best-practice\"],all:[],any:[],none:[\"accesskeys\"]},{id:\"area-alt\",selector:\"map area[href]\",excludeHidden:!1,tags:[\"cat.text-alternatives\",\"wcag2a\",\"wcag111\",\"wcag244\",\"wcag412\",\"section508\",\"section508.22.a\",\"ACT\"],all:[],any:[{options:{attribute:\"alt\"},id:\"non-empty-alt\"},\"aria-label\",\"aria-labelledby\",{options:{attribute:\"title\"},id:\"non-empty-title\"}],none:[]},{id:\"aria-allowed-attr\",matches:\"aria-allowed-attr-matches\",tags:[\"cat.aria\",\"wcag2a\",\"wcag412\"],all:[],any:[\"aria-allowed-attr\"],none:[\"aria-unsupported-attr\",{options:{elementsAllowedAriaLabel:[\"applet\",\"input\"]},id:\"aria-prohibited-attr\"}]},{id:\"aria-allowed-role\",excludeHidden:!1,selector:\"[role]\",matches:\"aria-allowed-role-matches\",tags:[\"cat.aria\",\"best-practice\"],all:[],any:[{options:{allowImplicit:!0,ignoredTags:[]},id:\"aria-allowed-role\"}],none:[]},{id:\"aria-command-name\",selector:'[role=\"link\"], [role=\"button\"], [role=\"menuitem\"]',matches:\"no-naming-method-matches\",tags:[\"cat.aria\",\"wcag2a\",\"wcag412\"],all:[],any:[\"has-visible-text\",\"aria-label\",\"aria-labelledby\",{options:{attribute:\"title\"},id:\"non-empty-title\"}],none:[]},{id:\"aria-dialog-name\",selector:'[role=\"dialog\"], [role=\"alertdialog\"]',matches:\"no-naming-method-matches\",tags:[\"cat.aria\",\"best-practice\"],all:[],any:[\"aria-label\",\"aria-labelledby\",{options:{attribute:\"title\"},id:\"non-empty-title\"}],none:[]},{id:\"aria-hidden-body\",selector:\"body\",excludeHidden:!1,matches:\"is-initiator-matches\",tags:[\"cat.aria\",\"wcag2a\",\"wcag412\"],all:[],any:[\"aria-hidden-body\"],none:[]},{id:\"aria-hidden-focus\",selector:'[aria-hidden=\"true\"]',matches:\"aria-hidden-focus-matches\",excludeHidden:!1,tags:[\"cat.name-role-value\",\"wcag2a\",\"wcag412\",\"wcag131\"],all:[\"focusable-modal-open\",\"focusable-disabled\",\"focusable-not-tabbable\"],any:[],none:[]},{id:\"aria-input-field-name\",selector:'[role=\"combobox\"], [role=\"listbox\"], [role=\"searchbox\"], [role=\"slider\"], [role=\"spinbutton\"], [role=\"textbox\"]',matches:\"no-naming-method-matches\",tags:[\"cat.aria\",\"wcag2a\",\"wcag412\",\"ACT\"],all:[],any:[\"aria-label\",\"aria-labelledby\",{options:{attribute:\"title\"},id:\"non-empty-title\"}],none:[\"no-implicit-explicit-label\"]},{id:\"aria-meter-name\",selector:'[role=\"meter\"]',matches:\"no-naming-method-matches\",tags:[\"cat.aria\",\"wcag2a\",\"wcag111\"],all:[],any:[\"aria-label\",\"aria-labelledby\",{options:{attribute:\"title\"},id:\"non-empty-title\"}],none:[]},{id:\"aria-progressbar-name\",selector:'[role=\"progressbar\"]',matches:\"no-naming-method-matches\",tags:[\"cat.aria\",\"wcag2a\",\"wcag111\"],all:[],any:[\"aria-label\",\"aria-labelledby\",{options:{attribute:\"title\"},id:\"non-empty-title\"}],none:[]},{id:\"aria-required-attr\",selector:\"[role]\",tags:[\"cat.aria\",\"wcag2a\",\"wcag412\"],all:[],any:[\"aria-required-attr\"],none:[]},{id:\"aria-required-children\",selector:\"[role]\",matches:\"aria-required-children-matches\",tags:[\"cat.aria\",\"wcag2a\",\"wcag131\"],all:[],any:[{options:{reviewEmpty:[\"doc-bibliography\",\"doc-endnotes\",\"grid\",\"list\",\"listbox\",\"table\",\"tablist\",\"tree\",\"treegrid\",\"rowgroup\"]},id:\"aria-required-children\"}],none:[]},{id:\"aria-required-parent\",selector:\"[role]\",matches:\"aria-required-parent-matches\",tags:[\"cat.aria\",\"wcag2a\",\"wcag131\"],all:[],any:[{options:{ownGroupRoles:[\"listitem\",\"treeitem\"]},id:\"aria-required-parent\"}],none:[]},{id:\"aria-roledescription\",selector:\"[aria-roledescription]\",tags:[\"cat.aria\",\"wcag2a\",\"wcag412\"],all:[],any:[{options:{supportedRoles:[\"button\",\"img\",\"checkbox\",\"radio\",\"combobox\",\"menuitemcheckbox\",\"menuitemradio\"]},id:\"aria-roledescription\"}],none:[]},{id:\"aria-roles\",selector:\"[role]\",matches:\"no-empty-role-matches\",tags:[\"cat.aria\",\"wcag2a\",\"wcag412\"],all:[],any:[],none:[\"fallbackrole\",\"invalidrole\",\"abstractrole\",\"unsupportedrole\"]},{id:\"aria-text\",selector:\"[role=text]\",tags:[\"cat.aria\",\"best-practice\"],all:[],any:[\"no-focusable-content\"],none:[]},{id:\"aria-toggle-field-name\",selector:'[role=\"checkbox\"], [role=\"menuitemcheckbox\"], [role=\"menuitemradio\"], [role=\"radio\"], [role=\"switch\"], [role=\"option\"]',matches:\"no-naming-method-matches\",tags:[\"cat.aria\",\"wcag2a\",\"wcag412\",\"ACT\"],all:[],any:[\"has-visible-text\",\"aria-label\",\"aria-labelledby\",{options:{attribute:\"title\"},id:\"non-empty-title\"}],none:[\"no-implicit-explicit-label\"]},{id:\"aria-tooltip-name\",selector:'[role=\"tooltip\"]',matches:\"no-naming-method-matches\",tags:[\"cat.aria\",\"wcag2a\",\"wcag412\"],all:[],any:[\"has-visible-text\",\"aria-label\",\"aria-labelledby\",{options:{attribute:\"title\"},id:\"non-empty-title\"}],none:[]},{id:\"aria-treeitem-name\",selector:'[role=\"treeitem\"]',matches:\"no-naming-method-matches\",tags:[\"cat.aria\",\"best-practice\"],all:[],any:[\"has-visible-text\",\"aria-label\",\"aria-labelledby\",{options:{attribute:\"title\"},id:\"non-empty-title\"}],none:[]},{id:\"aria-valid-attr-value\",matches:\"aria-has-attr-matches\",tags:[\"cat.aria\",\"wcag2a\",\"wcag412\"],all:[{options:[],id:\"aria-valid-attr-value\"},\"aria-errormessage\"],any:[],none:[]},{id:\"aria-valid-attr\",matches:\"aria-has-attr-matches\",tags:[\"cat.aria\",\"wcag2a\",\"wcag412\"],all:[],any:[{options:[],id:\"aria-valid-attr\"}],none:[]},{id:\"audio-caption\",selector:\"audio\",enabled:!1,excludeHidden:!1,tags:[\"cat.time-and-media\",\"wcag2a\",\"wcag121\",\"section508\",\"section508.22.a\"],all:[],any:[],none:[\"caption\"]},{id:\"autocomplete-valid\",matches:\"autocomplete-matches\",tags:[\"cat.forms\",\"wcag21aa\",\"wcag135\"],all:[\"autocomplete-valid\",\"autocomplete-appropriate\"],any:[],none:[]},{id:\"avoid-inline-spacing\",selector:\"[style]\",tags:[\"cat.structure\",\"wcag21aa\",\"wcag1412\"],all:[{options:{cssProperties:[\"line-height\",\"letter-spacing\",\"word-spacing\"]},id:\"avoid-inline-spacing\"}],any:[],none:[]},{id:\"blink\",selector:\"blink\",excludeHidden:!1,tags:[\"cat.time-and-media\",\"wcag2a\",\"wcag222\",\"section508\",\"section508.22.j\"],all:[],any:[],none:[\"is-on-screen\"]},{id:\"button-name\",selector:\"button\",matches:\"no-explicit-name-required-matches\",tags:[\"cat.name-role-value\",\"wcag2a\",\"wcag412\",\"section508\",\"section508.22.a\",\"ACT\"],all:[],any:[\"button-has-visible-text\",\"aria-label\",\"aria-labelledby\",{options:{attribute:\"title\"},id:\"non-empty-title\"},\"presentational-role\"],none:[]},{id:\"bypass\",selector:\"html\",pageLevel:!0,matches:\"bypass-matches\",reviewOnFail:!0,tags:[\"cat.keyboard\",\"wcag2a\",\"wcag241\",\"section508\",\"section508.22.o\"],all:[],any:[\"internal-link-present\",{options:{selector:\":is(h1, h2, h3, h4, h5, h6):not([role]), [role=heading]\"},id:\"header-present\"},{options:{selector:\"main, [role=main]\"},id:\"landmark\"}],none:[]},{id:\"color-contrast\",matches:\"color-contrast-matches\",excludeHidden:!1,tags:[\"cat.color\",\"wcag2aa\",\"wcag143\"],all:[],any:[{options:{ignoreUnicode:!0,ignoreLength:!1,boldValue:700,boldTextPt:14,largeTextPt:18,contrastRatio:{normal:{expected:4.5},large:{expected:3}},shadowOutlineEmMax:.1},id:\"color-contrast\"}],none:[]},{id:\"css-orientation-lock\",selector:\"html\",tags:[\"cat.structure\",\"wcag134\",\"wcag21aa\",\"experimental\"],all:[{options:{degreeThreshold:2},id:\"css-orientation-lock\"}],any:[],none:[],preload:!0},{id:\"definition-list\",selector:\"dl\",matches:\"no-role-matches\",tags:[\"cat.structure\",\"wcag2a\",\"wcag131\"],all:[],any:[],none:[\"structured-dlitems\",\"only-dlitems\"]},{id:\"dlitem\",selector:\"dd, dt\",matches:\"no-role-matches\",tags:[\"cat.structure\",\"wcag2a\",\"wcag131\"],all:[],any:[\"dlitem\"],none:[]},{id:\"document-title\",selector:\"html\",matches:\"is-initiator-matches\",tags:[\"cat.text-alternatives\",\"wcag2a\",\"wcag242\",\"ACT\"],all:[],any:[\"doc-has-title\"],none:[]},{id:\"duplicate-id-active\",selector:\"[id]\",matches:\"duplicate-id-active-matches\",excludeHidden:!1,tags:[\"cat.parsing\",\"wcag2a\",\"wcag411\"],all:[],any:[\"duplicate-id-active\"],none:[]},{id:\"duplicate-id-aria\",selector:\"[id]\",matches:\"duplicate-id-aria-matches\",excludeHidden:!1,tags:[\"cat.parsing\",\"wcag2a\",\"wcag411\"],all:[],any:[\"duplicate-id-aria\"],none:[]},{id:\"duplicate-id\",selector:\"[id]\",matches:\"duplicate-id-misc-matches\",excludeHidden:!1,tags:[\"cat.parsing\",\"wcag2a\",\"wcag411\"],all:[],any:[\"duplicate-id\"],none:[]},{id:\"empty-heading\",selector:'h1, h2, h3, h4, h5, h6, [role=\"heading\"]',matches:\"heading-matches\",tags:[\"cat.name-role-value\",\"best-practice\"],impact:\"minor\",all:[],any:[\"has-visible-text\",\"aria-label\",\"aria-labelledby\",{options:{attribute:\"title\"},id:\"non-empty-title\"}],none:[]},{id:\"empty-table-header\",selector:'th, [role=\"rowheader\"], [role=\"columnheader\"]',tags:[\"wcag131\",\"cat.aria\"],reviewOnFail:!0,all:[],any:[\"has-visible-text\"],none:[]},{id:\"focus-order-semantics\",selector:\"div, h1, h2, h3, h4, h5, h6, [role=heading], p, span\",matches:\"inserted-into-focus-order-matches\",tags:[\"cat.keyboard\",\"best-practice\",\"experimental\"],all:[],any:[{options:[],id:\"has-widget-role\"},{options:{roles:[\"tooltip\"]},id:\"valid-scrollable-semantics\"}],none:[]},{id:\"form-field-multiple-labels\",selector:\"input, select, textarea\",matches:\"label-matches\",tags:[\"cat.forms\",\"wcag2a\",\"wcag332\"],all:[],any:[],none:[\"multiple-label\"]},{id:\"frame-focusable-content\",selector:\"html\",matches:\"frame-focusable-content-matches\",tags:[\"cat.keyboard\",\"wcag2a\",\"wcag211\"],all:[],any:[\"frame-focusable-content\"],none:[]},{id:\"frame-tested\",selector:\"html, frame, iframe\",tags:[\"cat.structure\",\"review-item\",\"best-practice\"],all:[{options:{isViolation:!1},id:\"frame-tested\"}],any:[],none:[]},{id:\"frame-title-unique\",selector:\"frame[title], iframe[title]\",matches:\"frame-title-has-text-matches\",tags:[\"cat.text-alternatives\",\"best-practice\"],all:[],any:[],none:[\"unique-frame-title\"]},{id:\"frame-title\",selector:\"frame, iframe\",tags:[\"cat.text-alternatives\",\"wcag2a\",\"wcag241\",\"wcag412\",\"section508\",\"section508.22.i\"],all:[],any:[{options:{attribute:\"title\"},id:\"non-empty-title\"},\"aria-label\",\"aria-labelledby\",\"presentational-role\"],none:[]},{id:\"heading-order\",selector:\"h1, h2, h3, h4, h5, h6, [role=heading]\",matches:\"heading-matches\",tags:[\"cat.semantics\",\"best-practice\"],all:[],any:[\"heading-order\"],none:[]},{id:\"hidden-content\",selector:\"*\",excludeHidden:!1,tags:[\"cat.structure\",\"experimental\",\"review-item\",\"best-practice\"],all:[],any:[\"hidden-content\"],none:[]},{id:\"html-has-lang\",selector:\"html\",matches:\"is-initiator-matches\",tags:[\"cat.language\",\"wcag2a\",\"wcag311\",\"ACT\"],all:[],any:[{options:{attributes:[\"lang\",\"xml:lang\"]},id:\"has-lang\"}],none:[]},{id:\"html-lang-valid\",selector:\"html[lang], html[xml\\\\:lang]\",tags:[\"cat.language\",\"wcag2a\",\"wcag311\",\"ACT\"],all:[],any:[],none:[{options:{attributes:[\"lang\",\"xml:lang\"]},id:\"valid-lang\"}]},{id:\"html-xml-lang-mismatch\",selector:\"html[lang][xml\\\\:lang]\",matches:\"xml-lang-mismatch-matches\",tags:[\"cat.language\",\"wcag2a\",\"wcag311\",\"ACT\"],all:[\"xml-lang-mismatch\"],any:[],none:[]},{id:\"identical-links-same-purpose\",selector:'a[href], area[href], [role=\"link\"]',excludeHidden:!1,matches:\"identical-links-same-purpose-matches\",tags:[\"cat.semantics\",\"wcag2aaa\",\"wcag249\",\"best-practice\"],all:[\"identical-links-same-purpose\"],any:[],none:[]},{id:\"image-alt\",selector:\"img\",matches:\"no-explicit-name-required-matches\",tags:[\"cat.text-alternatives\",\"wcag2a\",\"wcag111\",\"section508\",\"section508.22.a\",\"ACT\"],all:[],any:[\"has-alt\",\"aria-label\",\"aria-labelledby\",{options:{attribute:\"title\"},id:\"non-empty-title\"},\"presentational-role\"],none:[\"alt-space-value\"]},{id:\"image-redundant-alt\",selector:\"img\",tags:[\"cat.text-alternatives\",\"best-practice\"],all:[],any:[],none:[{options:{parentSelector:\"button, [role=button], a[href], p, li, td, th\"},id:\"duplicate-img-label\"}]},{id:\"input-button-name\",selector:'input[type=\"button\"], input[type=\"submit\"], input[type=\"reset\"]',matches:\"no-explicit-name-required-matches\",tags:[\"cat.name-role-value\",\"wcag2a\",\"wcag412\",\"section508\",\"section508.22.a\"],all:[],any:[\"non-empty-if-present\",{options:{attribute:\"value\"},id:\"non-empty-value\"},\"aria-label\",\"aria-labelledby\",{options:{attribute:\"title\"},id:\"non-empty-title\"},\"presentational-role\"],none:[]},{id:\"input-image-alt\",selector:'input[type=\"image\"]',matches:\"no-explicit-name-required-matches\",tags:[\"cat.text-alternatives\",\"wcag2a\",\"wcag111\",\"section508\",\"section508.22.a\",\"ACT\"],all:[],any:[{options:{attribute:\"alt\"},id:\"non-empty-alt\"},\"aria-label\",\"aria-labelledby\",{options:{attribute:\"title\"},id:\"non-empty-title\"}],none:[]},{id:\"label-content-name-mismatch\",matches:\"label-content-name-mismatch-matches\",tags:[\"cat.semantics\",\"wcag21a\",\"wcag253\",\"experimental\"],all:[],any:[{options:{pixelThreshold:.1,occuranceThreshold:3},id:\"label-content-name-mismatch\"}],none:[]},{id:\"label-title-only\",selector:\"input, select, textarea\",matches:\"label-matches\",tags:[\"cat.forms\",\"best-practice\"],all:[],any:[],none:[\"title-only\"]},{id:\"label\",selector:\"input, textarea\",matches:\"label-matches\",tags:[\"cat.forms\",\"wcag2a\",\"wcag412\",\"wcag131\",\"section508\",\"section508.22.n\",\"ACT\"],all:[],any:[\"implicit-label\",\"explicit-label\",\"aria-label\",\"aria-labelledby\",{options:{attribute:\"title\"},id:\"non-empty-title\"},{options:{attribute:\"placeholder\"},id:\"non-empty-placeholder\"},\"presentational-role\"],none:[\"help-same-as-label\",\"hidden-explicit-label\"]},{id:\"landmark-banner-is-top-level\",selector:\"header:not([role]), [role=banner]\",matches:\"landmark-has-body-context-matches\",tags:[\"cat.semantics\",\"best-practice\"],all:[],any:[\"landmark-is-top-level\"],none:[]},{id:\"landmark-complementary-is-top-level\",selector:\"aside:not([role]), [role=complementary]\",tags:[\"cat.semantics\",\"best-practice\"],all:[],any:[\"landmark-is-top-level\"],none:[]},{id:\"landmark-contentinfo-is-top-level\",selector:\"footer:not([role]), [role=contentinfo]\",matches:\"landmark-has-body-context-matches\",tags:[\"cat.semantics\",\"best-practice\"],all:[],any:[\"landmark-is-top-level\"],none:[]},{id:\"landmark-main-is-top-level\",selector:\"main:not([role]), [role=main]\",tags:[\"cat.semantics\",\"best-practice\"],all:[],any:[\"landmark-is-top-level\"],none:[]},{id:\"landmark-no-duplicate-banner\",selector:\"header:not([role]), [role=banner]\",tags:[\"cat.semantics\",\"best-practice\"],all:[],any:[{options:{selector:\"header:not([role]), [role=banner]\",nativeScopeFilter:\"article, aside, main, nav, section\"},id:\"page-no-duplicate-banner\"}],none:[]},{id:\"landmark-no-duplicate-contentinfo\",selector:\"footer:not([role]), [role=contentinfo]\",tags:[\"cat.semantics\",\"best-practice\"],all:[],any:[{options:{selector:\"footer:not([role]), [role=contentinfo]\",nativeScopeFilter:\"article, aside, main, nav, section\"},id:\"page-no-duplicate-contentinfo\"}],none:[]},{id:\"landmark-no-duplicate-main\",selector:\"main:not([role]), [role=main]\",tags:[\"cat.semantics\",\"best-practice\"],all:[],any:[{options:{selector:\"main:not([role]), [role='main']\"},id:\"page-no-duplicate-main\"}],none:[]},{id:\"landmark-one-main\",selector:\"html\",tags:[\"cat.semantics\",\"best-practice\"],all:[{options:{selector:\"main:not([role]), [role='main']\"},id:\"page-has-main\"}],any:[],none:[]},{id:\"landmark-unique\",selector:\"[role=banner], [role=complementary], [role=contentinfo], [role=main], [role=navigation], [role=region], [role=search], [role=form], form, footer, header, aside, main, nav, section\",tags:[\"cat.semantics\",\"best-practice\"],matches:\"landmark-unique-matches\",all:[],any:[\"landmark-is-unique\"],none:[]},{id:\"link-in-text-block\",selector:\"a[href], [role=link]\",matches:\"link-in-text-block-matches\",excludeHidden:!1,tags:[\"cat.color\",\"experimental\",\"wcag2a\",\"wcag141\"],all:[\"link-in-text-block\"],any:[],none:[]},{id:\"link-name\",selector:\"a[href]\",tags:[\"cat.name-role-value\",\"wcag2a\",\"wcag412\",\"wcag244\",\"section508\",\"section508.22.a\",\"ACT\"],all:[],any:[\"has-visible-text\",\"aria-label\",\"aria-labelledby\",{options:{attribute:\"title\"},id:\"non-empty-title\"}],none:[\"focusable-no-name\"]},{id:\"list\",selector:\"ul, ol\",matches:\"no-role-matches\",tags:[\"cat.structure\",\"wcag2a\",\"wcag131\"],all:[],any:[],none:[\"only-listitems\"]},{id:\"listitem\",selector:\"li\",matches:\"no-role-matches\",tags:[\"cat.structure\",\"wcag2a\",\"wcag131\"],all:[],any:[\"listitem\"],none:[]},{id:\"marquee\",selector:\"marquee\",excludeHidden:!1,tags:[\"cat.parsing\",\"wcag2a\",\"wcag222\"],all:[],any:[],none:[\"is-on-screen\"]},{id:\"meta-refresh\",selector:'meta[http-equiv=\"refresh\"]',excludeHidden:!1,tags:[\"cat.time-and-media\",\"wcag2a\",\"wcag2aaa\",\"wcag221\",\"wcag224\",\"wcag325\"],all:[],any:[\"meta-refresh\"],none:[]},{id:\"meta-viewport-large\",selector:'meta[name=\"viewport\"]',matches:\"is-initiator-matches\",excludeHidden:!1,tags:[\"cat.sensory-and-visual-cues\",\"best-practice\"],all:[],any:[{options:{scaleMinimum:5,lowerBound:2},id:\"meta-viewport-large\"}],none:[]},{id:\"meta-viewport\",selector:'meta[name=\"viewport\"]',matches:\"is-initiator-matches\",excludeHidden:!1,tags:[\"cat.sensory-and-visual-cues\",\"best-practice\",\"ACT\"],all:[],any:[{options:{scaleMinimum:2},id:\"meta-viewport\"}],none:[]},{id:\"nested-interactive\",matches:\"nested-interactive-matches\",tags:[\"cat.keyboard\",\"wcag2a\",\"wcag412\"],all:[],any:[\"no-focusable-content\"],none:[]},{id:\"no-autoplay-audio\",excludeHidden:!1,selector:\"audio[autoplay], video[autoplay]\",matches:\"no-autoplay-audio-matches\",tags:[\"cat.time-and-media\",\"wcag2a\",\"wcag142\",\"experimental\"],preload:!0,all:[{options:{allowedDuration:3},id:\"no-autoplay-audio\"}],any:[],none:[]},{id:\"object-alt\",selector:\"object\",matches:\"no-explicit-name-required-matches\",tags:[\"cat.text-alternatives\",\"wcag2a\",\"wcag111\",\"section508\",\"section508.22.a\"],all:[],any:[\"aria-label\",\"aria-labelledby\",{options:{attribute:\"title\"},id:\"non-empty-title\"},\"presentational-role\"],none:[]},{id:\"p-as-heading\",selector:\"p\",matches:\"p-as-heading-matches\",tags:[\"cat.semantics\",\"wcag2a\",\"wcag131\",\"experimental\"],all:[{options:{margins:[{weight:150,italic:!0},{weight:150,size:1.15},{italic:!0,size:1.15},{size:1.4}]},id:\"p-as-heading\"}],any:[],none:[]},{id:\"page-has-heading-one\",selector:\"html\",tags:[\"cat.semantics\",\"best-practice\"],all:[{options:{selector:\"h1:not([role], [aria-level]), :is(h1, h2, h3, h4, h5, h6):not([role])[aria-level=1], [role=heading][aria-level=1]\"},id:\"page-has-heading-one\"}],any:[],none:[]},{id:\"presentation-role-conflict\",matches:\"has-implicit-chromium-role-matches\",selector:'[role=\"none\"], [role=\"presentation\"]',tags:[\"cat.aria\",\"best-practice\"],all:[],any:[],none:[\"is-element-focusable\",\"has-global-aria-attribute\"]},{id:\"region\",selector:\"body *\",tags:[\"cat.keyboard\",\"best-practice\"],all:[],any:[{options:{regionMatcher:\"dialog, [role=dialog], [role=alertdialog], svg, iframe\"},id:\"region\"}],none:[]},{id:\"role-img-alt\",selector:\"[role='img']:not(img, area, input, object)\",matches:\"html-namespace-matches\",tags:[\"cat.text-alternatives\",\"wcag2a\",\"wcag111\",\"section508\",\"section508.22.a\",\"ACT\"],all:[],any:[\"aria-label\",\"aria-labelledby\",{options:{attribute:\"title\"},id:\"non-empty-title\"}],none:[]},{id:\"scope-attr-valid\",selector:\"td[scope], th[scope]\",tags:[\"cat.tables\",\"best-practice\"],all:[\"html5-scope\",{options:{values:[\"row\",\"col\",\"rowgroup\",\"colgroup\"]},id:\"scope-value\"}],any:[],none:[]},{id:\"scrollable-region-focusable\",matches:\"scrollable-region-focusable-matches\",tags:[\"cat.keyboard\",\"wcag2a\",\"wcag211\"],all:[],any:[\"focusable-content\",\"focusable-element\"],none:[]},{id:\"select-name\",selector:\"select\",tags:[\"cat.forms\",\"wcag2a\",\"wcag412\",\"wcag131\",\"section508\",\"section508.22.n\",\"ACT\"],all:[],any:[\"implicit-label\",\"explicit-label\",\"aria-label\",\"aria-labelledby\",{options:{attribute:\"title\"},id:\"non-empty-title\"},\"presentational-role\"],none:[\"help-same-as-label\",\"hidden-explicit-label\"]},{id:\"server-side-image-map\",selector:\"img[ismap]\",tags:[\"cat.text-alternatives\",\"wcag2a\",\"wcag211\",\"section508\",\"section508.22.f\"],all:[],any:[],none:[\"exists\"]},{id:\"skip-link\",selector:'a[href^=\"#\"], a[href^=\"/#\"]',matches:\"skip-link-matches\",tags:[\"cat.keyboard\",\"best-practice\"],all:[],any:[\"skip-link\"],none:[]},{id:\"svg-img-alt\",selector:'[role=\"img\"], [role=\"graphics-symbol\"], svg[role=\"graphics-document\"]',matches:\"svg-namespace-matches\",tags:[\"cat.text-alternatives\",\"wcag2a\",\"wcag111\",\"section508\",\"section508.22.a\",\"ACT\"],all:[],any:[\"svg-non-empty-title\",\"aria-label\",\"aria-labelledby\",{options:{attribute:\"title\"},id:\"non-empty-title\"}],none:[]},{id:\"tabindex\",selector:\"[tabindex]\",tags:[\"cat.keyboard\",\"best-practice\"],all:[],any:[\"tabindex\"],none:[]},{id:\"table-duplicate-name\",selector:\"table\",tags:[\"cat.tables\",\"best-practice\"],all:[],any:[],none:[\"same-caption-summary\"]},{id:\"table-fake-caption\",selector:\"table\",matches:\"data-table-matches\",tags:[\"cat.tables\",\"experimental\",\"wcag2a\",\"wcag131\",\"section508\",\"section508.22.g\"],all:[\"caption-faked\"],any:[],none:[]},{id:\"td-has-header\",selector:\"table\",matches:\"data-table-large-matches\",tags:[\"cat.tables\",\"experimental\",\"wcag2a\",\"wcag131\",\"section508\",\"section508.22.g\"],all:[\"td-has-header\"],any:[],none:[]},{id:\"td-headers-attr\",selector:\"table\",tags:[\"cat.tables\",\"wcag2a\",\"wcag131\",\"section508\",\"section508.22.g\"],all:[\"td-headers-attr\"],any:[],none:[]},{id:\"th-has-data-cells\",selector:\"table\",matches:\"data-table-matches\",tags:[\"cat.tables\",\"wcag2a\",\"wcag131\",\"section508\",\"section508.22.g\"],all:[\"th-has-data-cells\"],any:[],none:[]},{id:\"valid-lang\",selector:\"[lang], [xml\\\\:lang]\",matches:\"not-html-matches\",tags:[\"cat.language\",\"wcag2aa\",\"wcag312\"],all:[],any:[],none:[{options:{attributes:[\"lang\",\"xml:lang\"]},id:\"valid-lang\"}]},{id:\"video-caption\",selector:\"video\",excludeHidden:!1,tags:[\"cat.text-alternatives\",\"wcag2a\",\"wcag122\",\"section508\",\"section508.22.a\"],all:[],any:[],none:[\"caption\"]}],checks:[{id:\"abstractrole\",evaluate:\"abstractrole-evaluate\"},{id:\"aria-allowed-attr\",evaluate:\"aria-allowed-attr-evaluate\"},{id:\"aria-allowed-role\",evaluate:\"aria-allowed-role-evaluate\",options:{allowImplicit:!0,ignoredTags:[]}},{id:\"aria-errormessage\",evaluate:\"aria-errormessage-evaluate\"},{id:\"aria-hidden-body\",evaluate:\"aria-hidden-body-evaluate\"},{id:\"aria-prohibited-attr\",evaluate:\"aria-prohibited-attr-evaluate\",options:{elementsAllowedAriaLabel:[\"applet\",\"input\"]}},{id:\"aria-required-attr\",evaluate:\"aria-required-attr-evaluate\"},{id:\"aria-required-children\",evaluate:\"aria-required-children-evaluate\",options:{reviewEmpty:[\"doc-bibliography\",\"doc-endnotes\",\"grid\",\"list\",\"listbox\",\"table\",\"tablist\",\"tree\",\"treegrid\",\"rowgroup\"]}},{id:\"aria-required-parent\",evaluate:\"aria-required-parent-evaluate\",options:{ownGroupRoles:[\"listitem\",\"treeitem\"]}},{id:\"aria-roledescription\",evaluate:\"aria-roledescription-evaluate\",options:{supportedRoles:[\"button\",\"img\",\"checkbox\",\"radio\",\"combobox\",\"menuitemcheckbox\",\"menuitemradio\"]}},{id:\"aria-unsupported-attr\",evaluate:\"aria-unsupported-attr-evaluate\"},{id:\"aria-valid-attr-value\",evaluate:\"aria-valid-attr-value-evaluate\",options:[]},{id:\"aria-valid-attr\",evaluate:\"aria-valid-attr-evaluate\",options:[]},{id:\"fallbackrole\",evaluate:\"fallbackrole-evaluate\"},{id:\"has-global-aria-attribute\",evaluate:\"has-global-aria-attribute-evaluate\"},{id:\"has-widget-role\",evaluate:\"has-widget-role-evaluate\",options:[]},{id:\"invalidrole\",evaluate:\"invalidrole-evaluate\"},{id:\"is-element-focusable\",evaluate:\"is-element-focusable-evaluate\"},{id:\"no-implicit-explicit-label\",evaluate:\"no-implicit-explicit-label-evaluate\"},{id:\"unsupportedrole\",evaluate:\"unsupportedrole-evaluate\"},{id:\"valid-scrollable-semantics\",evaluate:\"valid-scrollable-semantics-evaluate\",options:{roles:[\"tooltip\"]}},{id:\"color-contrast\",evaluate:\"color-contrast-evaluate\",options:{ignoreUnicode:!0,ignoreLength:!1,boldValue:700,boldTextPt:14,largeTextPt:18,contrastRatio:{normal:{expected:4.5},large:{expected:3}},shadowOutlineEmMax:.1}},{id:\"link-in-text-block\",evaluate:\"link-in-text-block-evaluate\"},{id:\"autocomplete-appropriate\",evaluate:\"autocomplete-appropriate-evaluate\"},{id:\"autocomplete-valid\",evaluate:\"autocomplete-valid-evaluate\"},{id:\"accesskeys\",evaluate:\"accesskeys-evaluate\",after:\"accesskeys-after\"},{id:\"focusable-content\",evaluate:\"focusable-content-evaluate\"},{id:\"focusable-disabled\",evaluate:\"focusable-disabled-evaluate\"},{id:\"focusable-element\",evaluate:\"focusable-element-evaluate\"},{id:\"focusable-modal-open\",evaluate:\"focusable-modal-open-evaluate\"},{id:\"focusable-no-name\",evaluate:\"focusable-no-name-evaluate\"},{id:\"focusable-not-tabbable\",evaluate:\"focusable-not-tabbable-evaluate\"},{id:\"frame-focusable-content\",evaluate:\"no-focusable-content-evaluate\"},{id:\"landmark-is-top-level\",evaluate:\"landmark-is-top-level-evaluate\"},{id:\"no-focusable-content\",evaluate:\"no-focusable-content-evaluate\"},{id:\"page-has-heading-one\",evaluate:\"has-descendant-evaluate\",after:\"has-descendant-after\",options:{selector:\"h1:not([role], [aria-level]), :is(h1, h2, h3, h4, h5, h6):not([role])[aria-level=1], [role=heading][aria-level=1]\"}},{id:\"page-has-main\",evaluate:\"has-descendant-evaluate\",after:\"has-descendant-after\",options:{selector:\"main:not([role]), [role='main']\"}},{id:\"page-no-duplicate-banner\",evaluate:\"page-no-duplicate-evaluate\",after:\"page-no-duplicate-after\",options:{selector:\"header:not([role]), [role=banner]\",nativeScopeFilter:\"article, aside, main, nav, section\"}},{id:\"page-no-duplicate-contentinfo\",evaluate:\"page-no-duplicate-evaluate\",after:\"page-no-duplicate-after\",options:{selector:\"footer:not([role]), [role=contentinfo]\",nativeScopeFilter:\"article, aside, main, nav, section\"}},{id:\"page-no-duplicate-main\",evaluate:\"page-no-duplicate-evaluate\",after:\"page-no-duplicate-after\",options:{selector:\"main:not([role]), [role='main']\"}},{id:\"tabindex\",evaluate:\"tabindex-evaluate\"},{id:\"alt-space-value\",evaluate:\"alt-space-value-evaluate\"},{id:\"duplicate-img-label\",evaluate:\"duplicate-img-label-evaluate\",options:{parentSelector:\"button, [role=button], a[href], p, li, td, th\"}},{id:\"explicit-label\",evaluate:\"explicit-evaluate\"},{id:\"help-same-as-label\",evaluate:\"help-same-as-label-evaluate\",enabled:!1},{id:\"hidden-explicit-label\",evaluate:\"hidden-explicit-label-evaluate\"},{id:\"implicit-label\",evaluate:\"implicit-evaluate\"},{id:\"label-content-name-mismatch\",evaluate:\"label-content-name-mismatch-evaluate\",options:{pixelThreshold:.1,occuranceThreshold:3}},{id:\"multiple-label\",evaluate:\"multiple-label-evaluate\"},{id:\"title-only\",evaluate:\"title-only-evaluate\"},{id:\"landmark-is-unique\",evaluate:\"landmark-is-unique-evaluate\",after:\"landmark-is-unique-after\"},{id:\"has-lang\",evaluate:\"has-lang-evaluate\",options:{attributes:[\"lang\",\"xml:lang\"]}},{id:\"valid-lang\",evaluate:\"valid-lang-evaluate\",options:{attributes:[\"lang\",\"xml:lang\"]}},{id:\"xml-lang-mismatch\",evaluate:\"xml-lang-mismatch-evaluate\"},{id:\"dlitem\",evaluate:\"dlitem-evaluate\"},{id:\"listitem\",evaluate:\"listitem-evaluate\"},{id:\"only-dlitems\",evaluate:\"only-dlitems-evaluate\"},{id:\"only-listitems\",evaluate:\"only-listitems-evaluate\"},{id:\"structured-dlitems\",evaluate:\"structured-dlitems-evaluate\"},{id:\"caption\",evaluate:\"caption-evaluate\"},{id:\"frame-tested\",evaluate:\"frame-tested-evaluate\",after:\"frame-tested-after\",options:{isViolation:!1}},{id:\"no-autoplay-audio\",evaluate:\"no-autoplay-audio-evaluate\",options:{allowedDuration:3}},{id:\"css-orientation-lock\",evaluate:\"css-orientation-lock-evaluate\",options:{degreeThreshold:2}},{id:\"meta-viewport-large\",evaluate:\"meta-viewport-scale-evaluate\",options:{scaleMinimum:5,lowerBound:2}},{id:\"meta-viewport\",evaluate:\"meta-viewport-scale-evaluate\",options:{scaleMinimum:2}},{id:\"header-present\",evaluate:\"has-descendant-evaluate\",after:\"has-descendant-after\",options:{selector:\":is(h1, h2, h3, h4, h5, h6):not([role]), [role=heading]\"}},{id:\"heading-order\",evaluate:\"heading-order-evaluate\",after:\"heading-order-after\"},{id:\"identical-links-same-purpose\",evaluate:\"identical-links-same-purpose-evaluate\",after:\"identical-links-same-purpose-after\"},{id:\"internal-link-present\",evaluate:\"internal-link-present-evaluate\"},{id:\"landmark\",evaluate:\"has-descendant-evaluate\",options:{selector:\"main, [role=main]\"}},{id:\"meta-refresh\",evaluate:\"meta-refresh-evaluate\"},{id:\"p-as-heading\",evaluate:\"p-as-heading-evaluate\",options:{margins:[{weight:150,italic:!0},{weight:150,size:1.15},{italic:!0,size:1.15},{size:1.4}]}},{id:\"region\",evaluate:\"region-evaluate\",options:{regionMatcher:\"dialog, [role=dialog], [role=alertdialog], svg, iframe\"}},{id:\"skip-link\",evaluate:\"skip-link-evaluate\"},{id:\"unique-frame-title\",evaluate:\"unique-frame-title-evaluate\",after:\"unique-frame-title-after\"},{id:\"duplicate-id-active\",evaluate:\"duplicate-id-evaluate\",after:\"duplicate-id-after\"},{id:\"duplicate-id-aria\",evaluate:\"duplicate-id-evaluate\",after:\"duplicate-id-after\"},{id:\"duplicate-id\",evaluate:\"duplicate-id-evaluate\",after:\"duplicate-id-after\"},{id:\"aria-label\",evaluate:\"aria-label-evaluate\"},{id:\"aria-labelledby\",evaluate:\"aria-labelledby-evaluate\"},{id:\"avoid-inline-spacing\",evaluate:\"avoid-inline-spacing-evaluate\",options:{cssProperties:[\"line-height\",\"letter-spacing\",\"word-spacing\"]}},{id:\"button-has-visible-text\",evaluate:\"has-text-content-evaluate\"},{id:\"doc-has-title\",evaluate:\"doc-has-title-evaluate\"},{id:\"exists\",evaluate:\"exists-evaluate\"},{id:\"has-alt\",evaluate:\"has-alt-evaluate\"},{id:\"has-visible-text\",evaluate:\"has-text-content-evaluate\"},{id:\"is-on-screen\",evaluate:\"is-on-screen-evaluate\"},{id:\"non-empty-alt\",evaluate:\"attr-non-space-content-evaluate\",options:{attribute:\"alt\"}},{id:\"non-empty-if-present\",evaluate:\"non-empty-if-present-evaluate\"},{id:\"non-empty-placeholder\",evaluate:\"attr-non-space-content-evaluate\",options:{attribute:\"placeholder\"}},{id:\"non-empty-title\",evaluate:\"attr-non-space-content-evaluate\",options:{attribute:\"title\"}},{id:\"non-empty-value\",evaluate:\"attr-non-space-content-evaluate\",options:{attribute:\"value\"}},{id:\"presentational-role\",evaluate:\"presentational-role-evaluate\"},{id:\"role-none\",evaluate:\"matches-definition-evaluate\",deprecated:!0,options:{matcher:{attributes:{role:\"none\"}}}},{id:\"role-presentation\",evaluate:\"matches-definition-evaluate\",deprecated:!0,options:{matcher:{attributes:{role:\"presentation\"}}}},{id:\"svg-non-empty-title\",evaluate:\"svg-non-empty-title-evaluate\"},{id:\"caption-faked\",evaluate:\"caption-faked-evaluate\"},{id:\"html5-scope\",evaluate:\"html5-scope-evaluate\"},{id:\"same-caption-summary\",evaluate:\"same-caption-summary-evaluate\"},{id:\"scope-value\",evaluate:\"scope-value-evaluate\",options:{values:[\"row\",\"col\",\"rowgroup\",\"colgroup\"]}},{id:\"td-has-header\",evaluate:\"td-has-header-evaluate\"},{id:\"td-headers-attr\",evaluate:\"td-headers-attr-evaluate\"},{id:\"th-has-data-cells\",evaluate:\"th-has-data-cells-evaluate\"},{id:\"hidden-content\",evaluate:\"hidden-content-evaluate\"}]})}(\"object\"==typeof window?window:this);";

module.exports = {
  source,
};

},{}],82:[function(require,module,exports){
/**
 * @license Copyright 2020 The Lighthouse Authors. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.
 */
'use strict';

/** @fileoverview Needed for the generated/SourceMap.js file */

const Common = {
  console,
};

module.exports = Common;

},{}],83:[function(require,module,exports){
/**
 * @license Copyright 2020 The Lighthouse Authors. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.
 */
'use strict';

const SDK = {
  TextSourceMap: require('./generated/SourceMap.js'),
};

/**
 * CDT pollutes Array.prototype w/ `lowerBound/upperBound`. SourceMap
 * relies on this, but only for a couple method return values. To avoid global pollution,
 * we explicitly set the extension functions on the return values.
 *
 * @param {unknown[]} array
 */
function extendArray(array) {
  // @ts-expect-error
  if (array.lowerBound) return;

  // @ts-expect-error
  array.lowerBound = lowerBound.bind(array);
  // @ts-expect-error
  array.upperBound = upperBound.bind(array);

  array.slice = function(start, end) {
    const retVal = Array.prototype.slice.call(array, start, end);
    extendArray(retVal);
    return retVal;
  };
  // @ts-expect-error
  array.filter = function(fn) {
    const retVal = Array.prototype.filter.call(array, fn);
    extendArray(retVal);
    return retVal;
  };
}

const originalMappings = SDK.TextSourceMap.prototype.mappings;
SDK.TextSourceMap.prototype.mappings = function() {
  const mappings = originalMappings.call(this);
  extendArray(mappings);
  return mappings;
};

const originalReversedMappings = SDK.TextSourceMap.prototype._reversedMappings;
SDK.TextSourceMap.prototype._reversedMappings = function(sourceURL) {
  const mappings = originalReversedMappings.call(this, sourceURL);
  extendArray(mappings);
  return mappings;
};

/**
 * `upperBound` and `lowerBound` are copied from CDT utilities.js.
 * These are the only methods needed from that file.
 */

/**
 * Return index of the leftmost element that is greater
 * than the specimen object. If there's no such element (i.e. all
 * elements are smaller or equal to the specimen) returns right bound.
 * The function works for sorted array.
 * When specified, |left| (inclusive) and |right| (exclusive) indices
 * define the search window.
 *
 * @param {!T} object
 * @param {function(!T,!S):number=} comparator
 * @param {number=} left
 * @param {number=} right
 * @return {number}
 * @this {Array.<!S>}
 * @template T,S
 */
function upperBound(object, comparator, left, right) {
  // @ts-expect-error
  function defaultComparator(a, b) {
    return a < b ? -1 : (a > b ? 1 : 0);
  }
  comparator = comparator || defaultComparator;
  let l = left || 0;
  let r = right !== undefined ? right : this.length;
  while (l < r) {
    const m = (l + r) >> 1;
    if (comparator(object, this[m]) >= 0) {
      l = m + 1;
    } else {
      r = m;
    }
  }
  return r;
}

/**
 * Return index of the leftmost element that is equal or greater
 * than the specimen object. If there's no such element (i.e. all
 * elements are smaller than the specimen) returns right bound.
 * The function works for sorted array.
 * When specified, |left| (inclusive) and |right| (exclusive) indices
 * define the search window.
 *
 * @param {!T} object
 * @param {function(!T,!S):number=} comparator
 * @param {number=} left
 * @param {number=} right
 * @return {number}
 * @this {Array.<!S>}
 * @template T,S
 */
function lowerBound(object, comparator, left, right) {
  // @ts-expect-error
  function defaultComparator(a, b) {
    return a < b ? -1 : (a > b ? 1 : 0);
  }
  comparator = comparator || defaultComparator;
  let l = left || 0;
  let r = right !== undefined ? right : this.length;
  while (l < r) {
    const m = (l + r) >> 1;
    if (comparator(object, this[m]) > 0) {
      l = m + 1;
    } else {
      r = m;
    }
  }
  return r;
}

// Add `lastColumnNumber` to mappings. This will eventually be added to CDT.
// @ts-expect-error
SDK.TextSourceMap.prototype.computeLastGeneratedColumns = function() {
  const mappings = this.mappings();
  // @ts-expect-error: `lastColumnNumber` is not on types yet.
  if (mappings.length && typeof mappings[0].lastColumnNumber !== 'undefined') return;

  for (let i = 0; i < mappings.length - 1; i++) {
    const mapping = mappings[i];
    const nextMapping = mappings[i + 1];
    if (mapping.lineNumber === nextMapping.lineNumber) {
      // @ts-expect-error: `lastColumnNumber` is not on types yet.
      mapping.lastColumnNumber = nextMapping.columnNumber;
    }
  }
};

module.exports = SDK;

},{"./generated/SourceMap.js":84}],84:[function(require,module,exports){
// @ts-nocheck
// generated by yarn build-cdt-lib
const Common = require('../Common.js')
"use strict";
/*
 * Copyright (C) 2012 Google Inc. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *
 *     * Redistributions of source code must retain the above copyright
 * notice, this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above
 * copyright notice, this list of conditions and the following disclaimer
 * in the documentation and/or other materials provided with the
 * distribution.
 *     * Neither the name of Google Inc. nor the names of its
 * contributors may be used to endorse or promote products derived from
 * this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
Object.defineProperty(exports, "__esModule", { value: true });

/**
 * @interface
 */
class SourceMap {
    /**
     * @return {string}
     */
    compiledURL() {
    }
    /**
     * @return {string}
     */
    url() {
    }
    /**
     * @return {!Array<string>}
     */
    sourceURLs() {
    }
    /**
     * @param {string} sourceURL
     * @return {?string}
     */
    embeddedContentByURL(sourceURL) {
    }
    /**
     * @param {number} lineNumber in compiled resource
     * @param {number} columnNumber in compiled resource
     * @return {?SourceMapEntry}
     */
    findEntry(lineNumber, columnNumber) {
    }
    /**
     * @param {string} sourceURL
     * @param {number} lineNumber
     * @param {number} columnNumber
     * @return {?SourceMapEntry}
     */
    sourceLineMapping(sourceURL, lineNumber, columnNumber) {
    }
    /**
     * @return {!Array<!SourceMapEntry>}
     */
    mappings() {
    }
    dispose() {
    }
}

/**
 * @unrestricted
 */
class SourceMapV3 {
    constructor() {
        /** @type {number} */ this.version;
        /** @type {string|undefined} */ this.file;
        /** @type {!Array.<string>} */ this.sources;
        /** @type {!Array.<!SourceMapV3.Section>|undefined} */ this.sections;
        /** @type {string} */ this.mappings;
        /** @type {string|undefined} */ this.sourceRoot;
        /** @type {!Array.<string>|undefined} */ this.names;
    }
}
/**
 * @unrestricted
 */
SourceMapV3.Section = class {
    constructor() {
        /** @type {!SourceMapV3} */ this.map;
        /** @type {!SourceMapV3.Offset} */ this.offset;
    }
};
/**
 * @unrestricted
 */
SourceMapV3.Offset = class {
    constructor() {
        /** @type {number} */ this.line;
        /** @type {number} */ this.column;
    }
};
/**
 * @unrestricted
 */
class SourceMapEntry {
    /**
     * @param {number} lineNumber
     * @param {number} columnNumber
     * @param {string=} sourceURL
     * @param {number=} sourceLineNumber
     * @param {number=} sourceColumnNumber
     * @param {string=} name
     */
    constructor(lineNumber, columnNumber, sourceURL, sourceLineNumber, sourceColumnNumber, name) {
        this.lineNumber = lineNumber;
        this.columnNumber = columnNumber;
        this.sourceURL = sourceURL;
        this.sourceLineNumber = sourceLineNumber;
        this.sourceColumnNumber = sourceColumnNumber;
        this.name = name;
    }
    /**
     * @param {!SourceMapEntry} entry1
     * @param {!SourceMapEntry} entry2
     * @return {number}
     */
    static compare(entry1, entry2) {
        if (entry1.lineNumber !== entry2.lineNumber) {
            return entry1.lineNumber - entry2.lineNumber;
        }
        return entry1.columnNumber - entry2.columnNumber;
    }
}



/**
 * @implements {SourceMap}
 * @unrestricted
 */
class TextSourceMap {
    /**
     * Implements Source Map V3 model. See https://github.com/google/closure-compiler/wiki/Source-Maps
     * for format description.
     * @param {string} compiledURL
     * @param {string} sourceMappingURL
     * @param {!SourceMapV3} payload
     */
    constructor(compiledURL, sourceMappingURL, payload) {
        if (!TextSourceMap._base64Map) {
            const base64Digits = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
            TextSourceMap._base64Map = {};
            for (let i = 0; i < base64Digits.length; ++i) {
                TextSourceMap._base64Map[base64Digits.charAt(i)] = i;
            }
        }
        this._json = payload;
        this._compiledURL = compiledURL;
        this._sourceMappingURL = sourceMappingURL;
        this._baseURL = sourceMappingURL.startsWith('data:') ? compiledURL : sourceMappingURL;
        /** @type {?Array<!SourceMapEntry>} */
        this._mappings = null;
        /** @type {!Map<string, !TextSourceMap.SourceInfo>} */
        this._sourceInfos = new Map();
        if (this._json.sections) {
            const sectionWithURL = !!this._json.sections.find(section => !!section.url);
            if (sectionWithURL) {
                Common.console.warn(`SourceMap "${sourceMappingURL}" contains unsupported "URL" field in one of its sections.`);
            }
        }
        this._eachSection(this._parseSources.bind(this));
    }
    /**
     * @override
     * @return {string}
     */
    compiledURL() {
        return this._compiledURL;
    }
    /**
     * @override
     * @return {string}
     */
    url() {
        return this._sourceMappingURL;
    }
    /**
     * @override
     * @return {!Array.<string>}
     */
    sourceURLs() {
        return this._sourceInfos.keysArray();
    }
    /**
     * @override
     * @param {string} sourceURL
     * @return {?string}
     */
    embeddedContentByURL(sourceURL) {
        if (!this._sourceInfos.has(sourceURL)) {
            return null;
        }
        return this._sourceInfos.get(sourceURL).content;
    }
    /**
     * @override
     * @param {number} lineNumber in compiled resource
     * @param {number} columnNumber in compiled resource
     * @return {?SourceMapEntry}
     */
    findEntry(lineNumber, columnNumber) {
        const mappings = this.mappings();
        const index = mappings.upperBound(undefined, (unused, entry) => lineNumber - entry.lineNumber || columnNumber - entry.columnNumber);
        return index ? mappings[index - 1] : null;
    }
    /**
     * @override
     * @param {string} sourceURL
     * @param {number} lineNumber
     * @param {number} columnNumber
     * @return {?SourceMapEntry}
     */
    sourceLineMapping(sourceURL, lineNumber, columnNumber) {
        const mappings = this._reversedMappings(sourceURL);
        const first = mappings.lowerBound(lineNumber, lineComparator);
        const last = mappings.upperBound(lineNumber, lineComparator);
        if (first >= mappings.length || mappings[first].sourceLineNumber !== lineNumber) {
            return null;
        }
        const columnMappings = mappings.slice(first, last);
        if (!columnMappings.length) {
            return null;
        }
        const index = columnMappings.lowerBound(columnNumber, (columnNumber, mapping) => columnNumber - mapping.sourceColumnNumber);
        return index >= columnMappings.length ? columnMappings[columnMappings.length - 1] : columnMappings[index];
        /**
         * @param {number} lineNumber
         * @param {!SourceMapEntry} mapping
         * @return {number}
         */
        function lineComparator(lineNumber, mapping) {
            return lineNumber - mapping.sourceLineNumber;
        }
    }
    /**
     * @param {string} sourceURL
     * @param {number} lineNumber
     * @param {number} columnNumber
     * @return {!Array<!SourceMapEntry>}
     */
    findReverseEntries(sourceURL, lineNumber, columnNumber) {
        const mappings = this._reversedMappings(sourceURL);
        const endIndex = mappings.upperBound(undefined, (unused, entry) => lineNumber - entry.sourceLineNumber || columnNumber - entry.sourceColumnNumber);
        let startIndex = endIndex;
        while (startIndex > 0 && mappings[startIndex - 1].sourceLineNumber === mappings[endIndex - 1].sourceLineNumber &&
            mappings[startIndex - 1].sourceColumnNumber === mappings[endIndex - 1].sourceColumnNumber) {
            --startIndex;
        }
        return mappings.slice(startIndex, endIndex);
    }
    /**
     * @override
     * @return {!Array<!SourceMapEntry>}
     */
    mappings() {
        if (this._mappings === null) {
            this._mappings = [];
            this._eachSection(this._parseMap.bind(this));
            this._json = null;
        }
        return /** @type {!Array<!SourceMapEntry>} */ (this._mappings);
    }
    /**
     * @param {string} sourceURL
     * @return {!Array.<!SourceMapEntry>}
     */
    _reversedMappings(sourceURL) {
        if (!this._sourceInfos.has(sourceURL)) {
            return [];
        }
        const mappings = this.mappings();
        const info = this._sourceInfos.get(sourceURL);
        if (info.reverseMappings === null) {
            info.reverseMappings = mappings.filter(mapping => mapping.sourceURL === sourceURL).sort(sourceMappingComparator);
        }
        return info.reverseMappings;
        /**
         * @param {!SourceMapEntry} a
         * @param {!SourceMapEntry} b
         * @return {number}
         */
        function sourceMappingComparator(a, b) {
            if (a.sourceLineNumber !== b.sourceLineNumber) {
                return a.sourceLineNumber - b.sourceLineNumber;
            }
            if (a.sourceColumnNumber !== b.sourceColumnNumber) {
                return a.sourceColumnNumber - b.sourceColumnNumber;
            }
            if (a.lineNumber !== b.lineNumber) {
                return a.lineNumber - b.lineNumber;
            }
            return a.columnNumber - b.columnNumber;
        }
    }
    /**
     * @param {function(!SourceMapV3, number, number)} callback
     */
    _eachSection(callback) {
        if (!this._json.sections) {
            callback(this._json, 0, 0);
            return;
        }
        for (const section of this._json.sections) {
            callback(section.map, section.offset.line, section.offset.column);
        }
    }
    /**
     * @param {!SourceMapV3} sourceMap
     */
    _parseSources(sourceMap) {
        const sourcesList = [];
        let sourceRoot = sourceMap.sourceRoot || '';
        if (sourceRoot && !sourceRoot.endsWith('/')) {
            sourceRoot += '/';
        }
        for (let i = 0; i < sourceMap.sources.length; ++i) {
            const href = sourceRoot + sourceMap.sources[i];
            let url = '' || href;
            const source = sourceMap.sourcesContent && sourceMap.sourcesContent[i];
            if (url === this._compiledURL && source) {
            }
            this._sourceInfos.set(url, new TextSourceMap.SourceInfo(source, null));
            sourcesList.push(url);
        }
        sourceMap[TextSourceMap._sourcesListSymbol] = sourcesList;
    }
    /**
     * @param {!SourceMapV3} map
     * @param {number} lineNumber
     * @param {number} columnNumber
     */
    _parseMap(map, lineNumber, columnNumber) {
        let sourceIndex = 0;
        let sourceLineNumber = 0;
        let sourceColumnNumber = 0;
        let nameIndex = 0;
        const sources = map[TextSourceMap._sourcesListSymbol];
        const names = map.names || [];
        const stringCharIterator = new TextSourceMap.StringCharIterator(map.mappings);
        let sourceURL = sources[sourceIndex];
        while (true) {
            if (stringCharIterator.peek() === ',') {
                stringCharIterator.next();
            }
            else {
                while (stringCharIterator.peek() === ';') {
                    lineNumber += 1;
                    columnNumber = 0;
                    stringCharIterator.next();
                }
                if (!stringCharIterator.hasNext()) {
                    break;
                }
            }
            columnNumber += this._decodeVLQ(stringCharIterator);
            if (!stringCharIterator.hasNext() || this._isSeparator(stringCharIterator.peek())) {
                this._mappings.push(new SourceMapEntry(lineNumber, columnNumber));
                continue;
            }
            const sourceIndexDelta = this._decodeVLQ(stringCharIterator);
            if (sourceIndexDelta) {
                sourceIndex += sourceIndexDelta;
                sourceURL = sources[sourceIndex];
            }
            sourceLineNumber += this._decodeVLQ(stringCharIterator);
            sourceColumnNumber += this._decodeVLQ(stringCharIterator);
            if (!stringCharIterator.hasNext() || this._isSeparator(stringCharIterator.peek())) {
                this._mappings.push(new SourceMapEntry(lineNumber, columnNumber, sourceURL, sourceLineNumber, sourceColumnNumber));
                continue;
            }
            nameIndex += this._decodeVLQ(stringCharIterator);
            this._mappings.push(new SourceMapEntry(lineNumber, columnNumber, sourceURL, sourceLineNumber, sourceColumnNumber, names[nameIndex]));
        }
        // As per spec, mappings are not necessarily sorted.
        this._mappings.sort(SourceMapEntry.compare);
    }
    /**
     * @param {string} char
     * @return {boolean}
     */
    _isSeparator(char) {
        return char === ',' || char === ';';
    }
    /**
     * @param {!TextSourceMap.StringCharIterator} stringCharIterator
     * @return {number}
     */
    _decodeVLQ(stringCharIterator) {
        // Read unsigned value.
        let result = 0;
        let shift = 0;
        let digit;
        do {
            digit = TextSourceMap._base64Map[stringCharIterator.next()];
            result += (digit & TextSourceMap._VLQ_BASE_MASK) << shift;
            shift += TextSourceMap._VLQ_BASE_SHIFT;
        } while (digit & TextSourceMap._VLQ_CONTINUATION_MASK);
        // Fix the sign.
        const negative = result & 1;
        result >>= 1;
        return negative ? -result : result;
    }
    /**
     * @param {string} url
     * @param {!TextUtils.TextRange} textRange
     * @return {!TextUtils.TextRange}
     */
    reverseMapTextRange(url, textRange) {
        /**
         * @param {!{lineNumber: number, columnNumber: number}} position
         * @param {!SourceMapEntry} mapping
         * @return {number}
         */
        function comparator(position, mapping) {
            if (position.lineNumber !== mapping.sourceLineNumber) {
                return position.lineNumber - mapping.sourceLineNumber;
            }
            return position.columnNumber - mapping.sourceColumnNumber;
        }
        const mappings = this._reversedMappings(url);
        const startIndex = mappings.lowerBound({ lineNumber: textRange.startLine, columnNumber: textRange.startColumn }, comparator);
        const endIndex = mappings.upperBound({ lineNumber: textRange.endLine, columnNumber: textRange.endColumn }, comparator);
        const startMapping = mappings[startIndex];
        const endMapping = mappings[endIndex];
        return new TextUtils.TextRange(startMapping.lineNumber, startMapping.columnNumber, endMapping.lineNumber, endMapping.columnNumber);
    }
    /**
     * @override
     */
    dispose() {
    }
}

TextSourceMap._VLQ_BASE_SHIFT = 5;
TextSourceMap._VLQ_BASE_MASK = (1 << 5) - 1;
TextSourceMap._VLQ_CONTINUATION_MASK = 1 << 5;
/**
 * @unrestricted
 */
TextSourceMap.StringCharIterator = class {
    /**
     * @param {string} string
     */
    constructor(string) {
        this._string = string;
        this._position = 0;
    }
    /**
     * @return {string}
     */
    next() {
        return this._string.charAt(this._position++);
    }
    /**
     * @return {string}
     */
    peek() {
        return this._string.charAt(this._position);
    }
    /**
     * @return {boolean}
     */
    hasNext() {
        return this._position < this._string.length;
    }
};
/**
 * @unrestricted
 */
TextSourceMap.SourceInfo = class {
    /**
     * @param {?string} content
     * @param {?Array<!SourceMapEntry>} reverseMappings
     */
    constructor(content, reverseMappings) {
        this.content = content;
        this.reverseMappings = reverseMappings;
    }
};
TextSourceMap._sourcesListSymbol = Symbol('sourcesList');




module.exports = TextSourceMap
},{"../Common.js":82}],85:[function(require,module,exports){
(function (__filename){(function (){
/**
 * @license Copyright 2021 The Lighthouse Authors. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.
 */
'use strict';

/** @typedef {import('csp_evaluator/finding').Finding} Finding */

const {
  evaluateForFailure,
  evaluateForSyntaxErrors,
  evaluateForWarnings,
} = require('csp_evaluator/dist/lighthouse/lighthouse_checks.js');
const {Type} = require('csp_evaluator/dist/finding.js');
const {CspParser} = require('csp_evaluator/dist/parser.js');
const {Directive} = require('csp_evaluator/dist/csp.js');

const log = require('lighthouse-logger');
const i18n = require('../lib/i18n/i18n.js');

const UIStrings = {
  /** Message shown when a CSP does not have a base-uri directive. Shown in a table with a list of other CSP vulnerabilities and suggestions. "CSP" stands for "Content Security Policy". "base-uri", "'none'", and "'self'" do not need to be translated. */
  missingBaseUri: 'Missing base-uri allows injected <base> tags to set the base URL for all ' +
    'relative URLs (e.g. scripts) to an attacker controlled domain. ' +
    'Consider setting base-uri to \'none\' or \'self\'.',
  /** Message shown when a CSP does not have a script-src directive. Shown in a table with a list of other CSP vulnerabilities and suggestions. "CSP" stands for "Content Security Policy". "script-src" does not need to be translated. */
  missingScriptSrc: 'script-src directive is missing. ' +
    'This can allow the execution of unsafe scripts.',
  /** Message shown when a CSP does not have a script-src directive. Shown in a table with a list of other CSP vulnerabilities and suggestions. "CSP" stands for "Content Security Policy". "object-src" and "'none'" do not need to be translated. */
  missingObjectSrc: 'Elements controlled by object-src are considered legacy features. ' +
    'Consider setting object-src to \'none\' to prevent the injection of ' +
    'plugins that execute unsafe scripts.',
  /** Message shown when a CSP uses a domain allowlist to filter out malicious scripts. Shown in a table with a list of other CSP vulnerabilities and suggestions. "CSP" stands for "Content Security Policy". "CSP", "'strict-dynamic'", "nonces", and "hashes" do not need to be translated. "allowlists" can be interpreted as "whitelist". */
  strictDynamic: 'Host allowlists can frequently be bypassed. Consider using ' +
    '\'strict-dynamic\' in combination with CSP nonces or hashes.',
  /** Message shown when a CSP allows inline scripts to be run in the page. Shown in a table with a list of other CSP vulnerabilities and suggestions. "CSP" stands for "Content Security Policy". "CSP", "'unsafe-inline'", "nonces", and "hashes" do not need to be translated. */
  unsafeInline: '\'unsafe-inline\' allows the execution of unsafe in-page scripts ' +
    'and event handlers. Consider using CSP nonces or hashes to allow scripts individually.',
  /** Message shown when a CSP is not backwards compatible with browsers that do not support CSP nonces/hashes. Shown in a table with a list of other CSP vulnerabilities and suggestions. "CSP" stands for "Content Security Policy". "'unsafe-inline'", "nonces", and "hashes" do not need to be translated. */
  unsafeInlineFallback: 'Consider adding \'unsafe-inline\' (ignored by browsers supporting ' +
    'nonces/hashes) to be backward compatible with older browsers.',
  /** Message shown when a CSP is not backwards compatible with browsers that do not support the 'strict-dynamic' keyword. Shown in a table with a list of other CSP vulnerabilities and suggestions. "CSP" stands for "Content Security Policy". "http:", "https:", and "'strict-dynamic'" do not need to be translated. */
  allowlistFallback: 'Consider adding https: and http: URL schemes (ignored by browsers ' +
    'supporting \'strict-dynamic\') to be backward compatible with older browsers.',
  /** Message shown when a CSP only provides a reporting destination through the report-to directive. Shown in a table with a list of other CSP vulnerabilities and suggestions. "CSP" stands for "Content Security Policy". "report-to", "report-uri", and "Chromium" do not need to be translated. */
  reportToOnly: 'The reporting destination is only configured via the report-to directive. ' +
    'This directive is only supported in Chromium-based browsers so it is ' +
    'recommended to also use a report-uri directive.',
  /** Message shown when a CSP does not provide a reporting destination. Shown in a table with a list of other CSP vulnerabilities and suggestions. "CSP" stands for "Content Security Policy". "CSP" does not need to be translated. */
  reportingDestinationMissing: 'No CSP configures a reporting destination. ' +
    'This makes it difficult to maintain the CSP over time and monitor for any breakages.',
  /** Message shown when a CSP nonce has less than 8 characters. Shown in a table with a list of other CSP vulnerabilities and suggestions. "CSP" stands for "Content Security Policy". "Nonces" does not need to be translated. */
  nonceLength: 'Nonces should be at least 8 characters long.',
  /** Message shown when a CSP nonce does not use teh base64 charset. Shown in a table with a list of other CSP vulnerabilities and suggestions. "CSP" stands for "Content Security Policy". "Nonces" and "base84" do not need to be translated. "charset" can be interpreted as "a set of characters". */
  nonceCharset: 'Nonces should use the base64 charset.',
  /**
   * @description Message shown when a CSP is missing a semicolon. Shown in a table with a list of other CSP vulnerabilities and suggestions. "CSP" stands for "Content Security Policy".
   * @example {'object-src'} keyword
   */
  missingSemicolon: 'Did you forget the semicolon? ' +
    '{keyword} seems to be a directive, not a keyword.',
  /** Message shown when a CSP contains an unknown keyword. Shown in a table with a list of other CSP vulnerabilities and suggestions. "CSP" stands for "Content Security Policy". "CSP" does not need to be translated. */
  unknownDirective: 'Unknown CSP directive.',
  /**
   * @description Message shown when a CSP contains an invalid keyword. Shown in a table with a list of other CSP vulnerabilities and suggestions. "CSP" stands for "Content Security Policy".
   * @example {'invalid-keyword'} keyword
   */
  unknownKeyword: '{keyword} seems to be an invalid keyword.',
  /** Message shown when a CSP uses the deprecated reflected-xss directive. Shown in a table with a list of other CSP vulnerabilities and suggestions. "CSP" stands for "Content Security Policy". "reflected-xss", "CSP2" and "X-XSS-Protection" do not need to be translated. */
  deprecatedReflectedXSS: 'reflected-xss is deprecated since CSP2. ' +
    'Please, use the X-XSS-Protection header instead.',
  /** Message shown when a CSP uses the deprecated referrer directive. Shown in a table with a list of other CSP vulnerabilities and suggestions. "CSP" stands for "Content Security Policy". "referrer", "CSP2" and "Referrer-Policy" do not need to be translated. */
  deprecatedReferrer: 'referrer is deprecated since CSP2. ' +
    'Please, use the Referrer-Policy header instead.',
  /** Message shown when a CSP uses the deprecated disown-opener directive. Shown in a table with a list of other CSP vulnerabilities and suggestions. "CSP" stands for "Content Security Policy". "disown-opener", "CSP3" and "Cross-Origin-Opener-Policy" do not need to be translated. */
  deprecatedDisownOpener: 'disown-opener is deprecated since CSP3. ' +
    'Please, use the Cross-Origin-Opener-Policy header instead.',
};

const str_ = i18n.createMessageInstanceIdFn(__filename, UIStrings);

/** @type {Record<number, string|LH.IcuMessage|Record<string, LH.IcuMessage>>} */
const FINDING_TO_UI_STRING = {
  [Type.MISSING_SEMICOLON]: UIStrings.missingSemicolon,
  [Type.UNKNOWN_DIRECTIVE]: str_(UIStrings.unknownDirective),
  [Type.INVALID_KEYWORD]: UIStrings.unknownKeyword,
  [Type.MISSING_DIRECTIVES]: {
    [Directive.BASE_URI]: str_(UIStrings.missingBaseUri),
    [Directive.SCRIPT_SRC]: str_(UIStrings.missingScriptSrc),
    [Directive.OBJECT_SRC]: str_(UIStrings.missingObjectSrc),
  },
  [Type.SCRIPT_UNSAFE_INLINE]: str_(UIStrings.unsafeInline),
  [Type.NONCE_LENGTH]: str_(UIStrings.nonceLength),
  [Type.NONCE_CHARSET]: str_(UIStrings.nonceCharset),
  [Type.DEPRECATED_DIRECTIVE]: {
    [Directive.REFLECTED_XSS]: str_(UIStrings.deprecatedReflectedXSS),
    [Directive.REFERRER]: str_(UIStrings.deprecatedReferrer),
    [Directive.DISOWN_OPENER]: str_(UIStrings.deprecatedDisownOpener),
  },
  [Type.STRICT_DYNAMIC]: str_(UIStrings.strictDynamic),
  [Type.UNSAFE_INLINE_FALLBACK]: str_(UIStrings.unsafeInlineFallback),
  [Type.ALLOWLIST_FALLBACK]: str_(UIStrings.allowlistFallback),
  [Type.REPORTING_DESTINATION_MISSING]: str_(UIStrings.reportingDestinationMissing),
  [Type.REPORT_TO_ONLY]: str_(UIStrings.reportToOnly),
};

/**
 * @param {Finding} finding
 * @return {LH.IcuMessage|string}
 */
function getTranslatedDescription(finding) {
  let result = FINDING_TO_UI_STRING[finding.type];
  if (!result) {
    log.warn('CSP Evaluator', `No translation found for description: ${finding.description}`);
    return finding.description;
  }

  // Return if translated result found.
  if (i18n.isIcuMessage(result)) return result;

  // If result was not translated, that means `finding.value` is included in the UI string.
  if (typeof result === 'string') return str_(result, {keyword: finding.value || ''});

  // Result is a record object, UI string depends on the directive.
  result = result[finding.directive];
  if (!result) {
    log.warn('CSP Evaluator', `No translation found for description: ${finding.description}`);
    return finding.description;
  }

  return result;
}

/**
 * @param {string} rawCsp
 */
function parseCsp(rawCsp) {
  return new CspParser(rawCsp).csp;
}

/**
 * @param {string[]} rawCsps
 * @return {{bypasses: Finding[], warnings: Finding[], syntax: Finding[][]}}
 */
function evaluateRawCspsForXss(rawCsps) {
  const parsedCsps = rawCsps.map(parseCsp);
  const bypasses = evaluateForFailure(parsedCsps);
  const warnings = evaluateForWarnings(parsedCsps);
  const syntax = evaluateForSyntaxErrors(parsedCsps);
  return {bypasses, warnings, syntax};
}

module.exports = {
  getTranslatedDescription,
  evaluateRawCspsForXss,
  parseCsp,
  UIStrings,
};

}).call(this)}).call(this,"/lighthouse-core/lib/csp-evaluator.js")
},{"../lib/i18n/i18n.js":96,"csp_evaluator/dist/csp.js":154,"csp_evaluator/dist/finding.js":155,"csp_evaluator/dist/lighthouse/lighthouse_checks.js":156,"csp_evaluator/dist/parser.js":157,"lighthouse-logger":188}],86:[function(require,module,exports){
/**
 * @license Copyright 2017 The Lighthouse Authors. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.
 */
'use strict';

/**
 * A union of all types derived from BaseNode, allowing type check discrimination
 * based on `node.type`. If a new node type is created, it should be added here.
 * @typedef {import('./cpu-node.js') | import('./network-node.js')} Node
 */

/**
 * @fileoverview This class encapsulates logic for handling resources and tasks used to model the
 * execution dependency graph of the page. A node has a unique identifier and can depend on other
 * nodes/be depended on. The construction of the graph maintains some important invariants that are
 * inherent to the model:
 *
 *    1. The graph is a DAG, there are no cycles.
 *    2. There is always a root node upon which all other nodes eventually depend.
 *
 * This allows particular optimizations in this class so that we do no need to check for cycles as
 * these methods are called and we can always start traversal at the root node.
 */
class BaseNode {
  /**
   * @param {string} id
   */
  constructor(id) {
    this._id = id;
    this._isMainDocument = false;
    /** @type {Node[]} */
    this._dependents = [];
    /** @type {Node[]} */
    this._dependencies = [];
  }

  /**
   * @return {string}
   */
  get id() {
    return this._id;
  }

  /**
   * @return {typeof BaseNode.TYPES[keyof typeof BaseNode.TYPES]}
   */
  get type() {
    throw new Error('Unimplemented');
  }

  /**
   * @return {number}
   */
  get startTime() {
    throw new Error('Unimplemented');
  }

  /**
   * @return {number}
   */
  get endTime() {
    throw new Error('Unimplemented');
  }

  /**
   * @param {boolean} value
   */
  setIsMainDocument(value) {
    this._isMainDocument = value;
  }

  /**
   * @return {boolean}
   */
  isMainDocument() {
    return this._isMainDocument;
  }

  /**
   * @return {Node[]}
   */
  getDependents() {
    return this._dependents.slice();
  }

  /**
   * @return {number}
   */
  getNumberOfDependents() {
    return this._dependents.length;
  }

  /**
   * @return {Node[]}
   */
  getDependencies() {
    return this._dependencies.slice();
  }

  /**
   * @return {number}
   */
  getNumberOfDependencies() {
    return this._dependencies.length;
  }

  /**
   * @return {Node}
   */
  getRootNode() {
    let rootNode = /** @type {Node} */ (/** @type {BaseNode} */ (this));
    while (rootNode._dependencies.length) {
      rootNode = rootNode._dependencies[0];
    }

    return rootNode;
  }

  /**
   * @param {Node} node
   */
  addDependent(node) {
    node.addDependency(/** @type {Node} */ (/** @type {BaseNode} */ (this)));
  }

  /**
   * @param {Node} node
   */
  addDependency(node) {
    // @ts-expect-error - in checkJs, ts doesn't know that CPUNode and NetworkNode *are* BaseNodes.
    if (node === this) throw new Error('Cannot add dependency on itself');

    if (this._dependencies.includes(node)) {
      return;
    }

    node._dependents.push(/** @type {Node} */ (/** @type {BaseNode} */ (this)));
    this._dependencies.push(node);
  }

  /**
   * @param {Node} node
   */
  removeDependent(node) {
    node.removeDependency(/** @type {Node} */ (/** @type {BaseNode} */ (this)));
  }

  /**
   * @param {Node} node
   */
  removeDependency(node) {
    if (!this._dependencies.includes(node)) {
      return;
    }

    const thisIndex = node._dependents.indexOf(/** @type {Node} */ (/** @type {BaseNode} */(this)));
    node._dependents.splice(thisIndex, 1);
    this._dependencies.splice(this._dependencies.indexOf(node), 1);
  }

  removeAllDependencies() {
    for (const node of this._dependencies.slice()) {
      this.removeDependency(node);
    }
  }

  /**
   * Computes whether the given node is anywhere in the dependency graph of this node.
   * While this method can prevent cycles, it walks the graph and should be used sparingly.
   * Nodes are always considered dependent on themselves for the purposes of cycle detection.
   * @param {BaseNode} node
   * @return {boolean}
   */
  isDependentOn(node) {
    let isDependentOnNode = false;
    this.traverse(currentNode => {
      if (isDependentOnNode) return;
      isDependentOnNode = currentNode === node;
    }, currentNode => {
      // If we've already found the dependency, don't traverse further.
      if (isDependentOnNode) return [];
      // Otherwise, traverse the dependencies.
      return currentNode.getDependencies();
    });

    return isDependentOnNode;
  }

  /**
   * Clones the node's information without adding any dependencies/dependents.
   * @return {Node}
   */
  cloneWithoutRelationships() {
    const node = /** @type {Node} */ (new BaseNode(this.id));
    node.setIsMainDocument(this._isMainDocument);
    return node;
  }

  /**
   * Clones the entire graph connected to this node filtered by the optional predicate. If a node is
   * included by the predicate, all nodes along the paths between the node and the root will be included. If the
   * node this was called on is not included in the resulting filtered graph, the method will throw.
   * @param {function(Node):boolean} [predicate]
   * @return {Node}
   */
  cloneWithRelationships(predicate) {
    const rootNode = this.getRootNode();

    /** @type {Map<string, Node>} */
    const idsToIncludedClones = new Map();

    // Walk down dependents.
    rootNode.traverse(node => {
      if (idsToIncludedClones.has(node.id)) return;

      if (predicate === undefined) {
        // No condition for entry, so clone every node.
        idsToIncludedClones.set(node.id, node.cloneWithoutRelationships());
        return;
      }

      if (predicate(node)) {
        // Node included, so walk back up dependencies, cloning nodes from here back to the root.
        node.traverse(
          node => idsToIncludedClones.set(node.id, node.cloneWithoutRelationships()),
          // Dependencies already cloned have already cloned ancestors, so no need to visit again.
          node => node._dependencies.filter(parent => !idsToIncludedClones.has(parent.id))
        );
      }
    });

    // Copy dependencies between nodes.
    rootNode.traverse(originalNode => {
      const clonedNode = idsToIncludedClones.get(originalNode.id);
      if (!clonedNode) return;

      for (const dependency of originalNode._dependencies) {
        const clonedDependency = idsToIncludedClones.get(dependency.id);
        if (!clonedDependency) throw new Error('Dependency somehow not cloned');
        clonedNode.addDependency(clonedDependency);
      }
    });

    const clonedThisNode = idsToIncludedClones.get(this.id);
    if (!clonedThisNode) throw new Error('Cloned graph missing node');
    return clonedThisNode;
  }

  /**
   * Traverses all connected nodes in BFS order, calling `callback` exactly once
   * on each. `traversalPath` is the shortest (though not necessarily unique)
   * path from `node` to the root of the iteration.
   *
   * The `getNextNodes` function takes a visited node and returns which nodes to
   * visit next. It defaults to returning the node's dependents.
   * @param {(node: Node, traversalPath: Node[]) => void} callback
   * @param {function(Node): Node[]} [getNextNodes]
   */
  traverse(callback, getNextNodes) {
    for (const {node, traversalPath} of this.traverseGenerator(getNextNodes)) {
      callback(node, traversalPath);
    }
  }

  /**
   * @see BaseNode.traverse
   * @param {function(Node): Node[]} [getNextNodes]
   */
  * traverseGenerator(getNextNodes) {
    if (!getNextNodes) {
      getNextNodes = node => node.getDependents();
    }

    /** @type {Node[][]} */
    // @ts-expect-error - only traverses graphs of Node, so force tsc to treat `this` as one
    const queue = [[this]];
    const visited = new Set([this.id]);

    while (queue.length) {
      /** @type {Node[]} */
      // @ts-expect-error - queue has length so it's guaranteed to have an item
      const traversalPath = queue.shift();
      const node = traversalPath[0];
      yield {node, traversalPath};

      for (const nextNode of getNextNodes(node)) {
        if (visited.has(nextNode.id)) continue;
        visited.add(nextNode.id);

        queue.push([nextNode, ...traversalPath]);
      }
    }
  }

  /**
   * Returns whether the given node has a cycle in its dependent graph by performing a DFS.
   * @param {Node} node
   * @param {'dependents'|'dependencies'|'both'} [direction]
   * @return {boolean}
   */
  static hasCycle(node, direction = 'both') {
    // Checking 'both' is the default entrypoint to recursively check both directions
    if (direction === 'both') {
      return BaseNode.hasCycle(node, 'dependents') || BaseNode.hasCycle(node, 'dependencies');
    }

    const visited = new Set();
    /** @type {Node[]} */
    const currentPath = [];
    const toVisit = [node];
    const depthAdded = new Map([[node, 0]]);

    // Keep going while we have nodes to visit in the stack
    while (toVisit.length) {
      // Get the last node in the stack (DFS uses stack, not queue)
      /** @type {Node} */
      // @ts-expect-error - toVisit has length so it's guaranteed to have an item
      const currentNode = toVisit.pop();

      // We've hit a cycle if the node we're visiting is in our current dependency path
      if (currentPath.includes(currentNode)) return true;
      // If we've already visited the node, no need to revisit it
      if (visited.has(currentNode)) continue;

      // Since we're visiting this node, clear out any nodes in our path that we had to backtrack
      // @ts-expect-error
      while (currentPath.length > depthAdded.get(currentNode)) currentPath.pop();

      // Update our data structures to reflect that we're adding this node to our path
      visited.add(currentNode);
      currentPath.push(currentNode);

      // Add all of its dependents to our toVisit stack
      const nodesToExplore = direction === 'dependents' ?
        currentNode._dependents :
        currentNode._dependencies;
      for (const nextNode of nodesToExplore) {
        if (toVisit.includes(nextNode)) continue;
        toVisit.push(nextNode);
        depthAdded.set(nextNode, currentPath.length);
      }
    }

    return false;
  }
}

BaseNode.TYPES = /** @type {{NETWORK: 'network', CPU: 'cpu'}} */({
  NETWORK: 'network',
  CPU: 'cpu',
});

module.exports = BaseNode;

},{}],87:[function(require,module,exports){
/**
 * @license Copyright 2017 The Lighthouse Authors. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.
 */
'use strict';

const BaseNode = require('./base-node.js');

class CPUNode extends BaseNode {
  /**
   * @param {LH.TraceEvent} parentEvent
   * @param {LH.TraceEvent[]=} childEvents
   */
  constructor(parentEvent, childEvents = []) {
    const nodeId = `${parentEvent.tid}.${parentEvent.ts}`;
    super(nodeId);

    this._event = parentEvent;
    this._childEvents = childEvents;
  }

  get type() {
    return BaseNode.TYPES.CPU;
  }

  /**
   * @return {number}
   */
  get startTime() {
    return this._event.ts;
  }

  /**
   * @return {number}
   */
  get endTime() {
    return this._event.ts + this._event.dur;
  }

  /**
   * @return {LH.TraceEvent}
   */
  get event() {
    return this._event;
  }

  /**
   * @return {LH.TraceEvent[]}
   */
  get childEvents() {
    return this._childEvents;
  }

  /**
   * Returns true if this node contains a Layout task.
   * @return {boolean}
   */
  didPerformLayout() {
    return this._childEvents.some(evt => evt.name === 'Layout');
  }

  /**
   * Returns the script URLs that had their EvaluateScript events occur in this task.
   */
  getEvaluateScriptURLs() {
    /** @type {Set<string>} */
    const urls = new Set();
    for (const event of this._childEvents) {
      if (event.name !== 'EvaluateScript') continue;
      if (!event.args.data || !event.args.data.url) continue;
      urls.add(event.args.data.url);
    }

    return urls;
  }

  /**
   * @return {CPUNode}
   */
  cloneWithoutRelationships() {
    return new CPUNode(this._event, this._childEvents);
  }
}

module.exports = CPUNode;

},{"./base-node.js":86}],88:[function(require,module,exports){
/**
 * @license Copyright 2017 The Lighthouse Authors. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.
 */
'use strict';

const BaseNode = require('./base-node.js');
const NetworkRequest = require('../network-request.js');

class NetworkNode extends BaseNode {
  /**
   * @param {LH.Artifacts.NetworkRequest} networkRecord
   */
  constructor(networkRecord) {
    super(networkRecord.requestId);
    /** @private */
    this._record = networkRecord;
  }

  get type() {
    return BaseNode.TYPES.NETWORK;
  }

  /**
   * @return {number}
   */
  get startTime() {
    return this._record.startTime * 1000 * 1000;
  }

  /**
   * @return {number}
   */
  get endTime() {
    return this._record.endTime * 1000 * 1000;
  }

  /**
   * @return {LH.Artifacts.NetworkRequest}
   */
  get record() {
    return this._record;
  }

  /**
   * @return {?string}
   */
  get initiatorType() {
    return this._record.initiator && this._record.initiator.type;
  }

  /**
   * @return {boolean}
   */
  get fromDiskCache() {
    return !!this._record.fromDiskCache;
  }

  /**
   * @return {boolean}
   */
  get isNonNetworkProtocol() {
    return NetworkRequest.isNonNetworkRequest(this._record);
  }


  /**
   * Returns whether this network record can be downloaded without a TCP connection.
   * During simulation we treat data coming in over a network connection separately from on-device data.
   * @return {boolean}
   */
  get isConnectionless() {
    return this.fromDiskCache || this.isNonNetworkProtocol;
  }

  /**
   * @return {boolean}
   */
  hasRenderBlockingPriority() {
    const priority = this._record.priority;
    const isScript = this._record.resourceType === NetworkRequest.TYPES.Script;
    const isDocument = this._record.resourceType === NetworkRequest.TYPES.Document;
    const isBlockingScript = priority === 'High' && isScript;
    const isBlockingHtmlImport = priority === 'High' && isDocument;
    return priority === 'VeryHigh' || isBlockingScript || isBlockingHtmlImport;
  }

  /**
   * @return {NetworkNode}
   */
  cloneWithoutRelationships() {
    const node = new NetworkNode(this._record);
    node.setIsMainDocument(this._isMainDocument);
    return node;
  }
}

module.exports = NetworkNode;

},{"../network-request.js":109,"./base-node.js":86}],89:[function(require,module,exports){
/**
 * @license Copyright 2018 The Lighthouse Authors. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.
 */
'use strict';

const NetworkAnalyzer = require('./network-analyzer.js');
const TcpConnection = require('./tcp-connection.js');

const DEFAULT_SERVER_RESPONSE_TIME = 30;
const TLS_SCHEMES = ['https', 'wss'];

// Each origin can have 6 simulatenous connections open
// https://cs.chromium.org/chromium/src/net/socket/client_socket_pool_manager.cc?type=cs&q="int+g_max_sockets_per_group"
const CONNECTIONS_PER_ORIGIN = 6;

module.exports = class ConnectionPool {
  /**
   * @param {LH.Artifacts.NetworkRequest[]} records
   * @param {Required<LH.Gatherer.Simulation.Options>} options
   */
  constructor(records, options) {
    this._options = options;

    this._records = records;
    /** @type {Map<string, TcpConnection[]>} */
    this._connectionsByOrigin = new Map();
    /** @type {Map<LH.Artifacts.NetworkRequest, TcpConnection>} */
    this._connectionsByRecord = new Map();
    this._connectionsInUse = new Set();
    this._connectionReusedByRequestId = NetworkAnalyzer.estimateIfConnectionWasReused(records, {
      forceCoarseEstimates: true,
    });

    this._initializeConnections();
  }

  /**
   * @return {TcpConnection[]}
   */
  connectionsInUse() {
    return Array.from(this._connectionsInUse);
  }

  _initializeConnections() {
    const connectionReused = this._connectionReusedByRequestId;
    const additionalRttByOrigin = this._options.additionalRttByOrigin;
    const serverResponseTimeByOrigin = this._options.serverResponseTimeByOrigin;

    const recordsByOrigin = NetworkAnalyzer.groupByOrigin(this._records);
    for (const [origin, records] of recordsByOrigin.entries()) {
      const connections = [];
      const additionalRtt = additionalRttByOrigin.get(origin) || 0;
      const responseTime = serverResponseTimeByOrigin.get(origin) || DEFAULT_SERVER_RESPONSE_TIME;

      for (const record of records) {
        if (connectionReused.get(record.requestId)) continue;

        const isTLS = TLS_SCHEMES.includes(record.parsedURL.scheme);
        const isH2 = record.protocol === 'h2';
        const connection = new TcpConnection(
          this._options.rtt + additionalRtt,
          this._options.throughput,
          responseTime,
          isTLS,
          isH2
        );

        connections.push(connection);
      }

      if (!connections.length) {
        throw new Error(`Could not find a connection for origin: ${origin}`);
      }

      // Make sure each origin has minimum number of connections available for max throughput.
      // But only if it's not over H2 which maximizes throughput already.
      const minConnections = connections[0].isH2() ? 1 : CONNECTIONS_PER_ORIGIN;
      while (connections.length < minConnections) connections.push(connections[0].clone());

      this._connectionsByOrigin.set(origin, connections);
    }
  }

  /**
   * @param {Array<TcpConnection>} connections
   * @param {{ignoreConnectionReused?: boolean, observedConnectionWasReused: boolean}} options
   */
  _findAvailableConnectionWithLargestCongestionWindow(connections, options) {
    const {ignoreConnectionReused, observedConnectionWasReused} = options;

    /** @type {TcpConnection|null} */
    let maxConnection = null;
    for (let i = 0; i < connections.length; i++) {
      const connection = connections[i];

      // Normally, we want to make sure the connection warmth matches the state of the record
      // we're acquiring for. Do this check first since it's the common case and cheaper than our
      // "in use" check below.
      // Use the _warmed property instead of the getter because this is a surprisingly hot code path.
      if (!ignoreConnectionReused && connection._warmed !== observedConnectionWasReused) {
        continue;
      }

      // Connections that are in use are never available.
      if (this._connectionsInUse.has(connection)) {
        continue;
      }

      // This connection is a match and is available! Update our max if it has a larger congestionWindow
      const currentMax = (maxConnection && maxConnection.congestionWindow) || -Infinity;
      if (connection.congestionWindow > currentMax) maxConnection = connection;
    }

    return maxConnection;
  }

  /**
   * This method finds an available connection to the origin specified by the network record or null
   * if no connection was available. If returned, connection will not be available for other network
   * records until release is called.
   *
   * If ignoreConnectionReused is true, acquire will consider all connections not in use as available.
   * Otherwise, only connections that have matching "warmth" are considered available.
   *
   * @param {LH.Artifacts.NetworkRequest} record
   * @param {{ignoreConnectionReused?: boolean}} options
   * @return {?TcpConnection}
   */
  acquire(record, options = {}) {
    if (this._connectionsByRecord.has(record)) throw new Error('Record already has a connection');

    const origin = record.parsedURL.securityOrigin;
    const observedConnectionWasReused = !!this._connectionReusedByRequestId.get(record.requestId);
    const connections = this._connectionsByOrigin.get(origin) || [];
    const connectionToUse = this._findAvailableConnectionWithLargestCongestionWindow(connections, {
      ignoreConnectionReused: options.ignoreConnectionReused,
      observedConnectionWasReused,
    });

    if (!connectionToUse) return null;

    this._connectionsInUse.add(connectionToUse);
    this._connectionsByRecord.set(record, connectionToUse);
    return connectionToUse;
  }

  /**
   * Return the connection currently being used to fetch a record. If no connection
   * currently being used for this record, an error will be thrown.
   *
   * @param {LH.Artifacts.NetworkRequest} record
   * @return {TcpConnection}
   */
  acquireActiveConnectionFromRecord(record) {
    const activeConnection = this._connectionsByRecord.get(record);
    if (!activeConnection) throw new Error('Could not find an active connection for record');

    return activeConnection;
  }

  /**
   * @param {LH.Artifacts.NetworkRequest} record
   */
  release(record) {
    const connection = this._connectionsByRecord.get(record);
    this._connectionsByRecord.delete(record);
    this._connectionsInUse.delete(connection);
  }
};

},{"./network-analyzer.js":91,"./tcp-connection.js":94}],90:[function(require,module,exports){
/**
 * @license Copyright 2018 The Lighthouse Authors. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.
 */
'use strict';

// A DNS lookup will usually take ~1-2 roundtrips of connection latency plus the extra DNS routing time.
// Example: https://www.webpagetest.org/result/180703_3A_e33ec79747c002ed4d7bcbfc81462203/1/details/#waterfall_view_step1
// Example: https://www.webpagetest.org/result/180707_1M_89673eb633b5d98386de95dfcf9b33d5/1/details/#waterfall_view_step1
// DNS is highly variable though, many times it's a little more than 1, but can easily be 4-5x RTT.
// We'll use 2 since it seems to give the most accurate results on average, but this can be tweaked.
const DNS_RESOLUTION_RTT_MULTIPLIER = 2;

class DNSCache {
  /**
   * @param {{rtt: number}} options
   */
  constructor({rtt}) {
    this._rtt = rtt;

    /** @type {Map<string, {resolvedAt: number}>} */
    this._resolvedDomainNames = new Map();
  }

  /**
   * @param {LH.Artifacts.NetworkRequest} request
   * @param {{requestedAt: number, shouldUpdateCache: boolean}=} options
   * @return {number}
   */
  getTimeUntilResolution(request, options) {
    const {requestedAt = 0, shouldUpdateCache = false} = options || {};

    const domain = request.parsedURL.host;
    const cacheEntry = this._resolvedDomainNames.get(domain);
    let timeUntilResolved = this._rtt * DNSCache.RTT_MULTIPLIER;
    if (cacheEntry) {
      const timeUntilCachedIsResolved = Math.max(cacheEntry.resolvedAt - requestedAt, 0);
      timeUntilResolved = Math.min(timeUntilCachedIsResolved, timeUntilResolved);
    }

    const resolvedAt = requestedAt + timeUntilResolved;
    if (shouldUpdateCache) this._updateCacheResolvedAtIfNeeded(request, resolvedAt);

    return timeUntilResolved;
  }

  /**
   * @param {LH.Artifacts.NetworkRequest} request
   * @param {number} resolvedAt
   */
  _updateCacheResolvedAtIfNeeded(request, resolvedAt) {
    const domain = request.parsedURL.host;
    const cacheEntry = this._resolvedDomainNames.get(domain) || {resolvedAt};
    cacheEntry.resolvedAt = Math.min(cacheEntry.resolvedAt, resolvedAt);
    this._resolvedDomainNames.set(domain, cacheEntry);
  }

  /**
   * Forcefully sets the DNS resolution time for a record.
   * Useful for testing and alternate execution simulations.
   *
   * @param {string} domain
   * @param {number} resolvedAt
   */
  setResolvedAt(domain, resolvedAt) {
    this._resolvedDomainNames.set(domain, {resolvedAt});
  }
}

DNSCache.RTT_MULTIPLIER = DNS_RESOLUTION_RTT_MULTIPLIER;

module.exports = DNSCache;

},{}],91:[function(require,module,exports){
/**
 * @license Copyright 2018 The Lighthouse Authors. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.
 */
'use strict';

const INITIAL_CWD = 14 * 1024;
const NetworkRequest = require('../../network-request.js');
const URL = require('../../url-shim.js');

// Assume that 40% of TTFB was server response time by default for static assets
const DEFAULT_SERVER_RESPONSE_PERCENTAGE = 0.4;

/**
 * For certain resource types, server response time takes up a greater percentage of TTFB (dynamic
 * assets like HTML documents, XHR/API calls, etc)
 * @type {Partial<Record<LH.Crdp.Network.ResourceType, number>>}
 */
const SERVER_RESPONSE_PERCENTAGE_OF_TTFB = {
  Document: 0.9,
  XHR: 0.9,
  Fetch: 0.9,
};

class NetworkAnalyzer {
  /**
   * @return {string}
   */
  static get SUMMARY() {
    return '__SUMMARY__';
  }

  /**
   * @param {LH.Artifacts.NetworkRequest[]} records
   * @return {Map<string, LH.Artifacts.NetworkRequest[]>}
   */
  static groupByOrigin(records) {
    const grouped = new Map();
    records.forEach(item => {
      const key = item.parsedURL.securityOrigin;
      const group = grouped.get(key) || [];
      group.push(item);
      grouped.set(key, group);
    });
    return grouped;
  }

  /**
   * @param {number[]} values
   * @return {NetworkAnalyzer.Summary}
   */
  static getSummary(values) {
    values.sort((a, b) => a - b);

    return {
      min: values[0],
      max: values[values.length - 1],
      avg: values.reduce((a, b) => a + b, 0) / values.length,
      median: values[Math.floor((values.length - 1) / 2)],
    };
  }

  /**
   * @param {Map<string,number[]>} values
   * @return {Map<string, NetworkAnalyzer.Summary>}
   */
  static summarize(values) {
    const summaryByKey = new Map();
    const allEstimates = [];
    for (const [key, estimates] of values) {
      summaryByKey.set(key, NetworkAnalyzer.getSummary(estimates));
      allEstimates.push(...estimates);
    }

    summaryByKey.set(NetworkAnalyzer.SUMMARY, NetworkAnalyzer.getSummary(allEstimates));
    return summaryByKey;
  }

  /** @typedef {{record: LH.Artifacts.NetworkRequest, timing: LH.Crdp.Network.ResourceTiming, connectionReused?: boolean}} RequestInfo */

  /**
   * @param {LH.Artifacts.NetworkRequest[]} records
   * @param {(e: RequestInfo) => number | number[] | undefined} iteratee
   * @return {Map<string, number[]>}
   */
  static _estimateValueByOrigin(records, iteratee) {
    const connectionWasReused = NetworkAnalyzer.estimateIfConnectionWasReused(records);
    const groupedByOrigin = NetworkAnalyzer.groupByOrigin(records);

    const estimates = new Map();
    for (const [origin, originRecords] of groupedByOrigin.entries()) {
      /** @type {number[]} */
      let originEstimates = [];

      for (const record of originRecords) {
        const timing = record.timing;
        if (!timing) continue;

        const value = iteratee({
          record,
          timing,
          connectionReused: connectionWasReused.get(record.requestId),
        });
        if (typeof value !== 'undefined') {
          originEstimates = originEstimates.concat(value);
        }
      }

      if (!originEstimates.length) continue;
      estimates.set(origin, originEstimates);
    }

    return estimates;
  }

  /**
   * Estimates the observed RTT to each origin based on how long the TCP handshake took.
   * This is the most accurate and preferred method of measurement when the data is available.
   *
   * @param {LH.Artifacts.NetworkRequest[]} records
   * @return {Map<string, number[]>}
   */
  static _estimateRTTByOriginViaTCPTiming(records) {
    return NetworkAnalyzer._estimateValueByOrigin(records, ({timing, connectionReused}) => {
      if (connectionReused) return;

      // If the request was SSL we get two estimates, one for the SSL negotiation and another for the
      // regular handshake. SSL can also be more than 1 RT but assume False Start was used.
      if (timing.sslStart > 0 && timing.sslEnd > 0) {
        return [timing.connectEnd - timing.sslStart, timing.sslStart - timing.connectStart];
      } else if (timing.connectStart > 0 && timing.connectEnd > 0) {
        return timing.connectEnd - timing.connectStart;
      }
    });
  }

  /**
   * Estimates the observed RTT to each origin based on how long a download took on a fresh connection.
   * NOTE: this will tend to overestimate the actual RTT quite significantly as the download can be
   * slow for other reasons as well such as bandwidth constraints.
   *
   * @param {LH.Artifacts.NetworkRequest[]} records
   * @return {Map<string, number[]>}
   */
  static _estimateRTTByOriginViaDownloadTiming(records) {
    return NetworkAnalyzer._estimateValueByOrigin(records, ({record, timing, connectionReused}) => {
      if (connectionReused) return;
      // Only look at downloads that went past the initial congestion window
      if (record.transferSize <= INITIAL_CWD) return;
      if (!Number.isFinite(timing.receiveHeadersEnd) || timing.receiveHeadersEnd < 0) return;

      // Compute the amount of time downloading everything after the first congestion window took
      const totalTime = (record.endTime - record.startTime) * 1000;
      const downloadTimeAfterFirstByte = totalTime - timing.receiveHeadersEnd;
      const numberOfRoundTrips = Math.log2(record.transferSize / INITIAL_CWD);

      // Ignore requests that required a high number of round trips since bandwidth starts to play
      // a larger role than latency
      if (numberOfRoundTrips > 5) return;
      return downloadTimeAfterFirstByte / numberOfRoundTrips;
    });
  }

  /**
   * Estimates the observed RTT to each origin based on how long it took until Chrome could
   * start sending the actual request when a new connection was required.
   * NOTE: this will tend to overestimate the actual RTT as the request can be delayed for other
   * reasons as well such as more SSL handshakes if TLS False Start is not enabled.
   *
   * @param {LH.Artifacts.NetworkRequest[]} records
   * @return {Map<string, number[]>}
   */
  static _estimateRTTByOriginViaSendStartTiming(records) {
    return NetworkAnalyzer._estimateValueByOrigin(records, ({record, timing, connectionReused}) => {
      if (connectionReused) return;
      if (!Number.isFinite(timing.sendStart) || timing.sendStart < 0) return;

      // Assume everything before sendStart was just DNS + (SSL)? + TCP handshake
      // 1 RT for DNS, 1 RT (maybe) for SSL, 1 RT for TCP
      let roundTrips = 2;
      if (record.parsedURL.scheme === 'https') roundTrips += 1;
      return timing.sendStart / roundTrips;
    });
  }

  /**
   * Estimates the observed RTT to each origin based on how long it took until Chrome received the
   * headers of the response (~TTFB).
   * NOTE: this is the most inaccurate way to estimate the RTT, but in some environments it's all
   * we have access to :(
   *
   * @param {LH.Artifacts.NetworkRequest[]} records
   * @return {Map<string, number[]>}
   */
  static _estimateRTTByOriginViaHeadersEndTiming(records) {
    return NetworkAnalyzer._estimateValueByOrigin(records, ({record, timing, connectionReused}) => {
      if (!Number.isFinite(timing.receiveHeadersEnd) || timing.receiveHeadersEnd < 0) return;
      if (!record.resourceType) return;

      const serverResponseTimePercentage = SERVER_RESPONSE_PERCENTAGE_OF_TTFB[record.resourceType]
        || DEFAULT_SERVER_RESPONSE_PERCENTAGE;
      const estimatedServerResponseTime = timing.receiveHeadersEnd * serverResponseTimePercentage;

      // When connection was reused...
      // TTFB = 1 RT for request + server response time
      let roundTrips = 1;

      // When connection was fresh...
      // TTFB = DNS + (SSL)? + TCP handshake + 1 RT for request + server response time
      if (!connectionReused) {
        roundTrips += 1; // DNS
        if (record.parsedURL.scheme === 'https') roundTrips += 1; // SSL
        roundTrips += 1; // TCP handshake
      }

      // subtract out our estimated server response time
      return Math.max((timing.receiveHeadersEnd - estimatedServerResponseTime) / roundTrips, 3);
    });
  }

  /**
   * Given the RTT to each origin, estimates the observed server response times.
   *
   * @param {LH.Artifacts.NetworkRequest[]} records
   * @param {Map<string, number>} rttByOrigin
   * @return {Map<string, number[]>}
   */
  static _estimateResponseTimeByOrigin(records, rttByOrigin) {
    return NetworkAnalyzer._estimateValueByOrigin(records, ({record, timing}) => {
      if (!Number.isFinite(timing.receiveHeadersEnd) || timing.receiveHeadersEnd < 0) return;
      if (!Number.isFinite(timing.sendEnd) || timing.sendEnd < 0) return;

      const ttfb = timing.receiveHeadersEnd - timing.sendEnd;
      const origin = record.parsedURL.securityOrigin;
      const rtt = rttByOrigin.get(origin) || rttByOrigin.get(NetworkAnalyzer.SUMMARY) || 0;
      return Math.max(ttfb - rtt, 0);
    });
  }

  /**
   * @param {LH.Artifacts.NetworkRequest[]} records
   * @return {boolean}
   */
  static canTrustConnectionInformation(records) {
    const connectionIdWasStarted = new Map();
    for (const record of records) {
      const started = connectionIdWasStarted.get(record.connectionId) || !record.connectionReused;
      connectionIdWasStarted.set(record.connectionId, started);
    }

    // We probably can't trust the network information if all the connection IDs were the same
    if (connectionIdWasStarted.size <= 1) return false;
    // Or if there were connections that were always reused (a connection had to have started at some point)
    return Array.from(connectionIdWasStarted.values()).every(started => started);
  }

  /**
   * Returns a map of requestId -> connectionReused, estimating the information if the information
   * available in the records themselves appears untrustworthy.
   *
   * @param {LH.Artifacts.NetworkRequest[]} records
   * @param {{forceCoarseEstimates: boolean}} [options]
   * @return {Map<string, boolean>}
   */
  static estimateIfConnectionWasReused(records, options) {
    const {forceCoarseEstimates = false} = options || {};

    // Check if we can trust the connection information coming from the protocol
    if (!forceCoarseEstimates && NetworkAnalyzer.canTrustConnectionInformation(records)) {
      return new Map(records.map(record => [record.requestId, !!record.connectionReused]));
    }

    // Otherwise we're on our own, a record may not have needed a fresh connection if...
    //   - It was not the first request to the domain
    //   - It was H2
    //   - It was after the first request to the domain ended
    const connectionWasReused = new Map();
    const groupedByOrigin = NetworkAnalyzer.groupByOrigin(records);
    for (const [_, originRecords] of groupedByOrigin.entries()) {
      const earliestReusePossible = originRecords
        .map(record => record.endTime)
        .reduce((a, b) => Math.min(a, b), Infinity);

      for (const record of originRecords) {
        connectionWasReused.set(
          record.requestId,
          record.startTime >= earliestReusePossible || record.protocol === 'h2'
        );
      }

      const firstRecord = originRecords.reduce((a, b) => (a.startTime > b.startTime ? b : a));
      connectionWasReused.set(firstRecord.requestId, false);
    }

    return connectionWasReused;
  }

  /**
   * Estimates the RTT to each origin by examining observed network timing information.
   * Attempts to use the most accurate information first and falls back to coarser estimates when it
   * is unavailable.
   *
   * @param {LH.Artifacts.NetworkRequest[]} records
   * @param {NetworkAnalyzer.RTTEstimateOptions} [options]
   * @return {Map<string, NetworkAnalyzer.Summary>}
   */
  static estimateRTTByOrigin(records, options) {
    const {
      forceCoarseEstimates = false,
      // coarse estimates include lots of extra time and noise
      // multiply by some factor to deflate the estimates a bit.
      coarseEstimateMultiplier = 0.3,
      useDownloadEstimates = true,
      useSendStartEstimates = true,
      useHeadersEndEstimates = true,
    } = options || {};

    let estimatesByOrigin = NetworkAnalyzer._estimateRTTByOriginViaTCPTiming(records);
    if (!estimatesByOrigin.size || forceCoarseEstimates) {
      estimatesByOrigin = new Map();
      const estimatesViaDownload = NetworkAnalyzer._estimateRTTByOriginViaDownloadTiming(records);
      const estimatesViaSendStart = NetworkAnalyzer._estimateRTTByOriginViaSendStartTiming(records);
      const estimatesViaTTFB = NetworkAnalyzer._estimateRTTByOriginViaHeadersEndTiming(records);

      for (const [origin, estimates] of estimatesViaDownload.entries()) {
        if (!useDownloadEstimates) continue;
        estimatesByOrigin.set(origin, estimates);
      }

      for (const [origin, estimates] of estimatesViaSendStart.entries()) {
        if (!useSendStartEstimates) continue;
        const existing = estimatesByOrigin.get(origin) || [];
        estimatesByOrigin.set(origin, existing.concat(estimates));
      }

      for (const [origin, estimates] of estimatesViaTTFB.entries()) {
        if (!useHeadersEndEstimates) continue;
        const existing = estimatesByOrigin.get(origin) || [];
        estimatesByOrigin.set(origin, existing.concat(estimates));
      }

      for (const estimates of estimatesByOrigin.values()) {
        estimates.forEach((x, i) => (estimates[i] = x * coarseEstimateMultiplier));
      }
    }

    if (!estimatesByOrigin.size) throw new Error('No timing information available');
    return NetworkAnalyzer.summarize(estimatesByOrigin);
  }

  /**
   * Estimates the server response time of each origin. RTT times can be passed in or will be
   * estimated automatically if not provided.
   *
   * @param {LH.Artifacts.NetworkRequest[]} records
   * @param {NetworkAnalyzer.RTTEstimateOptions & {rttByOrigin?: Map<string, number>}} [options]
   * @return {Map<string, NetworkAnalyzer.Summary>}
   */
  static estimateServerResponseTimeByOrigin(records, options) {
    let rttByOrigin = (options || {}).rttByOrigin;
    if (!rttByOrigin) {
      /** @type {Map<string, number>} */
      rttByOrigin = new Map();

      const rttSummaryByOrigin = NetworkAnalyzer.estimateRTTByOrigin(records, options);
      for (const [origin, summary] of rttSummaryByOrigin.entries()) {
        rttByOrigin.set(origin, summary.min);
      }
    }

    const estimatesByOrigin = NetworkAnalyzer._estimateResponseTimeByOrigin(records, rttByOrigin);
    return NetworkAnalyzer.summarize(estimatesByOrigin);
  }


  /**
   * Computes the average throughput for the given records in bits/second.
   * Excludes data URI, failed or otherwise incomplete, and cached requests.
   * Returns Infinity if there were no analyzable network records.
   *
   * @param {Array<LH.Artifacts.NetworkRequest>} networkRecords
   * @return {number}
   */
  static estimateThroughput(networkRecords) {
    let totalBytes = 0;

    // We will measure throughput by summing the total bytes downloaded by the total time spent
    // downloading those bytes. We slice up all the network records into start/end boundaries, so
    // it's easier to deal with the gaps in downloading.
    const timeBoundaries = networkRecords.reduce((boundaries, record) => {
      const scheme = record.parsedURL && record.parsedURL.scheme;
      // Requests whose bodies didn't come over the network or didn't completely finish will mess
      // with the computation, just skip over them.
      if (scheme === 'data' || record.failed || !record.finished ||
          record.statusCode > 300 || !record.transferSize) {
        return boundaries;
      }

      // If we've made it this far, all the times we need should be valid (i.e. not undefined/-1).
      totalBytes += record.transferSize;
      boundaries.push({time: record.responseReceivedTime, isStart: true});
      boundaries.push({time: record.endTime, isStart: false});
      return boundaries;
    }, /** @type {Array<{time: number, isStart: boolean}>} */([])).sort((a, b) => a.time - b.time);

    if (!timeBoundaries.length) {
      return Infinity;
    }

    let inflight = 0;
    let currentStart = 0;
    let totalDuration = 0;

    timeBoundaries.forEach(boundary => {
      if (boundary.isStart) {
        if (inflight === 0) {
          // We just ended a quiet period, keep track of when the download period started
          currentStart = boundary.time;
        }
        inflight++;
      } else {
        inflight--;
        if (inflight === 0) {
          // We just entered a quiet period, update our duration with the time we spent downloading
          totalDuration += boundary.time - currentStart;
        }
      }
    });

    return totalBytes * 8 / totalDuration;
  }

  /**
   * @param {Array<LH.Artifacts.NetworkRequest>} records
   * @param {string} [finalURL]
   * @return {LH.Artifacts.NetworkRequest}
   */
  static findMainDocument(records, finalURL) {
    const mainDocument = NetworkAnalyzer.findOptionalMainDocument(records, finalURL);
    if (!mainDocument) throw new Error('Unable to identify the main resource');
    return mainDocument;
  }

  /**
   * @param {Array<LH.Artifacts.NetworkRequest>} records
   * @param {string} [finalURL]
   * @return {LH.Artifacts.NetworkRequest|undefined}
   */
  static findOptionalMainDocument(records, finalURL) {
    // Try to find an exact match with the final URL first if we have one
    if (finalURL) {
      // equalWithExcludedFragments is expensive, so check that the finalUrl starts with the request first
      const mainResource = records.find(request => finalURL.startsWith(request.url) &&
        URL.equalWithExcludedFragments(request.url, finalURL));
      if (mainResource) return mainResource;
      // TODO: beacon !mainResource to Sentry, https://github.com/GoogleChrome/lighthouse/issues/7041
    }

    const documentRequests = records.filter(record => record.resourceType ===
        NetworkRequest.TYPES.Document);
    if (!documentRequests.length) return undefined;
    // The main document is the earliest document request, using position in networkRecords array to break ties.
    return documentRequests.reduce((min, r) => (r.startTime < min.startTime ? r : min));
  }

  /**
   * Resolves redirect chain given a main document.
   * See: {@link NetworkAnalyzer.findMainDocument}) for how to retrieve main document.
   *
   * @param {LH.Artifacts.NetworkRequest} request
   * @return {LH.Artifacts.NetworkRequest}
   */
  static resolveRedirects(request) {
    while (request.redirectDestination) request = request.redirectDestination;
    return request;
  }
}

module.exports = NetworkAnalyzer;

/**
 * @typedef NetworkAnalyzer.Summary
 * @property {number} min
 * @property {number} max
 * @property {number} avg
 * @property {number} median
 */

/**
 * @typedef NetworkAnalyzer.RTTEstimateOptions
 * @property {boolean} [forceCoarseEstimates] TCP connection handshake information will be used when available, but in some circumstances this data can be unreliable. This flag exposes an option to ignore the handshake data and use the coarse download/TTFB timing data.
 * @property {number} [coarseEstimateMultiplier] Coarse estimates include lots of extra time and noise multiply by some factor to deflate the estimates a bit.
 * @property {boolean} [useDownloadEstimates] Useful for testing to isolate the different methods of estimation.
 * @property {boolean} [useSendStartEstimates] Useful for testing to isolate the different methods of estimation.
 * @property {boolean} [useHeadersEndEstimates] Useful for testing to isolate the different methods of estimation.
 */

},{"../../network-request.js":109,"../../url-shim.js":"url"}],92:[function(require,module,exports){
/**
 * @license Copyright 2020 The Lighthouse Authors. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.
 */
'use strict';

const BaseNode = require('../base-node.js');

/**
 * @fileoverview
 *
 * This class encapsulates the type-related validation logic for moving timing information for nodes
 * through the different simulation phases. Methods here ensure that the invariants of simulation hold
 * as nodes are queued, partially simulated, and completed.
 */


/** @typedef {BaseNode.Node} Node */
/** @typedef {import('../network-node')} NetworkNode */
/** @typedef {import('../cpu-node')} CpuNode */

/**
 * @typedef NodeTimingComplete
 * @property {number} startTime
 * @property {number} endTime
 * @property {number} queuedTime Helpful for debugging.
 * @property {number} estimatedTimeElapsed
 * @property {number} timeElapsed
 * @property {number} timeElapsedOvershoot
 * @property {number} bytesDownloaded
 */

/** @typedef {Pick<NodeTimingComplete, 'queuedTime'>} NodeTimingQueued */

/** @typedef {NodeTimingQueued & Pick<NodeTimingComplete, 'startTime'|'timeElapsed'>} CpuNodeTimingStarted */
/** @typedef {CpuNodeTimingStarted & Pick<NodeTimingComplete, 'timeElapsedOvershoot'|'bytesDownloaded'>} NetworkNodeTimingStarted */

/** @typedef {CpuNodeTimingStarted & Pick<NodeTimingComplete, 'estimatedTimeElapsed'>} CpuNodeTimingInProgress */
/** @typedef {NetworkNodeTimingStarted & Pick<NodeTimingComplete, 'estimatedTimeElapsed'>} NetworkNodeTimingInProgress */

/** @typedef {CpuNodeTimingInProgress & Pick<NodeTimingComplete, 'endTime'>} CpuNodeTimingComplete */
/** @typedef {NetworkNodeTimingInProgress & Pick<NodeTimingComplete, 'endTime'>} NetworkNodeTimingComplete */

/** @typedef {NodeTimingQueued | CpuNodeTimingStarted | NetworkNodeTimingStarted | CpuNodeTimingInProgress | NetworkNodeTimingInProgress | CpuNodeTimingComplete | NetworkNodeTimingComplete} NodeTimingData */

class SimulatorTimingMap {
  constructor() {
    /** @type {Map<Node, NodeTimingData>} */
    this._nodeTimings = new Map();
  }

  /** @return {Array<Node>} */
  getNodes() {
    return Array.from(this._nodeTimings.keys());
  }

  /**
   * @param {Node} node
   * @param {{queuedTime: number}} values
   */
  setReadyToStart(node, values) {
    this._nodeTimings.set(node, values);
  }

  /**
   * @param {Node} node
   * @param {{startTime: number}} values
   */
  setInProgress(node, values) {
    const nodeTiming = {
      ...this.getQueued(node),
      startTime: values.startTime,
      timeElapsed: 0,
    };

    this._nodeTimings.set(
      node,
      node.type === BaseNode.TYPES.NETWORK
        ? {...nodeTiming, timeElapsedOvershoot: 0, bytesDownloaded: 0}
        : nodeTiming
    );
  }

  /**
   * @param {Node} node
   * @param {{endTime: number}} values
   */
  setCompleted(node, values) {
    const nodeTiming = {
      ...this.getInProgress(node),
      endTime: values.endTime,
    };

    this._nodeTimings.set(node, nodeTiming);
  }

  /**
   * @param {CpuNode} node
   * @param {{timeElapsed: number}} values
   */
  setCpu(node, values) {
    const nodeTiming = {
      ...this.getCpuStarted(node),
      timeElapsed: values.timeElapsed,
    };

    this._nodeTimings.set(node, nodeTiming);
  }

  /**
   * @param {CpuNode} node
   * @param {{estimatedTimeElapsed: number}} values
   */
  setCpuEstimated(node, values) {
    const nodeTiming = {
      ...this.getCpuStarted(node),
      estimatedTimeElapsed: values.estimatedTimeElapsed,
    };

    this._nodeTimings.set(node, nodeTiming);
  }

  /**
   * @param {NetworkNode} node
   * @param {{timeElapsed: number, timeElapsedOvershoot: number, bytesDownloaded: number}} values
   */
  setNetwork(node, values) {
    const nodeTiming = {
      ...this.getNetworkStarted(node),
      timeElapsed: values.timeElapsed,
      timeElapsedOvershoot: values.timeElapsedOvershoot,
      bytesDownloaded: values.bytesDownloaded,
    };

    this._nodeTimings.set(node, nodeTiming);
  }

  /**
   * @param {NetworkNode} node
   * @param {{estimatedTimeElapsed: number}} values
   */
  setNetworkEstimated(node, values) {
    const nodeTiming = {
      ...this.getNetworkStarted(node),
      estimatedTimeElapsed: values.estimatedTimeElapsed,
    };

    this._nodeTimings.set(node, nodeTiming);
  }

  /**
   * @param {Node} node
   * @return {NodeTimingQueued}
   */
  getQueued(node) {
    const timing = this._nodeTimings.get(node);
    if (!timing) throw new Error(`Node ${node.id} not yet queued`);
    return timing;
  }

  /**
   * @param {CpuNode} node
   * @return {CpuNodeTimingStarted}
   */
  getCpuStarted(node) {
    const timing = this._nodeTimings.get(node);
    if (!timing) throw new Error(`Node ${node.id} not yet queued`);
    if (!('startTime' in timing)) throw new Error(`Node ${node.id} not yet started`);
    if ('bytesDownloaded' in timing) throw new Error(`Node ${node.id} timing not valid`);
    return timing;
  }

  /**
   * @param {NetworkNode} node
   * @return {NetworkNodeTimingStarted}
   */
  getNetworkStarted(node) {
    const timing = this._nodeTimings.get(node);
    if (!timing) throw new Error(`Node ${node.id} not yet queued`);
    if (!('startTime' in timing)) throw new Error(`Node ${node.id} not yet started`);
    if (!('bytesDownloaded' in timing)) throw new Error(`Node ${node.id} timing not valid`);
    return timing;
  }

  /**
   * @param {Node} node
   * @return {CpuNodeTimingInProgress | NetworkNodeTimingInProgress}
   */
  getInProgress(node) {
    const timing = this._nodeTimings.get(node);
    if (!timing) throw new Error(`Node ${node.id} not yet queued`);
    if (!('startTime' in timing)) throw new Error(`Node ${node.id} not yet started`);
    if (!('estimatedTimeElapsed' in timing)) throw new Error(`Node ${node.id} not yet in progress`);
    return timing;
  }

  /**
   * @param {Node} node
   * @return {CpuNodeTimingComplete | NetworkNodeTimingComplete}
   */
  getCompleted(node) {
    const timing = this._nodeTimings.get(node);
    if (!timing) throw new Error(`Node ${node.id} not yet queued`);
    if (!('startTime' in timing)) throw new Error(`Node ${node.id} not yet started`);
    if (!('estimatedTimeElapsed' in timing)) throw new Error(`Node ${node.id} not yet in progress`);
    if (!('endTime' in timing)) throw new Error(`Node ${node.id} not yet completed`);
    return timing;
  }
}

module.exports = SimulatorTimingMap;

},{"../base-node.js":86}],93:[function(require,module,exports){
/**
 * @license Copyright 2017 The Lighthouse Authors. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.
 */
'use strict';

const BaseNode = require('../base-node.js');
const TcpConnection = require('./tcp-connection.js');
const ConnectionPool = require('./connection-pool.js');
const DNSCache = require('./dns-cache.js');
const mobileSlow4G = require('../../../config/constants.js').throttling.mobileSlow4G;
const SimulatorTimingMap = require('./simulator-timing-map.js');

/** @typedef {BaseNode.Node} Node */
/** @typedef {import('../network-node')} NetworkNode */
/** @typedef {import('../cpu-node')} CpuNode */

// see https://cs.chromium.org/search/?q=kDefaultMaxNumDelayableRequestsPerClient&sq=package:chromium&type=cs
const DEFAULT_MAXIMUM_CONCURRENT_REQUESTS = 10;
// layout tasks tend to be less CPU-bound and do not experience the same increase in duration
const DEFAULT_LAYOUT_TASK_MULTIPLIER = 0.5;
// if a task takes more than 10 seconds it's usually a sign it isn't actually CPU bound and we're overestimating
const DEFAULT_MAXIMUM_CPU_TASK_DURATION = 10000;

const NodeState = {
  NotReadyToStart: 0,
  ReadyToStart: 1,
  InProgress: 2,
  Complete: 3,
};

/** @type {Record<NetworkNode['record']['priority'], number>} */
const PriorityStartTimePenalty = {
  VeryHigh: 0,
  High: 0.25,
  Medium: 0.5,
  Low: 1,
  VeryLow: 2,
};

/** @type {Map<string, LH.Gatherer.Simulation.Result['nodeTimings']>} */
const ALL_SIMULATION_NODE_TIMINGS = new Map();

class Simulator {
  /**
   * @param {LH.Gatherer.Simulation.Options} [options]
   */
  constructor(options) {
    /** @type {Required<LH.Gatherer.Simulation.Options>} */
    this._options = Object.assign(
      {
        rtt: mobileSlow4G.rttMs,
        throughput: mobileSlow4G.throughputKbps * 1024,
        maximumConcurrentRequests: DEFAULT_MAXIMUM_CONCURRENT_REQUESTS,
        cpuSlowdownMultiplier: mobileSlow4G.cpuSlowdownMultiplier,
        layoutTaskMultiplier: DEFAULT_LAYOUT_TASK_MULTIPLIER,
        additionalRttByOrigin: new Map(),
        serverResponseTimeByOrigin: new Map(),
      },
      options
    );

    this._rtt = this._options.rtt;
    this._throughput = this._options.throughput;
    this._maximumConcurrentRequests = Math.max(Math.min(
      TcpConnection.maximumSaturatedConnections(this._rtt, this._throughput),
      this._options.maximumConcurrentRequests
    ), 1);
    this._cpuSlowdownMultiplier = this._options.cpuSlowdownMultiplier;
    this._layoutTaskMultiplier = this._cpuSlowdownMultiplier * this._options.layoutTaskMultiplier;
    /** @type {Array<Node>} */
    this._cachedNodeListByStartPosition = [];

    // Properties reset on every `.simulate` call but duplicated here for type checking
    this._flexibleOrdering = false;
    this._nodeTimings = new SimulatorTimingMap();
    /** @type {Map<string, number>} */
    this._numberInProgressByType = new Map();
    /** @type {Record<number, Set<Node>>} */
    this._nodes = {};
    this._dns = new DNSCache({rtt: this._rtt});
    /** @type {ConnectionPool} */
    // @ts-expect-error
    this._connectionPool = null;

    if (!Number.isFinite(this._rtt)) throw new Error(`Invalid rtt ${this._rtt}`);
    if (!Number.isFinite(this._throughput)) throw new Error(`Invalid rtt ${this._throughput}`);
  }

  /** @return {number} */
  get rtt() {
    return this._rtt;
  }

  /**
   * @param {Node} graph
   */
  _initializeConnectionPool(graph) {
    /** @type {LH.Artifacts.NetworkRequest[]} */
    const records = [];
    graph.getRootNode().traverse(node => {
      if (node.type === BaseNode.TYPES.NETWORK) {
        records.push(node.record);
      }
    });

    this._connectionPool = new ConnectionPool(records, this._options);
  }

  /**
   * Initializes the various state data structures such _nodeTimings and the _node Sets by state.
   */
  _initializeAuxiliaryData() {
    this._nodeTimings = new SimulatorTimingMap();
    this._numberInProgressByType = new Map();

    this._nodes = {};
    this._cachedNodeListByStartPosition = [];
    // NOTE: We don't actually need *all* of these sets, but the clarity that each node progresses
    // through the system is quite nice.
    for (const state of Object.values(NodeState)) {
      this._nodes[state] = new Set();
    }
  }

  /**
   * @param {string} type
   * @return {number}
   */
  _numberInProgress(type) {
    return this._numberInProgressByType.get(type) || 0;
  }

  /**
   * @param {Node} node
   * @param {number} queuedTime
   */
  _markNodeAsReadyToStart(node, queuedTime) {
    const nodeStartPosition = Simulator._computeNodeStartPosition(node);
    const firstNodeIndexWithGreaterStartPosition = this._cachedNodeListByStartPosition
      .findIndex(candidate => Simulator._computeNodeStartPosition(candidate) > nodeStartPosition);
    const insertionIndex = firstNodeIndexWithGreaterStartPosition === -1 ?
      this._cachedNodeListByStartPosition.length : firstNodeIndexWithGreaterStartPosition;
    this._cachedNodeListByStartPosition.splice(insertionIndex, 0, node);

    this._nodes[NodeState.ReadyToStart].add(node);
    this._nodes[NodeState.NotReadyToStart].delete(node);
    this._nodeTimings.setReadyToStart(node, {queuedTime});
  }

  /**
   * @param {Node} node
   * @param {number} startTime
   */
  _markNodeAsInProgress(node, startTime) {
    const indexOfNodeToStart = this._cachedNodeListByStartPosition.indexOf(node);
    this._cachedNodeListByStartPosition.splice(indexOfNodeToStart, 1);

    this._nodes[NodeState.InProgress].add(node);
    this._nodes[NodeState.ReadyToStart].delete(node);
    this._numberInProgressByType.set(node.type, this._numberInProgress(node.type) + 1);
    this._nodeTimings.setInProgress(node, {startTime});
  }

  /**
   * @param {Node} node
   * @param {number} endTime
   */
  _markNodeAsComplete(node, endTime) {
    this._nodes[NodeState.Complete].add(node);
    this._nodes[NodeState.InProgress].delete(node);
    this._numberInProgressByType.set(node.type, this._numberInProgress(node.type) - 1);
    this._nodeTimings.setCompleted(node, {endTime});

    // Try to add all its dependents to the queue
    for (const dependent of node.getDependents()) {
      // Skip dependent node if one of its dependencies hasn't finished yet
      const dependencies = dependent.getDependencies();
      if (dependencies.some(dep => !this._nodes[NodeState.Complete].has(dep))) continue;

      // Otherwise add it to the queue
      this._markNodeAsReadyToStart(dependent, endTime);
    }
  }

  /**
   * @param {LH.Artifacts.NetworkRequest} record
   * @return {?TcpConnection}
   */
  _acquireConnection(record) {
    return this._connectionPool.acquire(record, {
      ignoreConnectionReused: this._flexibleOrdering,
    });
  }

  /**
   * @return {Node[]}
   */
  _getNodesSortedByStartPosition() {
    // Make a copy so we don't skip nodes due to concurrent modification
    return Array.from(this._cachedNodeListByStartPosition);
  }

  /**
   * @param {Node} node
   * @param {number} totalElapsedTime
   */
  _startNodeIfPossible(node, totalElapsedTime) {
    if (node.type === BaseNode.TYPES.CPU) {
      // Start a CPU task if there's no other CPU task in process
      if (this._numberInProgress(node.type) === 0) {
        this._markNodeAsInProgress(node, totalElapsedTime);
      }

      return;
    }

    if (node.type !== BaseNode.TYPES.NETWORK) throw new Error('Unsupported');

    // If a network request is connectionless, we can always start it, so skip the connection checks
    if (!node.isConnectionless) {
      // Start a network request if we're not at max requests and a connection is available
      const numberOfActiveRequests = this._numberInProgress(node.type);
      if (numberOfActiveRequests >= this._maximumConcurrentRequests) return;
      const connection = this._acquireConnection(node.record);
      if (!connection) return;
    }

    this._markNodeAsInProgress(node, totalElapsedTime);
  }

  /**
   * Updates each connection in use with the available throughput based on the number of network requests
   * currently in flight.
   */
  _updateNetworkCapacity() {
    for (const connection of this._connectionPool.connectionsInUse()) {
      connection.setThroughput(this._throughput / this._nodes[NodeState.InProgress].size);
    }
  }

  /**
   * Estimates the number of milliseconds remaining given current condidtions before the node is complete.
   * @param {Node} node
   * @return {number}
   */
  _estimateTimeRemaining(node) {
    if (node.type === BaseNode.TYPES.CPU) {
      return this._estimateCPUTimeRemaining(node);
    } else if (node.type === BaseNode.TYPES.NETWORK) {
      return this._estimateNetworkTimeRemaining(node);
    } else {
      throw new Error('Unsupported');
    }
  }

  /**
   * @param {CpuNode} cpuNode
   * @return {number}
   */
  _estimateCPUTimeRemaining(cpuNode) {
    const timingData = this._nodeTimings.getCpuStarted(cpuNode);
    const multiplier = cpuNode.didPerformLayout()
      ? this._layoutTaskMultiplier
      : this._cpuSlowdownMultiplier;
    const totalDuration = Math.min(
      Math.round(cpuNode.event.dur / 1000 * multiplier),
      DEFAULT_MAXIMUM_CPU_TASK_DURATION
    );
    const estimatedTimeElapsed = totalDuration - timingData.timeElapsed;
    this._nodeTimings.setCpuEstimated(cpuNode, {estimatedTimeElapsed});
    return estimatedTimeElapsed;
  }

  /**
   * @param {NetworkNode} networkNode
   * @return {number}
   */
  _estimateNetworkTimeRemaining(networkNode) {
    const record = networkNode.record;
    const timingData = this._nodeTimings.getNetworkStarted(networkNode);

    let timeElapsed = 0;
    if (networkNode.fromDiskCache) {
      // Rough access time for seeking to location on disk and reading sequentially.
      // 8ms per seek + 20ms/MB
      // @see http://norvig.com/21-days.html#answers
      const sizeInMb = (record.resourceSize || 0) / 1024 / 1024;
      timeElapsed = 8 + 20 * sizeInMb - timingData.timeElapsed;
    } else if (networkNode.isNonNetworkProtocol) {
      // Estimates for the overhead of a data URL in Chromium and the decoding time for base64-encoded data.
      // 2ms per request + 10ms/MB
      // @see traces on https://dopiaza.org/tools/datauri/examples/index.php
      const sizeInMb = (record.resourceSize || 0) / 1024 / 1024;
      timeElapsed = 2 + 10 * sizeInMb - timingData.timeElapsed;
    } else {
      const connection = this._connectionPool.acquireActiveConnectionFromRecord(record);
      const dnsResolutionTime = this._dns.getTimeUntilResolution(record, {
        requestedAt: timingData.startTime,
        shouldUpdateCache: true,
      });
      const timeAlreadyElapsed = timingData.timeElapsed;
      const calculation = connection.simulateDownloadUntil(
        record.transferSize - timingData.bytesDownloaded,
        {timeAlreadyElapsed, dnsResolutionTime, maximumTimeToElapse: Infinity}
      );

      timeElapsed = calculation.timeElapsed;
    }

    const estimatedTimeElapsed = timeElapsed + timingData.timeElapsedOvershoot;
    this._nodeTimings.setNetworkEstimated(networkNode, {estimatedTimeElapsed});
    return estimatedTimeElapsed;
  }

  /**
   * Computes and returns the minimum estimated completion time of the nodes currently in progress.
   * @return {number}
   */
  _findNextNodeCompletionTime() {
    let minimumTime = Infinity;
    for (const node of this._nodes[NodeState.InProgress]) {
      minimumTime = Math.min(minimumTime, this._estimateTimeRemaining(node));
    }

    return minimumTime;
  }

  /**
   * Given a time period, computes the progress toward completion that the node made durin that time.
   * @param {Node} node
   * @param {number} timePeriodLength
   * @param {number} totalElapsedTime
   */
  _updateProgressMadeInTimePeriod(node, timePeriodLength, totalElapsedTime) {
    const timingData = this._nodeTimings.getInProgress(node);
    const isFinished = timingData.estimatedTimeElapsed === timePeriodLength;

    if (node.type === BaseNode.TYPES.CPU || node.isConnectionless) {
      return isFinished
        ? this._markNodeAsComplete(node, totalElapsedTime)
        : (timingData.timeElapsed += timePeriodLength);
    }

    if (node.type !== BaseNode.TYPES.NETWORK) throw new Error('Unsupported');
    if (!('bytesDownloaded' in timingData)) throw new Error('Invalid timing data');

    const record = node.record;
    const connection = this._connectionPool.acquireActiveConnectionFromRecord(record);
    const dnsResolutionTime = this._dns.getTimeUntilResolution(record, {
      requestedAt: timingData.startTime,
      shouldUpdateCache: true,
    });
    const calculation = connection.simulateDownloadUntil(
      record.transferSize - timingData.bytesDownloaded,
      {
        dnsResolutionTime,
        timeAlreadyElapsed: timingData.timeElapsed,
        maximumTimeToElapse: timePeriodLength - timingData.timeElapsedOvershoot,
      }
    );

    connection.setCongestionWindow(calculation.congestionWindow);
    connection.setH2OverflowBytesDownloaded(calculation.extraBytesDownloaded);

    if (isFinished) {
      connection.setWarmed(true);
      this._connectionPool.release(record);
      this._markNodeAsComplete(node, totalElapsedTime);
    } else {
      timingData.timeElapsed += calculation.timeElapsed;
      timingData.timeElapsedOvershoot += calculation.timeElapsed - timePeriodLength;
      timingData.bytesDownloaded += calculation.bytesDownloaded;
    }
  }

  /**
   * @return {Map<Node, LH.Gatherer.Simulation.NodeTiming>}
   */
  _computeFinalNodeTimings() {
    /** @type {Array<[Node, LH.Gatherer.Simulation.NodeTiming]>} */
    const nodeTimingEntries = [];
    for (const node of this._nodeTimings.getNodes()) {
      const timing = this._nodeTimings.getCompleted(node);
      nodeTimingEntries.push([node, {
        startTime: timing.startTime,
        endTime: timing.endTime,
        duration: timing.endTime - timing.startTime,
      }]);
    }

    // Most consumers will want the entries sorted by startTime, so insert them in that order
    nodeTimingEntries.sort((a, b) => a[1].startTime - b[1].startTime);
    return new Map(nodeTimingEntries);
  }

  /**
   * @return {Required<LH.Gatherer.Simulation.Options>}
   */
  getOptions() {
    return this._options;
  }

  /**
   * Estimates the time taken to process all of the graph's nodes, returns the overall time along with
   * each node annotated by start/end times.
   *
   * If flexibleOrdering is set, simulator/connection pool are allowed to deviate from what was
   * observed in the trace/devtoolsLog and start requests as soon as they are queued (i.e. do not
   * wait around for a warm connection to be available if the original record was fetched on a warm
   * connection).
   *
   * @param {Node} graph
   * @param {{flexibleOrdering?: boolean, label?: string}=} options
   * @return {LH.Gatherer.Simulation.Result}
   */
  simulate(graph, options) {
    if (BaseNode.hasCycle(graph)) {
      throw new Error('Cannot simulate graph with cycle');
    }

    options = Object.assign({
      label: undefined,
      flexibleOrdering: false,
    }, options);

    // initialize the necessary data containers
    this._flexibleOrdering = !!options.flexibleOrdering;
    this._dns = new DNSCache({rtt: this._rtt});
    this._initializeConnectionPool(graph);
    this._initializeAuxiliaryData();

    const nodesNotReadyToStart = this._nodes[NodeState.NotReadyToStart];
    const nodesReadyToStart = this._nodes[NodeState.ReadyToStart];
    const nodesInProgress = this._nodes[NodeState.InProgress];

    const rootNode = graph.getRootNode();
    rootNode.traverse(node => nodesNotReadyToStart.add(node));
    let totalElapsedTime = 0;
    let iteration = 0;

    // root node is always ready to start
    this._markNodeAsReadyToStart(rootNode, totalElapsedTime);

    // loop as long as we have nodes in the queue or currently in progress
    while (nodesReadyToStart.size || nodesInProgress.size) {
      // move all possible queued nodes to in progress
      for (const node of this._getNodesSortedByStartPosition()) {
        this._startNodeIfPossible(node, totalElapsedTime);
      }

      if (!nodesInProgress.size) {
        // interplay between fromDiskCache and connectionReused can be incorrect
        // proceed with flexibleOrdering if we can, otherwise give up
        if (this._flexibleOrdering) throw new Error('Failed to start a node');
        this._flexibleOrdering = true;
        continue;
      }

      // set the available throughput for all connections based on # inflight
      this._updateNetworkCapacity();

      // find the time that the next node will finish
      const minimumTime = this._findNextNodeCompletionTime();
      totalElapsedTime += minimumTime;

      // While this is no longer strictly necessary, it's always better than LH hanging
      if (!Number.isFinite(minimumTime) || iteration > 100000) {
        throw new Error('Simulation failed, depth exceeded');
      }

      iteration++;
      // update how far each node will progress until that point
      for (const node of nodesInProgress) {
        this._updateProgressMadeInTimePeriod(node, minimumTime, totalElapsedTime);
      }
    }

    const nodeTimings = this._computeFinalNodeTimings();
    ALL_SIMULATION_NODE_TIMINGS.set(options.label || 'unlabeled', nodeTimings);

    return {
      timeInMs: totalElapsedTime,
      nodeTimings,
    };
  }

  /** @return {Map<string, LH.Gatherer.Simulation.Result['nodeTimings']>} */
  static get ALL_NODE_TIMINGS() {
    return ALL_SIMULATION_NODE_TIMINGS;
  }

  /**
   * We attempt to start nodes by their observed start time using the record priority as a tie breaker.
   * When simulating, just because a low priority image started 5ms before a high priority image doesn't mean
   * it would have happened like that when the network was slower.
   * @param {Node} node
   */
  static _computeNodeStartPosition(node) {
    if (node.type === 'cpu') return node.startTime;
    return node.startTime + (PriorityStartTimePenalty[node.record.priority] * 1000 * 1000 || 0);
  }
}

module.exports = Simulator;

},{"../../../config/constants.js":56,"../base-node.js":86,"./connection-pool.js":89,"./dns-cache.js":90,"./simulator-timing-map.js":92,"./tcp-connection.js":94}],94:[function(require,module,exports){
/**
 * @license Copyright 2017 The Lighthouse Authors. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.
 */
'use strict';

const INITIAL_CONGESTION_WINDOW = 10;
const TCP_SEGMENT_SIZE = 1460;

class TcpConnection {
  /**
   * @param {number} rtt
   * @param {number} throughput
   * @param {number=} serverLatency
   * @param {boolean=} ssl
   * @param {boolean=} h2
   */
  constructor(rtt, throughput, serverLatency = 0, ssl = true, h2 = false) {
    this._warmed = false;
    this._ssl = ssl;
    this._h2 = h2;
    this._rtt = rtt;
    this._throughput = throughput;
    this._serverLatency = serverLatency;
    this._congestionWindow = INITIAL_CONGESTION_WINDOW;
    this._h2OverflowBytesDownloaded = 0;
  }

  /**
   * @param {number} rtt
   * @param {number} availableThroughput
   * @return {number}
   */
  static maximumSaturatedConnections(rtt, availableThroughput) {
    const roundTripsPerSecond = 1000 / rtt;
    const bytesPerRoundTrip = TCP_SEGMENT_SIZE;
    const bytesPerSecond = roundTripsPerSecond * bytesPerRoundTrip;
    const minimumThroughputRequiredPerRequest = bytesPerSecond * 8;
    return Math.floor(availableThroughput / minimumThroughputRequiredPerRequest);
  }

  /**
   * @return {number}
   */
  _computeMaximumCongestionWindowInSegments() {
    const bytesPerSecond = this._throughput / 8;
    const secondsPerRoundTrip = this._rtt / 1000;
    const bytesPerRoundTrip = bytesPerSecond * secondsPerRoundTrip;
    return Math.floor(bytesPerRoundTrip / TCP_SEGMENT_SIZE);
  }

  /**
   * @param {number} throughput
   */
  setThroughput(throughput) {
    this._throughput = throughput;
  }

  /**
   * @param {number} congestion
   */
  setCongestionWindow(congestion) {
    this._congestionWindow = congestion;
  }

  /**
   * @param {boolean} warmed
   */
  setWarmed(warmed) {
    this._warmed = warmed;
  }

  /**
   * @return {boolean}
   */
  isWarm() {
    return this._warmed;
  }

  /**
   * @return {boolean}
   */
  isH2() {
    return this._h2;
  }

  /**
   * @return {number}
   */
  get congestionWindow() {
    return this._congestionWindow;
  }

  /**
   * Sets the number of excess bytes that are available to this connection on future downloads, only
   * applies to H2 connections.
   * @param {number} bytes
   */
  setH2OverflowBytesDownloaded(bytes) {
    if (!this._h2) return;
    this._h2OverflowBytesDownloaded = bytes;
  }

  /**
   * @return {TcpConnection}
   */
  clone() {
    return Object.assign(new TcpConnection(this._rtt, this._throughput), this);
  }

  /**
   * Simulates a network download of a particular number of bytes over an optional maximum amount of time
   * and returns information about the ending state.
   *
   * See https://hpbn.co/building-blocks-of-tcp/#three-way-handshake and
   *  https://hpbn.co/transport-layer-security-tls/#tls-handshake for details.
   *
   * @param {number} bytesToDownload
   * @param {DownloadOptions} [options]
   * @return {DownloadResults}
   */
  simulateDownloadUntil(bytesToDownload, options) {
    const {timeAlreadyElapsed = 0, maximumTimeToElapse = Infinity, dnsResolutionTime = 0} =
      options || {};

    if (this._warmed && this._h2) {
      bytesToDownload -= this._h2OverflowBytesDownloaded;
    }
    const twoWayLatency = this._rtt;
    const oneWayLatency = twoWayLatency / 2;
    const maximumCongestionWindow = this._computeMaximumCongestionWindowInSegments();

    let handshakeAndRequest = oneWayLatency;
    if (!this._warmed) {
      handshakeAndRequest =
        // DNS lookup
        dnsResolutionTime +
        // SYN
        oneWayLatency +
        // SYN ACK
        oneWayLatency +
        // ACK + initial request
        oneWayLatency +
        // ClientHello/ServerHello assuming TLS False Start is enabled (https://istlsfastyet.com/#server-performance).
        (this._ssl ? twoWayLatency : 0);
    }

    let roundTrips = Math.ceil(handshakeAndRequest / twoWayLatency);
    let timeToFirstByte = handshakeAndRequest + this._serverLatency + oneWayLatency;
    if (this._warmed && this._h2) timeToFirstByte = 0;

    const timeElapsedForTTFB = Math.max(timeToFirstByte - timeAlreadyElapsed, 0);
    const maximumDownloadTimeToElapse = maximumTimeToElapse - timeElapsedForTTFB;

    let congestionWindow = Math.min(this._congestionWindow, maximumCongestionWindow);
    let totalBytesDownloaded = 0;
    if (timeElapsedForTTFB > 0) {
      totalBytesDownloaded = congestionWindow * TCP_SEGMENT_SIZE;
    } else {
      roundTrips = 0;
    }

    let downloadTimeElapsed = 0;
    let bytesRemaining = bytesToDownload - totalBytesDownloaded;
    while (bytesRemaining > 0 && downloadTimeElapsed <= maximumDownloadTimeToElapse) {
      roundTrips++;
      downloadTimeElapsed += twoWayLatency;
      congestionWindow = Math.max(Math.min(maximumCongestionWindow, congestionWindow * 2), 1);

      const bytesDownloadedInWindow = congestionWindow * TCP_SEGMENT_SIZE;
      totalBytesDownloaded += bytesDownloadedInWindow;
      bytesRemaining -= bytesDownloadedInWindow;
    }

    const timeElapsed = timeElapsedForTTFB + downloadTimeElapsed;
    const extraBytesDownloaded = this._h2 ? Math.max(totalBytesDownloaded - bytesToDownload, 0) : 0;
    const bytesDownloaded = Math.max(Math.min(totalBytesDownloaded, bytesToDownload), 0);

    return {
      roundTrips,
      timeElapsed,
      bytesDownloaded,
      extraBytesDownloaded,
      congestionWindow,
    };
  }
}

module.exports = TcpConnection;

/**
 * @typedef DownloadOptions
 * @property {number} [dnsResolutionTime]
 * @property {number} [timeAlreadyElapsed]
 * @property {number} [maximumTimeToElapse]
 */

/**
 * @typedef DownloadResults
 * @property {number} roundTrips
 * @property {number} timeElapsed
 * @property {number} bytesDownloaded
 * @property {number} extraBytesDownloaded
 * @property {number} congestionWindow
 */

},{}],95:[function(require,module,exports){
/**
 * @license Copyright 2016 The Lighthouse Authors. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.
 */
'use strict';

const NO_THROTTLING_METRICS = {
  latency: 0,
  downloadThroughput: 0,
  uploadThroughput: 0,
  offline: false,
};

const NO_CPU_THROTTLE_METRICS = {
  rate: 1,
};

/**
 * @param {LH.Gatherer.FRProtocolSession} session
 * @param {LH.Config.Settings} settings
 * @return {Promise<void>}
 */
async function emulate(session, settings) {
  if (settings.emulatedUserAgent !== false) {
    await session.sendCommand('Network.setUserAgentOverride', {
      userAgent: /** @type {string} */ (settings.emulatedUserAgent),
    });
  }
  // See devtools-entry for one usecase for disabling screenEmulation
  if (settings.screenEmulation.disabled !== true) {
    const {width, height, deviceScaleFactor, mobile} = settings.screenEmulation;
    const params = {width, height, deviceScaleFactor, mobile};
    await session.sendCommand('Emulation.setDeviceMetricsOverride', params);
    await session.sendCommand('Emulation.setTouchEmulationEnabled', {
      enabled: params.mobile,
    });
  }
}

/**
 * Sets the throttling options specified in config settings, clearing existing network throttling if
 * throttlingMethod is not `devtools` (but not CPU throttling, suspected requirement of WPT-compat).
 *
 * @param {LH.Gatherer.FRProtocolSession} session
 * @param {LH.Config.Settings} settings
 * @return {Promise<void>}
 */
async function throttle(session, settings) {
  // TODO(FR-COMPAT): reconsider if this should be resetting anything
  if (settings.throttlingMethod !== 'devtools') return clearNetworkThrottling(session);

  await Promise.all([
    enableNetworkThrottling(session, settings.throttling),
    enableCPUThrottling(session, settings.throttling),
  ]);
}

/**
 * @param {LH.Gatherer.FRProtocolSession} session
 * @return {Promise<void>}
 */
async function clearThrottling(session) {
  await Promise.all([clearNetworkThrottling(session), clearCPUThrottling(session)]);
}

/**
 * @param {LH.Gatherer.FRProtocolSession} session
 * @param {Required<LH.ThrottlingSettings>} throttlingSettings
 * @return {Promise<void>}
 */
function enableNetworkThrottling(session, throttlingSettings) {
  /** @type {LH.Crdp.Network.EmulateNetworkConditionsRequest} */
  const conditions = {
    offline: false,
    latency: throttlingSettings.requestLatencyMs || 0,
    downloadThroughput: throttlingSettings.downloadThroughputKbps || 0,
    uploadThroughput: throttlingSettings.uploadThroughputKbps || 0,
  };

  // DevTools expects throughput in bytes per second rather than kbps
  conditions.downloadThroughput = Math.floor(conditions.downloadThroughput * 1024 / 8);
  conditions.uploadThroughput = Math.floor(conditions.uploadThroughput * 1024 / 8);
  return session.sendCommand('Network.emulateNetworkConditions', conditions);
}

/**
 * @param {LH.Gatherer.FRProtocolSession} session
 * @return {Promise<void>}
 */
function clearNetworkThrottling(session) {
  return session.sendCommand('Network.emulateNetworkConditions', NO_THROTTLING_METRICS);
}

/**
 * @param {LH.Gatherer.FRProtocolSession} session
 * @param {Required<LH.ThrottlingSettings>} throttlingSettings
 * @return {Promise<void>}
 */
function enableCPUThrottling(session, throttlingSettings) {
  const rate = throttlingSettings.cpuSlowdownMultiplier;
  return session.sendCommand('Emulation.setCPUThrottlingRate', {rate});
}

/**
 * @param {LH.Gatherer.FRProtocolSession} session
 * @return {Promise<void>}
 */
function clearCPUThrottling(session) {
  return session.sendCommand('Emulation.setCPUThrottlingRate', NO_CPU_THROTTLE_METRICS);
}

module.exports = {
  emulate,
  throttle,
  clearThrottling,
  enableNetworkThrottling,
  clearNetworkThrottling,
  enableCPUThrottling,
  clearCPUThrottling,
};

},{}],96:[function(require,module,exports){
(function (__filename){(function (){
/**
 * @license Copyright 2018 The Lighthouse Authors. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.
 */
'use strict';

/** @typedef {import('../../lib/i18n/locales').LhlMessages} LhlMessages */

const path = require('path');
const MessageFormat = require('intl-messageformat').default;
const lookupClosestLocale = require('lookup-closest-locale');
const LOCALES = require('./locales.js');
const {isObjectOfUnknownValues, isObjectOrArrayOfUnknownValues} = require('../type-verifiers.js');
const log = require('lighthouse-logger');
const {LH_ROOT} = require('../../../root.js');

const DEFAULT_LOCALE = 'en';

/** @typedef {import('intl-messageformat-parser').Element} MessageElement */
/** @typedef {import('intl-messageformat-parser').ArgumentElement} ArgumentElement */

const MESSAGE_I18N_ID_REGEX = / | [^\s]+$/;

const UIStrings = {
  /** Used to show the duration in milliseconds that something lasted. The `{timeInMs}` placeholder will be replaced with the time duration, shown in milliseconds (e.g. 63 ms) */
  ms: '{timeInMs, number, milliseconds}\xa0ms',
  /** Used to show the duration in seconds that something lasted. The {timeInMs} placeholder will be replaced with the time duration, shown in seconds (e.g. 5.2 s) */
  seconds: '{timeInMs, number, seconds}\xa0s',
  /** Label shown per-audit to show how many bytes smaller the page could be if the user implemented the suggestions. The `{wastedBytes}` placeholder will be replaced with the number of bytes, shown in kibibytes (e.g. 148 KiB) */
  displayValueByteSavings: 'Potential savings of {wastedBytes, number, bytes}\xa0KiB',
  /** Label shown per-audit to show how many milliseconds faster the page load could be if the user implemented the suggestions. The `{wastedMs}` placeholder will be replaced with the time duration, shown in milliseconds (e.g. 140 ms) */
  displayValueMsSavings: 'Potential savings of {wastedMs, number, milliseconds}\xa0ms',
  /** Label shown per-audit to show how many HTML elements did not pass the audit. The `{# elements found}` placeholder will be replaced with the number of failing HTML elements. */
  displayValueElementsFound: `{nodeCount, plural, =1 {1 element found} other {# elements found}}`,
  /** Label for a column in a data table; entries will be the URL of a web resource */
  columnURL: 'URL',
  /** Label for a column in a data table; entries will be the size or quantity of some resource, e.g. the width and height dimensions of an image or the number of images in a web page. */
  columnSize: 'Size',
  /** Label for a column in a data table; entries will be the file size of a web resource in kilobytes. */
  columnResourceSize: 'Resource Size',
  /** Label for a column in a data table; entries will be the download size of a web resource in kilobytes. */
  columnTransferSize: 'Transfer Size',
  /** Label for a column in a data table; entries will be the time to live value of the cache header on a web resource. */
  columnCacheTTL: 'Cache TTL',
  /** Label for a column in a data table; entries will be the number of kilobytes the user could reduce their page by if they implemented the suggestions. */
  columnWastedBytes: 'Potential Savings',
  /** Label for a column in a data table; entries will be the number of milliseconds the user could reduce page load by if they implemented the suggestions. */
  columnWastedMs: 'Potential Savings',
  /** Label for a table column that displays how much time each row spent blocking other work on the main thread, entries will be the number of milliseconds spent. */
  columnBlockingTime: 'Main-Thread Blocking Time',
  /** Label for a column in a data table; entries will be the number of milliseconds spent during a particular activity. */
  columnTimeSpent: 'Time Spent',
  /** Label for a column in a data table; entries will be the location of a specific line of code in a file, in the format "line: 102". */
  columnLocation: 'Location',
  /** Label for a column in a data table; entries will be types of resources loaded over the network, e.g. "Scripts", "Third-Party", "Stylesheet". */
  columnResourceType: 'Resource Type',
  /** Label for a column in a data table; entries will be the number of network requests done by a webpage. */
  columnRequests: 'Requests',
  /** Label for a column in a data table; entries will be the names of arbitrary objects, e.g. the name of a Javascript library, or the name of a user defined timing event. */
  columnName: 'Name',
  /** Label for a column in a data table; entries will be the locations of JavaScript or CSS code, e.g. the name of a Javascript package or module. */
  columnSource: 'Source',
  /** Label for a column in a data table; entries will be how much a predetermined budget has been exeeded by. Depending on the context, this number could represent an excess in quantity or size of network requests, or, an excess in the duration of time that it takes for the page to load.*/
  columnOverBudget: 'Over Budget',
  /** Label for a column in a data table; entries will be a representation of a DOM element. */
  columnElement: 'Element',
  /** Label for a column in a data table; entries will be the number of milliseconds since the page started loading. */
  columnStartTime: 'Start Time',
  /** Label for a column in a data table; entries will be the total number of milliseconds from the start time until the end time. */
  columnDuration: 'Duration',
  /** Label for a column in a data table; entries will be a representation of a DOM element that did not meet certain suggestions. */
  columnFailingElem: 'Failing Elements',
  /** Label for a column in a data table; entries will be a description of the table item. */
  columnDescription: 'Description',
  /** Label for a row in a data table; entries will be the total number and byte size of all resources loaded by a web page. */
  totalResourceType: 'Total',
  /** Label for a row in a data table; entries will be the total number and byte size of all 'Document' resources loaded by a web page. */
  documentResourceType: 'Document',
  /** Label for a row in a data table; entries will be the total number and byte size of all 'Script' resources loaded by a web page. 'Script' refers to JavaScript or other files that are executable by a browser. */
  scriptResourceType: 'Script',
  /** Label for a row in a data table; entries will be the total number and byte size of all 'Stylesheet' resources loaded by a web page. 'Stylesheet' refers to CSS stylesheets. */
  stylesheetResourceType: 'Stylesheet',
  /** Label for a row in a data table; entries will be the total number and byte size of all 'Image' resources loaded by a web page. */
  imageResourceType: 'Image',
  /** Label for a row in a data table; entries will be the total number and byte size of all 'Media' resources loaded by a web page. 'Media' refers to audio and video files. */
  mediaResourceType: 'Media',
  /** Label for a row in a data table; entries will be the total number and byte size of all 'Font' resources loaded by a web page. */
  fontResourceType: 'Font',
  /** Label for a row in a data table; entries will be the total number and byte size of all resources loaded by a web page that don't fit into the categories of Document, Script, Stylesheet, Image, Media, & Font.*/
  otherResourceType: 'Other',
  /** Label for a row in a data table; entries will be the total number and byte size of all third-party resources loaded by a web page. 'Third-party resources are items loaded from URLs that aren't controlled by the owner of the web page. */
  thirdPartyResourceType: 'Third-party',
  /** Label used to identify a value in a table where many individual values are aggregated to a single value, for brevity. "Other resources" could also be read as "the rest of the resources". Resource refers to network resources requested by the browser. */
  otherResourcesLabel: 'Other resources',
  /** The name of the metric that marks the time at which the first text or image is painted by the browser. Shown to users as the label for the numeric metric value. Ideally fits within a ~40 character limit. */
  firstContentfulPaintMetric: 'First Contentful Paint',
  /** The name of the metric that marks the time at which the page is fully loaded and is able to quickly respond to user input (clicks, taps, and keypresses feel responsive). Shown to users as the label for the numeric metric value. Ideally fits within a ~40 character limit. */
  interactiveMetric: 'Time to Interactive',
  /** The name of the metric that marks the time at which a majority of the content has been painted by the browser. Shown to users as the label for the numeric metric value. Ideally fits within a ~40 character limit. */
  firstMeaningfulPaintMetric: 'First Meaningful Paint',
  /** The name of a metric that calculates the total duration of blocking time for a web page. Blocking times are time periods when the page would be blocked (prevented) from responding to user input (clicks, taps, and keypresses will feel slow to respond). Shown to users as the label for the numeric metric value. Ideally fits within a ~40 character limit. */
  totalBlockingTimeMetric: 'Total Blocking Time',
  /** The name of the metric "Maximum Potential First Input Delay" that marks the maximum estimated time between the page receiving input (a user clicking, tapping, or typing) and the page responding. Shown to users as the label for the numeric metric value. Ideally fits within a ~40 character limit. */
  maxPotentialFIDMetric: 'Max Potential First Input Delay',
  /** The name of the metric that summarizes how quickly the page looked visually complete. The name of this metric is largely abstract and can be loosely translated. Shown to users as the label for the numeric metric value. Ideally fits within a ~40 character limit. */
  speedIndexMetric: 'Speed Index',
  /** The name of the metric that marks the time at which the largest text or image is painted by the browser. Shown to users as the label for the numeric metric value. Ideally fits within a ~40 character limit. */
  largestContentfulPaintMetric: 'Largest Contentful Paint',
  /** The name of the metric "Cumulative Layout Shift" that indicates how much the page changes its layout while it loads. If big segments of the page shift their location during load, the Cumulative Layout Shift will be higher. Shown to users as the label for the numeric metric value. Ideally fits within a ~40 character limit. */
  cumulativeLayoutShiftMetric: 'Cumulative Layout Shift',
  /** Table item value for the severity of a small, or low impact vulnerability. Part of a ranking scale in the form: low, medium, high. */
  itemSeverityLow: 'Low',
  /** Table item value for the severity of a vulnerability. Part of a ranking scale in the form: low, medium, high. */
  itemSeverityMedium: 'Medium',
  /** Table item value for the severity of a high impact, or dangerous vulnerability. Part of a ranking scale in the form: low, medium, high. */
  itemSeverityHigh: 'High',
};

const formats = {
  number: {
    bytes: {
      maximumFractionDigits: 0,
    },
    milliseconds: {
      maximumFractionDigits: 0,
    },
    seconds: {
      // Force the seconds to the tenths place for limited output and ease of scanning
      minimumFractionDigits: 1,
      maximumFractionDigits: 1,
    },
    extendedPercent: {
      // Force allow up to two digits after decimal place in percentages. (Intl.NumberFormat options)
      maximumFractionDigits: 2,
      style: 'percent',
    },
  },
};

/**
 * Look up the best available locale for the requested language through these fall backs:
 * - exact match
 * - progressively shorter prefixes (`de-CH-1996` -> `de-CH` -> `de`)
 * - supported locales in Intl formatters
 *
 * If `locale` isn't provided or one could not be found, DEFAULT_LOCALE is returned.
 * @param {string|string[]=} locales
 * @return {LH.Locale}
 */
function lookupLocale(locales) {
  // If Node was built with `--with-intl=none`, `Intl` won't exist.
  if (typeof Intl !== 'object') {
    throw new Error('Lighthouse must be run in Node with `Intl` support. See https://nodejs.org/api/intl.html for help');
  }

  // TODO: could do more work to sniff out the user's locale
  const canonicalLocales = Intl.getCanonicalLocales(locales);

  // Filter by what's available in this runtime.
  const availableLocales = Intl.NumberFormat.supportedLocalesOf(canonicalLocales);

  const closestLocale = lookupClosestLocale(availableLocales, LOCALES);

  if (!closestLocale) {
    // Log extra info if we're pretty sure this version of Node was built with `--with-intl=small-icu`.
    if (Intl.NumberFormat.supportedLocalesOf('es').length === 0) {
      log.warn('i18n', 'Requested locale not available in this version of node. The `full-icu` npm module can provide additional locales. For help, see https://github.com/GoogleChrome/lighthouse/blob/master/readme.md#how-do-i-get-localized-lighthouse-results-via-the-cli');
    }
    // eslint-disable-next-line max-len
    log.warn('i18n', `locale(s) '${locales}' not available. Falling back to default '${DEFAULT_LOCALE}'`);
  }

  return closestLocale || DEFAULT_LOCALE;
}

/**
 * Function to retrieve all 'argumentElement's from an ICU message. An argumentElement
 * is an ICU element with an argument in it, like '{varName}' or '{varName, number, bytes}'. This
 * differs from 'messageElement's which are just arbitrary text in a message.
 *
 * Notes:
 *  This function will recursively inspect plural elements for nested argumentElements.
 *
 *  We need to find all the elements from the plural format sections, but
 *  they need to be deduplicated. I.e. "=1{hello {icu}} =other{hello {icu}}"
 *  the variable "icu" would appear twice if it wasn't de duplicated. And they cannot
 *  be stored in a set because they are not equal since their locations are different,
 *  thus they are stored via a Map keyed on the "id" which is the ICU varName.
 *
 * @param {Array<MessageElement>} icuElements
 * @param {Map<string, ArgumentElement>} [seenElementsById]
 * @return {Map<string, ArgumentElement>}
 */
function collectAllCustomElementsFromICU(icuElements, seenElementsById = new Map()) {
  for (const el of icuElements) {
    // We are only interested in elements that need ICU formatting (argumentElements)
    if (el.type !== 'argumentElement') continue;

    seenElementsById.set(el.id, el);

    // Plurals need to be inspected recursively
    if (!el.format || el.format.type !== 'pluralFormat') continue;
    // Look at all options of the plural (=1{} =other{}...)
    for (const option of el.format.options) {
      // Run collections on each option's elements
      collectAllCustomElementsFromICU(option.value.elements, seenElementsById);
    }
  }

  return seenElementsById;
}

/**
 * Returns a copy of the `values` object, with the values formatted based on how
 * they will be used in their icuMessage, e.g. KB or milliseconds. The original
 * object is unchanged.
 * @param {MessageFormat} messageFormatter
 * @param {Readonly<Record<string, string | number>>} values
 * @param {string} lhlMessage Used for clear error logging.
 * @return {Record<string, string | number>}
 */
function _preformatValues(messageFormatter, values, lhlMessage) {
  const elementMap = collectAllCustomElementsFromICU(messageFormatter.getAst().elements);
  const argumentElements = [...elementMap.values()];

  /** @type {Record<string, string | number>} */
  const formattedValues = {};

  for (const {id, format} of argumentElements) {
    // Throw an error if a message's value isn't provided
    if (id && (id in values) === false) {
      throw new Error(`ICU Message "${lhlMessage}" contains a value reference ("${id}") ` +
        `that wasn't provided`);
    }

    const value = values[id];

    // Direct `{id}` replacement and non-numeric values need no formatting.
    if (!format || format.type !== 'numberFormat') {
      formattedValues[id] = value;
      continue;
    }

    if (typeof value !== 'number') {
      throw new Error(`ICU Message "${lhlMessage}" contains a numeric reference ("${id}") ` +
        'but provided value was not a number');
    }

    // Format values for known styles.
    if (format.style === 'milliseconds') {
      // Round all milliseconds to the nearest 10.
      formattedValues[id] = Math.round(value / 10) * 10;
    } else if (format.style === 'seconds' && id === 'timeInMs') {
      // Convert all seconds to the correct unit (currently only for `timeInMs`).
      formattedValues[id] = Math.round(value / 100) / 10;
    } else if (format.style === 'bytes') {
      // Replace all the bytes with KB.
      formattedValues[id] = value / 1024;
    } else {
      // For all other number styles, the value isn't changed.
      formattedValues[id] = value;
    }
  }

  // Throw an error if a value is provided but has no placeholder in the message.
  for (const valueId of Object.keys(values)) {
    if (valueId in formattedValues) continue;

    // errorCode is a special case always allowed to help LHError ease-of-use.
    if (valueId === 'errorCode') {
      formattedValues.errorCode = values.errorCode;
      continue;
    }

    throw new Error(`Provided value "${valueId}" does not match any placeholder in ` +
      `ICU message "${lhlMessage}"`);
  }

  return formattedValues;
}

/**
 * Format string `message` by localizing `values` and inserting them.
 * @param {string} message
 * @param {Record<string, string | number>} values
 * @param {LH.Locale} locale
 * @return {string}
 */
function _formatMessage(message, values = {}, locale) {
  // When using accented english, force the use of a different locale for number formatting.
  const localeForMessageFormat = (locale === 'en-XA' || locale === 'en-XL') ? 'de-DE' : locale;

  const formatter = new MessageFormat(message, localeForMessageFormat, formats);

  // Preformat values for the message format like KB and milliseconds.
  const valuesForMessageFormat = _preformatValues(formatter, values, message);

  return formatter.format(valuesForMessageFormat);
}

/**
 * Retrieves the localized version of `icuMessage` and formats with any given
 * value replacements.
 * @param {LH.IcuMessage} icuMessage
 * @param {LH.Locale} locale
 * @return {string}
 */
function _localizeIcuMessage(icuMessage, locale) {
  const localeMessages = LOCALES[locale];
  if (!localeMessages) throw new Error(`Unsupported locale '${locale}'`);
  const localeMessage = localeMessages[icuMessage.i18nId];

  // Fall back to the default (usually the original english message) if we couldn't find a
  // message in the specified locale. This could be because of string drift between
  // Lighthouse versions or because new strings haven't been updated yet. Better to have
  // an english message than no message at all; in some cases it won't even matter.
  if (!localeMessage) {
    return icuMessage.formattedDefault;
  }

  return _formatMessage(localeMessage.message, icuMessage.values, locale);
}

/** @param {string[]} pathInLHR */
function _formatPathAsString(pathInLHR) {
  let pathAsString = '';
  for (const property of pathInLHR) {
    if (/^[a-z]+$/i.test(property)) {
      if (pathAsString.length) pathAsString += '.';
      pathAsString += property;
    } else {
      if (/]|"|'|\s/.test(property)) throw new Error(`Cannot handle "${property}" in i18n`);
      pathAsString += `[${property}]`;
    }
  }

  return pathAsString;
}

/**
 * @param {LH.Locale} locale
 * @return {LH.I18NRendererStrings}
 */
function getRendererFormattedStrings(locale) {
  const localeMessages = LOCALES[locale];
  if (!localeMessages) throw new Error(`Unsupported locale '${locale}'`);

  const icuMessageIds = Object.keys(localeMessages).filter(f => f.startsWith('report/'));
  const strings = /** @type {LH.I18NRendererStrings} */ ({});
  for (const icuMessageId of icuMessageIds) {
    const [filename, varName] = icuMessageId.split(' | ');
    if (!filename.endsWith('util.js')) throw new Error(`Unexpected message: ${icuMessageId}`);

    const key = /** @type {keyof LH.I18NRendererStrings} */ (varName);
    strings[key] = localeMessages[icuMessageId].message;
  }

  return strings;
}

/**
 * Returns a function that generates `LH.IcuMessage` objects to localize the
 * messages in `fileStrings` and the shared `i18n.UIStrings`.
 * @param {string} filename
 * @param {Record<string, string>} fileStrings
 */
function createIcuMessageFn(filename, fileStrings) {
  /**
   * Combined so fn can access both caller's strings and i18n.UIStrings shared across LH.
   * @type {Record<string, string>}
   */
  const mergedStrings = {...UIStrings, ...fileStrings};

  /**
   * Convert a message string and replacement values into an `LH.IcuMessage`.
   * @param {string} message
   * @param {Record<string, string | number>} [values]
   * @return {LH.IcuMessage}
   */
  const getIcuMessageFn = (message, values) => {
    const keyname = Object.keys(mergedStrings).find(key => mergedStrings[key] === message);
    if (!keyname) throw new Error(`Could not locate: ${message}`);

    const filenameToLookup = keyname in fileStrings ? filename : __filename;
    const unixStyleFilename = path.relative(LH_ROOT, filenameToLookup).replace(/\\/g, '/');
    const i18nId = `${unixStyleFilename} | ${keyname}`;

    return {
      i18nId,
      values,
      formattedDefault: _formatMessage(message, values, DEFAULT_LOCALE),
    };
  };

  return getIcuMessageFn;
}

/**
 * Returns whether `icuMessageOrNot`` is an `LH.IcuMessage` instance.
 * @param {unknown} icuMessageOrNot
 * @return {icuMessageOrNot is LH.IcuMessage}
 */
function isIcuMessage(icuMessageOrNot) {
  if (!isObjectOfUnknownValues(icuMessageOrNot)) {
    return false;
  }

  const {i18nId, values, formattedDefault} = icuMessageOrNot;
  if (typeof i18nId !== 'string') {
    return false;
  }

  // formattedDefault is required.
  if (typeof formattedDefault !== 'string') {
    return false;
  }

  // Values is optional.
  if (values !== undefined) {
    if (!isObjectOfUnknownValues(values)) {
      return false;
    }
    for (const value of Object.values(values)) {
      if (typeof value !== 'string' && typeof value !== 'number') {
        return false;
      }
    }
  }

  // Finally return true if i18nId seems correct.
  return MESSAGE_I18N_ID_REGEX.test(i18nId);
}

/**
 * Get the localized and formatted form of `icuMessageOrRawString` if it's an
 * LH.IcuMessage, or get it back directly if it's already a string.
 * Warning: this function throws if `icuMessageOrRawString` is not the expected
 * type (use function from `createIcuMessageFn` to create a valid LH.IcuMessage)
 * or `locale` isn't supported (use `lookupLocale` to find a valid locale).
 * @param {LH.IcuMessage | string} icuMessageOrRawString
 * @param {LH.Locale} locale
 * @return {string}
 */
function getFormatted(icuMessageOrRawString, locale) {
  if (isIcuMessage(icuMessageOrRawString)) {
    return _localizeIcuMessage(icuMessageOrRawString, locale);
  }

  if (typeof icuMessageOrRawString === 'string') {
    return icuMessageOrRawString;
  }

  // Should be impossible from types, but do a strict check in case malformed JSON makes it this far.
  throw new Error('Attempted to format invalid icuMessage type');
}

/**
 * Recursively walk the input object, looking for property values that are
 * `LH.IcuMessage`s and replace them with their localized values. Primarily
 * used with the full LHR or a Config as input.
 * Returns a map of locations that were replaced to the `IcuMessage` that was at
 * that location.
 * @param {unknown} inputObject
 * @param {LH.Locale} locale
 * @return {LH.IcuMessagePaths}
 */
function replaceIcuMessages(inputObject, locale) {
  /**
   * @param {unknown} subObject
   * @param {LH.IcuMessagePaths} icuMessagePaths
   * @param {string[]} pathInLHR
   */
  function replaceInObject(subObject, icuMessagePaths, pathInLHR = []) {
    if (!isObjectOrArrayOfUnknownValues(subObject)) return;

    for (const [property, possibleIcuMessage] of Object.entries(subObject)) {
      const currentPathInLHR = pathInLHR.concat([property]);

      // Replace any IcuMessages with a localized string.
      if (isIcuMessage(possibleIcuMessage)) {
        const formattedString = _localizeIcuMessage(possibleIcuMessage, locale);
        const messageInstancesInLHR = icuMessagePaths[possibleIcuMessage.i18nId] || [];
        const currentPathAsString = _formatPathAsString(currentPathInLHR);

        messageInstancesInLHR.push(
          possibleIcuMessage.values ?
            {values: possibleIcuMessage.values, path: currentPathAsString} :
            currentPathAsString
        );

        // @ts-ignore - tsc doesn't like that `property` can be either string key or array index.
        subObject[property] = formattedString;
        icuMessagePaths[possibleIcuMessage.i18nId] = messageInstancesInLHR;
      } else {
        replaceInObject(possibleIcuMessage, icuMessagePaths, currentPathInLHR);
      }
    }
  }

  /** @type {LH.IcuMessagePaths} */
  const icuMessagePaths = {};
  replaceInObject(inputObject, icuMessagePaths);
  return icuMessagePaths;
}

/**
 * Populate the i18n string lookup dict with locale data
 * Used when the host environment selects the locale and serves lighthouse the intended locale file
 * @see https://docs.google.com/document/d/1jnt3BqKB-4q3AE94UWFA0Gqspx8Sd_jivlB7gQMlmfk/edit
 * @param {LH.Locale} locale
 * @param {LhlMessages} lhlMessages
 */
function registerLocaleData(locale, lhlMessages) {
  LOCALES[locale] = lhlMessages;
}

/**
 * Returns true if the given value is a string or an LH.IcuMessage.
 * @param {unknown} value
 * @return {value is string|LH.IcuMessage}
 */
function isStringOrIcuMessage(value) {
  return typeof value === 'string' || isIcuMessage(value);
}

module.exports = {
  _formatPathAsString,
  UIStrings,
  lookupLocale,
  getRendererFormattedStrings,
  createIcuMessageFn,
  getFormatted,
  replaceIcuMessages,
  isIcuMessage,
  collectAllCustomElementsFromICU,
  registerLocaleData,
  isStringOrIcuMessage,
  // TODO: exported for backwards compatibility. Consider removing on future breaking change.
  createMessageInstanceIdFn: createIcuMessageFn,
};

}).call(this)}).call(this,"/lighthouse-core/lib/i18n/i18n.js")
},{"../../../root.js":261,"../type-verifiers.js":121,"./locales.js":97,"intl-messageformat":180,"lighthouse-logger":188,"lookup-closest-locale":218,"path":222}],97:[function(require,module,exports){
/**
 * @license Copyright 2018 The Lighthouse Authors. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.
 */
'use strict';

/**
 * @fileoverview
 * Define message file to be used for a given locale. A few aliases are defined below.
 *
 * Google locale inheritance rules: https://goto.google.com/ccssm
 * CLDR language aliases: https://www.unicode.org/cldr/charts/latest/supplemental/aliases.html
 * CLDR locale inheritance: https://github.com/unicode-cldr/cldr-core/blob/master/supplemental/parentLocales.json
 */

// TODO(paulirish): Centralize locale inheritance (combining this & i18n.lookupLocale()), adopt cldr parentLocale rules.

/** @typedef {Record<string, {message: string}>} LhlMessages */

// The keys within this const must exactly match the LH.Locale type in externs.d.ts
/** @type {Record<LH.Locale, LhlMessages>} */
const locales = {
  'en-US': require('./locales/en-US.json'), // The 'source' strings, with descriptions
  'en': require('./locales/en-US.json'), // According to CLDR/ICU, 'en' == 'en-US' dates/numbers (Why?!)

  // TODO: en-GB has just ~10 messages that are different from en-US. We should only ship those.
  'en-AU': require('./locales/en-GB.json'), // Alias of 'en-GB'
  'en-GB': require('./locales/en-GB.json'), // Alias of 'en-GB'
  'en-IE': require('./locales/en-GB.json'), // Alias of 'en-GB'
  'en-SG': require('./locales/en-GB.json'), // Alias of 'en-GB'
  'en-ZA': require('./locales/en-GB.json'), // Alias of 'en-GB'
  'en-IN': require('./locales/en-GB.json'), // Alias of 'en-GB'

  // All locales from here have a messages file, though we allow fallback to the base locale when the files are identical
  'ar-XB': require('./locales/ar-XB.json'), // psuedolocalization
  'ar': require('./locales/ar.json'),
  'bg': require('./locales/bg.json'),
  'ca': require('./locales/ca.json'),
  'cs': require('./locales/cs.json'),
  'da': require('./locales/da.json'),
  'de': require('./locales/de.json'), // de-AT, de-CH identical, so they fall back into de
  'el': require('./locales/el.json'),
  'en-XA': require('./locales/en-XA.json'), // psuedolocalization
  'en-XL': require('./locales/en-XL.json'), // local psuedolocalization
  'es': require('./locales/es.json'),
  'es-419': require('./locales/es-419.json'),
  // Aliases of es-419: https://raw.githubusercontent.com/unicode-cldr/cldr-core/master/supplemental/parentLocales.json
  'es-AR': require('./locales/es-419.json'),
  'es-BO': require('./locales/es-419.json'),
  'es-BR': require('./locales/es-419.json'),
  'es-BZ': require('./locales/es-419.json'),
  'es-CL': require('./locales/es-419.json'),
  'es-CO': require('./locales/es-419.json'),
  'es-CR': require('./locales/es-419.json'),
  'es-CU': require('./locales/es-419.json'),
  'es-DO': require('./locales/es-419.json'),
  'es-EC': require('./locales/es-419.json'),
  'es-GT': require('./locales/es-419.json'),
  'es-HN': require('./locales/es-419.json'),
  'es-MX': require('./locales/es-419.json'),
  'es-NI': require('./locales/es-419.json'),
  'es-PA': require('./locales/es-419.json'),
  'es-PE': require('./locales/es-419.json'),
  'es-PR': require('./locales/es-419.json'),
  'es-PY': require('./locales/es-419.json'),
  'es-SV': require('./locales/es-419.json'),
  'es-US': require('./locales/es-419.json'),
  'es-UY': require('./locales/es-419.json'),
  'es-VE': require('./locales/es-419.json'),

  'fi': require('./locales/fi.json'),
  'fil': require('./locales/fil.json'),
  'fr': require('./locales/fr.json'), // fr-CH identical, so it falls back into fr
  'he': require('./locales/he.json'),
  'hi': require('./locales/hi.json'),
  'hr': require('./locales/hr.json'),
  'hu': require('./locales/hu.json'),
  'gsw': require('./locales/de.json'), // swiss german. identical (for our purposes) to 'de'
  'id': require('./locales/id.json'),
  'in': require('./locales/id.json'), // Alias of 'id'
  'it': require('./locales/it.json'),
  'iw': require('./locales/he.json'), // Alias of 'he'
  'ja': require('./locales/ja.json'),
  'ko': require('./locales/ko.json'),
  'lt': require('./locales/lt.json'),
  'lv': require('./locales/lv.json'),
  'mo': require('./locales/ro.json'), // Alias of 'ro'
  'nl': require('./locales/nl.json'),
  'nb': require('./locales/no.json'), // Alias of 'no'
  'no': require('./locales/no.json'),
  'pl': require('./locales/pl.json'),
  'pt': require('./locales/pt.json'), // pt-BR identical, so it falls back into pt
  'pt-PT': require('./locales/pt-PT.json'),
  'ro': require('./locales/ro.json'),
  'ru': require('./locales/ru.json'),
  'sk': require('./locales/sk.json'),
  'sl': require('./locales/sl.json'),
  'sr': require('./locales/sr.json'),
  'sr-Latn': require('./locales/sr-Latn.json'),
  'sv': require('./locales/sv.json'),
  'ta': require('./locales/ta.json'),
  'te': require('./locales/te.json'),
  'th': require('./locales/th.json'),
  'tl': require('./locales/fil.json'), // Alias of 'fil'
  'tr': require('./locales/tr.json'),
  'uk': require('./locales/uk.json'),
  'vi': require('./locales/vi.json'),
  'zh': require('./locales/zh.json'), // aka ZH-Hans, sometimes seen as zh-CN, zh-Hans-CN, Simplified Chinese
  'zh-HK': require('./locales/zh-HK.json'), // aka zh-Hant-HK. Note: yue-Hant-HK is not supported.
  'zh-TW': require('./locales/zh-TW.json'), // aka zh-Hant, zh-Hant-TW, Traditional Chinese
};

module.exports = locales;

},{"./locales/ar-XB.json":144,"./locales/ar.json":144,"./locales/bg.json":144,"./locales/ca.json":144,"./locales/cs.json":144,"./locales/da.json":144,"./locales/de.json":144,"./locales/el.json":144,"./locales/en-GB.json":144,"./locales/en-US.json":144,"./locales/en-XA.json":144,"./locales/en-XL.json":144,"./locales/es-419.json":144,"./locales/es.json":144,"./locales/fi.json":144,"./locales/fil.json":144,"./locales/fr.json":144,"./locales/he.json":144,"./locales/hi.json":144,"./locales/hr.json":144,"./locales/hu.json":144,"./locales/id.json":144,"./locales/it.json":144,"./locales/ja.json":144,"./locales/ko.json":144,"./locales/lt.json":144,"./locales/lv.json":144,"./locales/nl.json":144,"./locales/no.json":144,"./locales/pl.json":144,"./locales/pt-PT.json":144,"./locales/pt.json":144,"./locales/ro.json":144,"./locales/ru.json":144,"./locales/sk.json":144,"./locales/sl.json":144,"./locales/sr-Latn.json":144,"./locales/sr.json":144,"./locales/sv.json":144,"./locales/ta.json":144,"./locales/te.json":144,"./locales/th.json":144,"./locales/tr.json":144,"./locales/uk.json":144,"./locales/vi.json":144,"./locales/zh-HK.json":144,"./locales/zh-TW.json":144,"./locales/zh.json":144}],98:[function(require,module,exports){
/**
 * @license Copyright 2016 The Lighthouse Authors. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.
 */
'use strict';

const URL = require('./url-shim.js');

/**
 * @param {NonNullable<LH.Artifacts.Manifest['value']>} manifest
 * @return {boolean} Does the manifest have any icons?
 */
function doExist(manifest) {
  if (!manifest || !manifest.icons) {
    return false;
  }
  if (manifest.icons.value.length === 0) {
    return false;
  }
  return true;
}

/**
 * @param {number} sizeRequirement
 * @param {NonNullable<LH.Artifacts.Manifest['value']>} manifest
 * @return {Array<string>} Value of satisfactory sizes (eg. ['192x192', '256x256'])
 */
function pngSizedAtLeast(sizeRequirement, manifest) {
  // An icon can be provided for a single size, or for multiple sizes.
  // To handle both, we flatten all found sizes into a single array.
  const iconValues = manifest.icons.value;
  /** @type {Array<string>} */
  const flattenedSizes = [];
  iconValues
    .filter(icon => {
      const typeHint = icon.value.type.value;
      if (typeHint) {
        // If a type hint is present, filter out icons that are not 'image/png'.
        return typeHint === 'image/png';
      }
      // Otherwise, fall back to filtering on the icons' extension.
      const src = icon.value.src.value;
      return src && new URL(src).pathname.endsWith('.png');
    })
    .forEach(icon => {
      // check that the icon has a size
      if (icon.value.sizes.value) {
        flattenedSizes.push(...icon.value.sizes.value);
      }
    });

  return flattenedSizes
      // discard sizes that are not AAxBB (eg. "any")
      .filter(size => /\d+x\d+/.test(size))
      .filter(size => {
        // Split the '24x24' strings into ['24','24'] arrays
        const sizeStrs = size.split(/x/i);
        // Cast the ['24','24'] strings into [24,24] numbers
        const sizeNums = [parseFloat(sizeStrs[0]), parseFloat(sizeStrs[1])];
        // Only keep sizes that are as big as our required size
        const areIconsBigEnough = sizeNums[0] >= sizeRequirement && sizeNums[1] >= sizeRequirement;
        // Square is required: https://code.google.com/p/chromium/codesearch#chromium/src/chrome/browser/manifest/manifest_icon_selector.cc&q=ManifestIconSelector::IconSizesContainsBiggerThanMinimumSize&sq=package:chromium
        const areIconsSquare = sizeNums[0] === sizeNums[1];
        return areIconsBigEnough && areIconsSquare;
      });
}

/**
 * @param {NonNullable<LH.Artifacts.Manifest['value']>} manifest
 * @return {boolean} Does the manifest icons value contain at least one icon with purpose including "maskable"
 */
function containsMaskableIcon(manifest) {
  const iconValues = manifest.icons.value;
  return iconValues.some(icon => {
    return icon.value.purpose &&
      icon.value.purpose.value &&
      icon.value.purpose.value.includes('maskable');
  });
}

module.exports = {
  doExist,
  pngSizedAtLeast,
  containsMaskableIcon,
};

},{"./url-shim.js":"url"}],99:[function(require,module,exports){
/**
 * @license Copyright 2018 The Lighthouse Authors. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.
 */
'use strict';

/**
 * @param {LH.Gatherer.Simulation.Result['nodeTimings']} nodeTimings
 * @return {LH.Trace}
 */
function convertNodeTimingsToTrace(nodeTimings) {
  /** @type {LH.TraceEvent[]} */
  const traceEvents = [];
  const baseTs = 1e9;
  const baseEvent = {pid: 1, tid: 1, cat: 'devtools.timeline'};
  const frame = 'A00001';
  /** @param {number} ms */
  const toMicroseconds = ms => baseTs + ms * 1000;

  traceEvents.push(createFakeTracingStartedEvent());
  traceEvents.push({...createFakeTracingStartedEvent(), name: 'TracingStartedInBrowser'});

  // Create a fake requestId counter
  let requestId = 1;
  let lastEventEndTime = 0;
  for (const [node, timing] of nodeTimings.entries()) {
    lastEventEndTime = Math.max(lastEventEndTime, timing.endTime);
    if (node.type === 'cpu') {
      // Represent all CPU work that was bundled in a task as an EvaluateScript event
      traceEvents.push(...createFakeTaskEvents(node, timing));
    } else {
      // Ignore data URIs as they don't really add much value
      if (/^data/.test(node.record.url)) continue;
      traceEvents.push(...createFakeNetworkEvents(node.record, timing));
    }
  }

  // Create a fake task event ~1s after the trace ends for a sane default bounds in DT
  traceEvents.push(
    ...createFakeTaskEvents(
      // @ts-expect-error
      {childEvents: [], event: {}},
      {
        startTime: lastEventEndTime + 1000,
        endTime: lastEventEndTime + 1001,
      }
    )
  );

  return {traceEvents};

  /**
   * @return {LH.TraceEvent}
   */
  function createFakeTracingStartedEvent() {
    const argsData = {
      frameTreeNodeId: 1,
      sessionId: '1.1',
      page: frame,
      persistentIds: true,
      frames: [{frame, url: 'about:blank', name: '', processId: 1}],
    };

    return {
      ...baseEvent,
      ts: baseTs - 1e5,
      ph: 'I',
      s: 't',
      cat: 'disabled-by-default-devtools.timeline',
      name: 'TracingStartedInPage',
      args: {data: argsData},
      dur: 0,
    };
  }

  /**
   * @param {LH.Gatherer.Simulation.GraphCPUNode} cpuNode
   * @param {{startTime: number, endTime: number}} timing
   * @return {LH.TraceEvent[]}
   */
  function createFakeTaskEvents(cpuNode, timing) {
    const argsData = {
      url: '',
      frame,
      lineNumber: 0,
      columnNumber: 0,
    };

    const eventTs = toMicroseconds(timing.startTime);

    /** @type {LH.TraceEvent[]} */
    const events = [
      {
        ...baseEvent,
        ph: 'X',
        name: 'Task',
        ts: eventTs,
        dur: (timing.endTime - timing.startTime) * 1000,
        args: {data: argsData},
      },
    ];

    const nestedBaseTs = cpuNode.event.ts || 0;
    const multiplier = (timing.endTime - timing.startTime) * 1000 / cpuNode.event.dur;
    // https://github.com/ChromeDevTools/devtools-frontend/blob/5429ac8a61ad4fa/front_end/timeline_model/TimelineModel.js#L1129-L1130
    const netReqEvents = new Set(['ResourceSendRequest', 'ResourceFinish',
      'ResourceReceiveResponse', 'ResourceReceivedData']);
    for (const event of cpuNode.childEvents) {
      if (netReqEvents.has(event.name)) continue;
      const ts = eventTs + (event.ts - nestedBaseTs) * multiplier;
      const newEvent = {...event, ...{pid: baseEvent.pid, tid: baseEvent.tid}, ts};
      if (event.dur) newEvent.dur = event.dur * multiplier;
      events.push(newEvent);
    }

    return events;
  }

  /**
   * @param {LH.Artifacts.NetworkRequest} record
   * @param {LH.Gatherer.Simulation.NodeTiming} timing
   * @return {LH.TraceEvent[]}
   */
  function createFakeNetworkEvents(record, timing) {
    requestId++;

    // 0ms requests get super-messed up rendering
    // Use 0.3ms instead so they're still hoverable, https://github.com/GoogleChrome/lighthouse/pull/5350#discussion_r194563201
    let {startTime, endTime} = timing; // eslint-disable-line prefer-const
    if (startTime === endTime) endTime += 0.3;

    const requestData = {requestId: requestId.toString(), frame};
    /** @type {StrictOmit<LH.TraceEvent, 'name'|'ts'|'args'>} */
    const baseRequestEvent = {...baseEvent, ph: 'I', s: 't', dur: 0};

    const sendRequestData = {
      ...requestData,
      requestMethod: record.requestMethod,
      url: record.url,
      priority: record.priority,
    };

    const receiveResponseData = {
      ...requestData,
      statusCode: record.statusCode,
      mimeType: record.mimeType,
      encodedDataLength: record.transferSize,
      fromCache: record.fromDiskCache,
      fromServiceWorker: record.fetchedViaServiceWorker,
    };

    const resourceFinishData = {
      ...requestData,
      decodedBodyLength: record.resourceSize,
      didFail: !!record.failed,
      finishTime: endTime,
    };

    /** @type {LH.TraceEvent[]} */
    const events = [
      {
        ...baseRequestEvent,
        name: 'ResourceSendRequest',
        ts: toMicroseconds(startTime),
        args: {data: sendRequestData},
      },
      {
        ...baseRequestEvent,
        name: 'ResourceFinish',
        ts: toMicroseconds(endTime),
        args: {data: resourceFinishData},
      },
    ];

    if (!record.failed) {
      events.push({
        ...baseRequestEvent,
        name: 'ResourceReceiveResponse',
        ts: toMicroseconds((startTime + endTime) / 2),
        args: {data: receiveResponseData},
      });
    }

    return events;
  }
}

module.exports = {
  simulationNamesToIgnore: [
    'unlabeled',
    // These node timings should be nearly identical to the ones produced for Interactive
    'optimisticSpeedIndex',
    'optimisticFlexSpeedIndex',
    'pessimisticSpeedIndex',
  ],
  convertNodeTimingsToTrace,
};

},{}],100:[function(require,module,exports){
module.exports={
  "moment": {
    "repository": "https://github.com/moment/moment.git",
    "lastScraped": 1597344573775,
    "versions": {
      "latest": {
        "gzip": 72054
      },
      "2.25.3": {
        "gzip": 71090
      },
      "2.25.2": {
        "gzip": 71119
      },
      "2.25.1": {
        "gzip": 20811
      },
      "2.25.0": {
        "gzip": 20876
      },
      "2.24.0": {
        "gzip": 67489
      },
      "2.23.0": {
        "gzip": 66675
      },
      "2.22.2": {
        "gzip": 65962
      },
      "2.22.1": {
        "gzip": 65949
      }
    }
  },
  "date-fns": {
    "repository": "https://github.com/date-fns/date-fns.git",
    "lastScraped": 1597344603463,
    "versions": {
      "latest": {
        "gzip": 18463
      }
    }
  },
  "luxon": {
    "repository": "https://github.com/moment/luxon.git",
    "lastScraped": 1597344608583,
    "versions": {
      "latest": {
        "gzip": 20912
      }
    }
  },
  "dayjs": {
    "repository": "https://github.com/iamkun/dayjs.git",
    "lastScraped": 1597344613371,
    "versions": {
      "latest": {
        "gzip": 2856
      }
    }
  }
}
},{}],101:[function(require,module,exports){
/**
 * @license Copyright 2020 The Lighthouse Authors. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.
 */

/**
 * @fileoverview This file contains a mapping of large JavaScript libraries to smaller alternatives.
 * These suggestions have been cherry-picked from BundlePhobia's open-source list of recommendations which can be found here (https://github.com/pastelsky/bundlephobia/blob/b244a53bc55af067bb0edfa3ace867c87fec17e7/server/middlewares/similar-packages/fixtures.js).
 */

'use strict';

/** @type {Record<string, string[]>} */
const suggestions = {
  // general-purpose-date-time
  'moment': ['date-fns', 'luxon', 'dayjs'],
};

module.exports = {suggestions};

},{}],102:[function(require,module,exports){
(function (process){(function (){
/**
 * @license Copyright 2020 The Lighthouse Authors. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.
 */
'use strict';

module.exports = {
  // NODE_ENV is set to test by jest and by smokehouse CLI runner
  // CI as a catchall for everything we do in GitHub Actions
  isUnderTest: !!process.env.CI || process.env.NODE_ENV === 'test',
};

}).call(this)}).call(this,require('_process'))
},{"_process":223}],103:[function(require,module,exports){
(function (__filename){(function (){
/**
 * @license Copyright 2018 The Lighthouse Authors. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.
 */
'use strict';

const i18n = require('./i18n/i18n.js');

/* eslint-disable max-len */
const UIStrings = {
  /**
   * @description Error message explaining that the Lighthouse run was not able to collect screenshots through Chrome.
   * @example {NO_SPEEDLINE_FRAMES} errorCode
   * */
  didntCollectScreenshots: `Chrome didn't collect any screenshots during the page load. Please make sure there is content visible on the page, and then try re-running Lighthouse. ({errorCode})`,
  /**
   * @description Error message explaining that the performance trace was not able to be recorded for the Lighthouse run.
   * @example {NO_TRACING_STARTED} errorCode
   * */
  badTraceRecording: 'Something went wrong with recording the trace over your page load. Please run Lighthouse again. ({errorCode})',
  /**
   * @description Error message explaining that the First Contentful Paint metric was not seen during the page load.
   * @example {NO_FCP} errorCode
   * */
  noFcp: 'The page did not paint any content. Please ensure you keep the browser window in the foreground during the load and try again. ({errorCode})',
  /**
   * @description Error message explaining that the page loaded too slowly to perform a Lighthouse run.
   * @example {NO_TTI_CPU_IDLE_PERIOD} errorCode
   * */
  pageLoadTookTooLong: 'Your page took too long to load. Please follow the opportunities in the report to reduce your page load time, and then try re-running Lighthouse. ({errorCode})',
  /** Error message explaining that Lighthouse could not load the requested URL and the steps that might be taken to fix the unreliability. */
  pageLoadFailed: 'Lighthouse was unable to reliably load the page you requested. Make sure you are testing the correct URL and that the server is properly responding to all requests.',
  /**
   * @description Error message explaining that Lighthouse could not load the requested URL and the steps that might be taken to fix the unreliability.
   * @example {404} statusCode
   * */
  pageLoadFailedWithStatusCode: 'Lighthouse was unable to reliably load the page you requested. Make sure you are testing the correct URL and that the server is properly responding to all requests. (Status code: {statusCode})',
  /**
   * @description Error message explaining that Lighthouse could not load the requested URL and the steps that might be taken to fix the unreliability.
   * @example {FAILED_DOCUMENT_REQUEST} errorDetails
   * */
  pageLoadFailedWithDetails: 'Lighthouse was unable to reliably load the page you requested. Make sure you are testing the correct URL and that the server is properly responding to all requests. (Details: {errorDetails})',
  /**
   * @description Error message explaining that the security certificate of the page Lighthouse observed was invalid, so the URL cannot be accessed. securityMessages will be replaced with one or more strings from the browser explaining what was insecure about the page load.
   * @example {net::ERR_CERT_DATE_INVALID} securityMessages
   * */
  pageLoadFailedInsecure: 'The URL you have provided does not have a valid security certificate. {securityMessages}',
  /** Error message explaining that Chrome prevented the page from loading and displayed an interstitial screen instead, so the URL cannot be accessed. */
  pageLoadFailedInterstitial: 'Chrome prevented page load with an interstitial. Make sure you are testing the correct URL and that the server is properly responding to all requests.',
  /** Error message explaining that Chrome has encountered an error during the Lighthouse run, and that Chrome should be restarted. */
  internalChromeError: 'An internal Chrome error occurred. Please restart Chrome and try re-running Lighthouse.',
  /** Error message explaining that fetching the resources of the webpage has taken longer than the maximum time. */
  requestContentTimeout: 'Fetching resource content has exceeded the allotted time',
  /**
   * @description Error message explaining that the webpage is non-HTML, so audits are ill-defined.
   * @example {application/xml} mimeType
   * */
  notHtml: 'The page provided is not HTML (served as MIME type {mimeType}).',
  /** Error message explaining that the provided URL Lighthouse points to is not valid, and cannot be loaded. */
  urlInvalid: 'The URL you have provided appears to be invalid.',
  /**
   * @description Error message explaining that the Chrome Devtools protocol has exceeded the maximum timeout allowed.
   * @example {Network.enable} protocolMethod
   * */
  protocolTimeout: 'Waiting for DevTools protocol response has exceeded the allotted time. (Method: {protocolMethod})',
  /** Error message explaining that the requested page could not be resolved by the DNS server. */
  dnsFailure: 'DNS servers could not resolve the provided domain.',
  /** Error message explaining that Lighthouse couldn't complete because the page has stopped responding to its instructions. */
  pageLoadFailedHung: 'Lighthouse was unable to reliably load the URL you requested because the page stopped responding.',
  /** Error message explaining that Lighthouse timed out while waiting for the initial connection to the Chrome Devtools protocol. */
  criTimeout: 'Timeout waiting for initial Debugger Protocol connection.',
  /**
   * @description Error message explaining that a resource that was required for testing was never collected. "artifactName" will be replaced with the name of the resource that wasn't collected.
   * @example {WebAppManifest} artifactName
   * */
  missingRequiredArtifact: 'Required {artifactName} gatherer did not run.',
  /**
   * @description Error message explaining that there was an error while trying to collect a resource that was required for testing. "artifactName" will be replaced with the name of the resource that wasn't collected; "errorMessage" will be replaced with a string description of the error that occurred.
   * @example {WebAppManifest} artifactName
   * @example {Manifest invalid} errorMessage
   * */
  erroredRequiredArtifact: 'Required {artifactName} gatherer encountered an error: {errorMessage}',

  /**
   * @description Error message explaining that a feature is unavailable due to an old version of Chrome. "featureName" will be replaced by the name of the feature which is not supported.
   * @example {Largest Contentful Paint} featureName
   * */
  oldChromeDoesNotSupportFeature: 'This version of Chrome is too old to support \'{featureName}\'. Use a newer version to see full results.',
};

const str_ = i18n.createMessageInstanceIdFn(__filename, UIStrings);


/**
 * @typedef LighthouseErrorDefinition
 * @property {string} code
 * @property {string} message
 * @property {RegExp} [pattern]
 * @property {boolean} [lhrRuntimeError] True if it should appear in the top-level LHR.runtimeError property.
 */

const LHERROR_SENTINEL = '__LighthouseErrorSentinel';
const ERROR_SENTINEL = '__ErrorSentinel';
/**
 * @typedef {{sentinel: '__LighthouseErrorSentinel', code: string, stack?: string, [p: string]: string|undefined}} SerializedLighthouseError
 * @typedef {{sentinel: '__ErrorSentinel', message: string, code?: string, stack?: string}} SerializedBaseError
 */

class LighthouseError extends Error {
  /**
   * @param {LighthouseErrorDefinition} errorDefinition
   * @param {Record<string, string|undefined>=} properties
   */
  constructor(errorDefinition, properties) {
    super(errorDefinition.code);
    this.name = 'LHError';
    this.code = errorDefinition.code;
    // Add additional properties to be ICU replacements in the error string.
    // `code` is always added as `errorCode` so callers don't need to specify the code multiple times.
    this.friendlyMessage = str_(errorDefinition.message, {errorCode: this.code, ...properties});
    this.lhrRuntimeError = !!errorDefinition.lhrRuntimeError;
    if (properties) Object.assign(this, properties);

    Error.captureStackTrace(this, LighthouseError);
  }

  /**
   * @param {string} method
   * @param {{message: string, data?: string|undefined}} protocolError
   * @return {Error|LighthouseError}
   */
  static fromProtocolMessage(method, protocolError) {
    // extract all errors with a regex pattern to match against.
    // if we find one, use the friendly LighthouseError definition
    const matchedErrorDefinition = Object.values(LighthouseError.errors)
      .filter(e => e.pattern)
      .find(e => e.pattern && e.pattern.test(protocolError.message));
    if (matchedErrorDefinition) {
      return new LighthouseError(matchedErrorDefinition);
    }

    // otherwise fallback to building a generic Error
    let errMsg = `(${method}): ${protocolError.message}`;
    if (protocolError.data) errMsg += ` (${protocolError.data})`;
    const error = new Error(`Protocol error ${errMsg}`);
    return Object.assign(error, {protocolMethod: method, protocolError: protocolError.message});
  }

  /**
   * A JSON.stringify replacer to serialize LHErrors and (as a fallback) Errors.
   * Returns a simplified version of the error object that can be reconstituted
   * as a copy of the original error at parse time.
   * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON/stringify#The_replacer_parameter
   * @param {Error|LighthouseError} err
   * @return {SerializedBaseError|SerializedLighthouseError}
   */
  static stringifyReplacer(err) {
    if (err instanceof LighthouseError) {
      // Remove class props so that remaining values were what was passed in as `properties`.
      // eslint-disable-next-line no-unused-vars
      const {name, code, message, friendlyMessage, lhrRuntimeError, stack, ...properties} = err;

      return {
        sentinel: LHERROR_SENTINEL,
        code,
        stack,
        ...properties,
      };
    }

    // Unexpected errors won't be LHErrors, but we want them serialized as well.
    if (err instanceof Error) {
      const {message, stack} = err;
      // @ts-expect-error - code can be helpful for e.g. node errors, so preserve it if it's present.
      const code = err.code;
      return {
        sentinel: ERROR_SENTINEL,
        message,
        code,
        stack,
      };
    }

    throw new Error('Invalid value for LHError stringification');
  }

  /**
   * A JSON.parse reviver. If any value passed in is a serialized Error or
   * LHError, the error is recreated as the original object. Otherwise, the
   * value is passed through unchanged.
   * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON/parse#Using_the_reviver_parameter
   * @param {string} key
   * @param {any} possibleError
   * @return {any}
   */
  static parseReviver(key, possibleError) {
    if (typeof possibleError === 'object' && possibleError !== null) {
      if (possibleError.sentinel === LHERROR_SENTINEL) {
        // Include sentinel in destructuring so it doesn't end up in `properties`.
        // eslint-disable-next-line no-unused-vars
        const {sentinel, code, stack, ...properties} = /** @type {SerializedLighthouseError} */ (possibleError);
        const errorDefinition = LighthouseError.errors[/** @type {keyof typeof ERRORS} */ (code)];
        const lhError = new LighthouseError(errorDefinition, properties);
        lhError.stack = stack;

        return lhError;
      }

      if (possibleError.sentinel === ERROR_SENTINEL) {
        const {message, code, stack} = /** @type {SerializedBaseError} */ (possibleError);
        const error = new Error(message);
        Object.assign(error, {code, stack});
        return error;
      }
    }

    return possibleError;
  }
}

const ERRORS = {
  // Screenshot/speedline errors
  NO_SPEEDLINE_FRAMES: {
    code: 'NO_SPEEDLINE_FRAMES',
    message: UIStrings.didntCollectScreenshots,
    lhrRuntimeError: true,
  },
  SPEEDINDEX_OF_ZERO: {
    code: 'SPEEDINDEX_OF_ZERO',
    message: UIStrings.didntCollectScreenshots,
    lhrRuntimeError: true,
  },
  NO_SCREENSHOTS: {
    code: 'NO_SCREENSHOTS',
    message: UIStrings.didntCollectScreenshots,
    lhrRuntimeError: true,
  },
  INVALID_SPEEDLINE: {
    code: 'INVALID_SPEEDLINE',
    message: UIStrings.didntCollectScreenshots,
    lhrRuntimeError: true,
  },

  // Trace parsing errors
  NO_TRACING_STARTED: {
    code: 'NO_TRACING_STARTED',
    message: UIStrings.badTraceRecording,
    lhrRuntimeError: true,
  },
  NO_RESOURCE_REQUEST: {
    code: 'NO_RESOURCE_REQUEST',
    message: UIStrings.badTraceRecording,
    lhrRuntimeError: true,
  },
  NO_NAVSTART: {
    code: 'NO_NAVSTART',
    message: UIStrings.badTraceRecording,
    lhrRuntimeError: true,
  },
  NO_FCP: {
    code: 'NO_FCP',
    message: UIStrings.noFcp,
    lhrRuntimeError: true,
  },
  NO_DCL: {
    code: 'NO_DCL',
    message: UIStrings.badTraceRecording,
    lhrRuntimeError: true,
  },
  NO_FMP: {
    code: 'NO_FMP',
    message: UIStrings.badTraceRecording,
  },
  NO_LCP: {
    code: 'NO_LCP',
    message: UIStrings.badTraceRecording,
  },
  NO_LCP_ALL_FRAMES: {
    code: 'NO_LCP_ALL_FRAMES',
    message: UIStrings.badTraceRecording,
  },
  UNSUPPORTED_OLD_CHROME: {
    code: 'UNSUPPORTED_OLD_CHROME',
    message: UIStrings.oldChromeDoesNotSupportFeature,
  },

  // TTI calculation failures
  NO_TTI_CPU_IDLE_PERIOD: {code: 'NO_TTI_CPU_IDLE_PERIOD', message: UIStrings.pageLoadTookTooLong},
  NO_TTI_NETWORK_IDLE_PERIOD: {
    code: 'NO_TTI_NETWORK_IDLE_PERIOD',
    message: UIStrings.pageLoadTookTooLong,
  },

  // Page load failures
  NO_DOCUMENT_REQUEST: {
    code: 'NO_DOCUMENT_REQUEST',
    message: UIStrings.pageLoadFailed,
    lhrRuntimeError: true,
  },
  /* Used when DevTools reports loading failed. Usually an internal (Chrome) issue.
   * Requries an additional `errorDetails` field for translation.
   */
  FAILED_DOCUMENT_REQUEST: {
    code: 'FAILED_DOCUMENT_REQUEST',
    message: UIStrings.pageLoadFailedWithDetails,
    lhrRuntimeError: true,
  },
  /* Used when status code is 4xx or 5xx.
   * Requires an additional `statusCode` field for translation.
   */
  ERRORED_DOCUMENT_REQUEST: {
    code: 'ERRORED_DOCUMENT_REQUEST',
    message: UIStrings.pageLoadFailedWithStatusCode,
    lhrRuntimeError: true,
  },
  /* Used when security error prevents page load.
   * Requires an additional `securityMessages` field for translation.
   */
  INSECURE_DOCUMENT_REQUEST: {
    code: 'INSECURE_DOCUMENT_REQUEST',
    message: UIStrings.pageLoadFailedInsecure,
    lhrRuntimeError: true,
  },
  /* Used when any Chrome interstitial error prevents page load.
   */
  CHROME_INTERSTITIAL_ERROR: {
    code: 'CHROME_INTERSTITIAL_ERROR',
    message: UIStrings.pageLoadFailedInterstitial,
    lhrRuntimeError: true,
  },
  /* Used when the page stopped responding and did not finish loading. */
  PAGE_HUNG: {
    code: 'PAGE_HUNG',
    message: UIStrings.pageLoadFailedHung,
    lhrRuntimeError: true,
  },
  /* Used when the page is non-HTML. */
  NOT_HTML: {
    code: 'NOT_HTML',
    message: UIStrings.notHtml,
    lhrRuntimeError: true,
  },

  // Protocol internal failures
  TRACING_ALREADY_STARTED: {
    code: 'TRACING_ALREADY_STARTED',
    message: UIStrings.internalChromeError,
    pattern: /Tracing.*started/,
    lhrRuntimeError: true,
  },
  PARSING_PROBLEM: {
    code: 'PARSING_PROBLEM',
    message: UIStrings.internalChromeError,
    pattern: /Parsing problem/,
    lhrRuntimeError: true,
  },
  READ_FAILED: {
    code: 'READ_FAILED',
    message: UIStrings.internalChromeError,
    pattern: /Read failed/,
    lhrRuntimeError: true,
  },

  // URL parsing failures
  INVALID_URL: {
    code: 'INVALID_URL',
    message: UIStrings.urlInvalid,
  },

  /* Protocol timeout failures
   * Requires an additional `protocolMethod` field for translation.
   */
  PROTOCOL_TIMEOUT: {
    code: 'PROTOCOL_TIMEOUT',
    message: UIStrings.protocolTimeout,
    lhrRuntimeError: true,
  },

  // DNS failure on main document (no resolution, timed out, etc)
  DNS_FAILURE: {
    code: 'DNS_FAILURE',
    message: UIStrings.dnsFailure,
    lhrRuntimeError: true,
  },

  /** A timeout in the initial connection to the debugger protocol. */
  CRI_TIMEOUT: {
    code: 'CRI_TIMEOUT',
    message: UIStrings.criTimeout,
    lhrRuntimeError: true,
  },

  /**
   * Error internal to Runner used when an artifact required for an audit is missing.
   * Requires an additional `artifactName` field for translation.
  */
  MISSING_REQUIRED_ARTIFACT: {
    code: 'MISSING_REQUIRED_ARTIFACT',
    message: UIStrings.missingRequiredArtifact,
  },

  /**
   * Error internal to Runner used when an artifact required for an audit was an error.
   * Requires additional `artifactName` and `errorMessage` fields for translation.
  */
  ERRORED_REQUIRED_ARTIFACT: {
    code: 'ERRORED_REQUIRED_ARTIFACT',
    message: UIStrings.erroredRequiredArtifact,
  },

  // Hey! When adding a new error type, update lighthouse-result.proto too.
  // Only necessary for runtime errors, which come from artifacts or pageLoadErrors.
};

/** @type {Record<keyof typeof ERRORS, LighthouseErrorDefinition>} */
LighthouseError.errors = ERRORS;
LighthouseError.NO_ERROR = 'NO_ERROR';
LighthouseError.UNKNOWN_ERROR = 'UNKNOWN_ERROR';
module.exports = LighthouseError;
module.exports.UIStrings = UIStrings;

}).call(this)}).call(this,"/lighthouse-core/lib/lh-error.js")
},{"./i18n/i18n.js":96}],104:[function(require,module,exports){
/**
 * @license Copyright 2021 The Lighthouse Authors. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.
 */
'use strict';

const LHError = require('../lib/lh-error.js');
const TraceProcessor = require('../lib/tracehouse/trace-processor.js');

// TraceProcessor throws generic errors, but we'd like our special localized and code-specific LHError
// objects to be thrown instead.
class LHTraceProcessor extends TraceProcessor {
  /**
   * @return {Error}
   */
  static createNoNavstartError() {
    return new LHError(LHError.errors.NO_NAVSTART);
  }

  /**
   * This isn't currently used, but will be when the time origin of trace processing is changed.
   * @see {TraceProcessor.computeTimeOrigin}
   * @see https://github.com/GoogleChrome/lighthouse/pull/11253#discussion_r507985527
   * @return {Error}
   */
  static createNoResourceSendRequestError() {
    return new LHError(LHError.errors.NO_RESOURCE_REQUEST);
  }

  /**
   * @return {Error}
   */
  static createNoTracingStartedError() {
    return new LHError(LHError.errors.NO_TRACING_STARTED);
  }

  /**
   * @return {Error}
   */
  static createNoFirstContentfulPaintError() {
    return new LHError(LHError.errors.NO_FCP);
  }
}

module.exports = LHTraceProcessor;

},{"../lib/lh-error.js":103,"../lib/tracehouse/trace-processor.js":119}],105:[function(require,module,exports){
/**
 * @license Copyright 2016 The Lighthouse Authors. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.
 */
'use strict';

const URL = require('./url-shim.js');
const cssParsers = require('cssstyle/lib/parsers');

const ALLOWED_DISPLAY_VALUES = [
  'fullscreen',
  'standalone',
  'minimal-ui',
  'browser',
];
/**
 * All display-mode fallbacks, including when unset, lead to default display mode 'browser'.
 * @see https://www.w3.org/TR/2016/WD-appmanifest-20160825/#dfn-default-display-mode
 */
const DEFAULT_DISPLAY_MODE = 'browser';

const ALLOWED_ORIENTATION_VALUES = [
  'any',
  'natural',
  'landscape',
  'portrait',
  'portrait-primary',
  'portrait-secondary',
  'landscape-primary',
  'landscape-secondary',
];

/**
 * @param {string} color
 * @return {boolean}
 */
function isValidColor(color) {
  return cssParsers.valueType(color) === cssParsers.TYPES.COLOR;
}

/**
 * @param {*} raw
 * @param {boolean=} trim
 */
function parseString(raw, trim) {
  let value;
  let warning;

  if (typeof raw === 'string') {
    value = trim ? raw.trim() : raw;
  } else {
    if (raw !== undefined) {
      warning = 'ERROR: expected a string.';
    }
    value = undefined;
  }

  return {
    raw,
    value,
    warning,
  };
}

/**
 * @param {*} raw
 */
function parseColor(raw) {
  const color = parseString(raw);

  // Finished if color missing or not a string.
  if (color.value === undefined) {
    return color;
  }

  // Use color parser to check CSS3 Color parsing.
  if (!isValidColor(color.raw)) {
    color.value = undefined;
    color.warning = 'ERROR: color parsing failed.';
  }

  return color;
}

/**
 * @param {*} jsonInput
 */
function parseName(jsonInput) {
  return parseString(jsonInput.name, true);
}

/**
 * @param {*} jsonInput
 */
function parseShortName(jsonInput) {
  return parseString(jsonInput.short_name, true);
}

/**
 * Returns whether the urls are of the same origin. See https://html.spec.whatwg.org/#same-origin
 * @param {string} url1
 * @param {string} url2
 * @return {boolean}
 */
function checkSameOrigin(url1, url2) {
  const parsed1 = new URL(url1);
  const parsed2 = new URL(url2);

  return parsed1.origin === parsed2.origin;
}

/**
 * https://www.w3.org/TR/2016/WD-appmanifest-20160825/#start_url-member
 * @param {*} jsonInput
 * @param {string} manifestUrl
 * @param {string} documentUrl
 * @return {{raw: any, value: string, warning?: string}}
 */
function parseStartUrl(jsonInput, manifestUrl, documentUrl) {
  const raw = jsonInput.start_url;

  // 8.10(3) - discard the empty string and non-strings.
  if (raw === '') {
    return {
      raw,
      value: documentUrl,
      warning: 'ERROR: start_url string empty',
    };
  }
  if (raw === undefined) {
    return {
      raw,
      value: documentUrl,
    };
  }
  if (typeof raw !== 'string') {
    return {
      raw,
      value: documentUrl,
      warning: 'ERROR: expected a string.',
    };
  }

  // 8.10(4) - construct URL with raw as input and manifestUrl as the base.
  let startUrl;
  try {
    startUrl = new URL(raw, manifestUrl).href;
  } catch (e) {
    // 8.10(5) - discard invalid URLs.
    return {
      raw,
      value: documentUrl,
      warning: `ERROR: invalid start_url relative to ${manifestUrl}`,
    };
  }

  // 8.10(6) - discard start_urls that are not same origin as documentUrl.
  if (!checkSameOrigin(startUrl, documentUrl)) {
    return {
      raw,
      value: documentUrl,
      warning: 'ERROR: start_url must be same-origin as document',
    };
  }

  return {
    raw,
    value: startUrl,
  };
}

/**
 * @param {*} jsonInput
 */
function parseDisplay(jsonInput) {
  const parsedString = parseString(jsonInput.display, true);
  const stringValue = parsedString.value;

  if (!stringValue) {
    return {
      raw: jsonInput,
      value: DEFAULT_DISPLAY_MODE,
      warning: parsedString.warning,
    };
  }

  const displayValue = stringValue.toLowerCase();
  if (!ALLOWED_DISPLAY_VALUES.includes(displayValue)) {
    return {
      raw: jsonInput,
      value: DEFAULT_DISPLAY_MODE,
      warning: 'ERROR: \'display\' has invalid value ' + displayValue +
        `. will fall back to ${DEFAULT_DISPLAY_MODE}.`,
    };
  }

  return {
    raw: jsonInput,
    value: displayValue,
    warning: undefined,
  };
}

/**
 * @param {*} jsonInput
 */
function parseOrientation(jsonInput) {
  const orientation = parseString(jsonInput.orientation, true);

  if (orientation.value &&
      !ALLOWED_ORIENTATION_VALUES.includes(orientation.value.toLowerCase())) {
    orientation.value = undefined;
    orientation.warning = 'ERROR: \'orientation\' has an invalid value, will be ignored.';
  }

  return orientation;
}

/**
 * @see https://www.w3.org/TR/2016/WD-appmanifest-20160825/#src-member
 * @param {*} raw
 * @param {string} manifestUrl
 */
function parseIcon(raw, manifestUrl) {
  // 9.4(3)
  const src = parseString(raw.src, true);
  // 9.4(4) - discard if trimmed value is the empty string.
  if (src.value === '') {
    src.value = undefined;
  }
  if (src.value) {
    try {
      // 9.4(4) - construct URL with manifest URL as the base
      src.value = new URL(src.value, manifestUrl).href;
    } catch (_) {
      // 9.4 "This algorithm will return a URL or undefined."
      src.warning = `ERROR: invalid icon url will be ignored: '${raw.src}'`;
      src.value = undefined;
    }
  }

  const type = parseString(raw.type, true);

  const parsedPurpose = parseString(raw.purpose);
  const purpose = {
    raw: raw.purpose,
    value: ['any'],
    /** @type {string|undefined} */
    warning: undefined,
  };
  if (parsedPurpose.value !== undefined) {
    purpose.value = parsedPurpose.value.split(/\s+/).map(value => value.toLowerCase());
  }

  const density = {
    raw: raw.density,
    value: 1,
    /** @type {string|undefined} */
    warning: undefined,
  };
  if (density.raw !== undefined) {
    density.value = parseFloat(density.raw);
    if (isNaN(density.value) || !isFinite(density.value) || density.value <= 0) {
      density.value = 1;
      density.warning = 'ERROR: icon density cannot be NaN, +∞, or less than or equal to +0.';
    }
  }

  let sizes;
  const parsedSizes = parseString(raw.sizes);
  if (parsedSizes.value !== undefined) {
    /** @type {Set<string>} */
    const set = new Set();
    parsedSizes.value.trim().split(/\s+/).forEach(size => set.add(size.toLowerCase()));
    sizes = {
      raw: raw.sizes,
      value: set.size > 0 ? Array.from(set) : undefined,
      warning: undefined,
    };
  } else {
    sizes = {...parsedSizes, value: undefined};
  }

  return {
    raw,
    value: {
      src,
      type,
      density,
      sizes,
      purpose,
    },
    warning: undefined,
  };
}

/**
 * @param {*} jsonInput
 * @param {string} manifestUrl
 */
function parseIcons(jsonInput, manifestUrl) {
  const raw = jsonInput.icons;

  if (raw === undefined) {
    return {
      raw,
      /** @type {Array<ReturnType<typeof parseIcon>>} */
      value: [],
      warning: undefined,
    };
  }

  if (!Array.isArray(raw)) {
    return {
      raw,
      /** @type {Array<ReturnType<typeof parseIcon>>} */
      value: [],
      warning: 'ERROR: \'icons\' expected to be an array but is not.',
    };
  }

  const parsedIcons = raw
    // 9.6(3)(1)
    .filter(icon => icon.src !== undefined)
    // 9.6(3)(2)(1)
    .map(icon => parseIcon(icon, manifestUrl));

  // NOTE: we still lose the specific message on these icons, but it's not possible to surface them
  // without a massive change to the structure and paradigms of `manifest-parser`.
  const ignoredIconsWithWarnings = parsedIcons
    .filter(icon => {
      const possibleWarnings = [icon.warning, icon.value.type.warning, icon.value.src.warning,
        icon.value.sizes.warning, icon.value.density.warning].filter(Boolean);
      const hasSrc = !!icon.value.src.value;
      return !!possibleWarnings.length && !hasSrc;
    });

  const value = parsedIcons
    // 9.6(3)(2)(2)
    .filter(parsedIcon => parsedIcon.value.src.value !== undefined);

  return {
    raw,
    value,
    warning: ignoredIconsWithWarnings.length ?
      'WARNING: Some icons were ignored due to warnings.' : undefined,
  };
}

/**
 * @param {*} raw
 */
function parseApplication(raw) {
  const platform = parseString(raw.platform, true);
  const id = parseString(raw.id, true);

  // 10.2.(2) and 10.2.(3)
  const appUrl = parseString(raw.url, true);
  if (appUrl.value) {
    try {
      // 10.2.(4) - attempt to construct URL.
      appUrl.value = new URL(appUrl.value).href;
    } catch (e) {
      appUrl.value = undefined;
      appUrl.warning = `ERROR: invalid application URL ${raw.url}`;
    }
  }

  return {
    raw,
    value: {
      platform,
      id,
      url: appUrl,
    },
    warning: undefined,
  };
}

/**
 * @param {*} jsonInput
 */
function parseRelatedApplications(jsonInput) {
  const raw = jsonInput.related_applications;

  if (raw === undefined) {
    return {
      raw,
      value: undefined,
      warning: undefined,
    };
  }

  if (!Array.isArray(raw)) {
    return {
      raw,
      value: undefined,
      warning: 'ERROR: \'related_applications\' expected to be an array but is not.',
    };
  }

  // TODO(bckenny): spec says to skip apps missing `platform`, so debug messages
  // on individual apps are lost. Warn instead?
  const value = raw
    .filter(application => !!application.platform)
    .map(parseApplication)
    .filter(parsedApp => !!parsedApp.value.id.value || !!parsedApp.value.url.value);

  return {
    raw,
    value,
    warning: undefined,
  };
}

/**
 * @param {*} jsonInput
 */
function parsePreferRelatedApplications(jsonInput) {
  const raw = jsonInput.prefer_related_applications;
  let value;
  let warning;

  if (typeof raw === 'boolean') {
    value = raw;
  } else {
    if (raw !== undefined) {
      warning = 'ERROR: \'prefer_related_applications\' expected to be a boolean.';
    }
    value = undefined;
  }

  return {
    raw,
    value,
    warning,
  };
}

/**
 * @param {*} jsonInput
 */
function parseThemeColor(jsonInput) {
  return parseColor(jsonInput.theme_color);
}

/**
 * @param {*} jsonInput
 */
function parseBackgroundColor(jsonInput) {
  return parseColor(jsonInput.background_color);
}

/**
 * Parse a manifest from the given inputs.
 * @param {string} string Manifest JSON string.
 * @param {string} manifestUrl URL of manifest file.
 * @param {string} documentUrl URL of document containing manifest link element.
 */
function parse(string, manifestUrl, documentUrl) {
  if (manifestUrl === undefined || documentUrl === undefined) {
    throw new Error('Manifest and document URLs required for manifest parsing.');
  }

  let jsonInput;

  try {
    jsonInput = JSON.parse(string);
  } catch (e) {
    return {
      raw: string,
      value: undefined,
      warning: 'ERROR: file isn\'t valid JSON: ' + e,
      url: manifestUrl,
    };
  }

  /* eslint-disable camelcase */
  const manifest = {
    name: parseName(jsonInput),
    short_name: parseShortName(jsonInput),
    start_url: parseStartUrl(jsonInput, manifestUrl, documentUrl),
    display: parseDisplay(jsonInput),
    orientation: parseOrientation(jsonInput),
    icons: parseIcons(jsonInput, manifestUrl),
    related_applications: parseRelatedApplications(jsonInput),
    prefer_related_applications: parsePreferRelatedApplications(jsonInput),
    theme_color: parseThemeColor(jsonInput),
    background_color: parseBackgroundColor(jsonInput),
  };
  /* eslint-enable camelcase */

  /** @type {string|undefined} */
  let manifestUrlWarning;
  try {
    const manifestUrlParsed = new URL(manifestUrl);
    if (!manifestUrlParsed.protocol.startsWith('http')) {
      manifestUrlWarning = `WARNING: manifest URL not available over a valid network protocol`;
    }
  } catch (_) {
    manifestUrlWarning = `ERROR: invalid manifest URL: '${manifestUrl}'`;
  }

  return {
    raw: string,
    value: manifest,
    warning: manifestUrlWarning,
    url: manifestUrl,
  };
}

module.exports = parse;

},{"./url-shim.js":"url","cssstyle/lib/parsers":160}],106:[function(require,module,exports){
/**
 * @license Copyright 2018 The Lighthouse Authors. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.
 */
'use strict';

// https://www.ecma-international.org/ecma-262/9.0/index.html#sec-punctuators
// eslint-disable-next-line max-len
const PUNCTUATOR_REGEX = /(return|case|{|\(|\[|\.\.\.|;|,|<|>|<=|>=|==|!=|===|!==|\+|-|\*|%|\*\*|\+\+|--|<<|>>|>>>|&|\||\^|!|~|&&|\|\||\?|:|=|\+=|-=|\*=|%=|\*\*=|<<=|>>=|>>>=|&=|\|=|\^=|=>|\/|\/=|\})$/;
const WHITESPACE_REGEX = /( |\n|\t)+$/;

/**
 * Look backwards from `startPosition` in `content` for an ECMAScript punctuator.
 * This is used to differentiate a RegExp from a divide statement.
 * If a punctuator immediately precedes a lone `/`, the `/` must be the start of a RegExp.
 *
 * @param {string} content
 * @param {number} startPosition
 */
function hasPunctuatorBefore(content, startPosition) {
  for (let i = startPosition; i > 0; i--) {
    // Try to grab at least 6 characters so we can check for `return`
    const sliceStart = Math.max(0, i - 6);
    const precedingCharacters = content.slice(sliceStart, i);
    // Skip over any ending whitespace
    if (WHITESPACE_REGEX.test(precedingCharacters)) continue;
    // Check if it's a punctuator
    return PUNCTUATOR_REGEX.test(precedingCharacters);
  }

  // The beginning of the content counts too for our purposes.
  // i.e. a script can't start with a divide symbol
  return true;
}


/**
 *
 * @param {string} content
 * @param {{singlelineComments: boolean, regex: boolean}} features
 */
function computeTokenLength(content, features) {
  let totalTokenLength = 0;
  let isInSinglelineComment = false;
  let isInMultilineComment = false;
  let isInLicenseComment = false;
  let isInString = false;
  let isInRegex = false;
  let isInRegexCharacterClass = false;
  let stringOpenChar = null;

  /**
   * Acts as stack for brace tracking.
   * @type {('templateBrace'|'normalBrace')[]}
   */
  const templateLiteralDepth = [];

  for (let i = 0; i < content.length; i++) {
    const twoChars = content.substr(i, 2);
    const char = twoChars.charAt(0);

    const isWhitespace = char === ' ' || char === '\n' || char === '\t';
    const isAStringOpenChar = char === `'` || char === '"' || char === '`';

    if (isInSinglelineComment) {
      if (char === '\n') {
        // End the comment when you hit a newline
        isInSinglelineComment = false;
      }
    } else if (isInMultilineComment) {
      // License comments count
      if (isInLicenseComment) totalTokenLength++;

      if (twoChars === '*/') {
        // License comments count, account for the '/' character we're skipping over
        if (isInLicenseComment) totalTokenLength++;
        // End the comment when we hit the closing sequence
        isInMultilineComment = false;
        // Skip over the '/' character since we've already processed it
        i++;
      }
    } else if (isInString) {
      // String characters count
      totalTokenLength++;

      if (stringOpenChar === '`' && twoChars === '${') {
        // Start new template literal
        templateLiteralDepth.push('templateBrace');
        isInString = false;
        totalTokenLength++;
        i++;
      } else if (char === '\\') {
        // Skip over any escaped characters
        totalTokenLength++;
        i++;
      } else if (char === stringOpenChar) {
        // End the string when we hit the same stringOpenCharacter
        isInString = false;
        // console.log(i, 'exiting string', stringOpenChar)
      }
    } else if (isInRegex) {
      // Regex characters count
      totalTokenLength++;

      if (char === '\\') {
        // Skip over any escaped characters
        totalTokenLength++;
        i++;
      } else if (char === '[') {
        // Register that we're entering a character class so we don't leave the regex prematurely
        isInRegexCharacterClass = true;
      } else if (char === ']' && isInRegexCharacterClass) {
        // Register that we're exiting the character class
        isInRegexCharacterClass = false;
      } else if (char === '/' && !isInRegexCharacterClass) {
        // End the string when we hit the regex close character
        isInRegex = false;
        // console.log(i, 'leaving regex', char)
      }
    } else {
      // We're not in any particular token mode, look for the start of different
      if (twoChars === '/*') {
        // Start the multi-line comment
        isInMultilineComment = true;
        // Check if it's a license comment so we know whether to count it
        isInLicenseComment = content.charAt(i + 2) === '!';
        // += 2 because we are processing 2 characters, not just 1
        if (isInLicenseComment) totalTokenLength += 2;
        // Skip over the '*' character since we've already processed it
        i++;
      } else if (twoChars === '//' && features.singlelineComments) {
        // Start the single-line comment
        isInSinglelineComment = true;
        isInMultilineComment = false;
        isInLicenseComment = false;
        // Skip over the second '/' character since we've already processed it
        i++;
      } else if (char === '/' && features.regex && hasPunctuatorBefore(content, i)) {
        // Start the regex
        isInRegex = true;
        // Regex characters count
        totalTokenLength++;
      } else if (char === '{' && templateLiteralDepth.length) {
        // Start normal code brace if inside a template literal
        templateLiteralDepth.push('normalBrace');
        totalTokenLength++;
      } else if (char === '}' && templateLiteralDepth.length) {
        // End one template literal if closing brace is for a template literal
        if (templateLiteralDepth[templateLiteralDepth.length - 1] === 'templateBrace') {
          isInString = true;
          stringOpenChar = '`';
        }
        templateLiteralDepth.pop();
        totalTokenLength++;
      } else if (isAStringOpenChar) {
        // Start the string
        isInString = true;
        // Save the open character for later so we know when to close it
        stringOpenChar = char;
        // String characters count
        totalTokenLength++;
      } else if (!isWhitespace) {
        // All non-whitespace characters count
        totalTokenLength++;
      }
    }
  }

  // If the content contained unbalanced comments, it's either invalid or we had a parsing error.
  // Report the token length as the entire string so it will be ignored.
  if (isInMultilineComment || isInString) {
    return content.length;
  }

  return totalTokenLength;
}

/**
 * @param {string} content
 */
function computeJSTokenLength(content) {
  return computeTokenLength(content, {singlelineComments: true, regex: true});
}

/**
 * @param {string} content
 */
function computeCSSTokenLength(content) {
  return computeTokenLength(content, {singlelineComments: false, regex: false});
}

module.exports = {computeJSTokenLength, computeCSSTokenLength};

},{}],107:[function(require,module,exports){
/**
 * @license Copyright 2021 The Lighthouse Authors. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.
 */
'use strict';

const LHError = require('./lh-error.js');
const NetworkAnalyzer = require('./dependency-graph/simulator/network-analyzer.js');

/**
 * Returns an error if the original network request failed or wasn't found.
 * @param {LH.Artifacts.NetworkRequest|undefined} mainRecord
 * @return {LH.LighthouseError|undefined}
 */
function getNetworkError(mainRecord) {
  if (!mainRecord) {
    return new LHError(LHError.errors.NO_DOCUMENT_REQUEST);
  } else if (mainRecord.failed) {
    const netErr = mainRecord.localizedFailDescription;
    // Match all resolution and DNS failures
    // https://cs.chromium.org/chromium/src/net/base/net_error_list.h?rcl=cd62979b
    if (
      netErr === 'net::ERR_NAME_NOT_RESOLVED' ||
      netErr === 'net::ERR_NAME_RESOLUTION_FAILED' ||
      netErr.startsWith('net::ERR_DNS_')
    ) {
      return new LHError(LHError.errors.DNS_FAILURE);
    } else {
      return new LHError(LHError.errors.FAILED_DOCUMENT_REQUEST, {errorDetails: netErr});
    }
  } else if (mainRecord.hasErrorStatusCode()) {
    return new LHError(LHError.errors.ERRORED_DOCUMENT_REQUEST, {
      statusCode: `${mainRecord.statusCode}`,
    });
  }
}

/**
 * Returns an error if we ended up on the `chrome-error` page and all other requests failed.
 * @param {LH.Artifacts.NetworkRequest|undefined} mainRecord
 * @param {Array<LH.Artifacts.NetworkRequest>} networkRecords
 * @return {LH.LighthouseError|undefined}
 */
function getInterstitialError(mainRecord, networkRecords) {
  // If we never requested a document, there's no interstitial error, let other cases handle it.
  if (!mainRecord) return undefined;

  const interstitialRequest = networkRecords.find(record =>
    record.documentURL.startsWith('chrome-error://')
  );
  // If the page didn't end up on a chrome interstitial, there's no error here.
  if (!interstitialRequest) return undefined;

  // If the main document didn't fail, we didn't end up on an interstitial.
  // FIXME: This doesn't handle client-side redirects.
  // None of our error-handling deals with this case either because passContext.url doesn't handle non-network redirects.
  if (!mainRecord.failed) return undefined;

  // If a request failed with the `net::ERR_CERT_*` collection of errors, then it's a security issue.
  if (mainRecord.localizedFailDescription.startsWith('net::ERR_CERT')) {
    return new LHError(LHError.errors.INSECURE_DOCUMENT_REQUEST, {
      securityMessages: mainRecord.localizedFailDescription,
    });
  }

  // If we made it this far, it's a generic Chrome interstitial error.
  return new LHError(LHError.errors.CHROME_INTERSTITIAL_ERROR);
}

/**
 * Returns an error if we try to load a non-HTML page.
 * Expects a network request with all redirects resolved, otherwise the MIME type may be incorrect.
 * @param {LH.Artifacts.NetworkRequest|undefined} finalRecord
 * @return {LH.LighthouseError|undefined}
 */
function getNonHtmlError(finalRecord) {
  // MIME types are case-insenstive but Chrome normalizes MIME types to be lowercase.
  const HTML_MIME_TYPE = 'text/html';

  // If we never requested a document, there's no doctype error, let other cases handle it.
  if (!finalRecord) return undefined;

  // mimeType is determined by the browser, we assume Chrome is determining mimeType correctly,
  // independently of 'Content-Type' response headers, and always sending mimeType if well-formed.
  if (HTML_MIME_TYPE !== finalRecord.mimeType) {
    return new LHError(LHError.errors.NOT_HTML, {mimeType: finalRecord.mimeType});
  }

  return undefined;
}

/**
 * Returns an error if the page load should be considered failed, e.g. from a
 * main document request failure, a security issue, etc.
 * @param {LH.LighthouseError|undefined} navigationError
 * @param {{url: string, loadFailureMode: LH.Gatherer.PassContext['passConfig']['loadFailureMode'], networkRecords: Array<LH.Artifacts.NetworkRequest>}} context
 * @return {LH.LighthouseError|undefined}
 */
function getPageLoadError(navigationError, context) {
  const {url, loadFailureMode, networkRecords} = context;
  /** @type {LH.Artifacts.NetworkRequest|undefined} */
  let mainRecord;
  try {
    mainRecord = NetworkAnalyzer.findMainDocument(networkRecords, url);
  } catch (_) {}

  // MIME Type is only set on the final redirected document request. Use this for the HTML check instead of root.
  let finalRecord;
  if (mainRecord) {
    finalRecord = NetworkAnalyzer.resolveRedirects(mainRecord);
  }

  const networkError = getNetworkError(mainRecord);
  const interstitialError = getInterstitialError(mainRecord, networkRecords);
  const nonHtmlError = getNonHtmlError(finalRecord);

  // Check to see if we need to ignore the page load failure.
  // e.g. When the driver is offline, the load will fail without page offline support.
  if (loadFailureMode === 'ignore') return;

  // We want to special-case the interstitial beyond FAILED_DOCUMENT_REQUEST. See https://github.com/GoogleChrome/lighthouse/pull/8865#issuecomment-497507618
  if (interstitialError) return interstitialError;

  // Network errors are usually the most specific and provide the best reason for why the page failed to load.
  // Prefer networkError over navigationError.
  // Example: `DNS_FAILURE` is better than `NO_FCP`.
  if (networkError) return networkError;

  // Error if page is not HTML.
  if (nonHtmlError) return nonHtmlError;

  // Navigation errors are rather generic and express some failure of the page to render properly.
  // Use `navigationError` as the last resort.
  // Example: `NO_FCP`, the page never painted content for some unknown reason.
  return navigationError;
}


module.exports = {
  getNetworkError,
  getInterstitialError,
  getPageLoadError,
  getNonHtmlError,
};

},{"./dependency-graph/simulator/network-analyzer.js":91,"./lh-error.js":103}],108:[function(require,module,exports){
/**
 * @license Copyright 2016 The Lighthouse Authors. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.
 */
'use strict';

const NetworkRequest = require('./network-request.js');
const EventEmitter = require('events').EventEmitter;

/** @typedef {'requeststarted'|'requestloaded'} NetworkRecorderEvent */

class NetworkRecorder extends EventEmitter {
  /**
   * Creates an instance of NetworkRecorder.
   */
  constructor() {
    super();

    /** @type {NetworkRequest[]} */
    this._records = [];
    /** @type {Map<string, NetworkRequest>} */
    this._recordsById = new Map();
    /** @type {string|null|undefined} */
    this._mainSessionId = null;
  }

  /**
   * Returns the array of raw network request data without finalizing the initiator and
   * redirect chain.
   * @return {Array<NetworkRequest>}
   */
  getRawRecords() {
    return Array.from(this._records);
  }

  /**
   * @param {NetworkRecorderEvent} event
   * @param {*} listener
   */
  on(event, listener) {
    return super.on(event, listener);
  }

  /**
   * @param {NetworkRecorderEvent} event
   * @param {*} listener
   */
  once(event, listener) {
    return super.once(event, listener);
  }

  /**
   * Listener for the DevTools SDK NetworkManager's RequestStarted event, which includes both
   * web socket and normal request creation.
   * @param {NetworkRequest} request
   * @private
   */
  onRequestStarted(request) {
    this._records.push(request);
    this._recordsById.set(request.requestId, request);

    this.emit('requeststarted', request);
  }

  /**
   * Listener for the DevTools SDK NetworkManager's RequestFinished event, which includes
   * request finish, failure, and redirect, as well as the closing of web sockets.
   * @param {NetworkRequest} request
   * @private
   */
  onRequestFinished(request) {
    this.emit('requestloaded', request);
  }

  // The below methods proxy network data into the NetworkRequest object which mimics the
  // DevTools SDK network layer.

  /**
   * @param {{params: LH.Crdp.Network.RequestWillBeSentEvent, sessionId?: string}} event
   */
  onRequestWillBeSent(event) {
    const data = event.params;
    const originalRequest = this._findRealRequestAndSetSession(data.requestId, event.sessionId);
    // This is a simple new request, create the NetworkRequest object and finish.
    if (!originalRequest) {
      const request = new NetworkRequest();
      request.onRequestWillBeSent(data);
      request.sessionId = event.sessionId;
      this.onRequestStarted(request);
      return;
    }

    // TODO: beacon to Sentry, https://github.com/GoogleChrome/lighthouse/issues/7041
    if (!data.redirectResponse) {
      return;
    }

    // On redirect, another requestWillBeSent message is fired for the same requestId.
    // Update/finish the previous network request and create a new one for the redirect.
    const modifiedData = {
      ...data,
      // Copy over the initiator as well to match DevTools behavior
      initiator: originalRequest.initiator,
      requestId: `${originalRequest.requestId}:redirect`,
    };
    const redirectedRequest = new NetworkRequest();

    redirectedRequest.onRequestWillBeSent(modifiedData);
    originalRequest.onRedirectResponse(data);

    originalRequest.redirectDestination = redirectedRequest;
    redirectedRequest.redirectSource = originalRequest;

    // Start the redirect request before finishing the original so we don't get erroneous quiet periods
    this.onRequestStarted(redirectedRequest);
    this.onRequestFinished(originalRequest);
  }

  /**
   * @param {{params: LH.Crdp.Network.RequestServedFromCacheEvent, sessionId?: string}} event
   */
  onRequestServedFromCache(event) {
    const data = event.params;
    const request = this._findRealRequestAndSetSession(data.requestId, event.sessionId);
    if (!request) return;
    request.onRequestServedFromCache();
  }

  /**
   * @param {{params: LH.Crdp.Network.ResponseReceivedEvent, sessionId?: string}} event
   */
  onResponseReceived(event) {
    const data = event.params;
    const request = this._findRealRequestAndSetSession(data.requestId, event.sessionId);
    if (!request) return;
    request.onResponseReceived(data);
  }

  /**
   * @param {{params: LH.Crdp.Network.DataReceivedEvent, sessionId?: string}} event
   */
  onDataReceived(event) {
    const data = event.params;
    const request = this._findRealRequestAndSetSession(data.requestId, event.sessionId);
    if (!request) return;
    request.onDataReceived(data);
  }

  /**
   * @param {{params: LH.Crdp.Network.LoadingFinishedEvent, sessionId?: string}} event
   */
  onLoadingFinished(event) {
    const data = event.params;
    const request = this._findRealRequestAndSetSession(data.requestId, event.sessionId);
    if (!request) return;
    request.onLoadingFinished(data);
    this.onRequestFinished(request);
  }

  /**
   * @param {{params: LH.Crdp.Network.LoadingFailedEvent, sessionId?: string}} event
   */
  onLoadingFailed(event) {
    const data = event.params;
    const request = this._findRealRequestAndSetSession(data.requestId, event.sessionId);
    if (!request) return;
    request.onLoadingFailed(data);
    this.onRequestFinished(request);
  }

  /**
   * @param {{params: LH.Crdp.Network.ResourceChangedPriorityEvent, sessionId?: string}} event
   */
  onResourceChangedPriority(event) {
    const data = event.params;
    const request = this._findRealRequestAndSetSession(data.requestId, event.sessionId);
    if (!request) return;
    request.onResourceChangedPriority(data);
  }

  /**
   * Routes network events to their handlers, so we can construct networkRecords
   * @param {LH.Protocol.RawEventMessage} event
   */
  dispatch(event) {
    switch (event.method) {
      case 'Network.requestWillBeSent': return this.onRequestWillBeSent(event);
      case 'Network.requestServedFromCache': return this.onRequestServedFromCache(event);
      case 'Network.responseReceived': return this.onResponseReceived(event);
      case 'Network.dataReceived': return this.onDataReceived(event);
      case 'Network.loadingFinished': return this.onLoadingFinished(event);
      case 'Network.loadingFailed': return this.onLoadingFailed(event);
      case 'Network.resourceChangedPriority': return this.onResourceChangedPriority(event);
      default: return;
    }
  }

  /**
   * Redirected requests all have identical requestIds over the protocol. Once a request has been
   * redirected all future messages referrencing that requestId are about the new destination, not
   * the original. This method is a helper for finding the real request object to which the current
   * message is referring.
   *
   * @param {string} requestId
   * @param {string|undefined} sessionId
   * @return {NetworkRequest|undefined}
   */
  _findRealRequestAndSetSession(requestId, sessionId) {
    // The very first sessionId processed is always the main sessionId. In all but DevTools,
    // this sessionId is undefined. However, in DevTools the main Lighthouse protocol connection
    // does send events with sessionId set to a string, because of how DevTools routes the protocol
    // to Lighthouse.
    // Many places in Lighthouse use `record.sessionId === undefined` to mean that the session is not
    // an OOPIF. To maintain this property, we intercept sessionId here and set it to undefined if
    // it matches the first value seen.
    if (this._mainSessionId === null) {
      this._mainSessionId = sessionId;
    }
    if (this._mainSessionId === sessionId) {
      sessionId = undefined;
    }

    let request = this._recordsById.get(requestId);
    if (!request || !request.isValid) return undefined;

    while (request.redirectDestination) {
      request = request.redirectDestination;
    }

    request.setSession(sessionId);

    return request;
  }

  /**
   * @param {NetworkRequest} record The record to find the initiator of
   * @param {Map<string, NetworkRequest[]>} recordsByURL
   * @return {NetworkRequest|null}
   * @private
   */
  static _chooseInitiatorRequest(record, recordsByURL) {
    if (record.redirectSource) {
      return record.redirectSource;
    }
    const stackFrames = (record.initiator.stack && record.initiator.stack.callFrames) || [];
    const initiatorURL = record.initiator.url || (stackFrames[0] && stackFrames[0].url);

    let candidates = recordsByURL.get(initiatorURL) || [];
    // The initiator must come before the initiated request.
    candidates = candidates.filter(cand => cand.responseReceivedTime <= record.startTime);
    if (candidates.length > 1) {
      // Disambiguate based on prefetch. Prefetch requests have type 'Other' and cannot
      // initiate requests, so we drop them here.
      const nonPrefetchCandidates = candidates.filter(
          cand => cand.resourceType !== NetworkRequest.TYPES.Other);
      if (nonPrefetchCandidates.length) {
        candidates = nonPrefetchCandidates;
      }
    }
    if (candidates.length > 1) {
      // Disambiguate based on frame. It's likely that the initiator comes from the same frame.
      const sameFrameCandidates = candidates.filter(cand => cand.frameId === record.frameId);
      if (sameFrameCandidates.length) {
        candidates = sameFrameCandidates;
      }
    }
    if (candidates.length > 1 && record.initiator.type === 'parser') {
      // Filter to just Documents when initiator type is parser.
      const documentCandidates = candidates.filter(cand =>
        cand.resourceType === NetworkRequest.TYPES.Document);
      if (documentCandidates.length) {
        candidates = documentCandidates;
      }
    }

    // Only return an initiator if the result is unambiguous.
    return candidates.length === 1 ? candidates[0] : null;
  }

  /**
   * Construct network records from a log of devtools protocol messages.
   * @param {LH.DevtoolsLog} devtoolsLog
   * @return {Array<LH.Artifacts.NetworkRequest>}
   */
  static recordsFromLogs(devtoolsLog) {
    const networkRecorder = new NetworkRecorder();
    // playback all the devtools messages to recreate network records
    devtoolsLog.forEach(message => networkRecorder.dispatch(message));

    // get out the list of records & filter out invalid records
    const records = networkRecorder.getRawRecords().filter(record => record.isValid);

    /** @type {Map<string, NetworkRequest[]>} */
    const recordsByURL = new Map();
    for (const record of records) {
      const records = recordsByURL.get(record.url) || [];
      records.push(record);
      recordsByURL.set(record.url, records);
    }

    // set the initiatorRequest and redirects array
    for (const record of records) {
      const initiatorRequest = NetworkRecorder._chooseInitiatorRequest(record, recordsByURL);
      if (initiatorRequest) {
        record.setInitiatorRequest(initiatorRequest);
      }

      let finalRecord = record;
      while (finalRecord.redirectDestination) finalRecord = finalRecord.redirectDestination;
      if (finalRecord === record || finalRecord.redirects) continue;

      const redirects = [];
      for (
        let redirect = finalRecord.redirectSource;
        redirect;
        redirect = redirect.redirectSource
      ) {
        redirects.unshift(redirect);
      }

      finalRecord.redirects = redirects;
    }

    return records;
  }
}

module.exports = NetworkRecorder;

},{"./network-request.js":109,"events":162}],109:[function(require,module,exports){
(function (global){(function (){
/**
 * @license Copyright 2018 The Lighthouse Authors. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.
 */
'use strict';

/**
 * @fileoverview Fills most of the role of NetworkManager and NetworkRequest classes from DevTools.
 * @see https://cs.chromium.org/chromium/src/third_party/blink/renderer/devtools/front_end/sdk/NetworkRequest.js
 * @see https://cs.chromium.org/chromium/src/third_party/blink/renderer/devtools/front_end/sdk/NetworkManager.js
 */

const URL = require('./url-shim.js');


// Lightrider X-Header names for timing information.
// See: _updateTransferSizeForLightrider and _updateTimingsForLightrider.
const HEADER_TCP = 'X-TCPMs';
const HEADER_SSL = 'X-SSLMs';
const HEADER_REQ = 'X-RequestMs';
const HEADER_RES = 'X-ResponseMs';
const HEADER_TOTAL = 'X-TotalMs';
const HEADER_FETCHED_SIZE = 'X-TotalFetchedSize';
const HEADER_PROTOCOL_IS_H2 = 'X-ProtocolIsH2';

/**
 * @typedef HeaderEntry
 * @property {string} name
 * @property {string} value
 */

/**
 * @typedef ParsedURL
 * @property {string} scheme Equivalent to a `new URL(url).protocol` BUT w/o the trailing colon (:)
 * @property {string} host Equivalent to a `new URL(url).hostname`
 * @property {string} securityOrigin
 */

/**
 * @typedef LightriderStatistics
 * The difference in endTime between the observed Lighthouse endTime and Lightrider's derived endTime.
 * @property {number} endTimeDeltaMs
 * The time spent making a TCP connection (connect + SSL).
 * @property {number} TCPMs
 * The time spent requesting a resource from a remote server, we use this to approx RTT.
 * @property {number} requestMs
 * The time spent transferring a resource from a remote server.
 * @property {number} responseMs
 */

/** @type {SelfMap<LH.Crdp.Network.ResourceType>} */
const RESOURCE_TYPES = {
  XHR: 'XHR',
  Fetch: 'Fetch',
  EventSource: 'EventSource',
  Script: 'Script',
  Stylesheet: 'Stylesheet',
  Image: 'Image',
  Media: 'Media',
  Font: 'Font',
  Document: 'Document',
  TextTrack: 'TextTrack',
  WebSocket: 'WebSocket',
  Other: 'Other',
  Manifest: 'Manifest',
  SignedExchange: 'SignedExchange',
  Ping: 'Ping',
  Preflight: 'Preflight',
  CSPViolationReport: 'CSPViolationReport',
};

class NetworkRequest {
  constructor() {
    this.requestId = '';
    this.connectionId = '0';
    this.connectionReused = false;

    this.url = '';
    this.protocol = '';
    this.isSecure = false;
    this.isValid = false;
    this.parsedURL = /** @type {ParsedURL} */ ({scheme: ''});
    this.documentURL = '';

    this.startTime = -1;
    /** @type {number} */
    this.endTime = -1;
    /** @type {number} */
    this.responseReceivedTime = -1;

    // Go read the comment on _updateTransferSizeForLightrider.
    this.transferSize = 0;
    this.resourceSize = 0;
    this.fromDiskCache = false;
    this.fromMemoryCache = false;
    this.fromPrefetchCache = false;

    /** @type {LightriderStatistics|undefined} Extra timing information available only when run in Lightrider. */
    this.lrStatistics = undefined;

    this.finished = false;
    this.requestMethod = '';
    this.statusCode = -1;
    /** @type {NetworkRequest|undefined} The network request that redirected to this one */
    this.redirectSource = undefined;
    /** @type {NetworkRequest|undefined} The network request that this one redirected to */
    this.redirectDestination = undefined;
    /** @type {NetworkRequest[]|undefined} The chain of network requests that redirected to this one */
    this.redirects = undefined;
    this.failed = false;
    this.localizedFailDescription = '';

    /** @type {LH.Crdp.Network.Initiator} */
    this.initiator = {type: 'other'};
    /** @type {LH.Crdp.Network.ResourceTiming|undefined} */
    this.timing = undefined;
    /** @type {LH.Crdp.Network.ResourceType|undefined} */
    this.resourceType = undefined;
    this.mimeType = '';
    /** @type {LH.Crdp.Network.ResourcePriority} */
    this.priority = 'Low';
    /** @type {NetworkRequest|undefined} */
    this.initiatorRequest = undefined;
    /** @type {HeaderEntry[]} */
    this.responseHeaders = [];
    /** @type {string} */
    this.responseHeadersText = '';

    this.fetchedViaServiceWorker = false;
    /** @type {string|undefined} */
    this.frameId = '';
    /**
     * @type {string|undefined}
     * Only set for child targets (OOPIFs). This is the sessionId of the protocol connection on
     * which this request was discovered. `undefined` means it came from the root.
     */
    this.sessionId = undefined;
    this.isLinkPreload = false;
  }

  /**
   * @return {boolean}
   */
  hasErrorStatusCode() {
    return this.statusCode >= 400;
  }

  /**
   * @param {NetworkRequest} initiatorRequest
   */
  setInitiatorRequest(initiatorRequest) {
    this.initiatorRequest = initiatorRequest;
  }

  /**
   * @param {LH.Crdp.Network.RequestWillBeSentEvent} data
   */
  onRequestWillBeSent(data) {
    this.requestId = data.requestId;
    let url;
    try {
      // try to construct the url and fill in request
      url = new URL(data.request.url);
    } catch (e) {
      // isValid left false, all other data is blank
      return;
    }
    this.url = data.request.url;
    this.documentURL = data.documentURL;
    this.parsedURL = {
      scheme: url.protocol.split(':')[0],
      // Intentional, DevTools uses different terminology
      host: url.hostname,
      securityOrigin: url.origin,
    };
    this.isSecure = URL.isSecureScheme(this.parsedURL.scheme);

    this.startTime = data.timestamp;

    this.requestMethod = data.request.method;

    this.initiator = data.initiator;
    this.resourceType = data.type && RESOURCE_TYPES[data.type];
    this.priority = data.request.initialPriority;

    this.frameId = data.frameId;
    this.isLinkPreload = data.initiator.type === 'preload' || !!data.request.isLinkPreload;
    this.isValid = true;
  }

  onRequestServedFromCache() {
    this.fromMemoryCache = true;
  }

  /**
   * @param {LH.Crdp.Network.ResponseReceivedEvent} data
   */
  onResponseReceived(data) {
    this._onResponse(data.response, data.timestamp, data.type);
    this._updateProtocolForLightrider();
    this.frameId = data.frameId;
  }

  /**
   * @param {LH.Crdp.Network.DataReceivedEvent} data
   */
  onDataReceived(data) {
    this.resourceSize += data.dataLength;
    if (data.encodedDataLength !== -1) {
      this.transferSize += data.encodedDataLength;
    }
  }

  /**
   * @param {LH.Crdp.Network.LoadingFinishedEvent} data
   */
  onLoadingFinished(data) {
    // On some requests DevTools can send duplicate events, prefer the first one for best timing data
    if (this.finished) return;

    this.finished = true;
    this.endTime = data.timestamp;
    if (data.encodedDataLength >= 0) {
      this.transferSize = data.encodedDataLength;
    }

    this._updateResponseReceivedTimeIfNecessary();
    this._updateTransferSizeForLightrider();
    this._updateTimingsForLightrider();
  }

  /**
   * @param {LH.Crdp.Network.LoadingFailedEvent} data
   */
  onLoadingFailed(data) {
    // On some requests DevTools can send duplicate events, prefer the first one for best timing data
    if (this.finished) return;

    this.finished = true;
    this.endTime = data.timestamp;

    this.failed = true;
    this.resourceType = data.type && RESOURCE_TYPES[data.type];
    this.localizedFailDescription = data.errorText;

    this._updateResponseReceivedTimeIfNecessary();
    this._updateTransferSizeForLightrider();
    this._updateTimingsForLightrider();
  }

  /**
   * @param {LH.Crdp.Network.ResourceChangedPriorityEvent} data
   */
  onResourceChangedPriority(data) {
    this.priority = data.newPriority;
  }

  /**
   * @param {LH.Crdp.Network.RequestWillBeSentEvent} data
   */
  onRedirectResponse(data) {
    if (!data.redirectResponse) throw new Error('Missing redirectResponse data');
    this._onResponse(data.redirectResponse, data.timestamp, data.type);
    this.resourceType = undefined;
    this.finished = true;
    this.endTime = data.timestamp;

    this._updateResponseReceivedTimeIfNecessary();
  }

  /**
   * @param {string=} sessionId
   */
  setSession(sessionId) {
    this.sessionId = sessionId;
  }

  /**
   * @param {LH.Crdp.Network.Response} response
   * @param {number} timestamp
   * @param {LH.Crdp.Network.ResponseReceivedEvent['type']=} resourceType
   */
  _onResponse(response, timestamp, resourceType) {
    this.url = response.url;

    this.connectionId = String(response.connectionId);
    this.connectionReused = response.connectionReused;

    if (response.protocol) this.protocol = response.protocol;

    this.responseReceivedTime = timestamp;

    this.transferSize = response.encodedDataLength;
    if (typeof response.fromDiskCache === 'boolean') this.fromDiskCache = response.fromDiskCache;
    if (typeof response.fromPrefetchCache === 'boolean') {
      this.fromPrefetchCache = response.fromPrefetchCache;
    }

    this.statusCode = response.status;

    this.timing = response.timing;
    if (resourceType) this.resourceType = RESOURCE_TYPES[resourceType];
    this.mimeType = response.mimeType;
    this.responseHeadersText = response.headersText || '';
    this.responseHeaders = NetworkRequest._headersDictToHeadersArray(response.headers);

    this.fetchedViaServiceWorker = !!response.fromServiceWorker;

    if (this.fromMemoryCache) this.timing = undefined;
    if (this.timing) this._recomputeTimesWithResourceTiming(this.timing);
  }

  /**
   * Resolve differences between conflicting timing signals. Based on the property setters in DevTools.
   * @see https://github.com/ChromeDevTools/devtools-frontend/blob/56a99365197b85c24b732ac92b0ac70feed80179/front_end/sdk/NetworkRequest.js#L485-L502
   * @param {LH.Crdp.Network.ResourceTiming} timing
   */
  _recomputeTimesWithResourceTiming(timing) {
    // Don't recompute times if the data is invalid. RequestTime should always be a thread timestamp.
    // If we don't have receiveHeadersEnd, we really don't have more accurate data.
    if (timing.requestTime === 0 || timing.receiveHeadersEnd === -1) return;
    // Take startTime and responseReceivedTime from timing data for better accuracy.
    // Timing's requestTime is a baseline in seconds, rest of the numbers there are ticks in millis.
    this.startTime = timing.requestTime;
    const headersReceivedTime = timing.requestTime + timing.receiveHeadersEnd / 1000;
    if (!this.responseReceivedTime || this.responseReceivedTime < 0) {
      this.responseReceivedTime = headersReceivedTime;
    }

    this.responseReceivedTime = Math.min(this.responseReceivedTime, headersReceivedTime);
    this.responseReceivedTime = Math.max(this.responseReceivedTime, this.startTime);
    // We're only at responseReceived (_onResponse) at this point.
    // This endTime may be redefined again after onLoading is done.
    this.endTime = Math.max(this.endTime, this.responseReceivedTime);
  }

  /**
   * Update responseReceivedTime to the endTime if endTime is earlier.
   * A response can't be received after the entire request finished.
   */
  _updateResponseReceivedTimeIfNecessary() {
    this.responseReceivedTime = Math.min(this.endTime, this.responseReceivedTime);
  }

  /**
   * LR loses transfer size information, but passes it in the 'X-TotalFetchedSize' header.
   * 'X-TotalFetchedSize' is the canonical transfer size in LR. Nothing should supersede it.
   *
   * The total length of the encoded data is spread out among multiple events. The sum of the
   * values in onResponseReceived and all the onDataReceived events typically equals the value
   * seen on the onLoadingFinished event. In <1% of cases we see the values differ. As we process
   * onResponseReceived and onDataReceived we accumulate the total encodedDataLength. When we
   * process onLoadingFinished, we override the accumulated total. We do this so that if the
   * request is aborted or fails, we still get a value via the accumulation.
   *
   * In Lightrider, due to instrumentation limitations, our values for encodedDataLength are bogus
   * and not valid. However the resource's true encodedDataLength/transferSize is shared via a
   * special response header, X-TotalFetchedSize. In this situation, we read this value from
   * responseReceived, use it for the transferSize and ignore the encodedDataLength values in
   * both dataReceived and loadingFinished.
   */
  _updateTransferSizeForLightrider() {
    // Bail if we aren't in Lightrider.
    if (!global.isLightrider) return;

    const totalFetchedSize = this.responseHeaders.find(item => item.name === HEADER_FETCHED_SIZE);
    // Bail if the header was missing.
    if (!totalFetchedSize) return;
    const floatValue = parseFloat(totalFetchedSize.value);
    // Bail if the header cannot be parsed.
    if (isNaN(floatValue)) return;
    this.transferSize = floatValue;
  }

  /**
   * LR loses protocol information.
   */
  _updateProtocolForLightrider() {
    // Bail if we aren't in Lightrider.
    if (!global.isLightrider) return;

    if (this.responseHeaders.some(item => item.name === HEADER_PROTOCOL_IS_H2)) {
      this.protocol = 'h2';
    }
  }

  /**
   * LR gets additional, accurate timing information from its underlying fetch infrastructure.  This
   * is passed in via X-Headers similar to 'X-TotalFetchedSize'.
   */
  _updateTimingsForLightrider() {
    // Bail if we aren't in Lightrider.
    if (!global.isLightrider) return;

    // For more info on timing nomenclature: https://www.w3.org/TR/resource-timing-2/#processing-model

    //    StartTime
    //    | ConnectStart
    //    | |     SSLStart  SSLEnd
    //    | |     |         | ConnectEnd
    //    | |     |         | | SendStart/End   ReceiveHeadersEnd
    //    | |     |         | | |               |                EndTime
    //    ▼ ▼     ▼         ▼ ▼ ▼               ▼                ▼
    //    [ [TCP  [   SSL   ] ] [   Request   ] [   Response   ] ]
    //    ▲ ▲     ▲         ▲ ▲ ▲             ▲ ▲              ▲ ▲
    //    | |     '-SSLMs---' | '-requestMs---' '-responseMs---' |
    //    | '----TCPMs--------'                                  |
    //    |                                                      |
    //    '------------------------TotalMs-----------------------'

    const totalHeader = this.responseHeaders.find(item => item.name === HEADER_TOTAL);
    // Bail if there was no totalTime.
    if (!totalHeader) return;

    const totalMs = parseInt(totalHeader.value);
    const TCPMsHeader = this.responseHeaders.find(item => item.name === HEADER_TCP);
    const SSLMsHeader = this.responseHeaders.find(item => item.name === HEADER_SSL);
    const requestMsHeader = this.responseHeaders.find(item => item.name === HEADER_REQ);
    const responseMsHeader = this.responseHeaders.find(item => item.name === HEADER_RES);

    // Make sure all times are initialized and are non-negative.
    const TCPMs = TCPMsHeader ? Math.max(0, parseInt(TCPMsHeader.value)) : 0;
    const SSLMs = SSLMsHeader ? Math.max(0, parseInt(SSLMsHeader.value)) : 0;
    const requestMs = requestMsHeader ? Math.max(0, parseInt(requestMsHeader.value)) : 0;
    const responseMs = responseMsHeader ? Math.max(0, parseInt(responseMsHeader.value)) : 0;

    // Bail if the timings don't add up.
    if (TCPMs + requestMs + responseMs !== totalMs) {
      return;
    }

    // Bail if SSL time is > TCP time.
    if (SSLMs > TCPMs) {
      return;
    }

    this.lrStatistics = {
      endTimeDeltaMs: (this.endTime - (this.startTime + (totalMs / 1000))) * 1000,
      TCPMs: TCPMs,
      requestMs: requestMs,
      responseMs: responseMs,
    };
  }

  /**
   * Convert the requestId to backend-version by removing the `:redirect` portion
   *
   * @param {string} requestId
   * @return {string}
   */
  static getRequestIdForBackend(requestId) {
    return requestId.replace(/(:redirect)+$/, '');
  }

  /**
   * Based on DevTools NetworkManager.
   * @see https://github.com/ChromeDevTools/devtools-frontend/blob/3415ee28e86a3f4bcc2e15b652d22069938df3a6/front_end/sdk/NetworkManager.js#L285-L297
   * @param {LH.Crdp.Network.Headers} headersDict
   * @return {Array<HeaderEntry>}
   */
  static _headersDictToHeadersArray(headersDict) {
    const result = [];
    for (const name of Object.keys(headersDict)) {
      const values = headersDict[name].split('\n');
      for (let i = 0; i < values.length; ++i) {
        result.push({name: name, value: values[i]});
      }
    }
    return result;
  }

  static get TYPES() {
    return RESOURCE_TYPES;
  }

  /**
   * @param {NetworkRequest} record
   * @return {boolean}
   */
  static isNonNetworkRequest(record) {
    // The 'protocol' field in devtools a string more like a `scheme`
    return URL.isNonNetworkProtocol(record.protocol);
  }

  /**
   * Technically there's not alignment on URLs that create "secure connections" vs "secure contexts"
   * https://github.com/GoogleChrome/lighthouse/pull/11766#discussion_r582340683
   * But for our purposes, we don't need to worry too much.
   * @param {NetworkRequest} record
   * @return {boolean}
   */
  static isSecureRequest(record) {
    return URL.isSecureScheme(record.parsedURL.scheme) ||
        URL.isSecureScheme(record.protocol) ||
        URL.isLikeLocalhost(record.parsedURL.host) ||
        NetworkRequest.isHstsRequest(record);
  }

  /**
   * Returns whether the network request was an HSTS redirect request.
   * @param {NetworkRequest} record
   * @return {boolean}
   */
  static isHstsRequest(record) {
    const destination = record.redirectDestination;
    if (!destination) return false;

    const reasonHeader = record.responseHeaders
      .find(header => header.name === 'Non-Authoritative-Reason');
    const reason = reasonHeader && reasonHeader.value;
    return reason === 'HSTS' && NetworkRequest.isSecureRequest(destination);
  }
}

NetworkRequest.HEADER_TCP = HEADER_TCP;
NetworkRequest.HEADER_SSL = HEADER_SSL;
NetworkRequest.HEADER_REQ = HEADER_REQ;
NetworkRequest.HEADER_RES = HEADER_RES;
NetworkRequest.HEADER_TOTAL = HEADER_TOTAL;
NetworkRequest.HEADER_FETCHED_SIZE = HEADER_FETCHED_SIZE;
NetworkRequest.HEADER_PROTOCOL_IS_H2 = HEADER_PROTOCOL_IS_H2;

module.exports = NetworkRequest;

}).call(this)}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./url-shim.js":"url"}],110:[function(require,module,exports){
/**
 * @license Copyright 2018 The Lighthouse Authors. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.
 */
'use strict';

/**
 * @fileoverview
 * Helper functions that are passed by `toString()` by Driver to be evaluated in target page.
 *
 * Every function in this module only runs in the browser, so it is ignored from
 * the c8 code coverage tool. See c8.sh
 *
 * Important: this module should only be imported like this:
 *     const pageFunctions = require('...');
 * Never like this:
 *     const {justWhatINeed} = require('...');
 * Otherwise, minification will mangle the variable names and break usage.
 */

/**
 * `typed-query-selector`'s CSS selector parser.
 * @template {string} T
 * @typedef {import('typed-query-selector/parser').ParseSelector<T>} ParseSelector
 */

/* global window document Node ShadowRoot HTMLElement */

/**
 * The `exceptionDetails` provided by the debugger protocol does not contain the useful
 * information such as name, message, and stack trace of the error when it's wrapped in a
 * promise. Instead, map to a successful object that contains this information.
 * @param {string|Error} [err] The error to convert
 * @return {{__failedInBrowser: boolean, name: string, message: string, stack: string|undefined}}
 */
function wrapRuntimeEvalErrorInBrowser(err) {
  if (!err || typeof err === 'string') {
    err = new Error(err);
  }

  return {
    __failedInBrowser: true,
    name: err.name || 'Error',
    message: err.message || 'unknown error',
    stack: err.stack,
  };
}

/**
 * @template {string} T
 * @param {T} selector Optional simple CSS selector to filter nodes on.
 *     Combinators are not supported.
 * @return {Array<ParseSelector<T>>}
 */
function getElementsInDocument(selector) {
  const realMatchesFn = window.__ElementMatches || window.Element.prototype.matches;
  /** @type {Array<ParseSelector<T>>} */
  const results = [];

  /** @param {NodeListOf<Element>} nodes */
  const _findAllElements = nodes => {
    for (let i = 0, el; el = nodes[i]; ++i) {
      if (!selector || realMatchesFn.call(el, selector)) {
        /** @type {ParseSelector<T>} */
        // @ts-expect-error - el is verified as matching above, tsc just can't verify it through the .call().
        const matchedEl = el;
        results.push(matchedEl);
      }

      // If the element has a shadow root, dig deeper.
      if (el.shadowRoot) {
        _findAllElements(el.shadowRoot.querySelectorAll('*'));
      }
    }
  };
  _findAllElements(document.querySelectorAll('*'));

  return results;
}

/**
 * Gets the opening tag text of the given node.
 * @param {Element|ShadowRoot} element
 * @param {Array<string>=} ignoreAttrs An optional array of attribute tags to not include in the HTML snippet.
 * @return {string}
 */
function getOuterHTMLSnippet(element, ignoreAttrs = [], snippetCharacterLimit = 500) {
  const ATTRIBUTE_CHAR_LIMIT = 75;
  // Autofill information that is injected into the snippet via AutofillShowTypePredictions
  // TODO(paulirish): Don't clean title attribute from all elements if it's unnecessary
  const autoFillIgnoreAttrs = ['autofill-information', 'autofill-prediction', 'title'];

  // ShadowRoots are sometimes passed in; use their hosts' outerHTML.
  if (element instanceof ShadowRoot) {
    element = element.host;
  }

  try {
    /** @type {Element} */
    // @ts-expect-error - clone will be same type as element - see https://github.com/microsoft/TypeScript/issues/283
    const clone = element.cloneNode();

    // Prevent any potential side-effects by appending to a template element.
    // See https://github.com/GoogleChrome/lighthouse/issues/11465
    const template = element.ownerDocument.createElement('template');
    template.content.append(clone);
    ignoreAttrs.concat(autoFillIgnoreAttrs).forEach(attribute =>{
      clone.removeAttribute(attribute);
    });
    let charCount = 0;
    for (const attributeName of clone.getAttributeNames()) {
      if (charCount > snippetCharacterLimit) {
        clone.removeAttribute(attributeName);
        continue;
      }

      let attributeValue = clone.getAttribute(attributeName);
      if (attributeValue === null) continue; // Can't happen.

      let dirty = false;

      // Replace img.src with img.currentSrc. Same for audio and video.
      if (attributeName === 'src' && 'currentSrc' in element) {
        const elementWithSrc = /** @type {HTMLImageElement|HTMLMediaElement} */ (element);
        const currentSrc = elementWithSrc.currentSrc;
        // Only replace if the two URLs do not resolve to the same location.
        const documentHref = elementWithSrc.ownerDocument.location.href;
        if (new URL(attributeValue, documentHref).toString() !== currentSrc) {
          attributeValue = currentSrc;
          dirty = true;
        }
      }

      // Elide attribute value if too long.
      if (attributeValue.length > ATTRIBUTE_CHAR_LIMIT) {
        attributeValue = attributeValue.slice(0, ATTRIBUTE_CHAR_LIMIT - 1) + '…';
        dirty = true;
      }

      if (dirty) clone.setAttribute(attributeName, attributeValue);
      charCount += attributeName.length + attributeValue.length;
    }

    const reOpeningTag = /^[\s\S]*?>/;
    const [match] = clone.outerHTML.match(reOpeningTag) || [];
    if (match && charCount > snippetCharacterLimit) {
      return match.slice(0, match.length - 1) + ' …>';
    }
    return match || '';
  } catch (_) {
    // As a last resort, fall back to localName.
    return `<${element.localName}>`;
  }
}

/**
 * Get the maximum size of a texture the GPU can handle
 * @see https://bugs.chromium.org/p/chromium/issues/detail?id=770769#c13
 * @return {number}
 */
function getMaxTextureSize() {
  try {
    const canvas = document.createElement('canvas');
    const gl = canvas.getContext('webgl');
    if (!gl) throw new Error('no webgl');
    const maxTextureSize = gl.getParameter(gl.MAX_TEXTURE_SIZE);
    return maxTextureSize;
  } catch (e) {
    // If the above fails for any reason we need a fallback number;
    // 4096 is the max texture size on a Pixel 2 XL, so to be conservative we'll use a low value like it.
    // But we'll subtract 1 just to identify this case later on.
    const MAX_TEXTURE_SIZE_FALLBACK = 4095;
    return MAX_TEXTURE_SIZE_FALLBACK;
  }
}

/**
 * Computes a memory/CPU performance benchmark index to determine rough device class.
 * @see https://github.com/GoogleChrome/lighthouse/issues/9085
 * @see https://docs.google.com/spreadsheets/d/1E0gZwKsxegudkjJl8Fki_sOwHKpqgXwt8aBAfuUaB8A/edit?usp=sharing
 *
 * Historically (until LH 6.3), this benchmark created a string of length 100,000 in a loop, and returned
 * the number of times per second the string can be created.
 *
 * Changes to v8 in 8.6.106 changed this number and also made Chrome more variable w.r.t GC interupts.
 * This benchmark now is a hybrid of a similar GC-heavy approach to the original benchmark and an array
 * copy benchmark.
 *
 * As of Chrome m86...
 *
 *  - 1000+ is a desktop-class device, Core i3 PC, iPhone X, etc
 *  - 800+ is a high-end Android phone, Galaxy S8, low-end Chromebook, etc
 *  - 125+ is a mid-tier Android phone, Moto G4, etc
 *  - <125 is a budget Android phone, Alcatel Ideal, Galaxy J2, etc
 * @return {number}
 */
function computeBenchmarkIndex() {
  /**
   * The GC-heavy benchmark that creates a string of length 10000 in a loop.
   * The returned index is the number of times per second the string can be created divided by 10.
   * The division by 10 is to keep similar magnitudes to an earlier version of BenchmarkIndex that
   * used a string length of 100000 instead of 10000.
   */
  function benchmarkIndexGC() {
    const start = Date.now();
    let iterations = 0;

    while (Date.now() - start < 500) {
      let s = '';
      for (let j = 0; j < 10000; j++) s += 'a'; // eslint-disable-line no-unused-vars

      iterations++;
    }

    const durationInSeconds = (Date.now() - start) / 1000;
    return Math.round(iterations / 10 / durationInSeconds);
  }

  /**
   * The non-GC-dependent benchmark that copies integers back and forth between two arrays of length 100000.
   * The returned index is the number of times per second a copy can be made, divided by 10.
   * The division by 10 is to keep similar magnitudes to the GC-dependent version.
   */
  function benchmarkIndexNoGC() {
    const arrA = [];
    const arrB = [];
    for (let i = 0; i < 100000; i++) arrA[i] = arrB[i] = i;

    const start = Date.now();
    let iterations = 0;

    // Some Intel CPUs have a performance cliff due to unlucky JCC instruction alignment.
    // Two possible fixes: call Date.now less often, or manually unroll the inner loop a bit.
    // We'll call Date.now less and only check the duration on every 10th iteration for simplicity.
    // See https://bugs.chromium.org/p/v8/issues/detail?id=10954#c1.
    while (iterations % 10 !== 0 || Date.now() - start < 500) {
      const src = iterations % 2 === 0 ? arrA : arrB;
      const tgt = iterations % 2 === 0 ? arrB : arrA;

      for (let j = 0; j < src.length; j++) tgt[j] = src[j];

      iterations++;
    }

    const durationInSeconds = (Date.now() - start) / 1000;
    return Math.round(iterations / 10 / durationInSeconds);
  }

  // The final BenchmarkIndex is a simple average of the two components.
  return (benchmarkIndexGC() + benchmarkIndexNoGC()) / 2;
}

/**
 * Adapted from DevTools' SDK.DOMNode.prototype.path
 *   https://github.com/ChromeDevTools/devtools-frontend/blob/4fff931bb/front_end/sdk/DOMModel.js#L625-L647
 * Backend: https://source.chromium.org/search?q=f:node.cc%20symbol:PrintNodePathTo&sq=&ss=chromium%2Fchromium%2Fsrc
 *
 * TODO: DevTools nodePath handling doesn't support iframes, but probably could. https://crbug.com/1127635
 * @param {Node} node
 * @return {string}
 */
function getNodePath(node) {
  // For our purposes, there's no worthwhile difference between shadow root and document fragment
  // We can consider them entirely synonymous.
  /** @param {Node} node @return {node is ShadowRoot} */
  const isShadowRoot = node => node.nodeType === Node.DOCUMENT_FRAGMENT_NODE;
  /** @param {Node} node */
  const getNodeParent = node => isShadowRoot(node) ? node.host : node.parentNode;

  /** @param {Node} node @return {number|'a'} */
  function getNodeIndex(node) {
    if (isShadowRoot(node)) {
      // User-agent shadow roots get 'u'. Non-UA shadow roots get 'a'.
      return 'a';
    }
    let index = 0;
    let prevNode;
    while (prevNode = node.previousSibling) {
      node = prevNode;
      // skip empty text nodes
      if (node.nodeType === Node.TEXT_NODE && (node.nodeValue || '').trim().length === 0) continue;
      index++;
    }
    return index;
  }

  /** @type {Node|null} */
  let currentNode = node;
  const path = [];
  while (currentNode && getNodeParent(currentNode)) {
    const index = getNodeIndex(currentNode);
    path.push([index, currentNode.nodeName]);
    currentNode = getNodeParent(currentNode);
  }
  path.reverse();
  return path.join(',');
}

/**
 * @param {Element} element
 * @return {string}
 *
 * Note: CSS Selectors having no standard mechanism to describe shadow DOM piercing. So we can't.
 *
 * If the node resides within shadow DOM, the selector *only* starts from the shadow root.
 * For example, consider this img within a <section> within a shadow root..
 *  - DOM: <html> <body> <div> #shadow-root <section> <img/>
 *  - nodePath: 0,HTML,1,BODY,1,DIV,a,#document-fragment,0,SECTION,0,IMG
 *  - nodeSelector: section > img
 */
function getNodeSelector(element) {
  /**
   * @param {Element} element
   */
  function getSelectorPart(element) {
    let part = element.tagName.toLowerCase();
    if (element.id) {
      part += '#' + element.id;
    } else if (element.classList.length > 0) {
      part += '.' + element.classList[0];
    }
    return part;
  }

  const parts = [];
  while (parts.length < 4) {
    parts.unshift(getSelectorPart(element));
    if (!element.parentElement) {
      break;
    }
    element = element.parentElement;
    if (element.tagName === 'HTML') {
      break;
    }
  }
  return parts.join(' > ');
}

/**
 * This function checks if an element or an ancestor of an element is `position:fixed`.
 * In addition we ensure that the element is capable of behaving as a `position:fixed`
 * element, checking that it lives within a scrollable ancestor.
 * @param {HTMLElement} element
 * @return {boolean}
 */
function isPositionFixed(element) {
  /**
   * @param {HTMLElement} element
   * @param {'overflowY'|'position'} attr
   * @return {string}
   */
  function getStyleAttrValue(element, attr) {
    // Check style before computedStyle as computedStyle is expensive.
    return element.style[attr] || window.getComputedStyle(element)[attr];
  }

  // Position fixed/sticky has no effect in case when document does not scroll.
  const htmlEl = document.querySelector('html');
  if (!htmlEl) throw new Error('html element not found in document');
  if (htmlEl.scrollHeight <= htmlEl.clientHeight ||
      !['scroll', 'auto', 'visible'].includes(getStyleAttrValue(htmlEl, 'overflowY'))) {
    return false;
  }

  /** @type {HTMLElement | null} */
  let currentEl = element;
  while (currentEl) {
    const position = getStyleAttrValue(currentEl, 'position');
    if ((position === 'fixed' || position === 'sticky')) {
      return true;
    }
    currentEl = currentEl.parentElement;
  }
  return false;
}

/**
 * Generate a human-readable label for the given element, based on end-user facing
 * strings like the innerText or alt attribute.
 * Returns label string or null if no useful label is found.
 * @param {Element} element
 * @return {string | null}
 */
function getNodeLabel(element) {
  // Inline so that audits that import getNodeLabel don't
  // also need to import truncate
  /**
   * @param {string} str
   * @param {number} maxLength
   * @return {string}
   */
  function truncate(str, maxLength) {
    if (str.length <= maxLength) {
      return str;
    }
    // Take advantage of string iterator multi-byte character awareness.
    // Regular `.slice` will ignore unicode character boundaries and lead to malformed text.
    return Array.from(str).slice(0, maxLength - 1).join('') + '…';
  }

  const tagName = element.tagName.toLowerCase();
  // html and body content is too broad to be useful, since they contain all page content
  if (tagName !== 'html' && tagName !== 'body') {
    const nodeLabel = element instanceof HTMLElement && element.innerText ||
        element.getAttribute('alt') || element.getAttribute('aria-label');
    if (nodeLabel) {
      return truncate(nodeLabel, 80);
    } else {
      // If no useful label was found then try to get one from a child.
      // E.g. if an a tag contains an image but no text we want the image alt/aria-label attribute.
      const nodeToUseForLabel = element.querySelector('[alt], [aria-label]');
      if (nodeToUseForLabel) {
        return getNodeLabel(nodeToUseForLabel);
      }
    }
  }
  return null;
}

/**
 * @param {Element} element
 * @return {LH.Artifacts.Rect}
 */
function getBoundingClientRect(element) {
  // The protocol does not serialize getters, so extract the values explicitly.
  const rect = element.getBoundingClientRect();
  return {
    top: Math.round(rect.top),
    bottom: Math.round(rect.bottom),
    left: Math.round(rect.left),
    right: Math.round(rect.right),
    width: Math.round(rect.width),
    height: Math.round(rect.height),
  };
}

/**
 * RequestIdleCallback shim that calculates the remaining deadline time in order to avoid a potential lighthouse
 * penalty for tests run with simulated throttling. Reduces the deadline time to (50 - safetyAllowance) / cpuSlowdownMultiplier to
 * ensure a long task is very unlikely if using the API correctly.
 * @param {number} cpuSlowdownMultiplier
 */
function wrapRequestIdleCallback(cpuSlowdownMultiplier) {
  const safetyAllowanceMs = 10;
  const maxExecutionTimeMs = Math.floor((50 - safetyAllowanceMs) / cpuSlowdownMultiplier);
  const nativeRequestIdleCallback = window.requestIdleCallback;
  window.requestIdleCallback = (cb, options) => {
    /**
     * @type {Parameters<typeof window['requestIdleCallback']>[0]}
     */
    const cbWrap = (deadline) => {
      const start = Date.now();
      // @ts-expect-error - save original on non-standard property.
      deadline.__timeRemaining = deadline.timeRemaining;
      deadline.timeRemaining = () => {
        // @ts-expect-error - access non-standard property.
        const timeRemaining = deadline.__timeRemaining();
        return Math.min(timeRemaining, Math.max(0, maxExecutionTimeMs - (Date.now() - start))
        );
      };
      deadline.timeRemaining.toString = () => {
        return 'function timeRemaining() { [native code] }';
      };
      cb(deadline);
    };
    return nativeRequestIdleCallback(cbWrap, options);
  };
  window.requestIdleCallback.toString = () => {
    return 'function requestIdleCallback() { [native code] }';
  };
}

/**
 * @param {Element|ShadowRoot} element
 * @return {LH.Artifacts.NodeDetails}
 */
function getNodeDetails(element) {
  // This bookkeeping is for the FullPageScreenshot gatherer.
  if (!window.__lighthouseNodesDontTouchOrAllVarianceGoesAway) {
    window.__lighthouseNodesDontTouchOrAllVarianceGoesAway = new Map();
  }

  element = element instanceof ShadowRoot ? element.host : element;
  const selector = getNodeSelector(element);

  // Create an id that will be unique across all execution contexts.
  // The id could be any arbitrary string, the exact value is not important.
  // For example, tagName is added only because it might be useful for debugging.
  // But execution id and map size are added to ensure uniqueness.
  // We also dedupe this id so that details collected for an element within the same
  // pass and execution context will share the same id. Not technically important, but
  // cuts down on some duplication.
  let lhId = window.__lighthouseNodesDontTouchOrAllVarianceGoesAway.get(element);
  if (!lhId) {
    lhId = [
      window.__lighthouseExecutionContextId !== undefined ?
        window.__lighthouseExecutionContextId :
        'page',
      window.__lighthouseNodesDontTouchOrAllVarianceGoesAway.size,
      element.tagName,
    ].join('-');
    window.__lighthouseNodesDontTouchOrAllVarianceGoesAway.set(element, lhId);
  }

  const details = {
    lhId,
    devtoolsNodePath: getNodePath(element),
    selector: selector,
    boundingRect: getBoundingClientRect(element),
    snippet: getOuterHTMLSnippet(element),
    nodeLabel: getNodeLabel(element) || selector,
  };

  return details;
}

const getNodeDetailsString = `function getNodeDetails(element) {
  ${getNodePath.toString()};
  ${getNodeSelector.toString()};
  ${getBoundingClientRect.toString()};
  ${getOuterHTMLSnippet.toString()};
  ${getNodeLabel.toString()};
  return (${getNodeDetails.toString()})(element);
}`;

module.exports = {
  wrapRuntimeEvalErrorInBrowserString: wrapRuntimeEvalErrorInBrowser.toString(),
  wrapRuntimeEvalErrorInBrowser,
  getElementsInDocument,
  getElementsInDocumentString: getElementsInDocument.toString(),
  getOuterHTMLSnippetString: getOuterHTMLSnippet.toString(),
  getOuterHTMLSnippet: getOuterHTMLSnippet,
  computeBenchmarkIndex: computeBenchmarkIndex,
  computeBenchmarkIndexString: computeBenchmarkIndex.toString(),
  getMaxTextureSize,
  getNodeDetailsString,
  getNodeDetails,
  getNodePathString: getNodePath.toString(),
  getNodeSelectorString: getNodeSelector.toString(),
  getNodePath,
  getNodeSelector: getNodeSelector,
  getNodeLabel: getNodeLabel,
  getNodeLabelString: getNodeLabel.toString(),
  isPositionFixedString: isPositionFixed.toString(),
  wrapRequestIdleCallback,
  getBoundingClientRectString: getBoundingClientRect.toString(),
};

},{}],111:[function(require,module,exports){
/**
 * @license Copyright 2018 The Lighthouse Authors. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.
 */
'use strict';

/**
 * @param {LH.Artifacts.Rect} rect
 * @param {{x:number, y:number}} point
 */
function rectContainsPoint(rect, {x, y}) {
  return rect.left <= x && rect.right >= x && rect.top <= y && rect.bottom >= y;
}

/**
 * Returns whether rect2 is contained entirely within rect1;
 * @param {LH.Artifacts.Rect} rect1
 * @param {LH.Artifacts.Rect} rect2
 * @return {boolean}
 */
// We sometimes run this as a part of a gatherer script injected into the page, so prevent
// renaming the function for code coverage.
/* c8 ignore start */
function rectContains(rect1, rect2) {
  return rect2.top >= rect1.top &&
    rect2.right <= rect1.right &&
    rect2.bottom <= rect1.bottom &&
    rect2.left >= rect1.left;
}
/* c8 ignore stop */

/**
 * @param {LH.Artifacts.Rect[]} rects
 * @return {LH.Artifacts.Rect[]}
 */
function filterOutTinyRects(rects) {
  return rects.filter(
    rect => rect.width > 1 && rect.height > 1
  );
}

/**
 * @param {LH.Artifacts.Rect[]} rects
 * @return {LH.Artifacts.Rect[]}
 */
function filterOutRectsContainedByOthers(rects) {
  const rectsToKeep = new Set(rects);

  for (const rect of rects) {
    for (const possiblyContainingRect of rects) {
      if (rect === possiblyContainingRect) continue;
      if (!rectsToKeep.has(possiblyContainingRect)) continue;
      if (rectContains(possiblyContainingRect, rect)) {
        rectsToKeep.delete(rect);
        break;
      }
    }
  }

  return Array.from(rectsToKeep);
}

/**
 * @param {LH.Artifacts.Rect} rect
 */
/* c8 ignore start */
function getRectCenterPoint(rect) {
  return {
    x: rect.left + rect.width / 2,
    y: rect.top + rect.height / 2,
  };
}
/* c8 ignore stop */

/**
 * @param {LH.Artifacts.Rect} rectA
 * @param {LH.Artifacts.Rect} rectB
 * @return {boolean}
 */
function rectsTouchOrOverlap(rectA, rectB) {
  // https://stackoverflow.com/questions/2752349/fast-rectangle-to-rectangle-intersection
  return (
    rectA.left <= rectB.right &&
    rectB.left <= rectA.right &&
    rectA.top <= rectB.bottom &&
    rectB.top <= rectA.bottom
  );
}

/**
 * Returns a bounding rect for all the passed in rects, with padded with half of
 * `padding` on all sides.
 * @param {LH.Artifacts.Rect[]} rects
 * @param {number} padding
 * @return {LH.Artifacts.Rect}
 */
function getBoundingRectWithPadding(rects, padding) {
  if (rects.length === 0) {
    throw new Error('No rects to take bounds of');
  }

  let left = Number.MAX_VALUE;
  let right = -Number.MAX_VALUE;
  let top = Number.MAX_VALUE;
  let bottom = -Number.MAX_VALUE;
  for (const rect of rects) {
    left = Math.min(left, rect.left);
    right = Math.max(right, rect.right);
    top = Math.min(top, rect.top);
    bottom = Math.max(bottom, rect.bottom);
  }

  // Pad on all sides.
  const halfMinSize = padding / 2;
  left -= halfMinSize;
  right += halfMinSize;
  top -= halfMinSize;
  bottom += halfMinSize;

  return {
    left,
    right,
    top,
    bottom,
    width: right - left,
    height: bottom - top,
  };
}

/**
 * @param {LH.Artifacts.Rect[]} rects
 */
function getBoundingRect(rects) {
  return getBoundingRectWithPadding(rects, 0);
}

/**
 * @param {{left:number, top:number, right:number, bottom: number}} rect
 * @return {LH.Artifacts.Rect}
 */
function addRectWidthAndHeight({left, top, right, bottom}) {
  return {
    left,
    top,
    right,
    bottom,
    width: right - left,
    height: bottom - top,
  };
}

/**
 * @param {{x:number, y:number, width:number, height: number}} rect
 * @return {LH.Artifacts.Rect}
 */
function addRectTopAndBottom({x, y, width, height}) {
  return {
    left: x,
    top: y,
    right: x + width,
    bottom: y + height,
    width,
    height,
  };
}

/**
 * @param {LH.Artifacts.Rect} rect1
 * @param {LH.Artifacts.Rect} rect2
 */
function getRectOverlapArea(rect1, rect2) {
  // https://stackoverflow.com/a/9325084/1290545
  const rectYOverlap = Math.min(rect1.bottom, rect2.bottom) - Math.max(rect1.top, rect2.top);
  if (rectYOverlap <= 0) return 0;

  const rectXOverlap = Math.min(rect1.right, rect2.right) - Math.max(rect1.left, rect2.left);
  if (rectXOverlap <= 0) return 0;

  return rectXOverlap * rectYOverlap;
}

/**
 * @param {LH.Artifacts.Rect} rect
 * @param {number} centerRectSize
 */
function getRectAtCenter(rect, centerRectSize) {
  return addRectWidthAndHeight({
    left: rect.left + rect.width / 2 - centerRectSize / 2,
    top: rect.top + rect.height / 2 - centerRectSize / 2,
    right: rect.right - rect.width / 2 + centerRectSize / 2,
    bottom: rect.bottom - rect.height / 2 + centerRectSize / 2,
  });
}

/**
 * @param {LH.Artifacts.Rect} rect
 */
/* c8 ignore start */
function getRectArea(rect) {
  return rect.width * rect.height;
}
/* c8 ignore stop */

/**
 * @param {LH.Artifacts.Rect[]} rects
 */
/* c8 ignore start */
function getLargestRect(rects) {
  let largestRect = rects[0];
  for (const rect of rects) {
    if (getRectArea(rect) > getRectArea(largestRect)) {
      largestRect = rect;
    }
  }
  return largestRect;
}
/* c8 ignore stop */

/**
 *
 * @param {LH.Artifacts.Rect[]} rectListA
 * @param {LH.Artifacts.Rect[]} rectListB
 */
function allRectsContainedWithinEachOther(rectListA, rectListB) {
  for (const rectA of rectListA) {
    for (const rectB of rectListB) {
      if (!rectContains(rectA, rectB) && !rectContains(rectB, rectA)) {
        return false;
      }
    }
  }
  return true;
}

module.exports = {
  rectContainsPoint,
  rectContains,
  addRectWidthAndHeight,
  addRectTopAndBottom,
  getRectOverlapArea,
  getRectAtCenter,
  getLargestRect,
  getRectArea,
  getRectCenterPoint,
  getBoundingRect,
  getBoundingRectWithPadding,
  rectsTouchOrOverlap,
  allRectsContainedWithinEachOther,
  filterOutRectsContainedByOthers,
  filterOutTinyRects,
};

},{}],112:[function(require,module,exports){
/**
 * @license Copyright 2017 The Lighthouse Authors. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.
 */
'use strict';

const log = require('lighthouse-logger');

/** @typedef {import('raven').CaptureOptions} CaptureOptions */
/** @typedef {import('raven').ConstructorOptions} ConstructorOptions */

const SENTRY_URL = 'https://a6bb0da87ee048cc9ae2a345fc09ab2e:63a7029f46f74265981b7e005e0f69f8@sentry.io/174697';

// Per-run chance of capturing errors (if enabled).
const SAMPLE_RATE = 0.01;

/** @type {Array<{pattern: RegExp, rate: number}>} */
const SAMPLED_ERRORS = [
  // Error code based sampling. Delete if still unused after 2019-01-01.
  // e.g.: {pattern: /No.*node with given id/, rate: 0.01},
];

const noop = () => {};

/**
 * A delegate for sentry so that environments without error reporting enabled will use
 * noop functions and environments with error reporting will call the actual Sentry methods.
 */
const sentryDelegate = {
  init,
  /** @type {(message: string, options?: CaptureOptions) => void} */
  captureMessage: noop,
  /** @type {(breadcrumb: any) => void} */
  captureBreadcrumb: noop,
  /** @type {() => any} */
  getContext: noop,
  /** @type {(error: Error, options?: CaptureOptions) => Promise<void>} */
  captureException: async () => {},
  _shouldSample() {
    return SAMPLE_RATE >= Math.random();
  },
};

/**
 * When called, replaces noops with actual Sentry implementation.
 * @param {{url: string, flags: LH.CliFlags, environmentData: ConstructorOptions}} opts
 */
function init(opts) {
  // If error reporting is disabled, leave the functions as a noop
  if (!opts.flags.enableErrorReporting) {
    return;
  }

  // If not selected for samping, leave the functions as a noop.
  if (!sentryDelegate._shouldSample()) {
    return;
  }

  try {
    const Sentry = require('raven');
    const sentryConfig = Object.assign({}, opts.environmentData,
      {captureUnhandledRejections: true});
    Sentry.config(SENTRY_URL, sentryConfig).install();

    // Have each delegate function call the corresponding sentry function by default
    sentryDelegate.captureMessage = (...args) => Sentry.captureMessage(...args);
    sentryDelegate.captureBreadcrumb = (...args) => Sentry.captureBreadcrumb(...args);
    sentryDelegate.getContext = () => Sentry.getContext();

    // Keep a record of exceptions per audit/gatherer so we can just report once
    const sentryExceptionCache = new Map();
    // Special case captureException to return a Promise so we don't process.exit too early
    sentryDelegate.captureException = async (err, opts = {}) => {
      // Ignore if there wasn't an error
      if (!err) return;

      // Ignore expected errors
      // @ts-expect-error Non-standard property added to flag error as not needing capturing.
      if (err.expected) return;

      const tags = opts.tags || {};
      if (tags.audit) {
        const key = `audit-${tags.audit}-${err.message}`;
        if (sentryExceptionCache.has(key)) return;
        sentryExceptionCache.set(key, true);
      }

      if (tags.gatherer) {
        const key = `gatherer-${tags.gatherer}-${err.message}`;
        if (sentryExceptionCache.has(key)) return;
        sentryExceptionCache.set(key, true);
      }

      // Sample known errors that occur at a high frequency.
      const sampledErrorMatch = SAMPLED_ERRORS.find(sample => sample.pattern.test(err.message));
      if (sampledErrorMatch && sampledErrorMatch.rate <= Math.random()) return;

      // @ts-expect-error - properties added to protocol method LHErrors.
      if (err.protocolMethod) {
        // Protocol errors all share same stack trace, so add more to fingerprint
        // @ts-expect-error - properties added to protocol method LHErrors.
        opts.fingerprint = ['{{ default }}', err.protocolMethod, err.protocolError];

        opts.tags = opts.tags || {};
        // @ts-expect-error - properties added to protocol method LHErrors.
        opts.tags.protocolMethod = err.protocolMethod;
      }

      return new Promise(resolve => {
        Sentry.captureException(err, opts, () => resolve());
      });
    };

    const context = Object.assign({
      url: opts.url,
      formFactor: opts.flags.formFactor,
      throttlingMethod: opts.flags.throttlingMethod,
    }, opts.flags.throttling);
    Sentry.mergeContext({extra: Object.assign({}, opts.environmentData.extra, context)});
  } catch (e) {
    log.warn(
      'sentry',
      'Could not load raven library, errors will not be reported.'
    );
  }
}

module.exports = sentryDelegate;

},{"lighthouse-logger":188,"raven":144}],113:[function(require,module,exports){
/**
 * @license Copyright 2019 The Lighthouse Authors. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.
 */
'use strict';

const log = require('lighthouse-logger');
const stackPacks = require('lighthouse-stack-packs');
const i18n = require('./i18n/i18n.js');

/**
 * Resolve a module on web and node
 * @param {string} module
 */
function resolve(module) {
  if (!require.resolve) {
    return `node_modules/${module}`;
  }

  return require.resolve(module);
}

/**
 * Pairs consisting of a stack pack's ID and the set of stacks needed to be
 * detected in a page to display that pack's advice.
 * @type {Array<{packId: string, requiredStacks: Array<string>}>}
 */
const stackPacksToInclude = [
  {
    packId: 'wordpress',
    requiredStacks: ['js:wordpress'],
  },
  {
    packId: 'drupal',
    requiredStacks: ['js:drupal'],
  },
  {
    packId: 'react',
    requiredStacks: ['js:react'],
  },
  {
    packId: 'angular',
    requiredStacks: ['js:@angular/core'],
  },
  {
    packId: 'amp',
    requiredStacks: ['js:amp'],
  },
  {
    packId: 'magento',
    requiredStacks: ['js:magento'],
  },
  {
    packId: 'octobercms',
    requiredStacks: ['js:octobercms'],
  },
  {
    packId: 'joomla',
    requiredStacks: ['js:joomla'],
  },
];

/**
 * Returns all packs that match the stacks found in the page.
 * @param {LH.Artifacts['Stacks']} pageStacks
 * @return {LH.RawIcu<Array<LH.Result.StackPack>>}
 */
function getStackPacks(pageStacks) {
  /** @type {LH.RawIcu<Array<LH.Result.StackPack>>} */
  const packs = [];

  for (const pageStack of pageStacks) {
    const stackPackToIncl = stackPacksToInclude.find(stackPackToIncl =>
      stackPackToIncl.requiredStacks.includes(`${pageStack.detector}:${pageStack.id}`));
    if (!stackPackToIncl) {
      continue;
    }

    // Grab the full pack definition.
    const matchedPack = stackPacks.find(pack => pack.id === stackPackToIncl.packId);
    if (!matchedPack) {
      log.warn('StackPacks',
        `'${stackPackToIncl.packId}' stack pack was matched but is not found in stack-packs lib`);
      continue;
    }

    // Create i18n handler to get translated strings.
    const str_ = i18n.createMessageInstanceIdFn(
      resolve(`lighthouse-stack-packs/packs/${matchedPack.id}`),
      matchedPack.UIStrings
    );

    /** @type {Record<string, LH.IcuMessage>} */
    const descriptions = {};
    /** @type {Record<string, string>} */
    const UIStrings = matchedPack.UIStrings;

    // Convert all strings into the correct translation.
    for (const key in UIStrings) {
      if (UIStrings[key]) {
        descriptions[key] = str_(UIStrings[key]);
      }
    }

    packs.push({
      id: matchedPack.id,
      title: matchedPack.title,
      iconDataURL: matchedPack.icon,
      descriptions,
    });
  }

  return packs;
}

module.exports = {
  getStackPacks,
  stackPacksToInclude,
};

},{"./i18n/i18n.js":96,"lighthouse-logger":188,"lighthouse-stack-packs":208}],114:[function(require,module,exports){
/**
 * @license Copyright 2017 The Lighthouse Authors. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.
 */
'use strict';

/**
 * Approximates the Gauss error function, the probability that a random variable
 * from the standard normal distribution lies within [-x, x]. Moved from
 * traceviewer.b.math.erf, based on Abramowitz and Stegun, formula 7.1.26.
 * @param {number} x
 * @return {number}
 */
function erf(x) {
  // erf(-x) = -erf(x);
  const sign = Math.sign(x);
  x = Math.abs(x);

  const a1 = 0.254829592;
  const a2 = -0.284496736;
  const a3 = 1.421413741;
  const a4 = -1.453152027;
  const a5 = 1.061405429;
  const p = 0.3275911;
  const t = 1 / (1 + p * x);
  const y = t * (a1 + t * (a2 + t * (a3 + t * (a4 + t * a5))));
  return sign * (1 - y * Math.exp(-x * x));
}

/**
 * Creates a log-normal distribution à la traceviewer's statistics package.
 * Specified by providing the median value, at which the score will be 0.5,
 * and the falloff, the initial point of diminishing returns where any
 * improvement in value will yield increasingly smaller gains in score. Both
 * values should be in the same units (e.g. milliseconds). See
 *   https://www.desmos.com/calculator/tx1wcjk8ch
 * for an interactive view of the relationship between these parameters and
 * the typical parameterization (location and shape) of the log-normal
 * distribution.
 * @param {number} median
 * @param {number} falloff
 * @return {{computeComplementaryPercentile: function(number): number}}
 */
function getLogNormalDistribution(median, falloff) {
  const location = Math.log(median);

  // The "falloff" value specified the location of the smaller of the positive
  // roots of the third derivative of the log-normal CDF. Calculate the shape
  // parameter in terms of that value and the median.
  const logRatio = Math.log(falloff / median);
  const shape = Math.sqrt(1 - 3 * logRatio - Math.sqrt((logRatio - 3) * (logRatio - 3) - 8)) / 2;

  return {
    computeComplementaryPercentile(x) {
      const standardizedX = (Math.log(x) - location) / (Math.SQRT2 * shape);
      return (1 - erf(standardizedX)) / 2;
    },
  };
}

/**
 * Returns the score (1 - percentile) of `value` in a log-normal distribution
 * specified by the `median` value, at which the score will be 0.5, and a 10th
 * percentile value, at which the score will be 0.9. The score represents the
 * amount of the distribution greater than `value`. All values should be in the
 * same units (e.g. milliseconds). See
 *   https://www.desmos.com/calculator/o98tbeyt1t
 * for an interactive view of the relationship between these parameters and the
 * typical parameterization (location and shape) of the log-normal distribution.
 * @param {{median: number, p10: number}} parameters
 * @param {number} value
 * @return {number}
 */
function getLogNormalScore({median, p10}, value) {
  // Required for the log-normal distribution.
  if (median <= 0) throw new Error('median must be greater than zero');
  if (p10 <= 0) throw new Error('p10 must be greater than zero');
  // Not required, but if p10 > median, it flips around and becomes the p90 point.
  if (p10 >= median) throw new Error('p10 must be less than the median');

  // Non-positive values aren't in the distribution, so always 1.
  if (value <= 0) return 1;

  // Closest double to `erfc-1(2 * 1/10)`.
  const INVERSE_ERFC_ONE_FIFTH = 0.9061938024368232;

  // Shape (σ) is `log(p10/median) / (sqrt(2)*erfc^-1(2 * 1/10))` and
  // standardizedX is `1/2 erfc(log(value/median) / (sqrt(2)*σ))`, so simplify a bit.
  const xLogRatio = Math.log(value / median);
  const p10LogRatio = -Math.log(p10 / median); // negate to keep σ positive.
  const standardizedX = xLogRatio * INVERSE_ERFC_ONE_FIFTH / p10LogRatio;
  const complementaryPercentile = (1 - erf(standardizedX)) / 2;

  // Clamp to [0, 1] to avoid any floating-point out-of-bounds issues.
  return Math.min(1, Math.max(0, complementaryPercentile));
}

/**
 * Interpolates the y value at a point x on the line defined by (x0, y0) and (x1, y1)
 * @param {number} x0
 * @param {number} y0
 * @param {number} x1
 * @param {number} y1
 * @param {number} x
 * @return {number}
 */
function linearInterpolation(x0, y0, x1, y1, x) {
  const slope = (y1 - y0) / (x1 - x0);
  return y0 + (x - x0) * slope;
}

module.exports = {
  linearInterpolation,
  getLogNormalDistribution,
  getLogNormalScore,
};

},{}],115:[function(require,module,exports){
/**
 * @license Copyright 2018 The Lighthouse Authors. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.
 */
'use strict';

const {
  filterOutRectsContainedByOthers,
  filterOutTinyRects,
  rectsTouchOrOverlap,
  rectContainsPoint,
  getBoundingRect,
  getRectCenterPoint,
} = require('./rect-helpers.js');

/**
 * Merge client rects together and remove small ones. This may result in a larger overall
 * size than that of the individual client rects.
 * We use this to simulate a finger tap on those targets later on.
 * @param {LH.Artifacts.Rect[]} clientRects
 */
function getTappableRectsFromClientRects(clientRects) {
  // 1x1px rect shouldn't be reason to treat the rect as something the user should tap on.
  // Often they're made invisble in some obscure way anyway, and only exist for e.g. accessibiliity.
  clientRects = filterOutTinyRects(clientRects);
  clientRects = filterOutRectsContainedByOthers(clientRects);
  clientRects = mergeTouchingClientRects(clientRects);
  return clientRects;
}

/**
 * Sometimes a child will reach out of the parent by a few px, but still
 * clearly belong to the same tap area in the users's eyes.
 * We can be quite generous here, since merging too much tends to cause false
 * passes instead of false failures (because there are more fingers)
 * @param {number} a
 * @param {number} b
 */
function almostEqual(a, b) {
  return Math.abs(a - b) <= 10;
}

/**
 * Merge touching rects based on what appears as one tappable area to the user.
 * @param {LH.Artifacts.Rect[]} clientRects
 * @return {LH.Artifacts.Rect[]}
 */
function mergeTouchingClientRects(clientRects) {
  for (let i = 0; i < clientRects.length; i++) {
    for (let j = i + 1; j < clientRects.length; j++) {
      const crA = clientRects[i];
      const crB = clientRects[j];

      /**
       * We try to determine whether the rects appear as a single tappable
       * area to the user, so that they'd tap in the middle of the merged rect.
       * Examples of what we want to merge:
       *
       * AAABBB
       *
       * AAA
       * AAA
       * BBBBB
       */
      const rectsLineUpHorizontally =
        almostEqual(crA.top, crB.top) || almostEqual(crA.bottom, crB.bottom);
      const rectsLineUpVertically =
        almostEqual(crA.left, crB.left) || almostEqual(crA.right, crB.right);
      const canMerge =
        rectsTouchOrOverlap(crA, crB) &&
        (rectsLineUpHorizontally || rectsLineUpVertically);

      if (canMerge) {
        const replacementClientRect = getBoundingRect([crA, crB]);
        const mergedRectCenter = getRectCenterPoint(replacementClientRect);

        if (
          !(
            rectContainsPoint(crA, mergedRectCenter) ||
            rectContainsPoint(crB, mergedRectCenter)
          )
        ) {
          // Don't merge because the new shape is too different from the
          // merged rects, and tapping in the middle wouldn't actually hit
          // either rect
          continue;
        }

        // Replace client rects with merged version
        clientRects = clientRects.filter(cr => cr !== crA && cr !== crB);
        clientRects.push(replacementClientRect);

        // Start over so we don't have to handle complexity introduced by array mutation.
        // Client rect ararys rarely contain more than 5 rects, so starting again doesn't cause perf issues.
        return mergeTouchingClientRects(clientRects);
      }
    }
  }

  return clientRects;
}

module.exports = {
  getTappableRectsFromClientRects,
};

},{"./rect-helpers.js":111}],116:[function(require,module,exports){
/**
 * @license Copyright 2020 The Lighthouse Authors. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.
 */
'use strict';

const thirdPartyWeb = require('third-party-web/httparchive-nostats-subset');

/** @typedef {import("third-party-web").IEntity} ThirdPartyEntity */
/** @typedef {import("third-party-web").IProduct} ThirdPartyProduct */

/**
 * @param {string} url
 * @return {ThirdPartyEntity|undefined}
 */
function getEntity(url) {
  return thirdPartyWeb.getEntity(url);
}

/**
 * @param {string} url
 * @return {ThirdPartyProduct|undefined}
 */
function getProduct(url) {
  return thirdPartyWeb.getProduct(url);
}

/**
 * @param {string} url
 * @param {ThirdPartyEntity | undefined} mainDocumentEntity
 */
function isThirdParty(url, mainDocumentEntity) {
  const entity = getEntity(url);
  if (!entity) return false;
  if (entity === mainDocumentEntity) return false;
  return true;
}

/**
 * @param {string} url
 * @param {ThirdPartyEntity | undefined} mainDocumentEntity
 */
function isFirstParty(url, mainDocumentEntity) {
  return !isThirdParty(url, mainDocumentEntity);
}

module.exports = {
  getEntity,
  getProduct,
  isThirdParty,
  isFirstParty,
};

},{"third-party-web/httparchive-nostats-subset":251}],117:[function(require,module,exports){
/**
 * @license Copyright 2017 The Lighthouse Authors. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.
 */
'use strict';

const {taskGroups, taskNameToGroup} = require('./task-groups.js');

/**
 * @fileoverview
 *
 * This artifact converts the array of raw trace events into an array of hierarchical
 * tasks for easier consumption and bottom-up analysis.
 *
 * Events are easily produced but difficult to consume. They're a mixture of start/end markers, "complete" events, etc.
 * @see https://docs.google.com/document/d/1CvAClvFfyA5R-PhYUmn5OOQtYMH4h6I0nSsKchNAySU/preview
 *
 * LH's TaskNode is an artifact that fills in the gaps a trace event leaves behind.
 * i.e. when did it end? which events are children/parents of this one?
 *
 * Each task will have its group/classification, start time, end time,
 * duration, and self time computed. Each task will potentially have a parent, children, and an
 * attributableURL for the script that was executing/forced this execution.
 */

/** @typedef {import('./task-groups.js').TaskGroup} TaskGroup */

/**
 * @typedef TaskNode
 * @prop {LH.TraceEvent} event
 * @prop {LH.TraceEvent|undefined} endEvent
 * @prop {TaskNode[]} children
 * @prop {TaskNode|undefined} parent
 * @prop {boolean} unbounded Indicates that the task had an endTime that was inferred rather than specified in the trace. i.e. in the source trace this task was unbounded.
 * @prop {number} startTime
 * @prop {number} endTime
 * @prop {number} duration
 * @prop {number} selfTime
 * @prop {string[]} attributableURLs
 * @prop {TaskGroup} group
 */

/** @typedef {{timers: Map<string, TaskNode>, xhrs: Map<string, TaskNode>, frameURLsById: Map<string, string>, lastTaskURLs: string[]}} PriorTaskData */

class MainThreadTasks {
  /**
   * @param {LH.TraceEvent} event
   * @param {LH.TraceEvent} [endEvent]
   * @return {TaskNode}
   */
  static _createNewTaskNode(event, endEvent) {
    const isCompleteEvent = event.ph === 'X' && !endEvent;
    const isStartEndEventPair = event.ph === 'B' && endEvent && endEvent.ph === 'E';
    if (!isCompleteEvent && !isStartEndEventPair) {
      throw new Error('Invalid parameters for _createNewTaskNode');
    }

    const startTime = event.ts;
    const endTime = endEvent ? endEvent.ts : event.ts + Number(event.dur || 0);

    const newTask = {
      event,
      endEvent,
      startTime,
      endTime,
      duration: endTime - startTime,

      // These properties will be filled in later
      unbounded: false,
      parent: undefined,
      children: [],
      attributableURLs: [],
      group: taskGroups.other,
      selfTime: NaN,
    };

    return newTask;
  }

  /**
   *
   * @param {TaskNode} currentTask
   * @param {number} stopTs
   * @param {PriorTaskData} priorTaskData
   * @param {Array<LH.TraceEvent>} reverseEventsQueue
   */
  static _assignAllTimersUntilTs(
      currentTask,
      stopTs,
      priorTaskData,
      reverseEventsQueue
  ) {
    while (reverseEventsQueue.length) {
      const nextTimerInstallEvent = reverseEventsQueue.pop();
      // We're out of events to look at; we're done.
      if (!nextTimerInstallEvent) break;

      // Timer event is after our current task; push it back on for next time, and we're done.
      if (nextTimerInstallEvent.ts > stopTs) {
        reverseEventsQueue.push(nextTimerInstallEvent);
        break;
      }

      // Timer event is before the current task, just skip it.
      if (nextTimerInstallEvent.ts < currentTask.startTime) {
        continue;
      }

      // We're right where we need to be, point the timerId to our `currentTask`
      /** @type {string} */
      // @ts-expect-error - timerId exists on `TimerInstall` events.
      const timerId = nextTimerInstallEvent.args.data.timerId;
      priorTaskData.timers.set(timerId, currentTask);
    }
  }

  /**
   * This function takes the start and end events from a thread and creates tasks from them.
   * We do this by iterating through the start and end event arrays simultaneously. For each start
   * event we attempt to find its end event.
   *
   * Because of this matching of start/end events and the need to be mutating our end events queue,
   * we reverse the array to more efficiently `.pop()` them off rather than `.shift()` them off.
   * While it's true the worst case runtime here is O(n^2), ~99.999% of the time the reverse loop is O(1)
   * because the overwhelmingly common case is that end event for a given start event is simply the very next event in our queue.
   *
   * @param {LH.TraceEvent[]} taskStartEvents
   * @param {LH.TraceEvent[]} taskEndEvents
   * @param {number} traceEndTs
   * @return {TaskNode[]}
   */
  static _createTasksFromStartAndEndEvents(taskStartEvents, taskEndEvents, traceEndTs) {
    /** @type {TaskNode[]} */
    const tasks = [];
    // Create a reversed copy of the array to avoid copying the rest of the queue on every mutation.
    // i.e. pop() is O(1) while shift() is O(n), we take the earliest ts element off the queue *a lot*
    // so we'll optimize for having the earliest timestamp events at the end of the array.
    const taskEndEventsReverseQueue = taskEndEvents.slice().reverse();

    for (let i = 0; i < taskStartEvents.length; i++) {
      const taskStartEvent = taskStartEvents[i];
      if (taskStartEvent.ph === 'X') {
        // Task is a complete X event, we have all the information we need already.
        tasks.push(MainThreadTasks._createNewTaskNode(taskStartEvent));
        continue;
      }

      // Task is a B/E event pair, we need to find the matching E event.
      let matchedEventIndex = -1;
      let matchingNestedEventCount = 0;
      let matchingNestedEventIndex = i + 1;

      // We loop through the reversed end events queue from back to front because we still want to
      // see end events in increasing timestamp order.
      // While worst case we will loop through all events, the overwhelmingly common case is that
      // the immediate next event is our event of interest which makes this loop typically O(1).
      for (let j = taskEndEventsReverseQueue.length - 1; j >= 0; j--) {
        const endEvent = taskEndEventsReverseQueue[j];
        // We are considering an end event, so we'll count how many nested events we saw along the way.
        for (; matchingNestedEventIndex < taskStartEvents.length; matchingNestedEventIndex++) {
          if (taskStartEvents[matchingNestedEventIndex].ts >= endEvent.ts) break;

          if (taskStartEvents[matchingNestedEventIndex].name === taskStartEvent.name) {
            matchingNestedEventCount++;
          }
        }

        // The event doesn't have a matching name, skip it.
        if (endEvent.name !== taskStartEvent.name) continue;
        // The event has a timestamp that is too early, skip it.
        if (endEvent.ts < taskStartEvent.ts) continue;

        // The event matches our name and happened after start, the last thing to check is if it was for a nested event.
        if (matchingNestedEventCount > 0) {
          // If it was for a nested event, decrement our counter and move on.
          matchingNestedEventCount--;
          continue;
        }

        // If it wasn't, we found our matching E event! Mark the index and stop the loop.
        matchedEventIndex = j;
        break;
      }

      /** @type {LH.TraceEvent} */
      let taskEndEvent;
      let unbounded = false;
      if (matchedEventIndex === -1) {
        // If we couldn't find an end event, we'll assume it's the end of the trace.
        // If this creates invalid parent/child relationships it will be caught in the next step.
        taskEndEvent = {...taskStartEvent, ph: 'E', ts: traceEndTs};
        unbounded = true;
      } else if (matchedEventIndex === taskEndEventsReverseQueue.length - 1) {
        // Use .pop() in the common case where the immediately next event is needed.
        // It's ~25x faster, https://jsperf.com/pop-vs-splice.
        taskEndEvent = /** @type {LH.TraceEvent} */ (taskEndEventsReverseQueue.pop());
      } else {
        taskEndEvent = taskEndEventsReverseQueue.splice(matchedEventIndex, 1)[0];
      }

      const task = MainThreadTasks._createNewTaskNode(taskStartEvent, taskEndEvent);
      task.unbounded = unbounded;
      tasks.push(task);
    }

    if (taskEndEventsReverseQueue.length) {
      throw new Error(
        `Fatal trace logic error - ${taskEndEventsReverseQueue.length} unmatched end events`
      );
    }

    return tasks;
  }

  /**
   * This function iterates through the tasks to set the `.parent`/`.children` properties of tasks
   * according to their implied nesting structure. If any of these relationships seem impossible based on
   * the timestamps, this method will throw.
   *
   * @param {TaskNode[]} sortedTasks
   * @param {LH.TraceEvent[]} timerInstallEvents
   * @param {PriorTaskData} priorTaskData
   */
  static _createTaskRelationships(sortedTasks, timerInstallEvents, priorTaskData) {
    /** @type {TaskNode|undefined} */
    let currentTask;
    // Create a reversed copy of the array to avoid copying the rest of the queue on every mutation.
    const timerInstallEventsReverseQueue = timerInstallEvents.slice().reverse();

    for (let i = 0; i < sortedTasks.length; i++) {
      let nextTask = sortedTasks[i];

      // Do bookkeeping on XHR requester data.
      if (nextTask.event.name === 'XHRReadyStateChange') {
        const data = nextTask.event.args.data;
        const url = data && data.url;
        if (data && url && data.readyState === 1) priorTaskData.xhrs.set(url, nextTask);
      }

      // This inner loop updates what our `currentTask` is at `nextTask.startTime - ε`.
      // While `nextTask` starts after our `currentTask`, close out the task, popup to the parent, and repeat.
      // If at the end `currentTask` is undefined, then `nextTask` is a toplevel task.
      // Otherwise, `nextTask` is a child of `currentTask`.
      while (
        currentTask &&
        Number.isFinite(currentTask.endTime) &&
        currentTask.endTime <= nextTask.startTime
      ) {
        MainThreadTasks._assignAllTimersUntilTs(
          currentTask,
          currentTask.endTime,
          priorTaskData,
          timerInstallEventsReverseQueue
        );
        currentTask = currentTask.parent;
      }

      // If there's a `currentTask`, `nextTask` must be a child.
      // Set the `.parent`/`.children` relationships and timer bookkeeping accordingly.
      if (currentTask) {
        if (nextTask.endTime > currentTask.endTime) {
          const timeDelta = nextTask.endTime - currentTask.endTime;
          // The child task is taking longer than the parent task, which should be impossible.
          // In reality these situations happen, so we allow for some flexibility in trace event times.
          if (timeDelta < 1000) {
            // It's less than 1ms, we'll let it slide by increasing the duration of the parent.
            currentTask.endTime = nextTask.endTime;
            currentTask.duration += timeDelta;
          } else if (nextTask.unbounded) {
            // It's ending at traceEndTs, it means we were missing the end event. We'll truncate it to the parent.
            nextTask.endTime = currentTask.endTime;
            nextTask.duration = nextTask.endTime - nextTask.startTime;
          } else if (
            nextTask.startTime - currentTask.startTime < 1000 &&
            !currentTask.children.length
          ) {
            // The true parent started less than 1ms before the true child, so we're looking at the relationship backwards.
            // We'll let it slide and fix the situation by swapping the two tasks into their correct positions
            // and increasing the duration of the parent.

            // Below is an artistic rendition of the heirarchy we are trying to create.
            //   ████████████currentTask.parent██████████████████
            //       █████████nextTask██████████████
            //      ███████currentTask███████
            const actualParentTask = nextTask;
            const actualChildTask = currentTask;

            // We'll grab the grandparent task to see if we need to fix it.
            // We'll reassign it to be the parent of `actualParentTask` in a bit.
            const grandparentTask = currentTask.parent;
            if (grandparentTask) {
              const lastGrandparentChildIndex = grandparentTask.children.length - 1;
              if (grandparentTask.children[lastGrandparentChildIndex] !== actualChildTask) {
                // The child we need to swap should always be the most recently added child.
                // But if not then there's a serious bug in this code, so double-check.
                throw new Error('Fatal trace logic error - impossible children');
              }

              grandparentTask.children.pop();
              grandparentTask.children.push(actualParentTask);
            }

            actualParentTask.parent = grandparentTask;
            actualParentTask.startTime = actualChildTask.startTime;
            actualParentTask.duration = actualParentTask.endTime - actualParentTask.startTime;
            currentTask = actualParentTask;
            nextTask = actualChildTask;
          } else {
            // None of our workarounds matched. It's time to throw an error.
            // When we fall into this error, it's usually because of one of two reasons.
            //    - There was slop in the opposite direction (child started 1ms before parent),
            //      the child was assumed to be parent instead, and another task already started.
            //    - The child timestamp ended more than 1ms after the parent.
            //      Two unrelated tasks where the first hangs over the second by >1ms is also this case.
            // These have more complicated fixes, so handling separately https://github.com/GoogleChrome/lighthouse/pull/9491#discussion_r327331204.
            /** @type {any} */
            const error = new Error('Fatal trace logic error - child cannot end after parent');
            error.timeDelta = timeDelta;
            error.nextTaskEvent = nextTask.event;
            error.nextTaskEndEvent = nextTask.endEvent;
            error.nextTaskEndTime = nextTask.endTime;
            error.currentTaskEvent = currentTask.event;
            error.currentTaskEndEvent = currentTask.endEvent;
            error.currentTaskEndTime = currentTask.endTime;
            throw error;
          }
        }

        nextTask.parent = currentTask;
        currentTask.children.push(nextTask);
        MainThreadTasks._assignAllTimersUntilTs(
          currentTask,
          nextTask.startTime,
          priorTaskData,
          timerInstallEventsReverseQueue
        );
      }

      currentTask = nextTask;
    }

    if (currentTask) {
      MainThreadTasks._assignAllTimersUntilTs(
        currentTask,
        currentTask.endTime,
        priorTaskData,
        timerInstallEventsReverseQueue
      );
    }
  }

  /**
   * This function takes the raw trace events sorted in increasing timestamp order and outputs connected task nodes.
   * To create the task heirarchy we make several passes over the events.
   *
   *    1. Create three arrays of X/B events, E events, and TimerInstall events.
   *    2. Create tasks for each X/B event, throwing if a matching E event cannot be found for a given B.
   *    3. Sort the tasks by ↑ startTime, ↓ duration.
   *    4. Match each task to its parent, throwing if there is any invalid overlap between tasks.
   *    5. Sort the tasks once more by ↑ startTime, ↓ duration in case they changed during relationship creation.
   *
   * @param {LH.TraceEvent[]} mainThreadEvents
   * @param {PriorTaskData} priorTaskData
   * @param {number} traceEndTs
   * @return {TaskNode[]}
   */
  static _createTasksFromEvents(mainThreadEvents, priorTaskData, traceEndTs) {
    /** @type {Array<LH.TraceEvent>} */
    const taskStartEvents = [];
    /** @type {Array<LH.TraceEvent>} */
    const taskEndEvents = [];
    /** @type {Array<LH.TraceEvent>} */
    const timerInstallEvents = [];

    // Phase 1 - Create three arrays of X/B events, E events, and TimerInstall events.
    for (const event of mainThreadEvents) {
      if (event.ph === 'X' || event.ph === 'B') taskStartEvents.push(event);
      if (event.ph === 'E') taskEndEvents.push(event);
      if (event.name === 'TimerInstall') timerInstallEvents.push(event);
    }

    // Phase 2 - Create tasks for each taskStartEvent.
    const tasks = MainThreadTasks._createTasksFromStartAndEndEvents(
      taskStartEvents,
      taskEndEvents,
      traceEndTs
    );

    // Phase 3 - Sort the tasks by increasing startTime, decreasing duration.
    const sortedTasks = tasks.sort(
      (taskA, taskB) => taskA.startTime - taskB.startTime || taskB.duration - taskA.duration
    );

    // Phase 4 - Match each task to its parent.
    MainThreadTasks._createTaskRelationships(sortedTasks, timerInstallEvents, priorTaskData);

    // Phase 5 - Sort once more in case the order changed after wiring up relationships.
    return sortedTasks.sort(
      (taskA, taskB) => taskA.startTime - taskB.startTime || taskB.duration - taskA.duration
    );
  }

  /**
   * @param {TaskNode} task
   * @param {TaskNode|undefined} parent
   * @return {number}
   */
  static _computeRecursiveSelfTime(task, parent) {
    if (parent && task.endTime > parent.endTime) {
      throw new Error('Fatal trace logic error - child cannot end after parent');
    }

    const childTime = task.children
      .map(child => MainThreadTasks._computeRecursiveSelfTime(child, task))
      .reduce((sum, child) => sum + child, 0);
    task.selfTime = task.duration - childTime;
    return task.duration;
  }

  /**
   * @param {TaskNode} task
   * @param {string[]} parentURLs
   * @param {string[]} allURLsInTree
   * @param {PriorTaskData} priorTaskData
   */
  static _computeRecursiveAttributableURLs(task, parentURLs, allURLsInTree, priorTaskData) {
    const args = task.event.args;
    const argsData = {...(args.beginData || {}), ...(args.data || {})};
    const frame = argsData.frame || '';
    let frameURL = priorTaskData.frameURLsById.get(frame);
    const stackFrameURLs = (argsData.stackTrace || []).map(entry => entry.url);

    // If the frame was an `about:blank` style ad frame, the first real URL will be more relevant to the frame's URL.
    const potentialFrameURL = stackFrameURLs[0];
    if (frame && frameURL && frameURL.startsWith('about:') && potentialFrameURL) {
      priorTaskData.frameURLsById.set(frame, potentialFrameURL);
      frameURL = potentialFrameURL;
    }

    /** @type {Array<string|undefined>} */
    let taskURLs = [];
    switch (task.event.name) {
      /**
       * Some trace events reference a specific script URL that triggered them.
       * Use this URL as the higher precedence attributable URL.
       * @see https://cs.chromium.org/chromium/src/third_party/blink/renderer/devtools/front_end/timeline/TimelineUIUtils.js?type=cs&q=_initEventStyles+-f:out+f:devtools&sq=package:chromium&g=0&l=678-744
       */
      case 'v8.compile':
      case 'EvaluateScript':
      case 'FunctionCall':
        taskURLs = [argsData.url, frameURL];
        break;
      case 'v8.compileModule':
        taskURLs = [task.event.args.fileName];
        break;
      case 'TimerFire': {
        /** @type {string} */
        // @ts-expect-error - timerId exists when name is TimerFire
        const timerId = task.event.args.data.timerId;
        const timerInstallerTaskNode = priorTaskData.timers.get(timerId);
        if (!timerInstallerTaskNode) break;
        taskURLs = timerInstallerTaskNode.attributableURLs;
        break;
      }
      case 'ParseHTML':
        taskURLs = [argsData.url, frameURL];
        break;
      case 'ParseAuthorStyleSheet':
        taskURLs = [argsData.styleSheetUrl, frameURL];
        break;
      case 'UpdateLayoutTree':
      case 'Layout':
      case 'Paint':
        // If we had a specific frame we were updating, just attribute it to that frame.
        if (frameURL) {
          taskURLs = [frameURL];
          break;
        }

        // Otherwise, sometimes Chrome will split layout into separate toplevel task after things have settled.
        // In this case we want to attribute the work to the prior task.
        // Inherit from previous task only if we don't have any task data set already.
        if (allURLsInTree.length) break;
        taskURLs = priorTaskData.lastTaskURLs;
        break;
      case 'XHRReadyStateChange':
      case 'XHRLoad': {
        // Inherit from task that issued the XHR
        const xhrUrl = argsData.url;
        const readyState = argsData.readyState;
        if (!xhrUrl || (typeof readyState === 'number' && readyState !== 4)) break;
        const xhrRequesterTaskNode = priorTaskData.xhrs.get(xhrUrl);
        if (!xhrRequesterTaskNode) break;
        taskURLs = xhrRequesterTaskNode.attributableURLs;
        break;
      }
      default:
        taskURLs = [];
        break;
    }

    /** @type {string[]} */
    const attributableURLs = Array.from(parentURLs);
    for (const url of [...taskURLs, ...stackFrameURLs]) {
      // Don't add empty URLs
      if (!url) continue;
      // Add unique URLs to our overall tree.
      if (!allURLsInTree.includes(url)) allURLsInTree.push(url);
      // Don't add consecutive, duplicate URLs
      if (attributableURLs[attributableURLs.length - 1] === url) continue;
      attributableURLs.push(url);
    }

    task.attributableURLs = attributableURLs;
    task.children.forEach(child =>
      MainThreadTasks._computeRecursiveAttributableURLs(
        child,
        attributableURLs,
        allURLsInTree,
        priorTaskData
      )
    );

    // After we've traversed the entire tree, set all the empty URLs to the set that we found in the task.
    // This attributes the overhead of browser task management to the scripts that created the work rather than
    // have it fall into the blackhole of "Other".
    if (!attributableURLs.length && !task.parent && allURLsInTree.length) {
      MainThreadTasks._setRecursiveEmptyAttributableURLs(task, allURLsInTree);
    }
  }

  /**
   * @param {TaskNode} task
   * @param {Array<string>} urls
   */
  static _setRecursiveEmptyAttributableURLs(task, urls) {
    // If this task had any attributableURLs, its children will too, so we can stop here.
    if (task.attributableURLs.length) return;

    task.attributableURLs = urls.slice();
    task.children.forEach(child =>
      MainThreadTasks._setRecursiveEmptyAttributableURLs(
        child,
        urls
      )
    );
  }

  /**
   * @param {TaskNode} task
   * @param {TaskGroup} [parentGroup]
   */
  static _computeRecursiveTaskGroup(task, parentGroup) {
    const group = taskNameToGroup[task.event.name];
    task.group = group || parentGroup || taskGroups.other;
    task.children.forEach(child => MainThreadTasks._computeRecursiveTaskGroup(child, task.group));
  }

  /**
   * @param {LH.TraceEvent[]} mainThreadEvents
   * @param {Array<{id: string, url: string}>} frames
   * @param {number} traceEndTs
   * @return {TaskNode[]}
   */
  static getMainThreadTasks(mainThreadEvents, frames, traceEndTs) {
    const timers = new Map();
    const xhrs = new Map();
    const frameURLsById = new Map();
    frames.forEach(({id, url}) => frameURLsById.set(id, url));
    /** @type {Array<string>} */
    const lastTaskURLs = [];
    const priorTaskData = {timers, xhrs, frameURLsById, lastTaskURLs};
    const tasks = MainThreadTasks._createTasksFromEvents(
      mainThreadEvents,
      priorTaskData,
      traceEndTs
    );

    // Compute the recursive properties we couldn't compute earlier, starting at the toplevel tasks
    for (const task of tasks) {
      if (task.parent) continue;

      MainThreadTasks._computeRecursiveSelfTime(task, undefined);
      MainThreadTasks._computeRecursiveAttributableURLs(task, [], [], priorTaskData);
      MainThreadTasks._computeRecursiveTaskGroup(task);
      priorTaskData.lastTaskURLs = task.attributableURLs;
    }

    // Rebase all the times to be relative to start of trace in ms
    const firstTs = (tasks[0] || {startTime: 0}).startTime;
    for (const task of tasks) {
      task.startTime = (task.startTime - firstTs) / 1000;
      task.endTime = (task.endTime - firstTs) / 1000;
      task.duration /= 1000;
      task.selfTime /= 1000;

      // Check that we have selfTime which captures all other timing data.
      if (!Number.isFinite(task.selfTime)) {
        throw new Error('Invalid task timing data');
      }
    }

    return tasks;
  }

  /**
   * Prints an artistic rendering of the task tree for easier debugability.
   *
   * @param {TaskNode[]} tasks
   * @param {{printWidth?: number, startTime?: number, endTime?: number, taskLabelFn?: (node: TaskNode) => string}} options
   * @return {string}
   */
  static printTaskTreeToDebugString(tasks, options = {}) {
    const traceEndMs = Math.max(...tasks.map(t => t.endTime), 0);
    const {
      printWidth = 100,
      startTime = 0,
      endTime = traceEndMs,
      taskLabelFn = node => node.event.name,
    } = options;

    /** @param {TaskNode} task */
    function computeTaskDepth(task) {
      let depth = 0;
      for (; task.parent; task = task.parent) depth++;
      return depth;
    }

    const traceRange = endTime - startTime;
    const characterInMs = traceRange / printWidth;

    /** @type {Map<TaskNode, {id: string, task: TaskNode}>} */
    const taskLegend = new Map();

    /** @type {Map<number, TaskNode[]>} */
    const tasksByDepth = new Map();
    for (const task of tasks) {
      if (task.startTime > endTime || task.endTime < startTime) continue;

      const depth = computeTaskDepth(task);
      const tasksAtDepth = tasksByDepth.get(depth) || [];
      tasksAtDepth.push(task);
      tasksByDepth.set(depth, tasksAtDepth);

      // Create a user-friendly ID for new tasks using a capital letter.
      // 65 is the ASCII code for 'A' and there are 26 letters in the english alphabet.
      const id = String.fromCharCode(65 + (taskLegend.size % 26));
      taskLegend.set(task, {id, task});
    }

    const debugStringLines = [
      `Trace Duration: ${traceEndMs.toFixed(0)}ms`,
      `Range: [${startTime}, ${endTime}]`,
      `█ = ${characterInMs.toFixed(2)}ms`,
      '',
    ];

    const increasingDepth = Array.from(tasksByDepth.entries()).sort((a, b) => a[0] - b[0]);
    for (const [, tasks] of increasingDepth) {
      const taskRow = Array.from({length: printWidth}).map(() => ' ');

      for (const task of tasks) {
        const taskStart = Math.max(task.startTime, startTime);
        const taskEnd = Math.min(task.endTime, endTime);

        const {id} = taskLegend.get(task) || {id: '?'};
        const startIndex = Math.floor(taskStart / characterInMs);
        const endIndex = Math.floor(taskEnd / characterInMs);
        const idIndex = Math.floor((startIndex + endIndex) / 2);
        for (let i = startIndex; i <= endIndex; i++) taskRow[i] = '█';
        for (let i = 0; i < id.length; i++) taskRow[idIndex] = id;
      }

      debugStringLines.push(taskRow.join(''));
    }

    debugStringLines.push('');
    for (const {id, task} of taskLegend.values()) {
      debugStringLines.push(`${id} = ${taskLabelFn(task)}`);
    }

    return debugStringLines.join('\n');
  }
}

module.exports = MainThreadTasks;

},{"./task-groups.js":118}],118:[function(require,module,exports){
/**
 * @license Copyright 2017 The Lighthouse Authors. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.
 */
'use strict';

/** @typedef {'parseHTML'|'styleLayout'|'paintCompositeRender'|'scriptParseCompile'|'scriptEvaluation'|'garbageCollection'|'other'} TaskGroupIds */

/**
 * @typedef TaskGroup
 * @property {TaskGroupIds} id
 * @property {string} label
 * @property {string[]} traceEventNames
 */

/**
 * Make sure the traceEventNames keep up with the ones in DevTools
 * @see https://cs.chromium.org/chromium/src/third_party/blink/renderer/devtools/front_end/timeline_model/TimelineModel.js?type=cs&q=TimelineModel.TimelineModel.RecordType+%3D&g=0&l=1156
 * @see https://cs.chromium.org/chromium/src/third_party/blink/renderer/devtools/front_end/timeline/TimelineUIUtils.js?type=cs&q=_initEventStyles+-f:out+f:devtools&sq=package:chromium&g=0&l=39
 * @type {{[P in TaskGroupIds]: {id: P, label: string, traceEventNames: Array<string>}}}
 */
const taskGroups = {
  parseHTML: {
    id: 'parseHTML',
    label: 'Parse HTML & CSS',
    traceEventNames: ['ParseHTML', 'ParseAuthorStyleSheet'],
  },
  styleLayout: {
    id: 'styleLayout',
    label: 'Style & Layout',
    traceEventNames: [
      'ScheduleStyleRecalculation',
      'UpdateLayoutTree', // previously RecalculateStyles
      'InvalidateLayout',
      'Layout',
    ],
  },
  paintCompositeRender: {
    id: 'paintCompositeRender',
    label: 'Rendering',
    traceEventNames: [
      'Animation',
      'HitTest',
      'PaintSetup',
      'Paint',
      'PaintImage',
      'RasterTask', // Previously Rasterize
      'ScrollLayer',
      'UpdateLayer',
      'UpdateLayerTree',
      'CompositeLayers',
    ],
  },
  scriptParseCompile: {
    id: 'scriptParseCompile',
    label: 'Script Parsing & Compilation',
    traceEventNames: ['v8.compile', 'v8.compileModule', 'v8.parseOnBackground'],
  },
  scriptEvaluation: {
    id: 'scriptEvaluation',
    label: 'Script Evaluation',
    traceEventNames: [
      'EventDispatch',
      'EvaluateScript',
      'v8.evaluateModule',
      'FunctionCall',
      'TimerFire',
      'FireIdleCallback',
      'FireAnimationFrame',
      'RunMicrotasks',
      'V8.Execute',
    ],
  },
  garbageCollection: {
    id: 'garbageCollection',
    label: 'Garbage Collection',
    traceEventNames: [
      'MinorGC', // Previously GCEvent
      'MajorGC',
      'BlinkGC.AtomicPhase', // Previously ThreadState::performIdleLazySweep, ThreadState::completeSweep, BlinkGCMarking

      // Kept for compatibility on older traces
      'ThreadState::performIdleLazySweep',
      'ThreadState::completeSweep',
      'BlinkGCMarking',
    ],
  },
  other: {
    id: 'other',
    label: 'Other',
    traceEventNames: [
      'MessageLoop::RunTask',
      'TaskQueueManager::ProcessTaskFromWorkQueue',
      'ThreadControllerImpl::DoWork',
    ],
  },
};

/** @type {Object<string, TaskGroup>} */
const taskNameToGroup = {};
for (const group of Object.values(taskGroups)) {
  for (const traceEventName of group.traceEventNames) {
    taskNameToGroup[traceEventName] = group;
  }
}

module.exports = {
  taskGroups,
  taskNameToGroup,
};

},{}],119:[function(require,module,exports){
/**
 * @license Copyright 2017 The Lighthouse Authors. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.
 */
'use strict';

/**
 * @fileoverview Singluar helper to parse a raw trace and extract the most useful data for
 * various tools. This artifact will take a trace and then:
 *
 * 1. Find the TracingStartedInPage and navigationStart events of our intended tab & frame.
 * 2. Find the firstContentfulPaint and marked firstMeaningfulPaint events
 * 3. Isolate only the trace events from the tab's process (including all threads like compositor)
 *      * Sort those trace events in chronological order (as order isn't guaranteed)
 * 4. Return all those items in one handy bundle.
 */

/** @typedef {Omit<LH.Artifacts.NavigationTraceTimes, 'firstContentfulPaintAllFrames'|'traceEnd'>} TraceNavigationTimesForFrame */
/** @typedef {'lastNavigationStart'|'firstResourceSendRequest'|'lighthouseMarker'|'auto'} TimeOriginDeterminationMethod */
/** @typedef {Omit<LH.TraceEvent, 'name'|'args'> & {name: 'FrameCommittedInBrowser', args: {data: {frame: string, url: string, parent?: string}}}} FrameCommittedEvent */
/** @typedef {Omit<LH.TraceEvent, 'name'|'args'> & {name: 'largestContentfulPaint::Invalidate'|'largestContentfulPaint::Candidate', args: {data?: {size?: number}, frame: string}}} LCPEvent */
/** @typedef {Omit<LH.TraceEvent, 'name'|'args'> & {name: 'largestContentfulPaint::Candidate', args: {data: {size: number}, frame: string}}} LCPCandidateEvent */

const log = require('lighthouse-logger');

const ACCEPTABLE_NAVIGATION_URL_REGEX = /^(chrome|https?):/;

// The ideal input response latency, the time between the input task and the
// first frame of the response.
const BASE_RESPONSE_LATENCY = 16;
// COMPAT: m71+ We added RunTask to `disabled-by-default-lighthouse`
const SCHEDULABLE_TASK_TITLE_LH = 'RunTask';
// m69-70 DoWork is different and we now need RunTask, see https://bugs.chromium.org/p/chromium/issues/detail?id=871204#c11
const SCHEDULABLE_TASK_TITLE_ALT1 = 'ThreadControllerImpl::RunTask';
// In m66-68 refactored to this task title, https://crrev.com/c/883346
const SCHEDULABLE_TASK_TITLE_ALT2 = 'ThreadControllerImpl::DoWork';
// m65 and earlier
const SCHEDULABLE_TASK_TITLE_ALT3 = 'TaskQueueManager::ProcessTaskFromWorkQueue';

class TraceProcessor {
  static get TIMESPAN_MARKER_ID() {
    return '__lighthouseTimespanStart__';
  }

  /**
   * @return {Error}
   */
  static createNoNavstartError() {
    return new Error('No navigationStart event found');
  }

  /**
   * @return {Error}
   */
  static createNoResourceSendRequestError() {
    return new Error('No ResourceSendRequest event found');
  }

  /**
   * @return {Error}
   */
  static createNoTracingStartedError() {
    return new Error('No tracingStartedInBrowser event found');
  }

  /**
   * @return {Error}
   */
  static createNoFirstContentfulPaintError() {
    return new Error('No FirstContentfulPaint event found');
  }

  /**
   * @return {Error}
   */
  static createNoLighthouseMarkerError() {
    return new Error('No Lighthouse timespan marker event found');
  }

  /**
   * Returns true if the event is a navigation start event of a document whose URL seems valid.
   *
   * @param {LH.TraceEvent} event
   */
  static _isNavigationStartOfInterest(event) {
    return event.name === 'navigationStart' &&
      (!event.args.data || !event.args.data.documentLoaderURL ||
        ACCEPTABLE_NAVIGATION_URL_REGEX.test(event.args.data.documentLoaderURL));
  }

  /**
   * This method sorts a group of trace events that have the same timestamp. We want to...
   *
   * 1. Put E events first, we finish off our existing events before we start new ones.
   * 2. Order B/X events by their duration, we want parents to start before child events.
   * 3. If we don't have any of this to go on, just use the position in the original array (stable sort).
   *
   * Note that the typical group size with the same timestamp will be quite small (<10 or so events),
   * and the number of groups typically ~1% of total trace, so the same ultra-performance-sensitive consideration
   * given to functions that run on entire traces does not necessarily apply here.
   *
   * @param {number[]} tsGroupIndices
   * @param {number[]} timestampSortedIndices
   * @param {number} indexOfTsGroupIndicesStart
   * @param {LH.TraceEvent[]} traceEvents
   * @return {number[]}
   */
  static _sortTimestampEventGroup(
      tsGroupIndices,
      timestampSortedIndices,
      indexOfTsGroupIndicesStart,
      traceEvents
  ) {
    /*
     * We have two different sets of indices going on here.

     *    1. There's the index for an element of `traceEvents`, referred to here as an `ArrayIndex`.
     *       `timestampSortedIndices` is an array of `ArrayIndex` elements.
     *    2. There's the index for an element of `timestampSortedIndices`, referred to here as a `TsIndex`.
     *       A `TsIndex` is therefore an index to an element which is itself an index.
     *
     * These two helper functions help resolve this layer of indirection.
     * Our final return value is an array of `ArrayIndex` in their final sort order.
     */
    /** @param {number} i */
    const lookupArrayIndexByTsIndex = i => timestampSortedIndices[i];
    /** @param {number} i */
    const lookupEventByTsIndex = i => traceEvents[lookupArrayIndexByTsIndex(i)];

    /** @type {Array<number>} */
    const eEventIndices = [];
    /** @type {Array<number>} */
    const bxEventIndices = [];
    /** @type {Array<number>} */
    const otherEventIndices = [];

    for (const tsIndex of tsGroupIndices) {
      // See comment above for the distinction between `tsIndex` and `arrayIndex`.
      const arrayIndex = lookupArrayIndexByTsIndex(tsIndex);
      const event = lookupEventByTsIndex(tsIndex);
      if (event.ph === 'E') eEventIndices.push(arrayIndex);
      else if (event.ph === 'X' || event.ph === 'B') bxEventIndices.push(arrayIndex);
      else otherEventIndices.push(arrayIndex);
    }

    /** @type {Map<number, number>} */
    const effectiveDuration = new Map();
    for (const index of bxEventIndices) {
      const event = traceEvents[index];
      if (event.ph === 'X') {
        effectiveDuration.set(index, event.dur);
      } else {
        // Find the next available 'E' event *after* the current group of events that matches our name, pid, and tid.
        let duration = Number.MAX_SAFE_INTEGER;
        // To find the next "available" 'E' event, we need to account for nested events of the same name.
        let additionalNestedEventsWithSameName = 0;
        const startIndex = indexOfTsGroupIndicesStart + tsGroupIndices.length;
        for (let j = startIndex; j < timestampSortedIndices.length; j++) {
          const potentialMatchingEvent = lookupEventByTsIndex(j);
          const eventMatches = potentialMatchingEvent.name === event.name &&
            potentialMatchingEvent.pid === event.pid &&
            potentialMatchingEvent.tid === event.tid;

          // The event doesn't match, just skip it.
          if (!eventMatches) continue;

          if (potentialMatchingEvent.ph === 'E' && additionalNestedEventsWithSameName === 0) {
            // It's the next available 'E' event for us, so set the duration and break the loop.
            duration = potentialMatchingEvent.ts - event.ts;
            break;
          } else if (potentialMatchingEvent.ph === 'E') {
            // It's an 'E' event but for a nested event. Decrement our counter and move on.
            additionalNestedEventsWithSameName--;
          } else if (potentialMatchingEvent.ph === 'B') {
            // It's a nested 'B' event. Increment our counter and move on.
            additionalNestedEventsWithSameName++;
          }
        }

        effectiveDuration.set(index, duration);
      }
    }

    bxEventIndices.sort((indexA, indexB) => ((effectiveDuration.get(indexB) || 0) -
      (effectiveDuration.get(indexA) || 0) || (indexA - indexB)));

    otherEventIndices.sort((indexA, indexB) => indexA - indexB);

    return [...eEventIndices, ...bxEventIndices, ...otherEventIndices];
  }

  /**
   * Sorts and filters trace events by timestamp and respecting the nesting structure inherent to
   * parent/child event relationships.
   *
   * @param {LH.TraceEvent[]} traceEvents
   * @param {(e: LH.TraceEvent) => boolean} filter
   */
  static filteredTraceSort(traceEvents, filter) {
    // create an array of the indices that we want to keep
    const indices = [];
    for (let srcIndex = 0; srcIndex < traceEvents.length; srcIndex++) {
      if (filter(traceEvents[srcIndex])) {
        indices.push(srcIndex);
      }
    }

    // Sort by ascending timestamp first.
    indices.sort((indexA, indexB) => traceEvents[indexA].ts - traceEvents[indexB].ts);

    // Now we find groups with equal timestamps and order them by their nesting structure.
    for (let i = 0; i < indices.length - 1; i++) {
      const ts = traceEvents[indices[i]].ts;
      const tsGroupIndices = [i];
      for (let j = i + 1; j < indices.length; j++) {
        if (traceEvents[indices[j]].ts !== ts) break;
        tsGroupIndices.push(j);
      }

      // We didn't find any other events with the same timestamp, just keep going.
      if (tsGroupIndices.length === 1) continue;

      // Sort the group by other criteria and replace our index array with it.
      const finalIndexOrder = TraceProcessor._sortTimestampEventGroup(
        tsGroupIndices,
        indices,
        i,
        traceEvents
      );
      indices.splice(i, finalIndexOrder.length, ...finalIndexOrder);
      // We just sorted this set of identical timestamps, so skip over the rest of the group.
      // -1 because we already have i++.
      i += tsGroupIndices.length - 1;
    }

    // create a new array using the target indices from previous sort step
    const sorted = [];
    for (let i = 0; i < indices.length; i++) {
      sorted.push(traceEvents[indices[i]]);
    }

    return sorted;
  }

  /**
   * There should *always* be at least one top level event, having 0 typically means something is
   * drastically wrong with the trace and we should just give up early and loudly.
   *
   * @param {LH.TraceEvent[]} events
   */
  static assertHasToplevelEvents(events) {
    const hasToplevelTask = events.some(this.isScheduleableTask);
    if (!hasToplevelTask) {
      throw new Error('Could not find any top level events');
    }
  }


  /**
   * Calculate duration at specified percentiles for given population of
   * durations.
   * If one of the durations overlaps the end of the window, the full
   * duration should be in the duration array, but the length not included
   * within the window should be given as `clippedLength`. For instance, if a
   * 50ms duration occurs 10ms before the end of the window, `50` should be in
   * the `durations` array, and `clippedLength` should be set to 40.
   * @see https://docs.google.com/document/d/1b9slyaB9yho91YTOkAQfpCdULFkZM9LqsipcX3t7He8/preview
   * @param {!Array<number>} durations Array of durations, sorted in ascending order.
   * @param {number} totalTime Total time (in ms) of interval containing durations.
   * @param {!Array<number>} percentiles Array of percentiles of interest, in ascending order.
   * @param {number=} clippedLength Optional length clipped from a duration overlapping end of window. Default of 0.
   * @return {!Array<{percentile: number, time: number}>}
   * @private
   */
  static _riskPercentiles(durations, totalTime, percentiles, clippedLength = 0) {
    let busyTime = 0;
    for (let i = 0; i < durations.length; i++) {
      busyTime += durations[i];
    }
    busyTime -= clippedLength;

    // Start with idle time already complete.
    let completedTime = totalTime - busyTime;
    let duration = 0;
    let cdfTime = completedTime;
    const results = [];

    let durationIndex = -1;
    let remainingCount = durations.length + 1;
    if (clippedLength > 0) {
      // If there was a clipped duration, one less in count since one hasn't started yet.
      remainingCount--;
    }

    // Find percentiles of interest, in order.
    for (const percentile of percentiles) {
      // Loop over durations, calculating a CDF value for each until it is above
      // the target percentile.
      const percentileTime = percentile * totalTime;
      while (cdfTime < percentileTime && durationIndex < durations.length - 1) {
        completedTime += duration;
        remainingCount -= (duration < 0 ? -1 : 1);

        if (clippedLength > 0 && clippedLength < durations[durationIndex + 1]) {
          duration = -clippedLength;
          clippedLength = 0;
        } else {
          durationIndex++;
          duration = durations[durationIndex];
        }

        // Calculate value of CDF (multiplied by totalTime) for the end of this duration.
        cdfTime = completedTime + Math.abs(duration) * remainingCount;
      }

      // Negative results are within idle time (0ms wait by definition), so clamp at zero.
      results.push({
        percentile,
        time: Math.max(0, (percentileTime - completedTime) / remainingCount) +
          BASE_RESPONSE_LATENCY,
      });
    }

    return results;
  }

  /**
   * Calculates the maximum queueing time (in ms) of high priority tasks for
   * selected percentiles within a window of the main thread.
   * @see https://docs.google.com/document/d/1b9slyaB9yho91YTOkAQfpCdULFkZM9LqsipcX3t7He8/preview
   * @param {Array<ToplevelEvent>} events
   * @param {number} startTime Start time (in ms relative to timeOrigin) of range of interest.
   * @param {number} endTime End time (in ms relative to timeOrigin) of range of interest.
   * @param {!Array<number>=} percentiles Optional array of percentiles to compute. Defaults to [0.5, 0.75, 0.9, 0.99, 1].
   * @return {!Array<{percentile: number, time: number}>}
   */
  static getRiskToResponsiveness(
      events,
      startTime,
      endTime,
      percentiles = [0.5, 0.75, 0.9, 0.99, 1]
  ) {
    const totalTime = endTime - startTime;
    percentiles.sort((a, b) => a - b);

    const ret = this.getMainThreadTopLevelEventDurations(events, startTime, endTime);
    return this._riskPercentiles(ret.durations, totalTime, percentiles,
        ret.clippedLength);
  }

  /**
   * Provides durations in ms of all main thread top-level events
   * @param {Array<ToplevelEvent>} topLevelEvents
   * @param {number} startTime Optional start time (in ms relative to timeOrigin) of range of interest. Defaults to 0.
   * @param {number} endTime Optional end time (in ms relative to timeOrigin) of range of interest. Defaults to trace end.
   * @return {{durations: Array<number>, clippedLength: number}}
   */
  static getMainThreadTopLevelEventDurations(topLevelEvents, startTime = 0, endTime = Infinity) {
    // Find durations of all slices in range of interest.
    /** @type {Array<number>} */
    const durations = [];
    let clippedLength = 0;

    for (const event of topLevelEvents) {
      if (event.end < startTime || event.start > endTime) {
        continue;
      }

      let duration = event.duration;
      let eventStart = event.start;
      if (eventStart < startTime) {
        // Any part of task before window can be discarded.
        eventStart = startTime;
        duration = event.end - startTime;
      }

      if (event.end > endTime) {
        // Any part of task after window must be clipped but accounted for.
        clippedLength = duration - (endTime - eventStart);
      }

      durations.push(duration);
    }
    durations.sort((a, b) => a - b);

    return {
      durations,
      clippedLength,
    };
  }

  /**
   * Provides the top level events on the main thread with timestamps in ms relative to timeOrigin.
   * start.
   * @param {LH.Artifacts.ProcessedTrace} trace
   * @param {number=} startTime Optional start time (in ms relative to timeOrigin) of range of interest. Defaults to 0.
   * @param {number=} endTime Optional end time (in ms relative to timeOrigin) of range of interest. Defaults to trace end.
   * @return {Array<ToplevelEvent>}
   */
  static getMainThreadTopLevelEvents(trace, startTime = 0, endTime = Infinity) {
    const topLevelEvents = [];
    // note: mainThreadEvents is already sorted by event start
    for (const event of trace.mainThreadEvents) {
      if (!this.isScheduleableTask(event) || !event.dur) continue;

      const start = (event.ts - trace.timeOriginEvt.ts) / 1000;
      const end = (event.ts + event.dur - trace.timeOriginEvt.ts) / 1000;
      if (start > endTime || end < startTime) continue;

      topLevelEvents.push({
        start,
        end,
        duration: event.dur / 1000,
      });
    }

    return topLevelEvents;
  }

  /**
   * @param {LH.TraceEvent[]} events
   * @return {{pid: number, tid: number, frameId: string}}
   */
  static findMainFrameIds(events) {
    // Prefer the newer TracingStartedInBrowser event first, if it exists
    const startedInBrowserEvt = events.find(e => e.name === 'TracingStartedInBrowser');
    if (startedInBrowserEvt && startedInBrowserEvt.args.data &&
        startedInBrowserEvt.args.data.frames) {
      const mainFrame = startedInBrowserEvt.args.data.frames.find(frame => !frame.parent);
      const frameId = mainFrame && mainFrame.frame;
      const pid = mainFrame && mainFrame.processId;

      const threadNameEvt = events.find(e => e.pid === pid && e.ph === 'M' &&
        e.cat === '__metadata' && e.name === 'thread_name' && e.args.name === 'CrRendererMain');
      const tid = threadNameEvt && threadNameEvt.tid;

      if (pid && tid && frameId) {
        return {
          pid,
          tid,
          frameId,
        };
      }
    }

    // Support legacy browser versions that do not emit TracingStartedInBrowser event.
    // The first TracingStartedInPage in the trace is definitely our renderer thread of interest
    // Beware: the tracingStartedInPage event can appear slightly after a navigationStart
    const startedInPageEvt = events.find(e => e.name === 'TracingStartedInPage');
    if (startedInPageEvt && startedInPageEvt.args && startedInPageEvt.args.data) {
      const frameId = startedInPageEvt.args.data.page;
      if (frameId) {
        return {
          pid: startedInPageEvt.pid,
          tid: startedInPageEvt.tid,
          frameId,
        };
      }
    }

    // Support the case where everything else fails, see https://github.com/GoogleChrome/lighthouse/issues/7118.
    // If we can't find either TracingStarted event, then we'll fallback to the first navStart that
    // looks like it was loading the main frame with a real URL. Because the schema for this event
    // has changed across Chrome versions, we'll be extra defensive about finding this case.
    const navStartEvt = events.find(e => Boolean(e.name === 'navigationStart' && e.args &&
      e.args.data && e.args.data.isLoadingMainFrame && e.args.data.documentLoaderURL));
    // Find the first resource that was requested and make sure it agrees on the id.
    const firstResourceSendEvt = events.find(e => e.name === 'ResourceSendRequest');
    // We know that these properties exist if we found the events, but TSC doesn't.
    if (navStartEvt && navStartEvt.args && navStartEvt.args.data &&
        firstResourceSendEvt &&
        firstResourceSendEvt.pid === navStartEvt.pid &&
        firstResourceSendEvt.tid === navStartEvt.tid) {
      const frameId = navStartEvt.args.frame;
      if (frameId) {
        return {
          pid: navStartEvt.pid,
          tid: navStartEvt.tid,
          frameId,
        };
      }
    }

    throw this.createNoTracingStartedError();
  }

  /**
   * @param {LH.TraceEvent} evt
   * @return {boolean}
   */
  static isScheduleableTask(evt) {
    return evt.name === SCHEDULABLE_TASK_TITLE_LH ||
    evt.name === SCHEDULABLE_TASK_TITLE_ALT1 ||
    evt.name === SCHEDULABLE_TASK_TITLE_ALT2 ||
    evt.name === SCHEDULABLE_TASK_TITLE_ALT3;
  }

  /**
   * @param {LH.TraceEvent} evt
   * @return {evt is LCPEvent}
   */
  static isLCPEvent(evt) {
    if (evt.name !== 'largestContentfulPaint::Invalidate' &&
        evt.name !== 'largestContentfulPaint::Candidate') return false;
    return Boolean(evt.args && evt.args.frame);
  }

  /**
   * @param {LH.TraceEvent} evt
   * @return {evt is LCPCandidateEvent}
   */
  static isLCPCandidateEvent(evt) {
    return Boolean(
      evt.name === 'largestContentfulPaint::Candidate' &&
      evt.args &&
      evt.args.frame &&
      evt.args.data &&
      evt.args.data.size !== undefined
    );
  }

  /**
   * Returns the maximum LCP event across all frames in `events`.
   * Sets `invalidated` flag if LCP of every frame is invalidated.
   *
   * LCP's trace event was first introduced in m78. We can't surface an LCP for older Chrome versions.
   * LCP comes from a frame's latest `largestContentfulPaint::Candidate`, but it can be invalidated by a `largestContentfulPaint::Invalidate` event.
   *
   * @param {LH.TraceEvent[]} events
   * @param {LH.TraceEvent} timeOriginEvent
   * @return {{lcp: LCPEvent | undefined, invalidated: boolean}}
   */
  static computeValidLCPAllFrames(events, timeOriginEvent) {
    const lcpEvents = events.filter(this.isLCPEvent).reverse();

    /** @type {Map<string, LCPEvent>} */
    const finalLcpEventsByFrame = new Map();
    for (const e of lcpEvents) {
      if (e.ts <= timeOriginEvent.ts) break;

      // Already found final LCP state of this frame.
      const frame = e.args.frame;
      if (finalLcpEventsByFrame.has(frame)) continue;

      finalLcpEventsByFrame.set(frame, e);
    }

    /** @type {LCPCandidateEvent | undefined} */
    let maxLcpAcrossFrames;
    for (const lcp of finalLcpEventsByFrame.values()) {
      if (!this.isLCPCandidateEvent(lcp)) continue;
      if (!maxLcpAcrossFrames || lcp.args.data.size > maxLcpAcrossFrames.args.data.size) {
        maxLcpAcrossFrames = lcp;
      }
    }

    return {
      lcp: maxLcpAcrossFrames,
      // LCP events were found, but final LCP event of every frame was an invalidate event.
      invalidated: Boolean(!maxLcpAcrossFrames && finalLcpEventsByFrame.size),
    };
  }

  /**
   * @param {Array<{id: string, url: string, parent?: string}>} frames
   * @return {Map<string, string>}
   */
  static resolveRootFrames(frames) {
    /** @type {Map<string, string>} */
    const parentFrames = new Map();
    for (const frame of frames) {
      if (!frame.parent) continue;
      parentFrames.set(frame.id, frame.parent);
    }

    /** @type {Map<string, string>} */
    const frameIdToRootFrameId = new Map();
    for (const frame of frames) {
      let cur = frame.id;
      while (parentFrames.has(cur)) {
        cur = /** @type {string} */ (parentFrames.get(cur));
      }
      frameIdToRootFrameId.set(frame.id, cur);
    }

    return frameIdToRootFrameId;
  }

  /**
   * Finds key trace events, identifies main process/thread, and returns timings of trace events
   * in milliseconds since the time origin in addition to the standard microsecond monotonic timestamps.
   * @param {LH.Trace} trace
   * @param {{timeOriginDeterminationMethod?: TimeOriginDeterminationMethod}} [options]
   * @return {LH.Artifacts.ProcessedTrace}
  */
  static processTrace(trace, options) {
    const {timeOriginDeterminationMethod = 'auto'} = options || {};

    // Parse the trace for our key events and sort them by timestamp. Note: sort
    // *must* be stable to keep events correctly nested.
    const keyEvents = this.filteredTraceSort(trace.traceEvents, e => {
      return e.cat.includes('blink.user_timing') ||
          e.cat.includes('loading') ||
          e.cat.includes('devtools.timeline') ||
          e.cat === '__metadata';
    });

    // Find the inspected frame
    const mainFrameIds = this.findMainFrameIds(keyEvents);

    const frames = keyEvents
      .filter(/** @return {evt is FrameCommittedEvent} */ evt => {
        return Boolean(
          evt.name === 'FrameCommittedInBrowser' &&
          evt.args.data &&
          evt.args.data.frame &&
          evt.args.data.url
        );
      })
      .map(evt => {
        return {
          id: evt.args.data.frame,
          url: evt.args.data.url,
          parent: evt.args.data.parent,
        };
      });
    const frameIdToRootFrameId = this.resolveRootFrames(frames);

    // Filter to just events matching the main frame ID, just to make sure.
    const frameEvents = keyEvents.filter(e => e.args.frame === mainFrameIds.frameId);

    // Filter to just events matching the main frame ID or any child frame IDs.
    // In practice, there should always be FrameCommittedInBrowser events to define the frame tree.
    // Unfortunately, many test traces do not include FrameCommittedInBrowser events due to minification.
    // This ensures there is always a minimal frame tree and events so those tests don't fail.
    let frameTreeEvents = [];
    if (frameIdToRootFrameId.has(mainFrameIds.frameId)) {
      frameTreeEvents = keyEvents.filter(e => {
        return e.args.frame && frameIdToRootFrameId.get(e.args.frame) === mainFrameIds.frameId;
      });
    } else {
      log.warn(
        'trace-of-tab',
        'frameTreeEvents may be incomplete, make sure the trace has FrameCommittedInBrowser events'
      );
      frameIdToRootFrameId.set(mainFrameIds.frameId, mainFrameIds.frameId);
      frameTreeEvents = frameEvents;
    }

    // Compute our time origin to use for all relative timings.
    const timeOriginEvt = this.computeTimeOrigin(
      {keyEvents, frameEvents, mainFrameIds},
      timeOriginDeterminationMethod
    );

    // Subset all trace events to just our tab's process (incl threads other than main)
    // stable-sort events to keep them correctly nested.
    const processEvents = TraceProcessor
      .filteredTraceSort(trace.traceEvents, e => e.pid === mainFrameIds.pid);

    const mainThreadEvents = processEvents
      .filter(e => e.tid === mainFrameIds.tid);

    // Ensure our traceEnd reflects all page activity.
    const traceEnd = this.computeTraceEnd(trace.traceEvents, timeOriginEvt);

    // This could be much more concise with object spread, but the consensus is that explicitness is
    // preferred over brevity here.
    return {
      frames,
      mainThreadEvents,
      frameEvents,
      frameTreeEvents,
      processEvents,
      mainFrameIds,
      timeOriginEvt,
      timings: {
        timeOrigin: 0,
        traceEnd: traceEnd.timing,
      },
      timestamps: {
        timeOrigin: timeOriginEvt.ts,
        traceEnd: traceEnd.timestamp,
      },
    };
  }

  /**
   * Finds key navigation trace events and computes timings of events in milliseconds since the time
   * origin in addition to the standard microsecond monotonic timestamps.
   * @param {LH.Artifacts.ProcessedTrace} processedTrace
   * @return {LH.Artifacts.ProcessedNavigation}
  */
  static processNavigation(processedTrace) {
    const {frameEvents, frameTreeEvents, timeOriginEvt, timings, timestamps} = processedTrace;

    // Compute the key frame timings for the main frame.
    const frameTimings = this.computeNavigationTimingsForFrame(frameEvents, {timeOriginEvt});

    // Compute FCP for all frames.
    const fcpAllFramesEvt = frameTreeEvents.find(
      e => e.name === 'firstContentfulPaint' && e.ts > timeOriginEvt.ts
    );

    if (!fcpAllFramesEvt) {
      throw this.createNoFirstContentfulPaintError();
    }

    // Compute LCP for all frames.
    const lcpAllFramesEvt = this.computeValidLCPAllFrames(frameTreeEvents, timeOriginEvt).lcp;

    /** @param {number} ts */
    const getTiming = ts => (ts - timeOriginEvt.ts) / 1000;
    /** @param {number=} ts */
    const maybeGetTiming = (ts) => ts === undefined ? undefined : getTiming(ts);

    return {
      timings: {
        timeOrigin: timings.timeOrigin,
        firstPaint: frameTimings.timings.firstPaint,
        firstContentfulPaint: frameTimings.timings.firstContentfulPaint,
        firstContentfulPaintAllFrames: getTiming(fcpAllFramesEvt.ts),
        firstMeaningfulPaint: frameTimings.timings.firstMeaningfulPaint,
        largestContentfulPaint: frameTimings.timings.largestContentfulPaint,
        largestContentfulPaintAllFrames: maybeGetTiming(lcpAllFramesEvt && lcpAllFramesEvt.ts),
        load: frameTimings.timings.load,
        domContentLoaded: frameTimings.timings.domContentLoaded,
        traceEnd: timings.traceEnd,
      },
      timestamps: {
        timeOrigin: timestamps.timeOrigin,
        firstPaint: frameTimings.timestamps.firstPaint,
        firstContentfulPaint: frameTimings.timestamps.firstContentfulPaint,
        firstContentfulPaintAllFrames: fcpAllFramesEvt.ts,
        firstMeaningfulPaint: frameTimings.timestamps.firstMeaningfulPaint,
        largestContentfulPaint: frameTimings.timestamps.largestContentfulPaint,
        largestContentfulPaintAllFrames: lcpAllFramesEvt && lcpAllFramesEvt.ts,
        load: frameTimings.timestamps.load,
        domContentLoaded: frameTimings.timestamps.domContentLoaded,
        traceEnd: timestamps.traceEnd,
      },
      firstPaintEvt: frameTimings.firstPaintEvt,
      firstContentfulPaintEvt: frameTimings.firstContentfulPaintEvt,
      firstContentfulPaintAllFramesEvt: fcpAllFramesEvt,
      firstMeaningfulPaintEvt: frameTimings.firstMeaningfulPaintEvt,
      largestContentfulPaintEvt: frameTimings.largestContentfulPaintEvt,
      largestContentfulPaintAllFramesEvt: lcpAllFramesEvt,
      loadEvt: frameTimings.loadEvt,
      domContentLoadedEvt: frameTimings.domContentLoadedEvt,
      fmpFellBack: frameTimings.fmpFellBack,
      lcpInvalidated: frameTimings.lcpInvalidated,
    };
  }

  /**
   * Computes the last observable timestamp in a set of trace events.
   *
   * @param {Array<LH.TraceEvent>} events
   * @param {LH.TraceEvent} timeOriginEvt
   * @return {{timing: number, timestamp: number}}
   */
  static computeTraceEnd(events, timeOriginEvt) {
    let maxTs = -Infinity;
    for (const event of events) {
      maxTs = Math.max(event.ts + (event.dur || 0), maxTs);
    }

    return {timestamp: maxTs, timing: (maxTs - timeOriginEvt.ts) / 1000};
  }

  /**
   * Computes the time origin using the specified method.
   *
   *    - firstResourceSendRequest
   *      Uses the time that the very first network request is sent in the main frame.
   *      Eventually should be used in place of lastNavigationStart as the default for navigations.
   *      This method includes the cost of all redirects when evaluating a navigation (which matches lantern behavior).
   *      The only difference between firstResourceSendRequest and the first `navigationStart` is
   *      the unload time of `about:blank` (which is a Lighthouse implementation detail and shouldn't be included).
   *
   *    - lastNavigationStart
   *      Uses the time of the last `navigationStart` event in the main frame.
   *      The historical time origin of Lighthouse from 2016-Present.
   *      This method excludes the cost of client-side redirects when evaluating a navigation.
   *      Can also be skewed by several hundred milliseconds or even seconds when the browser takes a long
   *      time to unload `about:blank`.
   *
   * @param {{keyEvents: Array<LH.TraceEvent>, frameEvents: Array<LH.TraceEvent>, mainFrameIds: {frameId: string}}} traceEventSubsets
   * @param {TimeOriginDeterminationMethod} method
   * @return {LH.TraceEvent}
   */
  static computeTimeOrigin(traceEventSubsets, method) {
    const lastNavigationStart = () => {
      // Our time origin will be the last frame navigation in the trace
      const frameEvents = traceEventSubsets.frameEvents;
      return frameEvents.filter(this._isNavigationStartOfInterest).pop();
    };

    const lighthouseMarker = () => {
      const frameEvents = traceEventSubsets.keyEvents;
      return frameEvents.find(
        evt =>
          evt.name === 'clock_sync' &&
          evt.args.sync_id === TraceProcessor.TIMESPAN_MARKER_ID
      );
    };

    switch (method) {
      case 'firstResourceSendRequest': {
        // Our time origin will be the timestamp of the first request that's sent in the frame.
        const fetchStart = traceEventSubsets.keyEvents.find(event => {
          if (event.name !== 'ResourceSendRequest') return false;
          const data = event.args.data || {};
          return data.frame === traceEventSubsets.mainFrameIds.frameId;
        });
        if (!fetchStart) throw this.createNoResourceSendRequestError();
        return fetchStart;
      }
      case 'lastNavigationStart': {
        const navigationStart = lastNavigationStart();
        if (!navigationStart) throw this.createNoNavstartError();
        return navigationStart;
      }
      case 'lighthouseMarker': {
        const marker = lighthouseMarker();
        if (!marker) throw this.createNoLighthouseMarkerError();
        return marker;
      }
      case 'auto': {
        const marker = lighthouseMarker() || lastNavigationStart();
        if (!marker) throw this.createNoNavstartError();
        return marker;
      }
    }
  }

  /**
   * Computes timings of trace events of key trace events in milliseconds since the time origin
   * in addition to the standard microsecond monotonic timestamps.
   * @param {Array<LH.TraceEvent>} frameEvents
   * @param {{timeOriginEvt: LH.TraceEvent}} options
  */
  static computeNavigationTimingsForFrame(frameEvents, options) {
    const {timeOriginEvt} = options;

    // Find our first paint of this frame
    const firstPaint = frameEvents.find(e => e.name === 'firstPaint' && e.ts > timeOriginEvt.ts);

    // FCP will follow at/after the FP. Used in so many places we require it.
    const firstContentfulPaint = frameEvents.find(
      e => e.name === 'firstContentfulPaint' && e.ts > timeOriginEvt.ts
    );

    if (!firstContentfulPaint) {
      throw this.createNoFirstContentfulPaintError();
    }

    // fMP will follow at/after the FP
    let firstMeaningfulPaint = frameEvents.find(
      e => e.name === 'firstMeaningfulPaint' && e.ts > timeOriginEvt.ts
    );
    let fmpFellBack = false;

    // If there was no firstMeaningfulPaint event found in the trace, the network idle detection
    // may have not been triggered before Lighthouse finished tracing.
    // In this case, we'll use the last firstMeaningfulPaintCandidate we can find.
    // However, if no candidates were found (a bogus trace, likely), we fail.
    if (!firstMeaningfulPaint) {
      const fmpCand = 'firstMeaningfulPaintCandidate';
      fmpFellBack = true;
      log.verbose('trace-of-tab', `No firstMeaningfulPaint found, falling back to last ${fmpCand}`);
      const lastCandidate = frameEvents.filter(e => e.name === fmpCand).pop();
      if (!lastCandidate) {
        log.verbose('trace-of-tab', 'No `firstMeaningfulPaintCandidate` events found in trace');
      }
      firstMeaningfulPaint = lastCandidate;
    }

    // This function accepts events spanning multiple frames, but this usage will only provide events from the main frame.
    const lcpResult = this.computeValidLCPAllFrames(frameEvents, timeOriginEvt);

    const load = frameEvents.find(e => e.name === 'loadEventEnd' && e.ts > timeOriginEvt.ts);
    const domContentLoaded = frameEvents.find(
      e => e.name === 'domContentLoadedEventEnd' && e.ts > timeOriginEvt.ts
    );

    /** @param {{ts: number}=} event */
    const getTimestamp = (event) => event && event.ts;
    /** @type {TraceNavigationTimesForFrame} */
    const timestamps = {
      timeOrigin: timeOriginEvt.ts,
      firstPaint: getTimestamp(firstPaint),
      firstContentfulPaint: firstContentfulPaint.ts,
      firstMeaningfulPaint: getTimestamp(firstMeaningfulPaint),
      largestContentfulPaint: getTimestamp(lcpResult.lcp),
      load: getTimestamp(load),
      domContentLoaded: getTimestamp(domContentLoaded),
    };

    /** @param {number} ts */
    const getTiming = ts => (ts - timeOriginEvt.ts) / 1000;
    /** @param {number=} ts */
    const maybeGetTiming = (ts) => ts === undefined ? undefined : getTiming(ts);
    /** @type {TraceNavigationTimesForFrame} */
    const timings = {
      timeOrigin: 0,
      firstPaint: maybeGetTiming(timestamps.firstPaint),
      firstContentfulPaint: getTiming(timestamps.firstContentfulPaint),
      firstMeaningfulPaint: maybeGetTiming(timestamps.firstMeaningfulPaint),
      largestContentfulPaint: maybeGetTiming(timestamps.largestContentfulPaint),
      load: maybeGetTiming(timestamps.load),
      domContentLoaded: maybeGetTiming(timestamps.domContentLoaded),
    };

    return {
      timings,
      timestamps,
      timeOriginEvt: timeOriginEvt,
      firstPaintEvt: firstPaint,
      firstContentfulPaintEvt: firstContentfulPaint,
      firstMeaningfulPaintEvt: firstMeaningfulPaint,
      largestContentfulPaintEvt: lcpResult.lcp,
      loadEvt: load,
      domContentLoadedEvt: domContentLoaded,
      fmpFellBack,
      lcpInvalidated: lcpResult.invalidated,
    };
  }
}

module.exports = TraceProcessor;


/**
 * @typedef ToplevelEvent
 * @prop {number} start
 * @prop {number} end
 * @prop {number} duration
 */

},{"lighthouse-logger":188}],120:[function(require,module,exports){
/**
 * @license Copyright 2017 The Lighthouse Authors. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.
 */
'use strict';

const log = require('lighthouse-logger');
const TraceProcessor = require('../tracehouse/trace-processor.js');

/**
 * @param {LH.Audit.Results} auditResults
 * @return {LH.Artifacts.TimingSummary|undefined}
 */
function getUberMetrics(auditResults) {
  const metricsAudit = auditResults.metrics;
  if (!metricsAudit || !metricsAudit.details || !('items' in metricsAudit.details)) return;

  return metricsAudit.details.items[0];
}

class Metrics {
  /**
   * @param {Array<LH.TraceEvent>} traceEvents
   * @param {LH.Audit.Results} auditResults
   */
  constructor(traceEvents, auditResults) {
    this._traceEvents = traceEvents;
    this._auditResults = auditResults;
  }

  /**
   * Returns simplified representation of all metrics
   * @return {Array<{id: string, name: string, tsKey: keyof LH.Artifacts.TimingSummary}>} metrics to consider
   */
  static get metricsDefinitions() {
    return [
      {
        name: 'Time Origin',
        id: 'timeorigin',
        tsKey: 'observedTimeOriginTs',
      },
      {
        name: 'First Contentful Paint',
        id: 'ttfcp',
        tsKey: 'observedFirstContentfulPaintTs',
      },
      {
        name: 'First Meaningful Paint',
        id: 'ttfmp',
        tsKey: 'observedFirstMeaningfulPaintTs',
      },
      {
        name: 'Speed Index',
        id: 'si',
        tsKey: 'observedSpeedIndexTs',
      },
      {
        name: 'First Visual Change',
        id: 'fv',
        tsKey: 'observedFirstVisualChangeTs',
      },
      {
        name: 'Visually Complete 100%',
        id: 'vc100',
        tsKey: 'observedLastVisualChangeTs',
      },
      {
        name: 'Interactive',
        id: 'tti',
        tsKey: 'interactiveTs',
      },
      {
        name: 'End of Trace',
        id: 'eot',
        tsKey: 'observedTraceEndTs',
      },
      {
        name: 'On Load',
        id: 'onload',
        tsKey: 'observedLoadTs',
      },
      {
        name: 'DOM Content Loaded',
        id: 'dcl',
        tsKey: 'observedDomContentLoadedTs',
      },
    ];
  }

  /**
   * Returns simplified representation of all metrics' timestamps from monotonic clock
   * @return {Array<{ts: number, id: string, name: string}>} metrics to consider
   */
  gatherMetrics() {
    const uberMetrics = getUberMetrics(this._auditResults);
    if (!uberMetrics) {
      return [];
    }

    /** @type {Array<{ts: number, id: string, name: string}>} */
    const resolvedMetrics = [];
    Metrics.metricsDefinitions.forEach(metric => {
      // Skip if auditResults is missing a particular audit result
      const ts = uberMetrics[metric.tsKey];
      if (ts === undefined) {
        log.error('pwmetrics-events', `${metric.name} timestamp not found`);
        return;
      }

      resolvedMetrics.push({
        id: metric.id,
        name: metric.name,
        ts,
      });
    });

    return resolvedMetrics;
  }

  /**
   * Get the trace event data for our timeOrigin
   * @param {Array<{ts: number, id: string, name: string}>} metrics
   * @return {{pid: number, tid: number, ts: number} | {errorMessage: string}}
   */
  getTimeOriginEvt(metrics) {
    const timeOriginMetric = metrics.find(e => e.id === 'timeorigin');
    if (!timeOriginMetric) return {errorMessage: 'timeorigin Metric not found in definitions'};
    try {
      const frameIds = TraceProcessor.findMainFrameIds(this._traceEvents);
      return {pid: frameIds.pid, tid: frameIds.tid, ts: timeOriginMetric.ts};
    } catch (err) {
      return {errorMessage: err.message};
    }
  }

  /**
   * Constructs performance.measure trace events, which have start/end events as follows:
   *     { "pid": 89922,"tid":1295,"ts":77176783452,"ph":"b","cat":"blink.user_timing","name":"innermeasure","args":{},"tts":1257886,"id":"0xe66c67"}
   *     { "pid": 89922,"tid":1295,"ts":77176882592,"ph":"e","cat":"blink.user_timing","name":"innermeasure","args":{},"tts":1257898,"id":"0xe66c67"}
   * @param {{ts: number, id: string, name: string}} metric
   * @param {{pid: number, tid: number, ts: number}} timeOriginEvt
   * @return {Array<LH.TraceEvent>} Pair of trace events (start/end)
   */
  synthesizeEventPair(metric, timeOriginEvt) {
    // We'll masquerade our fake events to look mostly like the timeOrigin event
    const eventBase = {
      pid: timeOriginEvt.pid,
      tid: timeOriginEvt.tid,
      cat: 'blink.user_timing',
      name: metric.name,
      args: {},
      // randomized id is same for the pair
      id: `0x${((Math.random() * 1000000) | 0).toString(16)}`,
    };
    const fakeMeasureStartEvent = Object.assign({}, eventBase, {
      ts: timeOriginEvt.ts,
      ph: 'b',
    });
    const fakeMeasureEndEvent = Object.assign({}, eventBase, {
      ts: metric.ts,
      ph: 'e',
    });
    return /** @type {Array<LH.TraceEvent>} */ ([fakeMeasureStartEvent, fakeMeasureEndEvent]);
  }

  /**
   * @return {Array<LH.TraceEvent>} User timing raw trace event pairs
   */
  generateFakeEvents() {
    const metrics = this.gatherMetrics();
    if (metrics.length === 0) {
      log.error('metrics-events', 'Metrics collection had errors, not synthetizing trace events');
      return [];
    }

    const timeOriginEvt = this.getTimeOriginEvt(metrics);
    if ('errorMessage' in timeOriginEvt) {
      log.error('pwmetrics-events', `Reference timeOrigin error: ${timeOriginEvt.errorMessage}`);
      return [];
    }

    /** @type {Array<LH.TraceEvent>} */
    const fakeEvents = [];
    metrics.forEach(metric => {
      if (metric.id === 'timeorigin') {
        return;
      }
      if (!metric.ts) {
        log.error('pwmetrics-events', `(${metric.name}) missing timestamp. Skipping…`);
        return;
      }
      log.verbose('pwmetrics-events', `Sythesizing trace events for ${metric.name}`);
      fakeEvents.push(...this.synthesizeEventPair(metric, timeOriginEvt));
    });
    return fakeEvents;
  }
}

module.exports = Metrics;

},{"../tracehouse/trace-processor.js":119,"lighthouse-logger":188}],121:[function(require,module,exports){
/**
 * @license Copyright 2020 The Lighthouse Authors. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.
 */
'use strict';

/**
 * @fileoverview A collection of general type verification functions for dealing
 * with external data. If these grow in scope they could be auto-generated with
 * something like `io-ts`, but it's not worth the complexity yet.
 */

/**
 * Type predicate verifying `val` is an object (excluding `Array` and `null`).
 * @param {unknown} val
 * @return {val is Record<string, unknown>}
 */
function isObjectOfUnknownValues(val) {
  return typeof val === 'object' && val !== null && !Array.isArray(val);
}

/**
 * Type predicate verifying `val` is an object or an array.
 * @param {unknown} val
 * @return {val is Record<string, unknown>|Array<unknown>}
 */
function isObjectOrArrayOfUnknownValues(val) {
  return typeof val === 'object' && val !== null;
}

module.exports = {
  isObjectOfUnknownValues,
  isObjectOrArrayOfUnknownValues,
};

},{}],122:[function(require,module,exports){
(function (process){(function (){
/**
 * @license Copyright 2016 The Lighthouse Authors. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.
 */
'use strict';

const isDeepEqual = require('lodash.isequal');
const Driver = require('./gather/driver.js');
const GatherRunner = require('./gather/gather-runner.js');
const ReportScoring = require('./scoring.js');
const Audit = require('./audits/audit.js');
const log = require('lighthouse-logger');
const i18n = require('./lib/i18n/i18n.js');
const stackPacks = require('./lib/stack-packs.js');
const assetSaver = require('./lib/asset-saver.js');

const path = require('path');
const URL = require('./lib/url-shim.js');
const Sentry = require('./lib/sentry.js');
const generateReport = require('../report/report-generator.js').generateReport;
const LHError = require('./lib/lh-error.js');

/** @typedef {import('./gather/connections/connection.js')} Connection */
/** @typedef {import('./lib/arbitrary-equality-map.js')} ArbitraryEqualityMap */
/** @typedef {LH.Config.Config} Config */

class Runner {
  /**
   * @template {LH.Config.Config | LH.Config.FRConfig} TConfig
   * @param {(runnerData: {requestedUrl: string, config: TConfig, driverMock?: Driver}) => Promise<LH.Artifacts>} gatherFn
   * @param {{config: TConfig, computedCache: Map<string, ArbitraryEqualityMap>, url?: string, driverMock?: Driver}} runOpts
   * @return {Promise<LH.RunnerResult|undefined>}
   */
  static async run(gatherFn, runOpts) {
    const settings = runOpts.config.settings;
    try {
      const runnerStatus = {msg: 'Runner setup', id: 'lh:runner:run'};
      log.time(runnerStatus, 'verbose');

      /**
       * List of top-level warnings for this Lighthouse run.
       * @type {Array<string | LH.IcuMessage>}
       */
      const lighthouseRunWarnings = [];

      const sentryContext = Sentry.getContext();
      Sentry.captureBreadcrumb({
        message: 'Run started',
        category: 'lifecycle',
        data: sentryContext && sentryContext.extra,
      });

      // User can run -G solo, -A solo, or -GA together
      // -G and -A will run partial lighthouse pipelines,
      // and -GA will run everything plus save artifacts and lhr to disk.

      // Gather phase
      // Either load saved artifacts off disk or from the browser
      let artifacts;
      let requestedUrl;
      if (settings.auditMode && !settings.gatherMode) {
        // No browser required, just load the artifacts from disk.
        const path = Runner._getDataSavePath(settings);
        artifacts = assetSaver.loadArtifacts(path);
        requestedUrl = artifacts.URL.requestedUrl;

        if (!requestedUrl) {
          throw new Error('Cannot run audit mode on empty URL');
        }
        if (runOpts.url && !URL.equalWithExcludedFragments(runOpts.url, requestedUrl)) {
          throw new Error('Cannot run audit mode on different URL');
        }
      } else {
        // verify the url is valid and that protocol is allowed
        if (runOpts.url && URL.isValid(runOpts.url) && URL.isProtocolAllowed(runOpts.url)) {
          // Use canonicalized URL (with trailing slashes and such)
          requestedUrl = new URL(runOpts.url).href;
        } else {
          throw new LHError(LHError.errors.INVALID_URL);
        }

        artifacts = await gatherFn({
          requestedUrl,
          config: runOpts.config,
          driverMock: runOpts.driverMock,
        });

        // -G means save these to ./latest-run, etc.
        if (settings.gatherMode) {
          const path = Runner._getDataSavePath(settings);
          await assetSaver.saveArtifacts(artifacts, path);
        }
      }

      // Potentially quit early
      if (settings.gatherMode && !settings.auditMode) return;

      // Audit phase
      if (!runOpts.config.audits) {
        throw new Error('No audits to evaluate.');
      }
      const auditResultsById = await Runner._runAudits(settings, runOpts.config.audits, artifacts,
          lighthouseRunWarnings, runOpts.computedCache);

      // LHR construction phase
      const resultsStatus = {msg: 'Generating results...', id: 'lh:runner:generate'};
      log.time(resultsStatus);

      if (artifacts.LighthouseRunWarnings) {
        lighthouseRunWarnings.push(...artifacts.LighthouseRunWarnings);
      }

      // Entering: conclusion of the lighthouse result object
      const lighthouseVersion = require('../package.json').version;

      // Use version from gathering stage.
      // If accessibility gatherer didn't run or errored, it won't be in credits.
      const axeVersion = artifacts.Accessibility && artifacts.Accessibility.version;
      const credits = {
        'axe-core': axeVersion,
      };

      /** @type {Record<string, LH.RawIcu<LH.Result.Category>>} */
      let categories = {};
      if (runOpts.config.categories) {
        categories = ReportScoring.scoreAllCategories(runOpts.config.categories, auditResultsById);
      }

      log.timeEnd(resultsStatus);
      log.timeEnd(runnerStatus);

      /** @type {LH.RawIcu<LH.Result>} */
      const i18nLhr = {
        userAgent: artifacts.HostUserAgent,
        environment: {
          networkUserAgent: artifacts.NetworkUserAgent,
          hostUserAgent: artifacts.HostUserAgent,
          benchmarkIndex: artifacts.BenchmarkIndex,
          credits,
        },
        lighthouseVersion,
        fetchTime: artifacts.fetchTime,
        requestedUrl: requestedUrl,
        finalUrl: artifacts.URL.finalUrl,
        runWarnings: lighthouseRunWarnings,
        runtimeError: Runner.getArtifactRuntimeError(artifacts),
        audits: auditResultsById,
        configSettings: settings,
        categories,
        categoryGroups: runOpts.config.groups || undefined,
        timing: this._getTiming(artifacts),
        i18n: {
          rendererFormattedStrings: i18n.getRendererFormattedStrings(settings.locale),
          icuMessagePaths: {},
        },
        stackPacks: stackPacks.getStackPacks(artifacts.Stacks),
      };

      // Replace ICU message references with localized strings; save replaced paths in lhr.
      i18nLhr.i18n.icuMessagePaths = i18n.replaceIcuMessages(i18nLhr, settings.locale);

      // LHR has now been localized.
      const lhr = /** @type {LH.Result} */ (i18nLhr);

      // Save lhr to ./latest-run, but only if -GA is used.
      if (settings.gatherMode && settings.auditMode) {
        const path = Runner._getDataSavePath(settings);
        assetSaver.saveLhr(lhr, path);
      }

      // Create the HTML, JSON, and/or CSV string
      const report = generateReport(lhr, settings.output);

      return {lhr, artifacts, report};
    } catch (err) {
      // i18n LighthouseError strings.
      if (err.friendlyMessage) {
        err.friendlyMessage = i18n.getFormatted(err.friendlyMessage, settings.locale);
      }
      await Sentry.captureException(err, {level: 'fatal'});
      throw err;
    }
  }

  /**
   * This handles both the auditMode case where gatherer entries need to be merged in and
   * the gather/audit case where timingEntriesFromRunner contains all entries from this run,
   * including those also in timingEntriesFromArtifacts.
   * @param {LH.Artifacts} artifacts
   * @return {LH.Result.Timing}
   */
  static _getTiming(artifacts) {
    const timingEntriesFromArtifacts = artifacts.Timing || [];
    const timingEntriesFromRunner = log.takeTimeEntries();
    const timingEntriesKeyValues = [
      ...timingEntriesFromArtifacts,
      ...timingEntriesFromRunner,
      // As entries can share a name, dedupe based on the startTime timestamp
    ].map(entry => /** @type {[number, PerformanceEntry]} */ ([entry.startTime, entry]));
    const timingEntries = Array.from(new Map(timingEntriesKeyValues).values())
    // Truncate timestamps to hundredths of a millisecond saves ~4KB. No need for microsecond
    // resolution.
    .map(entry => {
      return {
        // Don't spread entry because browser PerformanceEntries can't be spread.
        // https://github.com/GoogleChrome/lighthouse/issues/8638
        startTime: parseFloat(entry.startTime.toFixed(2)),
        name: entry.name,
        duration: parseFloat(entry.duration.toFixed(2)),
        entryType: entry.entryType,
      };
    });
    const runnerEntry = timingEntries.find(e => e.name === 'lh:runner:run');
    return {entries: timingEntries, total: runnerEntry && runnerEntry.duration || 0};
  }

  /**
   * Establish connection, load page and collect all required artifacts
   * @param {string} requestedUrl
   * @param {{config: Config, computedCache: Map<string, ArbitraryEqualityMap>, driverMock?: Driver}} runnerOpts
   * @param {Connection} connection
   * @return {Promise<LH.Artifacts>}
   */
  static async _gatherArtifactsFromBrowser(requestedUrl, runnerOpts, connection) {
    if (!runnerOpts.config.passes) {
      throw new Error('No browser artifacts are either provided or requested.');
    }
    const driver = runnerOpts.driverMock || new Driver(connection);
    const gatherOpts = {
      driver,
      requestedUrl,
      settings: runnerOpts.config.settings,
      computedCache: runnerOpts.computedCache,
    };
    const artifacts = await GatherRunner.run(runnerOpts.config.passes, gatherOpts);
    return artifacts;
  }

  /**
   * Run all audits with specified settings and artifacts.
   * @param {LH.Config.Settings} settings
   * @param {Array<LH.Config.AuditDefn>} audits
   * @param {LH.Artifacts} artifacts
   * @param {Array<string | LH.IcuMessage>} runWarnings
   * @param {Map<string, ArbitraryEqualityMap>} computedCache
   * @return {Promise<Record<string, LH.RawIcu<LH.Audit.Result>>>}
   */
  static async _runAudits(settings, audits, artifacts, runWarnings, computedCache) {
    const status = {msg: 'Analyzing and running audits...', id: 'lh:runner:auditing'};
    log.time(status);

    if (artifacts.settings) {
      const overrides = {
        locale: undefined,
        gatherMode: undefined,
        auditMode: undefined,
        output: undefined,
        channel: undefined,
        budgets: undefined,
      };
      const normalizedGatherSettings = Object.assign({}, artifacts.settings, overrides);
      const normalizedAuditSettings = Object.assign({}, settings, overrides);

      if (!isDeepEqual(normalizedGatherSettings, normalizedAuditSettings)) {
        throw new Error('Cannot change settings between gathering and auditing');
      }
    }

    // Members of LH.Audit.Context that are shared across all audits.
    const sharedAuditContext = {
      settings,
      computedCache,
    };

    // Run each audit sequentially
    /** @type {Record<string, LH.RawIcu<LH.Audit.Result>>} */
    const auditResultsById = {};
    for (const auditDefn of audits) {
      const auditId = auditDefn.implementation.meta.id;
      const auditResult = await Runner._runAudit(auditDefn, artifacts, sharedAuditContext,
          runWarnings);
      auditResultsById[auditId] = auditResult;
    }

    log.timeEnd(status);
    return auditResultsById;
  }

  /**
   * Checks that the audit's required artifacts exist and runs the audit if so.
   * Otherwise returns error audit result.
   * @param {LH.Config.AuditDefn} auditDefn
   * @param {LH.Artifacts} artifacts
   * @param {Pick<LH.Audit.Context, 'settings'|'computedCache'>} sharedAuditContext
   * @param {Array<string | LH.IcuMessage>} runWarnings
   * @return {Promise<LH.RawIcu<LH.Audit.Result>>}
   * @private
   */
  static async _runAudit(auditDefn, artifacts, sharedAuditContext, runWarnings) {
    const audit = auditDefn.implementation;
    const status = {
      msg: `Auditing: ${i18n.getFormatted(audit.meta.title, 'en-US')}`,
      id: `lh:audit:${audit.meta.id}`,
    };
    log.time(status);

    let auditResult;
    try {
      // Return an early error if an artifact required for the audit is missing or an error.
      for (const artifactName of audit.meta.requiredArtifacts) {
        const noArtifact = artifacts[artifactName] === undefined;

        // If trace/devtoolsLog required, check that DEFAULT_PASS trace/devtoolsLog exists.
        // NOTE: for now, not a pass-specific check of traces or devtoolsLogs.
        const noRequiredTrace = artifactName === 'traces' && !artifacts.traces[Audit.DEFAULT_PASS];
        const noRequiredDevtoolsLog = artifactName === 'devtoolsLogs' &&
            !artifacts.devtoolsLogs[Audit.DEFAULT_PASS];

        if (noArtifact || noRequiredTrace || noRequiredDevtoolsLog) {
          log.warn('Runner',
              `${artifactName} gatherer, required by audit ${audit.meta.id}, did not run.`);
          throw new LHError(LHError.errors.MISSING_REQUIRED_ARTIFACT, {artifactName});
        }

        // If artifact was an error, output error result on behalf of audit.
        if (artifacts[artifactName] instanceof Error) {
          /** @type {Error} */
          // @ts-expect-error An artifact *could* be an Error, but caught here, so ignore elsewhere.
          const artifactError = artifacts[artifactName];

          Sentry.captureException(artifactError, {
            tags: {gatherer: artifactName},
            level: 'error',
          });

          log.warn('Runner', `${artifactName} gatherer, required by audit ${audit.meta.id},` +
            ` encountered an error: ${artifactError.message}`);

          // Create a friendlier display error and mark it as expected to avoid duplicates in Sentry
          const error = new LHError(LHError.errors.ERRORED_REQUIRED_ARTIFACT,
              {artifactName, errorMessage: artifactError.message});
          // @ts-expect-error Non-standard property added to Error
          error.expected = true;
          throw error;
        }
      }

      // all required artifacts are in good shape, so we proceed
      const auditOptions = Object.assign({}, audit.defaultOptions, auditDefn.options);
      const auditContext = {
        options: auditOptions,
        ...sharedAuditContext,
      };

      // Only pass the declared required and optional artifacts to the audit
      // The type is masquerading as `LH.Artifacts` but will only contain a subset of the keys
      // to prevent consumers from unnecessary type assertions.
      const requestedArtifacts = audit.meta.requiredArtifacts
        .concat(audit.meta.__internalOptionalArtifacts || []);
      const narrowedArtifacts = requestedArtifacts
        .reduce((narrowedArtifacts, artifactName) => {
          const requestedArtifact = artifacts[artifactName];
          // @ts-expect-error tsc can't yet express that artifactName is only a single type in each iteration, not a union of types.
          narrowedArtifacts[artifactName] = requestedArtifact;
          return narrowedArtifacts;
        }, /** @type {LH.Artifacts} */ ({}));
      const product = await audit.audit(narrowedArtifacts, auditContext);
      runWarnings.push(...product.runWarnings || []);

      auditResult = Audit.generateAuditResult(audit, product);
    } catch (err) {
      // Log error if it hasn't already been logged above.
      if (err.code !== 'MISSING_REQUIRED_ARTIFACT' && err.code !== 'ERRORED_REQUIRED_ARTIFACT') {
        log.warn(audit.meta.id, `Caught exception: ${err.message}`);
      }

      Sentry.captureException(err, {tags: {audit: audit.meta.id}, level: 'error'});
      // Errors become error audit result.
      const errorMessage = err.friendlyMessage ? err.friendlyMessage : err.message;
      auditResult = Audit.generateErrorAuditResult(audit, errorMessage);
    }

    log.timeEnd(status);
    return auditResult;
  }

  /**
   * Searches a pass's artifacts for any `lhrRuntimeError` error artifacts.
   * Returns the first one found or `null` if none found.
   * @param {LH.Artifacts} artifacts
   * @return {LH.RawIcu<LH.Result['runtimeError']>|undefined}
   */
  static getArtifactRuntimeError(artifacts) {
    const possibleErrorArtifacts = [
      artifacts.PageLoadError, // Preferentially use `PageLoadError`, if it exists.
      ...Object.values(artifacts), // Otherwise check amongst all artifacts.
    ];

    for (const possibleErrorArtifact of possibleErrorArtifacts) {
      if (possibleErrorArtifact instanceof LHError && possibleErrorArtifact.lhrRuntimeError) {
        const errorMessage = possibleErrorArtifact.friendlyMessage || possibleErrorArtifact.message;

        return {
          code: possibleErrorArtifact.code,
          message: errorMessage,
        };
      }
    }

    return undefined;
  }

  /**
   * Returns list of audit names for external querying.
   * @return {Array<string>}
   */
  static getAuditList() {
    const ignoredFiles = [
      'audit.js',
      'violation-audit.js',
      'accessibility/axe-audit.js',
      'multi-check-audit.js',
      'byte-efficiency/byte-efficiency-audit.js',
      'manual/manual-audit.js',
    ];

    const fileList = [
      ...["accessibility","apple-touch-icon.js","audit.js","autocomplete.js","bootup-time.js","byte-efficiency","content-width.js","critical-request-chains.js","csp-xss.js","deprecations.js","diagnostics.js","dobetterweb","errors-in-console.js","final-screenshot.js","font-display.js","full-page-screenshot.js","image-aspect-ratio.js","image-size-responsive.js","installable-manifest.js","is-on-https.js","large-javascript-libraries.js","largest-contentful-paint-element.js","layout-shift-elements.js","long-tasks.js","main-thread-tasks.js","mainthread-work-breakdown.js","manual","maskable-icon.js","metrics","metrics.js","multi-check-audit.js","network-requests.js","network-rtt.js","network-server-latency.js","no-unload-listeners.js","non-composited-animations.js","performance-budget.js","predictive-perf.js","preload-fonts.js","preload-lcp-image.js","redirects-http.js","redirects.js","resource-summary.js","screenshot-thumbnails.js","script-treemap-data.js","seo","server-response-time.js","service-worker.js","splash-screen.js","themed-omnibox.js","third-party-facades.js","third-party-summary.js","timing-budget.js","unsized-images.js","user-timings.js","uses-rel-preconnect.js","uses-rel-preload.js","valid-source-maps.js","viewport.js","violation-audit.js"],
      ...["appcache-manifest.js","charset.js","doctype.js","dom-size.js","external-anchors-use-rel-noopener.js","geolocation-on-start.js","inspector-issues.js","js-libraries.js","no-document-write.js","no-vulnerable-libraries.js","notification-on-start.js","password-inputs-can-be-pasted-into.js","uses-http2.js","uses-passive-event-listeners.js"].map(f => `dobetterweb/${f}`),
      ...["cumulative-layout-shift.js","first-contentful-paint-3g.js","first-contentful-paint.js","first-meaningful-paint.js","interactive.js","largest-contentful-paint.js","max-potential-fid.js","speed-index.js","total-blocking-time.js"].map(f => `metrics/${f}`),
      ...["canonical.js","crawlable-anchors.js","font-size.js","hreflang.js","http-status-code.js","is-crawlable.js","link-text.js","manual","meta-description.js","plugins.js","robots-txt.js","tap-targets.js"].map(f => `seo/${f}`),
      ...["structured-data.js"].map(f => `seo/manual/${f}`),
      ...["accesskeys.js","aria-allowed-attr.js","aria-command-name.js","aria-hidden-body.js","aria-hidden-focus.js","aria-input-field-name.js","aria-meter-name.js","aria-progressbar-name.js","aria-required-attr.js","aria-required-children.js","aria-required-parent.js","aria-roles.js","aria-toggle-field-name.js","aria-tooltip-name.js","aria-treeitem-name.js","aria-valid-attr-value.js","aria-valid-attr.js","axe-audit.js","button-name.js","bypass.js","color-contrast.js","definition-list.js","dlitem.js","document-title.js","duplicate-id-active.js","duplicate-id-aria.js","form-field-multiple-labels.js","frame-title.js","heading-order.js","html-has-lang.js","html-lang-valid.js","image-alt.js","input-image-alt.js","label.js","link-name.js","list.js","listitem.js","manual","meta-refresh.js","meta-viewport.js","object-alt.js","tabindex.js","td-headers-attr.js","th-has-data-cells.js","valid-lang.js","video-caption.js"]
          .map(f => `accessibility/${f}`),
      ...["custom-controls-labels.js","custom-controls-roles.js","focus-traps.js","focusable-controls.js","interactive-element-affordance.js","logical-tab-order.js","managed-focus.js","offscreen-content-hidden.js","use-landmarks.js","visual-order-follows-dom.js"]
          .map(f => `accessibility/manual/${f}`),
      ...["byte-efficiency-audit.js","duplicated-javascript.js","efficient-animated-content.js","legacy-javascript.js","modern-image-formats.js","offscreen-images.js","polyfill-graph-data.json","render-blocking-resources.js","total-byte-weight.js","unminified-css.js","unminified-javascript.js","unused-css-rules.js","unused-javascript.js","uses-long-cache-ttl.js","uses-optimized-images.js","uses-responsive-images-snapshot.js","uses-responsive-images.js","uses-text-compression.js"]
          .map(f => `byte-efficiency/${f}`),
      ...["manual-audit.js","pwa-cross-browser.js","pwa-each-page-has-url.js","pwa-page-transitions.js"].map(f => `manual/${f}`),
    ];
    return fileList.filter(f => {
      return /\.js$/.test(f) && !ignoredFiles.includes(f);
    }).sort();
  }

  /**
   * Returns list of gatherer names for external querying.
   * @return {Array<string>}
   */
  static getGathererList() {
    const fileList = [
      ...["accessibility.js","anchor-elements.js","cache-contents.js","console-messages.js","css-usage.js","devtools-log-compat.js","devtools-log.js","dobetterweb","form-elements.js","full-page-screenshot.js","gather-context.js","gatherer.js","global-listeners.js","host-form-factor.js","host-user-agent.js","http-redirect.js","iframe-elements.js","image-elements.js","inspector-issues.js","installability-errors.js","js-usage.js","link-elements.js","main-document-content.js","meta-elements.js","network-user-agent.js","script-elements.js","seo","service-worker.js","source-maps.js","stacks.js","trace-compat.js","trace-elements.js","trace.js","viewport-dimensions.js","web-app-manifest.js"],
      ...["embedded-content.js","font-size.js","robots-txt.js","tap-targets.js"].map(f => `seo/${f}`),
      ...["appcache.js","doctype.js","domstats.js","optimized-images.js","password-inputs-with-prevented-paste.js","response-compression.js","tags-blocking-first-paint.js"]
          .map(f => `dobetterweb/${f}`),
    ];
    return fileList.filter(f => /\.js$/.test(f) && f !== 'gatherer.js').sort();
  }

  /**
   * Get path to use for -G and -A modes. Defaults to $CWD/latest-run
   * @param {LH.Config.Settings} settings
   * @return {string}
   */
  static _getDataSavePath(settings) {
    const {auditMode, gatherMode} = settings;

    // This enables usage like: -GA=./custom-folder
    if (typeof auditMode === 'string') return path.resolve(process.cwd(), auditMode);
    if (typeof gatherMode === 'string') return path.resolve(process.cwd(), gatherMode);

    return path.join(process.cwd(), 'latest-run');
  }
}

module.exports = Runner;

}).call(this)}).call(this,require('_process'))
},{"../package.json":259,"../report/report-generator.js":260,"./audits/audit.js":3,"./gather/driver.js":64,"./gather/gather-runner.js":76,"./lib/asset-saver.js":80,"./lib/i18n/i18n.js":96,"./lib/lh-error.js":103,"./lib/sentry.js":112,"./lib/stack-packs.js":113,"./lib/url-shim.js":"url","./scoring.js":123,"_process":223,"lighthouse-logger":188,"lodash.isequal":217,"path":222}],123:[function(require,module,exports){
/**
 * @license Copyright 2018 The Lighthouse Authors. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.
 */

'use strict';

const Audit = require('./audits/audit.js');

/**
 * Clamp figure to 2 decimal places
 * @param {number} val
 * @return {number}
 */
const clampTo2Decimals = val => Math.round(val * 100) / 100;

class ReportScoring {
  /**
   * Computes the weighted-average of the score of the list of items.
   * @param {Array<{score: number|null, weight: number}>} items
   * @return {number|null}
   */
  static arithmeticMean(items) {
    // Filter down to just the items with a weight as they have no effect on score
    items = items.filter(item => item.weight > 0);
    // If there is 1 null score, return a null average
    if (items.some(item => item.score === null)) return null;

    const results = items.reduce(
      (result, item) => {
        const score = item.score;
        const weight = item.weight;

        return {
          weight: result.weight + weight,
          sum: result.sum + /** @type {number} */ (score) * weight,
        };
      },
      {weight: 0, sum: 0}
    );

    return clampTo2Decimals(results.sum / results.weight || 0);
  }

  /**
   * Returns the report JSON object with computed scores.
   * @param {Object<string, LH.Config.Category>} configCategories
   * @param {Object<string, LH.RawIcu<LH.Audit.Result>>} resultsByAuditId
   * @return {Object<string, LH.RawIcu<LH.Result.Category>>}
   */
  static scoreAllCategories(configCategories, resultsByAuditId) {
    /** @type {Record<string, LH.RawIcu<LH.Result.Category>>} */
    const scoredCategories = {};

    for (const [categoryId, configCategory] of Object.entries(configCategories)) {
      // Copy category audit members
      const auditRefs = configCategory.auditRefs.map(configMember => {
        const member = {...configMember};

        // If a result was not applicable, meaning its checks did not run against anything on
        // the page, force it's weight to 0. It will not count during the arithmeticMean() but
        // will still be included in the final report json and displayed in the report as
        // "Not Applicable".
        const result = resultsByAuditId[member.id];
        if (result.scoreDisplayMode === Audit.SCORING_MODES.NOT_APPLICABLE ||
            result.scoreDisplayMode === Audit.SCORING_MODES.INFORMATIVE ||
            result.scoreDisplayMode === Audit.SCORING_MODES.MANUAL) {
          member.weight = 0;
        }

        return member;
      });

      const scores = auditRefs.map(auditRef => ({
        score: resultsByAuditId[auditRef.id].score,
        weight: auditRef.weight,
      }));
      const score = ReportScoring.arithmeticMean(scores);

      scoredCategories[categoryId] = {
        ...configCategory,
        auditRefs,
        id: categoryId,
        score,
      };
    }

    return scoredCategories;
  }
}

module.exports = ReportScoring;

},{"./audits/audit.js":3}],124:[function(require,module,exports){
// @ts-nocheck
// Auto-generated by lighthouse-core/scripts/copy-util-commonjs.sh
// Temporary solution until all our code uses esmodules
/**
 * @license
 * Copyright 2017 The Lighthouse Authors. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS-IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';

/** @template T @typedef {import('./i18n').I18n<T>} I18n */

const ELLIPSIS = '\u2026';
const NBSP = '\xa0';
const PASS_THRESHOLD = 0.9;
const SCREENSHOT_PREFIX = 'data:image/jpeg;base64,';

const RATINGS = {
  PASS: {label: 'pass', minScore: PASS_THRESHOLD},
  AVERAGE: {label: 'average', minScore: 0.5},
  FAIL: {label: 'fail'},
  ERROR: {label: 'error'},
};

// 25 most used tld plus one domains (aka public suffixes) from http archive.
// @see https://github.com/GoogleChrome/lighthouse/pull/5065#discussion_r191926212
// The canonical list is https://publicsuffix.org/learn/ but we're only using subset to conserve bytes
const listOfTlds = [
  'com', 'co', 'gov', 'edu', 'ac', 'org', 'go', 'gob', 'or', 'net', 'in', 'ne', 'nic', 'gouv',
  'web', 'spb', 'blog', 'jus', 'kiev', 'mil', 'wi', 'qc', 'ca', 'bel', 'on',
];

class Util {
  static get PASS_THRESHOLD() {
    return PASS_THRESHOLD;
  }

  static get MS_DISPLAY_VALUE() {
    return `%10d${NBSP}ms`;
  }

  /**
   * Returns a new LHR that's reshaped for slightly better ergonomics within the report rendereer.
   * Also, sets up the localized UI strings used within renderer and makes changes to old LHRs to be
   * compatible with current renderer.
   * The LHR passed in is not mutated.
   * TODO(team): we all agree the LHR shape change is technical debt we should fix
   * @param {LH.Result} result
   * @return {LH.ReportResult}
   */
  static prepareReportResult(result) {
    // If any mutations happen to the report within the renderers, we want the original object untouched
    const clone = /** @type {LH.ReportResult} */ (JSON.parse(JSON.stringify(result)));

    // If LHR is older (≤3.0.3), it has no locale setting. Set default.
    if (!clone.configSettings.locale) {
      clone.configSettings.locale = 'en';
    }
    if (!clone.configSettings.formFactor) {
      // @ts-expect-error fallback handling for emulatedFormFactor
      clone.configSettings.formFactor = clone.configSettings.emulatedFormFactor;
    }

    for (const audit of Object.values(clone.audits)) {
      // Turn 'not-applicable' (LHR <4.0) and 'not_applicable' (older proto versions)
      // into 'notApplicable' (LHR ≥4.0).
      // @ts-expect-error tsc rightly flags that these values shouldn't occur.
      // eslint-disable-next-line max-len
      if (audit.scoreDisplayMode === 'not_applicable' || audit.scoreDisplayMode === 'not-applicable') {
        audit.scoreDisplayMode = 'notApplicable';
      }

      if (audit.details) {
        // Turn `auditDetails.type` of undefined (LHR <4.2) and 'diagnostic' (LHR <5.0)
        // into 'debugdata' (LHR ≥5.0).
        // @ts-expect-error tsc rightly flags that these values shouldn't occur.
        if (audit.details.type === undefined || audit.details.type === 'diagnostic') {
          // @ts-expect-error details is of type never.
          audit.details.type = 'debugdata';
        }

        // Add the jpg data URL prefix to filmstrip screenshots without them (LHR <5.0).
        if (audit.details.type === 'filmstrip') {
          for (const screenshot of audit.details.items) {
            if (!screenshot.data.startsWith(SCREENSHOT_PREFIX)) {
              screenshot.data = SCREENSHOT_PREFIX + screenshot.data;
            }
          }
        }
      }
    }

    // For convenience, smoosh all AuditResults into their auditRef (which has just weight & group)
    if (typeof clone.categories !== 'object') throw new Error('No categories provided.');

    /** @type {Map<string, Array<LH.ReportResult.AuditRef>>} */
    const relevantAuditToMetricsMap = new Map();

    for (const category of Object.values(clone.categories)) {
      // Make basic lookup table for relevantAudits
      category.auditRefs.forEach(metricRef => {
        if (!metricRef.relevantAudits) return;
        metricRef.relevantAudits.forEach(auditId => {
          const arr = relevantAuditToMetricsMap.get(auditId) || [];
          arr.push(metricRef);
          relevantAuditToMetricsMap.set(auditId, arr);
        });
      });

      category.auditRefs.forEach(auditRef => {
        const result = clone.audits[auditRef.id];
        auditRef.result = result;

        // Attach any relevantMetric auditRefs
        if (relevantAuditToMetricsMap.has(auditRef.id)) {
          auditRef.relevantMetrics = relevantAuditToMetricsMap.get(auditRef.id);
        }

        // attach the stackpacks to the auditRef object
        if (clone.stackPacks) {
          clone.stackPacks.forEach(pack => {
            if (pack.descriptions[auditRef.id]) {
              auditRef.stackPacks = auditRef.stackPacks || [];
              auditRef.stackPacks.push({
                title: pack.title,
                iconDataURL: pack.iconDataURL,
                description: pack.descriptions[auditRef.id],
              });
            }
          });
        }
      });
    }

    return clone;
  }

  /**
   * Used to determine if the "passed" for the purposes of showing up in the "failed" or "passed"
   * sections of the report.
   *
   * @param {{score: (number|null), scoreDisplayMode: string}} audit
   * @return {boolean}
   */
  static showAsPassed(audit) {
    switch (audit.scoreDisplayMode) {
      case 'manual':
      case 'notApplicable':
        return true;
      case 'error':
      case 'informative':
        return false;
      case 'numeric':
      case 'binary':
      default:
        return Number(audit.score) >= RATINGS.PASS.minScore;
    }
  }

  /**
   * Convert a score to a rating label.
   * @param {number|null} score
   * @param {string=} scoreDisplayMode
   * @return {string}
   */
  static calculateRating(score, scoreDisplayMode) {
    // Handle edge cases first, manual and not applicable receive 'pass', errored audits receive 'error'
    if (scoreDisplayMode === 'manual' || scoreDisplayMode === 'notApplicable') {
      return RATINGS.PASS.label;
    } else if (scoreDisplayMode === 'error') {
      return RATINGS.ERROR.label;
    } else if (score === null) {
      return RATINGS.FAIL.label;
    }

    // At this point, we're rating a standard binary/numeric audit
    let rating = RATINGS.FAIL.label;
    if (score >= RATINGS.PASS.minScore) {
      rating = RATINGS.PASS.label;
    } else if (score >= RATINGS.AVERAGE.minScore) {
      rating = RATINGS.AVERAGE.label;
    }
    return rating;
  }

  /**
   * Split a string by markdown code spans (enclosed in `backticks`), splitting
   * into segments that were enclosed in backticks (marked as `isCode === true`)
   * and those that outside the backticks (`isCode === false`).
   * @param {string} text
   * @return {Array<{isCode: true, text: string}|{isCode: false, text: string}>}
   */
  static splitMarkdownCodeSpans(text) {
    /** @type {Array<{isCode: true, text: string}|{isCode: false, text: string}>} */
    const segments = [];

    // Split on backticked code spans.
    const parts = text.split(/`(.*?)`/g);
    for (let i = 0; i < parts.length; i ++) {
      const text = parts[i];

      // Empty strings are an artifact of splitting, not meaningful.
      if (!text) continue;

      // Alternates between plain text and code segments.
      const isCode = i % 2 !== 0;
      segments.push({
        isCode,
        text,
      });
    }

    return segments;
  }

  /**
   * Split a string on markdown links (e.g. [some link](https://...)) into
   * segments of plain text that weren't part of a link (marked as
   * `isLink === false`), and segments with text content and a URL that did make
   * up a link (marked as `isLink === true`).
   * @param {string} text
   * @return {Array<{isLink: true, text: string, linkHref: string}|{isLink: false, text: string}>}
   */
  static splitMarkdownLink(text) {
    /** @type {Array<{isLink: true, text: string, linkHref: string}|{isLink: false, text: string}>} */
    const segments = [];

    const parts = text.split(/\[([^\]]+?)\]\((https?:\/\/.*?)\)/g);
    while (parts.length) {
      // Shift off the same number of elements as the pre-split and capture groups.
      const [preambleText, linkText, linkHref] = parts.splice(0, 3);

      if (preambleText) { // Skip empty text as it's an artifact of splitting, not meaningful.
        segments.push({
          isLink: false,
          text: preambleText,
        });
      }

      // Append link if there are any.
      if (linkText && linkHref) {
        segments.push({
          isLink: true,
          text: linkText,
          linkHref,
        });
      }
    }

    return segments;
  }

  /**
   * @param {URL} parsedUrl
   * @param {{numPathParts?: number, preserveQuery?: boolean, preserveHost?: boolean}=} options
   * @return {string}
   */
  static getURLDisplayName(parsedUrl, options) {
    // Closure optional properties aren't optional in tsc, so fallback needs undefined  values.
    options = options || {numPathParts: undefined, preserveQuery: undefined,
      preserveHost: undefined};
    const numPathParts = options.numPathParts !== undefined ? options.numPathParts : 2;
    const preserveQuery = options.preserveQuery !== undefined ? options.preserveQuery : true;
    const preserveHost = options.preserveHost || false;

    let name;

    if (parsedUrl.protocol === 'about:' || parsedUrl.protocol === 'data:') {
      // Handle 'about:*' and 'data:*' URLs specially since they have no path.
      name = parsedUrl.href;
    } else {
      name = parsedUrl.pathname;
      const parts = name.split('/').filter(part => part.length);
      if (numPathParts && parts.length > numPathParts) {
        name = ELLIPSIS + parts.slice(-1 * numPathParts).join('/');
      }

      if (preserveHost) {
        name = `${parsedUrl.host}/${name.replace(/^\//, '')}`;
      }
      if (preserveQuery) {
        name = `${name}${parsedUrl.search}`;
      }
    }

    const MAX_LENGTH = 64;
    // Always elide hexadecimal hash
    name = name.replace(/([a-f0-9]{7})[a-f0-9]{13}[a-f0-9]*/g, `$1${ELLIPSIS}`);
    // Also elide other hash-like mixed-case strings
    name = name.replace(/([a-zA-Z0-9-_]{9})(?=.*[a-z])(?=.*[A-Z])(?=.*[0-9])[a-zA-Z0-9-_]{10,}/g,
      `$1${ELLIPSIS}`);
    // Also elide long number sequences
    name = name.replace(/(\d{3})\d{6,}/g, `$1${ELLIPSIS}`);
    // Merge any adjacent ellipses
    name = name.replace(/\u2026+/g, ELLIPSIS);

    // Elide query params first
    if (name.length > MAX_LENGTH && name.includes('?')) {
      // Try to leave the first query parameter intact
      name = name.replace(/\?([^=]*)(=)?.*/, `?$1$2${ELLIPSIS}`);

      // Remove it all if it's still too long
      if (name.length > MAX_LENGTH) {
        name = name.replace(/\?.*/, `?${ELLIPSIS}`);
      }
    }

    // Elide too long names next
    if (name.length > MAX_LENGTH) {
      const dotIndex = name.lastIndexOf('.');
      if (dotIndex >= 0) {
        name = name.slice(0, MAX_LENGTH - 1 - (name.length - dotIndex)) +
          // Show file extension
          `${ELLIPSIS}${name.slice(dotIndex)}`;
      } else {
        name = name.slice(0, MAX_LENGTH - 1) + ELLIPSIS;
      }
    }

    return name;
  }

  /**
   * Split a URL into a file, hostname and origin for easy display.
   * @param {string} url
   * @return {{file: string, hostname: string, origin: string}}
   */
  static parseURL(url) {
    const parsedUrl = new URL(url);
    return {
      file: Util.getURLDisplayName(parsedUrl),
      hostname: parsedUrl.hostname,
      origin: parsedUrl.origin,
    };
  }

  /**
   * @param {string|URL} value
   * @return {!URL}
   */
  static createOrReturnURL(value) {
    if (value instanceof URL) {
      return value;
    }

    return new URL(value);
  }

  /**
   * Gets the tld of a domain
   *
   * @param {string} hostname
   * @return {string} tld
   */
  static getTld(hostname) {
    const tlds = hostname.split('.').slice(-2);

    if (!listOfTlds.includes(tlds[0])) {
      return `.${tlds[tlds.length - 1]}`;
    }

    return `.${tlds.join('.')}`;
  }

  /**
   * Returns a primary domain for provided hostname (e.g. www.example.com -> example.com).
   * @param {string|URL} url hostname or URL object
   * @return {string}
   */
  static getRootDomain(url) {
    const hostname = Util.createOrReturnURL(url).hostname;
    const tld = Util.getTld(hostname);

    // tld is .com or .co.uk which means we means that length is 1 to big
    // .com => 2 & .co.uk => 3
    const splitTld = tld.split('.');

    // get TLD + root domain
    return hostname.split('.').slice(-splitTld.length).join('.');
  }

  /**
   * @param {LH.Config.Settings} settings
   * @return {!Array<{name: string, description: string}>}
   */
  static getEnvironmentDisplayValues(settings) {
    const emulationDesc = Util.getEmulationDescriptions(settings);

    return [
      {
        name: Util.i18n.strings.runtimeSettingsDevice,
        description: emulationDesc.deviceEmulation,
      },
      {
        name: Util.i18n.strings.runtimeSettingsNetworkThrottling,
        description: emulationDesc.networkThrottling,
      },
      {
        name: Util.i18n.strings.runtimeSettingsCPUThrottling,
        description: emulationDesc.cpuThrottling,
      },
    ];
  }

  /**
   * @param {LH.Config.Settings} settings
   * @return {{deviceEmulation: string, networkThrottling: string, cpuThrottling: string}}
   */
  static getEmulationDescriptions(settings) {
    let cpuThrottling;
    let networkThrottling;

    const throttling = settings.throttling;

    switch (settings.throttlingMethod) {
      case 'provided':
        cpuThrottling = Util.i18n.strings.throttlingProvided;
        networkThrottling = Util.i18n.strings.throttlingProvided;
        break;
      case 'devtools': {
        const {cpuSlowdownMultiplier, requestLatencyMs} = throttling;
        cpuThrottling = `${Util.i18n.formatNumber(cpuSlowdownMultiplier)}x slowdown (DevTools)`;
        networkThrottling = `${Util.i18n.formatNumber(requestLatencyMs)}${NBSP}ms HTTP RTT, ` +
          `${Util.i18n.formatNumber(throttling.downloadThroughputKbps)}${NBSP}Kbps down, ` +
          `${Util.i18n.formatNumber(throttling.uploadThroughputKbps)}${NBSP}Kbps up (DevTools)`;
        break;
      }
      case 'simulate': {
        const {cpuSlowdownMultiplier, rttMs, throughputKbps} = throttling;
        cpuThrottling = `${Util.i18n.formatNumber(cpuSlowdownMultiplier)}x slowdown (Simulated)`;
        networkThrottling = `${Util.i18n.formatNumber(rttMs)}${NBSP}ms TCP RTT, ` +
          `${Util.i18n.formatNumber(throughputKbps)}${NBSP}Kbps throughput (Simulated)`;
        break;
      }
      default:
        cpuThrottling = Util.i18n.strings.runtimeUnknown;
        networkThrottling = Util.i18n.strings.runtimeUnknown;
    }

    // TODO(paulirish): revise Runtime Settings strings: https://github.com/GoogleChrome/lighthouse/pull/11796
    const deviceEmulation = {
      mobile: Util.i18n.strings.runtimeMobileEmulation,
      desktop: Util.i18n.strings.runtimeDesktopEmulation,
    }[settings.formFactor] || Util.i18n.strings.runtimeNoEmulation;

    return {
      deviceEmulation,
      cpuThrottling,
      networkThrottling,
    };
  }

  /**
   * Returns only lines that are near a message, or the first few lines if there are
   * no line messages.
   * @param {LH.Audit.Details.SnippetValue['lines']} lines
   * @param {LH.Audit.Details.SnippetValue['lineMessages']} lineMessages
   * @param {number} surroundingLineCount Number of lines to include before and after
   * the message. If this is e.g. 2 this function might return 5 lines.
   */
  static filterRelevantLines(lines, lineMessages, surroundingLineCount) {
    if (lineMessages.length === 0) {
      // no lines with messages, just return the first bunch of lines
      return lines.slice(0, surroundingLineCount * 2 + 1);
    }

    const minGapSize = 3;
    const lineNumbersToKeep = new Set();
    // Sort messages so we can check lineNumbersToKeep to see how big the gap to
    // the previous line is.
    lineMessages = lineMessages.sort((a, b) => (a.lineNumber || 0) - (b.lineNumber || 0));
    lineMessages.forEach(({lineNumber}) => {
      let firstSurroundingLineNumber = lineNumber - surroundingLineCount;
      let lastSurroundingLineNumber = lineNumber + surroundingLineCount;

      while (firstSurroundingLineNumber < 1) {
        // make sure we still show (surroundingLineCount * 2 + 1) lines in total
        firstSurroundingLineNumber++;
        lastSurroundingLineNumber++;
      }
      // If only a few lines would be omitted normally then we prefer to include
      // extra lines to avoid the tiny gap
      if (lineNumbersToKeep.has(firstSurroundingLineNumber - minGapSize - 1)) {
        firstSurroundingLineNumber -= minGapSize;
      }
      for (let i = firstSurroundingLineNumber; i <= lastSurroundingLineNumber; i++) {
        const surroundingLineNumber = i;
        lineNumbersToKeep.add(surroundingLineNumber);
      }
    });

    return lines.filter(line => lineNumbersToKeep.has(line.lineNumber));
  }

  /**
   * @param {string} categoryId
   */
  static isPluginCategory(categoryId) {
    return categoryId.startsWith('lighthouse-plugin-');
  }
}

/**
 * Some parts of the report renderer require data found on the LHR. Instead of wiring it
 * through, we have this global.
 * @type {LH.ReportResult | null}
 */
Util.reportJson = null;

/**
 * An always-increasing counter for making unique SVG ID suffixes.
 */
Util.getUniqueSuffix = (() => {
  let svgSuffix = 0;
  return function() {
    return svgSuffix++;
  };
})();

/** @type {I18n<typeof Util['UIStrings']>} */
// @ts-expect-error: Is set in report renderer.
Util.i18n = null;

/**
 * Report-renderer-specific strings.
 */
Util.UIStrings = {
  /** Disclaimer shown to users below the metric values (First Contentful Paint, Time to Interactive, etc) to warn them that the numbers they see will likely change slightly the next time they run Lighthouse. */
  varianceDisclaimer: 'Values are estimated and may vary. The [performance score is calculated](https://web.dev/performance-scoring/) directly from these metrics.',
  /** Text link pointing to an interactive calculator that explains Lighthouse scoring. The link text should be fairly short. */
  calculatorLink: 'See calculator.',
  /** Label preceding a radio control for filtering the list of audits. The radio choices are various performance metrics (FCP, LCP, TBT), and if chosen, the audits in the report are hidden if they are not relevant to the selected metric. */
  showRelevantAudits: 'Show audits relevant to:',
  /** Column heading label for the listing of opportunity audits. Each audit title represents an opportunity. There are only 2 columns, so no strict character limit.  */
  opportunityResourceColumnLabel: 'Opportunity',
  /** Column heading label for the estimated page load savings of opportunity audits. Estimated Savings is the total amount of time (in seconds) that Lighthouse computed could be reduced from the total page load time, if the suggested action is taken. There are only 2 columns, so no strict character limit. */
  opportunitySavingsColumnLabel: 'Estimated Savings',

  /** An error string displayed next to a particular audit when it has errored, but not provided any specific error message. */
  errorMissingAuditInfo: 'Report error: no audit information',
  /** A label, shown next to an audit title or metric title, indicating that there was an error computing it. The user can hover on the label to reveal a tooltip with the extended error message. Translation should be short (< 20 characters). */
  errorLabel: 'Error!',
  /** This label is shown above a bulleted list of warnings. It is shown directly below an audit that produced warnings. Warnings describe situations the user should be aware of, as Lighthouse was unable to complete all the work required on this audit. For example, The 'Unable to decode image (biglogo.jpg)' warning may show up below an image encoding audit. */
  warningHeader: 'Warnings: ',
  /** Section heading shown above a list of passed audits that contain warnings. Audits under this section do not negatively impact the score, but Lighthouse has generated some potentially actionable suggestions that should be reviewed. This section is expanded by default and displays after the failing audits. */
  warningAuditsGroupTitle: 'Passed audits but with warnings',
  /** Section heading shown above a list of audits that are passing. 'Passed' here refers to a passing grade. This section is collapsed by default, as the user should be focusing on the failed audits instead. Users can click this heading to reveal the list. */
  passedAuditsGroupTitle: 'Passed audits',
  /** Section heading shown above a list of audits that do not apply to the page. For example, if an audit is 'Are images optimized?', but the page has no images on it, the audit will be marked as not applicable. This is neither passing or failing. This section is collapsed by default, as the user should be focusing on the failed audits instead. Users can click this heading to reveal the list. */
  notApplicableAuditsGroupTitle: 'Not applicable',
  /** Section heading shown above a list of audits that were not computed by Lighthouse. They serve as a list of suggestions for the user to go and manually check. For example, Lighthouse can't automate testing cross-browser compatibility, so that is listed within this section, so the user is reminded to test it themselves. This section is collapsed by default, as the user should be focusing on the failed audits instead. Users can click this heading to reveal the list. */
  manualAuditsGroupTitle: 'Additional items to manually check',

  /** Label shown preceding any important warnings that may have invalidated the entire report. For example, if the user has Chrome extensions installed, they may add enough performance overhead that Lighthouse's performance metrics are unreliable. If shown, this will be displayed at the top of the report UI. */
  toplevelWarningsMessage: 'There were issues affecting this run of Lighthouse:',

  /** String of text shown in a graphical representation of the flow of network requests for the web page. This label represents the initial network request that fetches an HTML page. This navigation may be redirected (eg. Initial navigation to http://example.com redirects to https://www.example.com). */
  crcInitialNavigation: 'Initial Navigation',
  /** Label of value shown in the summary of critical request chains. Refers to the total amount of time (milliseconds) of the longest critical path chain/sequence of network requests. Example value: 2310 ms */
  crcLongestDurationLabel: 'Maximum critical path latency:',

  /** Label for button that shows all lines of the snippet when clicked */
  snippetExpandButtonLabel: 'Expand snippet',
  /** Label for button that only shows a few lines of the snippet when clicked */
  snippetCollapseButtonLabel: 'Collapse snippet',

  /** Explanation shown to users below performance results to inform them that the test was done with a 4G network connection and to warn them that the numbers they see will likely change slightly the next time they run Lighthouse. 'Lighthouse' becomes link text to additional documentation. */
  lsPerformanceCategoryDescription: '[Lighthouse](https://developers.google.com/web/tools/lighthouse/) analysis of the current page on an emulated mobile network. Values are estimated and may vary.',
  /** Title of the lab data section of the Performance category. Within this section are various speed metrics which quantify the pageload performance into values presented in seconds and milliseconds. "Lab" is an abbreviated form of "laboratory", and refers to the fact that the data is from a controlled test of a website, not measurements from real users visiting that site.  */
  labDataTitle: 'Lab Data',

  /** This label is for a checkbox above a table of items loaded by a web page. The checkbox is used to show or hide third-party (or "3rd-party") resources in the table, where "third-party resources" refers to items loaded by a web page from URLs that aren't controlled by the owner of the web page. */
  thirdPartyResourcesLabel: 'Show 3rd-party resources',
  /** This label is for a button that opens a new tab to a webapp called "Treemap", which is a nested visual representation of a heierarchy of data related to the reports (script bytes and coverage, resource breakdown, etc.) */
  viewTreemapLabel: 'View Treemap',

  /** Option in a dropdown menu that opens a small, summary report in a print dialog.  */
  dropdownPrintSummary: 'Print Summary',
  /** Option in a dropdown menu that opens a full Lighthouse report in a print dialog.  */
  dropdownPrintExpanded: 'Print Expanded',
  /** Option in a dropdown menu that copies the Lighthouse JSON object to the system clipboard. */
  dropdownCopyJSON: 'Copy JSON',
  /** Option in a dropdown menu that saves the Lighthouse report HTML locally to the system as a '.html' file. */
  dropdownSaveHTML: 'Save as HTML',
  /** Option in a dropdown menu that saves the Lighthouse JSON object to the local system as a '.json' file. */
  dropdownSaveJSON: 'Save as JSON',
  /** Option in a dropdown menu that opens the current report in the Lighthouse Viewer Application. */
  dropdownViewer: 'Open in Viewer',
  /** Option in a dropdown menu that saves the current report as a new GitHub Gist. */
  dropdownSaveGist: 'Save as Gist',
  /** Option in a dropdown menu that toggles the themeing of the report between Light(default) and Dark themes. */
  dropdownDarkTheme: 'Toggle Dark Theme',

  /** Title of the Runtime settings table in a Lighthouse report.  Runtime settings are the environment configurations that a specific report used at auditing time. */
  runtimeSettingsTitle: 'Runtime Settings',
  /** Label for a row in a table that shows the URL that was audited during a Lighthouse run. */
  runtimeSettingsUrl: 'URL',
  /** Label for a row in a table that shows the time at which a Lighthouse run was conducted; formatted as a timestamp, e.g. Jan 1, 1970 12:00 AM UTC. */
  runtimeSettingsFetchTime: 'Fetch Time',
  /** Label for a row in a table that describes the kind of device that was emulated for the Lighthouse run.  Example values for row elements: 'No Emulation', 'Emulated Desktop', etc. */
  runtimeSettingsDevice: 'Device',
  /** Label for a row in a table that describes the network throttling conditions that were used during a Lighthouse run, if any. */
  runtimeSettingsNetworkThrottling: 'Network throttling',
  /** Label for a row in a table that describes the CPU throttling conditions that were used during a Lighthouse run, if any.*/
  runtimeSettingsCPUThrottling: 'CPU throttling',
  /** Label for a row in a table that shows in what tool Lighthouse is being run (e.g. The lighthouse CLI, Chrome DevTools, Lightrider, WebPageTest, etc). */
  runtimeSettingsChannel: 'Channel',
  /** Label for a row in a table that shows the User Agent that was detected on the Host machine that ran Lighthouse. */
  runtimeSettingsUA: 'User agent (host)',
  /** Label for a row in a table that shows the User Agent that was used to send out all network requests during the Lighthouse run. */
  runtimeSettingsUANetwork: 'User agent (network)',
  /** Label for a row in a table that shows the estimated CPU power of the machine running Lighthouse. Example row values: 532, 1492, 783. */
  runtimeSettingsBenchmark: 'CPU/Memory Power',
  /** Label for a row in a table that shows the version of the Axe library used. Example row values: 2.1.0, 3.2.3 */
  runtimeSettingsAxeVersion: 'Axe version',

  /** Label for button to create an issue against the Lighthouse GitHub project. */
  footerIssue: 'File an issue',

  /** Descriptive explanation for emulation setting when no device emulation is set. */
  runtimeNoEmulation: 'No emulation',
  /** Descriptive explanation for emulation setting when emulating a Moto G4 mobile device. */
  runtimeMobileEmulation: 'Emulated Moto G4',
  /** Descriptive explanation for emulation setting when emulating a generic desktop form factor, as opposed to a mobile-device like form factor. */
  runtimeDesktopEmulation: 'Emulated Desktop',
  /** Descriptive explanation for a runtime setting that is set to an unknown value. */
  runtimeUnknown: 'Unknown',

  /** Descriptive explanation for environment throttling that was provided by the runtime environment instead of provided by Lighthouse throttling. */
  throttlingProvided: 'Provided by environment',
};


module.exports = Util;

},{}],125:[function(require,module,exports){
const HEADER_REGEXP = /([a-zA-Z][a-zA-Z_-]*)\s*(?:=(?:"([^"]*)"|([^ \t",;]*)))?/g

const STRINGS = {
  maxAge: 'max-age',
  sharedMaxAge: 's-maxage',
  maxStale: 'max-stale',
  minFresh: 'min-fresh',
  immutable: 'immutable',
  mustRevalidate: 'must-revalidate',
  noCache: 'no-cache',
  noStore: 'no-store',
  noTransform: 'no-transform',
  onlyIfCached: 'only-if-cached',
  private: 'private',
  proxyRevalidate: 'proxy-revalidate',
  public: 'public'
}

function parseBooleanOnly(value) {
  return value === null
}

function parseDuration(value) {
  if (!value) {
    return null
  }

  const duration = parseInt(value, 10)

  if (!Number.isFinite(duration) || duration < 0) {
    return null
  }

  return duration
}

class CacheControl {
  constructor() {
    this.maxAge = null
    this.sharedMaxAge = null
    this.maxStale = null
    this.maxStaleDuration = null
    this.minFresh = null
    this.immutable = null
    this.mustRevalidate = null
    this.noCache = null
    this.noStore = null
    this.noTransform = null
    this.onlyIfCached = null
    this.private = null
    this.proxyRevalidate = null
    this.public = null
  }

  parse(header) {
    if (!header || header.length === 0) {
      return this
    }

    const values = {}
    const matches = header.match(HEADER_REGEXP) || []

    Array.prototype.forEach.call(matches, match => {
      const tokens = match.split('=', 2)

      const [key] = tokens
      let value = null

      if (tokens.length > 1) {
        value = tokens[1].trim()
      }

      values[key.toLowerCase()] = value
    })

    this.maxAge = parseDuration(values[STRINGS.maxAge])
    this.sharedMaxAge = parseDuration(values[STRINGS.sharedMaxAge])

    this.maxStale = parseBooleanOnly(values[STRINGS.maxStale])
    this.maxStaleDuration = parseDuration(values[STRINGS.maxStale])
    if (this.maxStaleDuration) {
      this.maxStale = true
    }

    this.minFresh = parseDuration(values[STRINGS.minFresh])

    this.immutable = parseBooleanOnly(values[STRINGS.immutable])
    this.mustRevalidate = parseBooleanOnly(values[STRINGS.mustRevalidate])
    this.noCache = parseBooleanOnly(values[STRINGS.noCache])
    this.noStore = parseBooleanOnly(values[STRINGS.noStore])
    this.noTransform = parseBooleanOnly(values[STRINGS.noTransform])
    this.onlyIfCached = parseBooleanOnly(values[STRINGS.onlyIfCached])
    this.private = parseBooleanOnly(values[STRINGS.private])
    this.proxyRevalidate = parseBooleanOnly(values[STRINGS.proxyRevalidate])
    this.public = parseBooleanOnly(values[STRINGS.public])

    return this
  }

  format() {
    const tokens = []

    if (this.maxAge) {
      tokens.push(`${STRINGS.maxAge}=${this.maxAge}`)
    }

    if (this.sharedMaxAge) {
      tokens.push(`${STRINGS.sharedMaxAge}=${this.sharedMaxAge}`)
    }

    if (this.maxStale) {
      if (this.maxStaleDuration) {
        tokens.push(`${STRINGS.maxStale}=${this.maxStaleDuration}`)
      } else {
        tokens.push(STRINGS.maxStale)
      }
    }

    if (this.minFresh) {
      tokens.push(`${STRINGS.minFresh}=${this.minFresh}`)
    }

    if (this.immutable) {
      tokens.push(STRINGS.immutable)
    }

    if (this.mustRevalidate) {
      tokens.push(STRINGS.mustRevalidate)
    }

    if (this.noCache) {
      tokens.push(STRINGS.noCache)
    }

    if (this.noStore) {
      tokens.push(STRINGS.noStore)
    }

    if (this.noTransform) {
      tokens.push(STRINGS.noTransform)
    }

    if (this.onlyIfCached) {
      tokens.push(STRINGS.onlyIfCached)
    }

    if (this.private) {
      tokens.push(STRINGS.private)
    }

    if (this.proxyRevalidate) {
      tokens.push(STRINGS.proxyRevalidate)
    }

    if (this.public) {
      tokens.push(STRINGS.public)
    }

    return tokens.join(', ')
  }
}

function parse(header) {
  const cc = new CacheControl()
  return cc.parse(header)
}

function format(cc) {
  if (!(cc instanceof CacheControl)) {
    return CacheControl.prototype.format.call(cc)
  }

  return cc.format()
}

module.exports = {
  CacheControl,
  parse,
  format
}

},{}],126:[function(require,module,exports){

/**
 * Array#filter.
 *
 * @param {Array} arr
 * @param {Function} fn
 * @param {Object=} self
 * @return {Array}
 * @throw TypeError
 */

module.exports = function (arr, fn, self) {
  if (arr.filter) return arr.filter(fn, self);
  if (void 0 === arr || null === arr) throw new TypeError;
  if ('function' != typeof fn) throw new TypeError;
  var ret = [];
  for (var i = 0; i < arr.length; i++) {
    if (!hasOwn.call(arr, i)) continue;
    var val = arr[i];
    if (fn.call(self, val, i, arr)) ret.push(val);
  }
  return ret;
};

var hasOwn = Object.prototype.hasOwnProperty;

},{}],127:[function(require,module,exports){
(function (global){(function (){
'use strict';

// compare and isBuffer taken from https://github.com/feross/buffer/blob/680e9e5e488f22aac27599a57dc844a6315928dd/index.js
// original notice:

/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
 * @license  MIT
 */
function compare(a, b) {
  if (a === b) {
    return 0;
  }

  var x = a.length;
  var y = b.length;

  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i];
      y = b[i];
      break;
    }
  }

  if (x < y) {
    return -1;
  }
  if (y < x) {
    return 1;
  }
  return 0;
}
function isBuffer(b) {
  if (global.Buffer && typeof global.Buffer.isBuffer === 'function') {
    return global.Buffer.isBuffer(b);
  }
  return !!(b != null && b._isBuffer);
}

// based on node assert, original notice:

// http://wiki.commonjs.org/wiki/Unit_Testing/1.0
//
// THIS IS NOT TESTED NOR LIKELY TO WORK OUTSIDE V8!
//
// Originally from narwhal.js (http://narwhaljs.org)
// Copyright (c) 2009 Thomas Robinson <280north.com>
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the 'Software'), to
// deal in the Software without restriction, including without limitation the
// rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
// sell copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
// ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

var util = require('util/');
var hasOwn = Object.prototype.hasOwnProperty;
var pSlice = Array.prototype.slice;
var functionsHaveNames = (function () {
  return function foo() {}.name === 'foo';
}());
function pToString (obj) {
  return Object.prototype.toString.call(obj);
}
function isView(arrbuf) {
  if (isBuffer(arrbuf)) {
    return false;
  }
  if (typeof global.ArrayBuffer !== 'function') {
    return false;
  }
  if (typeof ArrayBuffer.isView === 'function') {
    return ArrayBuffer.isView(arrbuf);
  }
  if (!arrbuf) {
    return false;
  }
  if (arrbuf instanceof DataView) {
    return true;
  }
  if (arrbuf.buffer && arrbuf.buffer instanceof ArrayBuffer) {
    return true;
  }
  return false;
}
// 1. The assert module provides functions that throw
// AssertionError's when particular conditions are not met. The
// assert module must conform to the following interface.

var assert = module.exports = ok;

// 2. The AssertionError is defined in assert.
// new assert.AssertionError({ message: message,
//                             actual: actual,
//                             expected: expected })

var regex = /\s*function\s+([^\(\s]*)\s*/;
// based on https://github.com/ljharb/function.prototype.name/blob/adeeeec8bfcc6068b187d7d9fb3d5bb1d3a30899/implementation.js
function getName(func) {
  if (!util.isFunction(func)) {
    return;
  }
  if (functionsHaveNames) {
    return func.name;
  }
  var str = func.toString();
  var match = str.match(regex);
  return match && match[1];
}
assert.AssertionError = function AssertionError(options) {
  this.name = 'AssertionError';
  this.actual = options.actual;
  this.expected = options.expected;
  this.operator = options.operator;
  if (options.message) {
    this.message = options.message;
    this.generatedMessage = false;
  } else {
    this.message = getMessage(this);
    this.generatedMessage = true;
  }
  var stackStartFunction = options.stackStartFunction || fail;
  if (Error.captureStackTrace) {
    Error.captureStackTrace(this, stackStartFunction);
  } else {
    // non v8 browsers so we can have a stacktrace
    var err = new Error();
    if (err.stack) {
      var out = err.stack;

      // try to strip useless frames
      var fn_name = getName(stackStartFunction);
      var idx = out.indexOf('\n' + fn_name);
      if (idx >= 0) {
        // once we have located the function frame
        // we need to strip out everything before it (and its line)
        var next_line = out.indexOf('\n', idx + 1);
        out = out.substring(next_line + 1);
      }

      this.stack = out;
    }
  }
};

// assert.AssertionError instanceof Error
util.inherits(assert.AssertionError, Error);

function truncate(s, n) {
  if (typeof s === 'string') {
    return s.length < n ? s : s.slice(0, n);
  } else {
    return s;
  }
}
function inspect(something) {
  if (functionsHaveNames || !util.isFunction(something)) {
    return util.inspect(something);
  }
  var rawname = getName(something);
  var name = rawname ? ': ' + rawname : '';
  return '[Function' +  name + ']';
}
function getMessage(self) {
  return truncate(inspect(self.actual), 128) + ' ' +
         self.operator + ' ' +
         truncate(inspect(self.expected), 128);
}

// At present only the three keys mentioned above are used and
// understood by the spec. Implementations or sub modules can pass
// other keys to the AssertionError's constructor - they will be
// ignored.

// 3. All of the following functions must throw an AssertionError
// when a corresponding condition is not met, with a message that
// may be undefined if not provided.  All assertion methods provide
// both the actual and expected values to the assertion error for
// display purposes.

function fail(actual, expected, message, operator, stackStartFunction) {
  throw new assert.AssertionError({
    message: message,
    actual: actual,
    expected: expected,
    operator: operator,
    stackStartFunction: stackStartFunction
  });
}

// EXTENSION! allows for well behaved errors defined elsewhere.
assert.fail = fail;

// 4. Pure assertion tests whether a value is truthy, as determined
// by !!guard.
// assert.ok(guard, message_opt);
// This statement is equivalent to assert.equal(true, !!guard,
// message_opt);. To test strictly for the value true, use
// assert.strictEqual(true, guard, message_opt);.

function ok(value, message) {
  if (!value) fail(value, true, message, '==', assert.ok);
}
assert.ok = ok;

// 5. The equality assertion tests shallow, coercive equality with
// ==.
// assert.equal(actual, expected, message_opt);

assert.equal = function equal(actual, expected, message) {
  if (actual != expected) fail(actual, expected, message, '==', assert.equal);
};

// 6. The non-equality assertion tests for whether two objects are not equal
// with != assert.notEqual(actual, expected, message_opt);

assert.notEqual = function notEqual(actual, expected, message) {
  if (actual == expected) {
    fail(actual, expected, message, '!=', assert.notEqual);
  }
};

// 7. The equivalence assertion tests a deep equality relation.
// assert.deepEqual(actual, expected, message_opt);

assert.deepEqual = function deepEqual(actual, expected, message) {
  if (!_deepEqual(actual, expected, false)) {
    fail(actual, expected, message, 'deepEqual', assert.deepEqual);
  }
};

assert.deepStrictEqual = function deepStrictEqual(actual, expected, message) {
  if (!_deepEqual(actual, expected, true)) {
    fail(actual, expected, message, 'deepStrictEqual', assert.deepStrictEqual);
  }
};

function _deepEqual(actual, expected, strict, memos) {
  // 7.1. All identical values are equivalent, as determined by ===.
  if (actual === expected) {
    return true;
  } else if (isBuffer(actual) && isBuffer(expected)) {
    return compare(actual, expected) === 0;

  // 7.2. If the expected value is a Date object, the actual value is
  // equivalent if it is also a Date object that refers to the same time.
  } else if (util.isDate(actual) && util.isDate(expected)) {
    return actual.getTime() === expected.getTime();

  // 7.3 If the expected value is a RegExp object, the actual value is
  // equivalent if it is also a RegExp object with the same source and
  // properties (`global`, `multiline`, `lastIndex`, `ignoreCase`).
  } else if (util.isRegExp(actual) && util.isRegExp(expected)) {
    return actual.source === expected.source &&
           actual.global === expected.global &&
           actual.multiline === expected.multiline &&
           actual.lastIndex === expected.lastIndex &&
           actual.ignoreCase === expected.ignoreCase;

  // 7.4. Other pairs that do not both pass typeof value == 'object',
  // equivalence is determined by ==.
  } else if ((actual === null || typeof actual !== 'object') &&
             (expected === null || typeof expected !== 'object')) {
    return strict ? actual === expected : actual == expected;

  // If both values are instances of typed arrays, wrap their underlying
  // ArrayBuffers in a Buffer each to increase performance
  // This optimization requires the arrays to have the same type as checked by
  // Object.prototype.toString (aka pToString). Never perform binary
  // comparisons for Float*Arrays, though, since e.g. +0 === -0 but their
  // bit patterns are not identical.
  } else if (isView(actual) && isView(expected) &&
             pToString(actual) === pToString(expected) &&
             !(actual instanceof Float32Array ||
               actual instanceof Float64Array)) {
    return compare(new Uint8Array(actual.buffer),
                   new Uint8Array(expected.buffer)) === 0;

  // 7.5 For all other Object pairs, including Array objects, equivalence is
  // determined by having the same number of owned properties (as verified
  // with Object.prototype.hasOwnProperty.call), the same set of keys
  // (although not necessarily the same order), equivalent values for every
  // corresponding key, and an identical 'prototype' property. Note: this
  // accounts for both named and indexed properties on Arrays.
  } else if (isBuffer(actual) !== isBuffer(expected)) {
    return false;
  } else {
    memos = memos || {actual: [], expected: []};

    var actualIndex = memos.actual.indexOf(actual);
    if (actualIndex !== -1) {
      if (actualIndex === memos.expected.indexOf(expected)) {
        return true;
      }
    }

    memos.actual.push(actual);
    memos.expected.push(expected);

    return objEquiv(actual, expected, strict, memos);
  }
}

function isArguments(object) {
  return Object.prototype.toString.call(object) == '[object Arguments]';
}

function objEquiv(a, b, strict, actualVisitedObjects) {
  if (a === null || a === undefined || b === null || b === undefined)
    return false;
  // if one is a primitive, the other must be same
  if (util.isPrimitive(a) || util.isPrimitive(b))
    return a === b;
  if (strict && Object.getPrototypeOf(a) !== Object.getPrototypeOf(b))
    return false;
  var aIsArgs = isArguments(a);
  var bIsArgs = isArguments(b);
  if ((aIsArgs && !bIsArgs) || (!aIsArgs && bIsArgs))
    return false;
  if (aIsArgs) {
    a = pSlice.call(a);
    b = pSlice.call(b);
    return _deepEqual(a, b, strict);
  }
  var ka = objectKeys(a);
  var kb = objectKeys(b);
  var key, i;
  // having the same number of owned properties (keys incorporates
  // hasOwnProperty)
  if (ka.length !== kb.length)
    return false;
  //the same set of keys (although not necessarily the same order),
  ka.sort();
  kb.sort();
  //~~~cheap key test
  for (i = ka.length - 1; i >= 0; i--) {
    if (ka[i] !== kb[i])
      return false;
  }
  //equivalent values for every corresponding key, and
  //~~~possibly expensive deep test
  for (i = ka.length - 1; i >= 0; i--) {
    key = ka[i];
    if (!_deepEqual(a[key], b[key], strict, actualVisitedObjects))
      return false;
  }
  return true;
}

// 8. The non-equivalence assertion tests for any deep inequality.
// assert.notDeepEqual(actual, expected, message_opt);

assert.notDeepEqual = function notDeepEqual(actual, expected, message) {
  if (_deepEqual(actual, expected, false)) {
    fail(actual, expected, message, 'notDeepEqual', assert.notDeepEqual);
  }
};

assert.notDeepStrictEqual = notDeepStrictEqual;
function notDeepStrictEqual(actual, expected, message) {
  if (_deepEqual(actual, expected, true)) {
    fail(actual, expected, message, 'notDeepStrictEqual', notDeepStrictEqual);
  }
}


// 9. The strict equality assertion tests strict equality, as determined by ===.
// assert.strictEqual(actual, expected, message_opt);

assert.strictEqual = function strictEqual(actual, expected, message) {
  if (actual !== expected) {
    fail(actual, expected, message, '===', assert.strictEqual);
  }
};

// 10. The strict non-equality assertion tests for strict inequality, as
// determined by !==.  assert.notStrictEqual(actual, expected, message_opt);

assert.notStrictEqual = function notStrictEqual(actual, expected, message) {
  if (actual === expected) {
    fail(actual, expected, message, '!==', assert.notStrictEqual);
  }
};

function expectedException(actual, expected) {
  if (!actual || !expected) {
    return false;
  }

  if (Object.prototype.toString.call(expected) == '[object RegExp]') {
    return expected.test(actual);
  }

  try {
    if (actual instanceof expected) {
      return true;
    }
  } catch (e) {
    // Ignore.  The instanceof check doesn't work for arrow functions.
  }

  if (Error.isPrototypeOf(expected)) {
    return false;
  }

  return expected.call({}, actual) === true;
}

function _tryBlock(block) {
  var error;
  try {
    block();
  } catch (e) {
    error = e;
  }
  return error;
}

function _throws(shouldThrow, block, expected, message) {
  var actual;

  if (typeof block !== 'function') {
    throw new TypeError('"block" argument must be a function');
  }

  if (typeof expected === 'string') {
    message = expected;
    expected = null;
  }

  actual = _tryBlock(block);

  message = (expected && expected.name ? ' (' + expected.name + ').' : '.') +
            (message ? ' ' + message : '.');

  if (shouldThrow && !actual) {
    fail(actual, expected, 'Missing expected exception' + message);
  }

  var userProvidedMessage = typeof message === 'string';
  var isUnwantedException = !shouldThrow && util.isError(actual);
  var isUnexpectedException = !shouldThrow && actual && !expected;

  if ((isUnwantedException &&
      userProvidedMessage &&
      expectedException(actual, expected)) ||
      isUnexpectedException) {
    fail(actual, expected, 'Got unwanted exception' + message);
  }

  if ((shouldThrow && actual && expected &&
      !expectedException(actual, expected)) || (!shouldThrow && actual)) {
    throw actual;
  }
}

// 11. Expected to throw an error:
// assert.throws(block, Error_opt, message_opt);

assert.throws = function(block, /*optional*/error, /*optional*/message) {
  _throws(true, block, error, message);
};

// EXTENSION! This is annoying to write outside this module.
assert.doesNotThrow = function(block, /*optional*/error, /*optional*/message) {
  _throws(false, block, error, message);
};

assert.ifError = function(err) { if (err) throw err; };

var objectKeys = Object.keys || function (obj) {
  var keys = [];
  for (var key in obj) {
    if (hasOwn.call(obj, key)) keys.push(key);
  }
  return keys;
};

}).call(this)}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"util/":130}],128:[function(require,module,exports){
if (typeof Object.create === 'function') {
  // implementation from standard node.js 'util' module
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    ctor.prototype = Object.create(superCtor.prototype, {
      constructor: {
        value: ctor,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
  };
} else {
  // old school shim for old browsers
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    var TempCtor = function () {}
    TempCtor.prototype = superCtor.prototype
    ctor.prototype = new TempCtor()
    ctor.prototype.constructor = ctor
  }
}

},{}],129:[function(require,module,exports){
module.exports = function isBuffer(arg) {
  return arg && typeof arg === 'object'
    && typeof arg.copy === 'function'
    && typeof arg.fill === 'function'
    && typeof arg.readUInt8 === 'function';
}
},{}],130:[function(require,module,exports){
(function (process,global){(function (){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

var formatRegExp = /%[sdj%]/g;
exports.format = function(f) {
  if (!isString(f)) {
    var objects = [];
    for (var i = 0; i < arguments.length; i++) {
      objects.push(inspect(arguments[i]));
    }
    return objects.join(' ');
  }

  var i = 1;
  var args = arguments;
  var len = args.length;
  var str = String(f).replace(formatRegExp, function(x) {
    if (x === '%%') return '%';
    if (i >= len) return x;
    switch (x) {
      case '%s': return String(args[i++]);
      case '%d': return Number(args[i++]);
      case '%j':
        try {
          return JSON.stringify(args[i++]);
        } catch (_) {
          return '[Circular]';
        }
      default:
        return x;
    }
  });
  for (var x = args[i]; i < len; x = args[++i]) {
    if (isNull(x) || !isObject(x)) {
      str += ' ' + x;
    } else {
      str += ' ' + inspect(x);
    }
  }
  return str;
};


// Mark that a method should not be used.
// Returns a modified function which warns once by default.
// If --no-deprecation is set, then it is a no-op.
exports.deprecate = function(fn, msg) {
  // Allow for deprecating things in the process of starting up.
  if (isUndefined(global.process)) {
    return function() {
      return exports.deprecate(fn, msg).apply(this, arguments);
    };
  }

  if (process.noDeprecation === true) {
    return fn;
  }

  var warned = false;
  function deprecated() {
    if (!warned) {
      if (process.throwDeprecation) {
        throw new Error(msg);
      } else if (process.traceDeprecation) {
        console.trace(msg);
      } else {
        console.error(msg);
      }
      warned = true;
    }
    return fn.apply(this, arguments);
  }

  return deprecated;
};


var debugs = {};
var debugEnviron;
exports.debuglog = function(set) {
  if (isUndefined(debugEnviron))
    debugEnviron = process.env.NODE_DEBUG || '';
  set = set.toUpperCase();
  if (!debugs[set]) {
    if (new RegExp('\\b' + set + '\\b', 'i').test(debugEnviron)) {
      var pid = process.pid;
      debugs[set] = function() {
        var msg = exports.format.apply(exports, arguments);
        console.error('%s %d: %s', set, pid, msg);
      };
    } else {
      debugs[set] = function() {};
    }
  }
  return debugs[set];
};


/**
 * Echos the value of a value. Trys to print the value out
 * in the best way possible given the different types.
 *
 * @param {Object} obj The object to print out.
 * @param {Object} opts Optional options object that alters the output.
 */
/* legacy: obj, showHidden, depth, colors*/
function inspect(obj, opts) {
  // default options
  var ctx = {
    seen: [],
    stylize: stylizeNoColor
  };
  // legacy...
  if (arguments.length >= 3) ctx.depth = arguments[2];
  if (arguments.length >= 4) ctx.colors = arguments[3];
  if (isBoolean(opts)) {
    // legacy...
    ctx.showHidden = opts;
  } else if (opts) {
    // got an "options" object
    exports._extend(ctx, opts);
  }
  // set default options
  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;
  if (isUndefined(ctx.depth)) ctx.depth = 2;
  if (isUndefined(ctx.colors)) ctx.colors = false;
  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;
  if (ctx.colors) ctx.stylize = stylizeWithColor;
  return formatValue(ctx, obj, ctx.depth);
}
exports.inspect = inspect;


// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics
inspect.colors = {
  'bold' : [1, 22],
  'italic' : [3, 23],
  'underline' : [4, 24],
  'inverse' : [7, 27],
  'white' : [37, 39],
  'grey' : [90, 39],
  'black' : [30, 39],
  'blue' : [34, 39],
  'cyan' : [36, 39],
  'green' : [32, 39],
  'magenta' : [35, 39],
  'red' : [31, 39],
  'yellow' : [33, 39]
};

// Don't use 'blue' not visible on cmd.exe
inspect.styles = {
  'special': 'cyan',
  'number': 'yellow',
  'boolean': 'yellow',
  'undefined': 'grey',
  'null': 'bold',
  'string': 'green',
  'date': 'magenta',
  // "name": intentionally not styling
  'regexp': 'red'
};


function stylizeWithColor(str, styleType) {
  var style = inspect.styles[styleType];

  if (style) {
    return '\u001b[' + inspect.colors[style][0] + 'm' + str +
           '\u001b[' + inspect.colors[style][1] + 'm';
  } else {
    return str;
  }
}


function stylizeNoColor(str, styleType) {
  return str;
}


function arrayToHash(array) {
  var hash = {};

  array.forEach(function(val, idx) {
    hash[val] = true;
  });

  return hash;
}


function formatValue(ctx, value, recurseTimes) {
  // Provide a hook for user-specified inspect functions.
  // Check that value is an object with an inspect function on it
  if (ctx.customInspect &&
      value &&
      isFunction(value.inspect) &&
      // Filter out the util module, it's inspect function is special
      value.inspect !== exports.inspect &&
      // Also filter out any prototype objects using the circular check.
      !(value.constructor && value.constructor.prototype === value)) {
    var ret = value.inspect(recurseTimes, ctx);
    if (!isString(ret)) {
      ret = formatValue(ctx, ret, recurseTimes);
    }
    return ret;
  }

  // Primitive types cannot have properties
  var primitive = formatPrimitive(ctx, value);
  if (primitive) {
    return primitive;
  }

  // Look up the keys of the object.
  var keys = Object.keys(value);
  var visibleKeys = arrayToHash(keys);

  if (ctx.showHidden) {
    keys = Object.getOwnPropertyNames(value);
  }

  // IE doesn't make error fields non-enumerable
  // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx
  if (isError(value)
      && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {
    return formatError(value);
  }

  // Some type of object without properties can be shortcutted.
  if (keys.length === 0) {
    if (isFunction(value)) {
      var name = value.name ? ': ' + value.name : '';
      return ctx.stylize('[Function' + name + ']', 'special');
    }
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    }
    if (isDate(value)) {
      return ctx.stylize(Date.prototype.toString.call(value), 'date');
    }
    if (isError(value)) {
      return formatError(value);
    }
  }

  var base = '', array = false, braces = ['{', '}'];

  // Make Array say that they are Array
  if (isArray(value)) {
    array = true;
    braces = ['[', ']'];
  }

  // Make functions say that they are functions
  if (isFunction(value)) {
    var n = value.name ? ': ' + value.name : '';
    base = ' [Function' + n + ']';
  }

  // Make RegExps say that they are RegExps
  if (isRegExp(value)) {
    base = ' ' + RegExp.prototype.toString.call(value);
  }

  // Make dates with properties first say the date
  if (isDate(value)) {
    base = ' ' + Date.prototype.toUTCString.call(value);
  }

  // Make error with message first say the error
  if (isError(value)) {
    base = ' ' + formatError(value);
  }

  if (keys.length === 0 && (!array || value.length == 0)) {
    return braces[0] + base + braces[1];
  }

  if (recurseTimes < 0) {
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    } else {
      return ctx.stylize('[Object]', 'special');
    }
  }

  ctx.seen.push(value);

  var output;
  if (array) {
    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
  } else {
    output = keys.map(function(key) {
      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
    });
  }

  ctx.seen.pop();

  return reduceToSingleString(output, base, braces);
}


function formatPrimitive(ctx, value) {
  if (isUndefined(value))
    return ctx.stylize('undefined', 'undefined');
  if (isString(value)) {
    var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '')
                                             .replace(/'/g, "\\'")
                                             .replace(/\\"/g, '"') + '\'';
    return ctx.stylize(simple, 'string');
  }
  if (isNumber(value))
    return ctx.stylize('' + value, 'number');
  if (isBoolean(value))
    return ctx.stylize('' + value, 'boolean');
  // For some reason typeof null is "object", so special case here.
  if (isNull(value))
    return ctx.stylize('null', 'null');
}


function formatError(value) {
  return '[' + Error.prototype.toString.call(value) + ']';
}


function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
  var output = [];
  for (var i = 0, l = value.length; i < l; ++i) {
    if (hasOwnProperty(value, String(i))) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          String(i), true));
    } else {
      output.push('');
    }
  }
  keys.forEach(function(key) {
    if (!key.match(/^\d+$/)) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          key, true));
    }
  });
  return output;
}


function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
  var name, str, desc;
  desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };
  if (desc.get) {
    if (desc.set) {
      str = ctx.stylize('[Getter/Setter]', 'special');
    } else {
      str = ctx.stylize('[Getter]', 'special');
    }
  } else {
    if (desc.set) {
      str = ctx.stylize('[Setter]', 'special');
    }
  }
  if (!hasOwnProperty(visibleKeys, key)) {
    name = '[' + key + ']';
  }
  if (!str) {
    if (ctx.seen.indexOf(desc.value) < 0) {
      if (isNull(recurseTimes)) {
        str = formatValue(ctx, desc.value, null);
      } else {
        str = formatValue(ctx, desc.value, recurseTimes - 1);
      }
      if (str.indexOf('\n') > -1) {
        if (array) {
          str = str.split('\n').map(function(line) {
            return '  ' + line;
          }).join('\n').substr(2);
        } else {
          str = '\n' + str.split('\n').map(function(line) {
            return '   ' + line;
          }).join('\n');
        }
      }
    } else {
      str = ctx.stylize('[Circular]', 'special');
    }
  }
  if (isUndefined(name)) {
    if (array && key.match(/^\d+$/)) {
      return str;
    }
    name = JSON.stringify('' + key);
    if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
      name = name.substr(1, name.length - 2);
      name = ctx.stylize(name, 'name');
    } else {
      name = name.replace(/'/g, "\\'")
                 .replace(/\\"/g, '"')
                 .replace(/(^"|"$)/g, "'");
      name = ctx.stylize(name, 'string');
    }
  }

  return name + ': ' + str;
}


function reduceToSingleString(output, base, braces) {
  var numLinesEst = 0;
  var length = output.reduce(function(prev, cur) {
    numLinesEst++;
    if (cur.indexOf('\n') >= 0) numLinesEst++;
    return prev + cur.replace(/\u001b\[\d\d?m/g, '').length + 1;
  }, 0);

  if (length > 60) {
    return braces[0] +
           (base === '' ? '' : base + '\n ') +
           ' ' +
           output.join(',\n  ') +
           ' ' +
           braces[1];
  }

  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
}


// NOTE: These type checking functions intentionally don't use `instanceof`
// because it is fragile and can be easily faked with `Object.create()`.
function isArray(ar) {
  return Array.isArray(ar);
}
exports.isArray = isArray;

function isBoolean(arg) {
  return typeof arg === 'boolean';
}
exports.isBoolean = isBoolean;

function isNull(arg) {
  return arg === null;
}
exports.isNull = isNull;

function isNullOrUndefined(arg) {
  return arg == null;
}
exports.isNullOrUndefined = isNullOrUndefined;

function isNumber(arg) {
  return typeof arg === 'number';
}
exports.isNumber = isNumber;

function isString(arg) {
  return typeof arg === 'string';
}
exports.isString = isString;

function isSymbol(arg) {
  return typeof arg === 'symbol';
}
exports.isSymbol = isSymbol;

function isUndefined(arg) {
  return arg === void 0;
}
exports.isUndefined = isUndefined;

function isRegExp(re) {
  return isObject(re) && objectToString(re) === '[object RegExp]';
}
exports.isRegExp = isRegExp;

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}
exports.isObject = isObject;

function isDate(d) {
  return isObject(d) && objectToString(d) === '[object Date]';
}
exports.isDate = isDate;

function isError(e) {
  return isObject(e) &&
      (objectToString(e) === '[object Error]' || e instanceof Error);
}
exports.isError = isError;

function isFunction(arg) {
  return typeof arg === 'function';
}
exports.isFunction = isFunction;

function isPrimitive(arg) {
  return arg === null ||
         typeof arg === 'boolean' ||
         typeof arg === 'number' ||
         typeof arg === 'string' ||
         typeof arg === 'symbol' ||  // ES6 symbol
         typeof arg === 'undefined';
}
exports.isPrimitive = isPrimitive;

exports.isBuffer = require('./support/isBuffer');

function objectToString(o) {
  return Object.prototype.toString.call(o);
}


function pad(n) {
  return n < 10 ? '0' + n.toString(10) : n.toString(10);
}


var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',
              'Oct', 'Nov', 'Dec'];

// 26 Feb 16:19:34
function timestamp() {
  var d = new Date();
  var time = [pad(d.getHours()),
              pad(d.getMinutes()),
              pad(d.getSeconds())].join(':');
  return [d.getDate(), months[d.getMonth()], time].join(' ');
}


// log is just a thin wrapper to console.log that prepends a timestamp
exports.log = function() {
  console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));
};


/**
 * Inherit the prototype methods from one constructor into another.
 *
 * The Function.prototype.inherits from lang.js rewritten as a standalone
 * function (not on Function.prototype). NOTE: If this file is to be loaded
 * during bootstrapping this function needs to be rewritten using some native
 * functions as prototype setup using normal JavaScript does not work as
 * expected during bootstrapping (see mirror.js in r114903).
 *
 * @param {function} ctor Constructor function which needs to inherit the
 *     prototype.
 * @param {function} superCtor Constructor function to inherit prototype from.
 */
exports.inherits = require('inherits');

exports._extend = function(origin, add) {
  // Don't do anything if add isn't an object
  if (!add || !isObject(add)) return origin;

  var keys = Object.keys(add);
  var i = keys.length;
  while (i--) {
    origin[keys[i]] = add[keys[i]];
  }
  return origin;
};

function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

}).call(this)}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./support/isBuffer":129,"_process":223,"inherits":128}],131:[function(require,module,exports){
(function (global){(function (){
'use strict';

var filter = require('array-filter');

module.exports = function availableTypedArrays() {
	return filter([
		'BigInt64Array',
		'BigUint64Array',
		'Float32Array',
		'Float64Array',
		'Int16Array',
		'Int32Array',
		'Int8Array',
		'Uint16Array',
		'Uint32Array',
		'Uint8Array',
		'Uint8ClampedArray'
	], function (typedArray) {
		return typeof global[typedArray] === 'function';
	});
};

}).call(this)}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"array-filter":126}],132:[function(require,module,exports){
'use strict'

exports.byteLength = byteLength
exports.toByteArray = toByteArray
exports.fromByteArray = fromByteArray

var lookup = []
var revLookup = []
var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array

var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
for (var i = 0, len = code.length; i < len; ++i) {
  lookup[i] = code[i]
  revLookup[code.charCodeAt(i)] = i
}

// Support decoding URL-safe base64 strings, as Node.js does.
// See: https://en.wikipedia.org/wiki/Base64#URL_applications
revLookup['-'.charCodeAt(0)] = 62
revLookup['_'.charCodeAt(0)] = 63

function getLens (b64) {
  var len = b64.length

  if (len % 4 > 0) {
    throw new Error('Invalid string. Length must be a multiple of 4')
  }

  // Trim off extra bytes after placeholder bytes are found
  // See: https://github.com/beatgammit/base64-js/issues/42
  var validLen = b64.indexOf('=')
  if (validLen === -1) validLen = len

  var placeHoldersLen = validLen === len
    ? 0
    : 4 - (validLen % 4)

  return [validLen, placeHoldersLen]
}

// base64 is 4/3 + up to two characters of the original data
function byteLength (b64) {
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function _byteLength (b64, validLen, placeHoldersLen) {
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function toByteArray (b64) {
  var tmp
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]

  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))

  var curByte = 0

  // if there are placeholders, only get up to the last complete 4 chars
  var len = placeHoldersLen > 0
    ? validLen - 4
    : validLen

  for (var i = 0; i < len; i += 4) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 18) |
      (revLookup[b64.charCodeAt(i + 1)] << 12) |
      (revLookup[b64.charCodeAt(i + 2)] << 6) |
      revLookup[b64.charCodeAt(i + 3)]
    arr[curByte++] = (tmp >> 16) & 0xFF
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 2) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 2) |
      (revLookup[b64.charCodeAt(i + 1)] >> 4)
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 1) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 10) |
      (revLookup[b64.charCodeAt(i + 1)] << 4) |
      (revLookup[b64.charCodeAt(i + 2)] >> 2)
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  return arr
}

function tripletToBase64 (num) {
  return lookup[num >> 18 & 0x3F] +
    lookup[num >> 12 & 0x3F] +
    lookup[num >> 6 & 0x3F] +
    lookup[num & 0x3F]
}

function encodeChunk (uint8, start, end) {
  var tmp
  var output = []
  for (var i = start; i < end; i += 3) {
    tmp =
      ((uint8[i] << 16) & 0xFF0000) +
      ((uint8[i + 1] << 8) & 0xFF00) +
      (uint8[i + 2] & 0xFF)
    output.push(tripletToBase64(tmp))
  }
  return output.join('')
}

function fromByteArray (uint8) {
  var tmp
  var len = uint8.length
  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes
  var parts = []
  var maxChunkLength = 16383 // must be multiple of 3

  // go through the array every three bytes, we'll deal with trailing stuff later
  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push(encodeChunk(
      uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)
    ))
  }

  // pad the end with zeros, but make sure to not forget the extra bytes
  if (extraBytes === 1) {
    tmp = uint8[len - 1]
    parts.push(
      lookup[tmp >> 2] +
      lookup[(tmp << 4) & 0x3F] +
      '=='
    )
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + uint8[len - 1]
    parts.push(
      lookup[tmp >> 10] +
      lookup[(tmp >> 4) & 0x3F] +
      lookup[(tmp << 2) & 0x3F] +
      '='
    )
  }

  return parts.join('')
}

},{}],133:[function(require,module,exports){

},{}],134:[function(require,module,exports){
(function (process,Buffer){(function (){
'use strict';
/* eslint camelcase: "off" */

var assert = require('assert');

var Zstream = require('pako/lib/zlib/zstream');
var zlib_deflate = require('pako/lib/zlib/deflate.js');
var zlib_inflate = require('pako/lib/zlib/inflate.js');
var constants = require('pako/lib/zlib/constants');

for (var key in constants) {
  exports[key] = constants[key];
}

// zlib modes
exports.NONE = 0;
exports.DEFLATE = 1;
exports.INFLATE = 2;
exports.GZIP = 3;
exports.GUNZIP = 4;
exports.DEFLATERAW = 5;
exports.INFLATERAW = 6;
exports.UNZIP = 7;

var GZIP_HEADER_ID1 = 0x1f;
var GZIP_HEADER_ID2 = 0x8b;

/**
 * Emulate Node's zlib C++ layer for use by the JS layer in index.js
 */
function Zlib(mode) {
  if (typeof mode !== 'number' || mode < exports.DEFLATE || mode > exports.UNZIP) {
    throw new TypeError('Bad argument');
  }

  this.dictionary = null;
  this.err = 0;
  this.flush = 0;
  this.init_done = false;
  this.level = 0;
  this.memLevel = 0;
  this.mode = mode;
  this.strategy = 0;
  this.windowBits = 0;
  this.write_in_progress = false;
  this.pending_close = false;
  this.gzip_id_bytes_read = 0;
}

Zlib.prototype.close = function () {
  if (this.write_in_progress) {
    this.pending_close = true;
    return;
  }

  this.pending_close = false;

  assert(this.init_done, 'close before init');
  assert(this.mode <= exports.UNZIP);

  if (this.mode === exports.DEFLATE || this.mode === exports.GZIP || this.mode === exports.DEFLATERAW) {
    zlib_deflate.deflateEnd(this.strm);
  } else if (this.mode === exports.INFLATE || this.mode === exports.GUNZIP || this.mode === exports.INFLATERAW || this.mode === exports.UNZIP) {
    zlib_inflate.inflateEnd(this.strm);
  }

  this.mode = exports.NONE;

  this.dictionary = null;
};

Zlib.prototype.write = function (flush, input, in_off, in_len, out, out_off, out_len) {
  return this._write(true, flush, input, in_off, in_len, out, out_off, out_len);
};

Zlib.prototype.writeSync = function (flush, input, in_off, in_len, out, out_off, out_len) {
  return this._write(false, flush, input, in_off, in_len, out, out_off, out_len);
};

Zlib.prototype._write = function (async, flush, input, in_off, in_len, out, out_off, out_len) {
  assert.equal(arguments.length, 8);

  assert(this.init_done, 'write before init');
  assert(this.mode !== exports.NONE, 'already finalized');
  assert.equal(false, this.write_in_progress, 'write already in progress');
  assert.equal(false, this.pending_close, 'close is pending');

  this.write_in_progress = true;

  assert.equal(false, flush === undefined, 'must provide flush value');

  this.write_in_progress = true;

  if (flush !== exports.Z_NO_FLUSH && flush !== exports.Z_PARTIAL_FLUSH && flush !== exports.Z_SYNC_FLUSH && flush !== exports.Z_FULL_FLUSH && flush !== exports.Z_FINISH && flush !== exports.Z_BLOCK) {
    throw new Error('Invalid flush value');
  }

  if (input == null) {
    input = Buffer.alloc(0);
    in_len = 0;
    in_off = 0;
  }

  this.strm.avail_in = in_len;
  this.strm.input = input;
  this.strm.next_in = in_off;
  this.strm.avail_out = out_len;
  this.strm.output = out;
  this.strm.next_out = out_off;
  this.flush = flush;

  if (!async) {
    // sync version
    this._process();

    if (this._checkError()) {
      return this._afterSync();
    }
    return;
  }

  // async version
  var self = this;
  process.nextTick(function () {
    self._process();
    self._after();
  });

  return this;
};

Zlib.prototype._afterSync = function () {
  var avail_out = this.strm.avail_out;
  var avail_in = this.strm.avail_in;

  this.write_in_progress = false;

  return [avail_in, avail_out];
};

Zlib.prototype._process = function () {
  var next_expected_header_byte = null;

  // If the avail_out is left at 0, then it means that it ran out
  // of room.  If there was avail_out left over, then it means
  // that all of the input was consumed.
  switch (this.mode) {
    case exports.DEFLATE:
    case exports.GZIP:
    case exports.DEFLATERAW:
      this.err = zlib_deflate.deflate(this.strm, this.flush);
      break;
    case exports.UNZIP:
      if (this.strm.avail_in > 0) {
        next_expected_header_byte = this.strm.next_in;
      }

      switch (this.gzip_id_bytes_read) {
        case 0:
          if (next_expected_header_byte === null) {
            break;
          }

          if (this.strm.input[next_expected_header_byte] === GZIP_HEADER_ID1) {
            this.gzip_id_bytes_read = 1;
            next_expected_header_byte++;

            if (this.strm.avail_in === 1) {
              // The only available byte was already read.
              break;
            }
          } else {
            this.mode = exports.INFLATE;
            break;
          }

        // fallthrough
        case 1:
          if (next_expected_header_byte === null) {
            break;
          }

          if (this.strm.input[next_expected_header_byte] === GZIP_HEADER_ID2) {
            this.gzip_id_bytes_read = 2;
            this.mode = exports.GUNZIP;
          } else {
            // There is no actual difference between INFLATE and INFLATERAW
            // (after initialization).
            this.mode = exports.INFLATE;
          }

          break;
        default:
          throw new Error('invalid number of gzip magic number bytes read');
      }

    // fallthrough
    case exports.INFLATE:
    case exports.GUNZIP:
    case exports.INFLATERAW:
      this.err = zlib_inflate.inflate(this.strm, this.flush

      // If data was encoded with dictionary
      );if (this.err === exports.Z_NEED_DICT && this.dictionary) {
        // Load it
        this.err = zlib_inflate.inflateSetDictionary(this.strm, this.dictionary);
        if (this.err === exports.Z_OK) {
          // And try to decode again
          this.err = zlib_inflate.inflate(this.strm, this.flush);
        } else if (this.err === exports.Z_DATA_ERROR) {
          // Both inflateSetDictionary() and inflate() return Z_DATA_ERROR.
          // Make it possible for After() to tell a bad dictionary from bad
          // input.
          this.err = exports.Z_NEED_DICT;
        }
      }
      while (this.strm.avail_in > 0 && this.mode === exports.GUNZIP && this.err === exports.Z_STREAM_END && this.strm.next_in[0] !== 0x00) {
        // Bytes remain in input buffer. Perhaps this is another compressed
        // member in the same archive, or just trailing garbage.
        // Trailing zero bytes are okay, though, since they are frequently
        // used for padding.

        this.reset();
        this.err = zlib_inflate.inflate(this.strm, this.flush);
      }
      break;
    default:
      throw new Error('Unknown mode ' + this.mode);
  }
};

Zlib.prototype._checkError = function () {
  // Acceptable error states depend on the type of zlib stream.
  switch (this.err) {
    case exports.Z_OK:
    case exports.Z_BUF_ERROR:
      if (this.strm.avail_out !== 0 && this.flush === exports.Z_FINISH) {
        this._error('unexpected end of file');
        return false;
      }
      break;
    case exports.Z_STREAM_END:
      // normal statuses, not fatal
      break;
    case exports.Z_NEED_DICT:
      if (this.dictionary == null) {
        this._error('Missing dictionary');
      } else {
        this._error('Bad dictionary');
      }
      return false;
    default:
      // something else.
      this._error('Zlib error');
      return false;
  }

  return true;
};

Zlib.prototype._after = function () {
  if (!this._checkError()) {
    return;
  }

  var avail_out = this.strm.avail_out;
  var avail_in = this.strm.avail_in;

  this.write_in_progress = false;

  // call the write() cb
  this.callback(avail_in, avail_out);

  if (this.pending_close) {
    this.close();
  }
};

Zlib.prototype._error = function (message) {
  if (this.strm.msg) {
    message = this.strm.msg;
  }
  this.onerror(message, this.err

  // no hope of rescue.
  );this.write_in_progress = false;
  if (this.pending_close) {
    this.close();
  }
};

Zlib.prototype.init = function (windowBits, level, memLevel, strategy, dictionary) {
  assert(arguments.length === 4 || arguments.length === 5, 'init(windowBits, level, memLevel, strategy, [dictionary])');

  assert(windowBits >= 8 && windowBits <= 15, 'invalid windowBits');
  assert(level >= -1 && level <= 9, 'invalid compression level');

  assert(memLevel >= 1 && memLevel <= 9, 'invalid memlevel');

  assert(strategy === exports.Z_FILTERED || strategy === exports.Z_HUFFMAN_ONLY || strategy === exports.Z_RLE || strategy === exports.Z_FIXED || strategy === exports.Z_DEFAULT_STRATEGY, 'invalid strategy');

  this._init(level, windowBits, memLevel, strategy, dictionary);
  this._setDictionary();
};

Zlib.prototype.params = function () {
  throw new Error('deflateParams Not supported');
};

Zlib.prototype.reset = function () {
  this._reset();
  this._setDictionary();
};

Zlib.prototype._init = function (level, windowBits, memLevel, strategy, dictionary) {
  this.level = level;
  this.windowBits = windowBits;
  this.memLevel = memLevel;
  this.strategy = strategy;

  this.flush = exports.Z_NO_FLUSH;

  this.err = exports.Z_OK;

  if (this.mode === exports.GZIP || this.mode === exports.GUNZIP) {
    this.windowBits += 16;
  }

  if (this.mode === exports.UNZIP) {
    this.windowBits += 32;
  }

  if (this.mode === exports.DEFLATERAW || this.mode === exports.INFLATERAW) {
    this.windowBits = -1 * this.windowBits;
  }

  this.strm = new Zstream();

  switch (this.mode) {
    case exports.DEFLATE:
    case exports.GZIP:
    case exports.DEFLATERAW:
      this.err = zlib_deflate.deflateInit2(this.strm, this.level, exports.Z_DEFLATED, this.windowBits, this.memLevel, this.strategy);
      break;
    case exports.INFLATE:
    case exports.GUNZIP:
    case exports.INFLATERAW:
    case exports.UNZIP:
      this.err = zlib_inflate.inflateInit2(this.strm, this.windowBits);
      break;
    default:
      throw new Error('Unknown mode ' + this.mode);
  }

  if (this.err !== exports.Z_OK) {
    this._error('Init error');
  }

  this.dictionary = dictionary;

  this.write_in_progress = false;
  this.init_done = true;
};

Zlib.prototype._setDictionary = function () {
  if (this.dictionary == null) {
    return;
  }

  this.err = exports.Z_OK;

  switch (this.mode) {
    case exports.DEFLATE:
    case exports.DEFLATERAW:
      this.err = zlib_deflate.deflateSetDictionary(this.strm, this.dictionary);
      break;
    default:
      break;
  }

  if (this.err !== exports.Z_OK) {
    this._error('Failed to set dictionary');
  }
};

Zlib.prototype._reset = function () {
  this.err = exports.Z_OK;

  switch (this.mode) {
    case exports.DEFLATE:
    case exports.DEFLATERAW:
    case exports.GZIP:
      this.err = zlib_deflate.deflateReset(this.strm);
      break;
    case exports.INFLATE:
    case exports.INFLATERAW:
    case exports.GUNZIP:
      this.err = zlib_inflate.inflateReset(this.strm);
      break;
    default:
      break;
  }

  if (this.err !== exports.Z_OK) {
    this._error('Failed to reset stream');
  }
};

exports.Zlib = Zlib;
}).call(this)}).call(this,require('_process'),require("buffer").Buffer)
},{"_process":223,"assert":127,"buffer":145,"pako/lib/zlib/constants":138,"pako/lib/zlib/deflate.js":140,"pako/lib/zlib/inflate.js":144,"pako/lib/zlib/zstream":143}],135:[function(require,module,exports){
(function (process){(function (){
'use strict';

var Buffer = require('buffer').Buffer;
var Transform = require('stream').Transform;
var binding = require('./binding');
var util = require('util');
var assert = require('assert').ok;
var kMaxLength = require('buffer').kMaxLength;
var kRangeErrorMessage = 'Cannot create final Buffer. It would be larger ' + 'than 0x' + kMaxLength.toString(16) + ' bytes';

// zlib doesn't provide these, so kludge them in following the same
// const naming scheme zlib uses.
binding.Z_MIN_WINDOWBITS = 8;
binding.Z_MAX_WINDOWBITS = 15;
binding.Z_DEFAULT_WINDOWBITS = 15;

// fewer than 64 bytes per chunk is stupid.
// technically it could work with as few as 8, but even 64 bytes
// is absurdly low.  Usually a MB or more is best.
binding.Z_MIN_CHUNK = 64;
binding.Z_MAX_CHUNK = Infinity;
binding.Z_DEFAULT_CHUNK = 16 * 1024;

binding.Z_MIN_MEMLEVEL = 1;
binding.Z_MAX_MEMLEVEL = 9;
binding.Z_DEFAULT_MEMLEVEL = 8;

binding.Z_MIN_LEVEL = -1;
binding.Z_MAX_LEVEL = 9;
binding.Z_DEFAULT_LEVEL = binding.Z_DEFAULT_COMPRESSION;

// expose all the zlib constants
var bkeys = Object.keys(binding);
for (var bk = 0; bk < bkeys.length; bk++) {
  var bkey = bkeys[bk];
  if (bkey.match(/^Z/)) {
    Object.defineProperty(exports, bkey, {
      enumerable: true, value: binding[bkey], writable: false
    });
  }
}

// translation table for return codes.
var codes = {
  Z_OK: binding.Z_OK,
  Z_STREAM_END: binding.Z_STREAM_END,
  Z_NEED_DICT: binding.Z_NEED_DICT,
  Z_ERRNO: binding.Z_ERRNO,
  Z_STREAM_ERROR: binding.Z_STREAM_ERROR,
  Z_DATA_ERROR: binding.Z_DATA_ERROR,
  Z_MEM_ERROR: binding.Z_MEM_ERROR,
  Z_BUF_ERROR: binding.Z_BUF_ERROR,
  Z_VERSION_ERROR: binding.Z_VERSION_ERROR
};

var ckeys = Object.keys(codes);
for (var ck = 0; ck < ckeys.length; ck++) {
  var ckey = ckeys[ck];
  codes[codes[ckey]] = ckey;
}

Object.defineProperty(exports, 'codes', {
  enumerable: true, value: Object.freeze(codes), writable: false
});

exports.Deflate = Deflate;
exports.Inflate = Inflate;
exports.Gzip = Gzip;
exports.Gunzip = Gunzip;
exports.DeflateRaw = DeflateRaw;
exports.InflateRaw = InflateRaw;
exports.Unzip = Unzip;

exports.createDeflate = function (o) {
  return new Deflate(o);
};

exports.createInflate = function (o) {
  return new Inflate(o);
};

exports.createDeflateRaw = function (o) {
  return new DeflateRaw(o);
};

exports.createInflateRaw = function (o) {
  return new InflateRaw(o);
};

exports.createGzip = function (o) {
  return new Gzip(o);
};

exports.createGunzip = function (o) {
  return new Gunzip(o);
};

exports.createUnzip = function (o) {
  return new Unzip(o);
};

// Convenience methods.
// compress/decompress a string or buffer in one step.
exports.deflate = function (buffer, opts, callback) {
  if (typeof opts === 'function') {
    callback = opts;
    opts = {};
  }
  return zlibBuffer(new Deflate(opts), buffer, callback);
};

exports.deflateSync = function (buffer, opts) {
  return zlibBufferSync(new Deflate(opts), buffer);
};

exports.gzip = function (buffer, opts, callback) {
  if (typeof opts === 'function') {
    callback = opts;
    opts = {};
  }
  return zlibBuffer(new Gzip(opts), buffer, callback);
};

exports.gzipSync = function (buffer, opts) {
  return zlibBufferSync(new Gzip(opts), buffer);
};

exports.deflateRaw = function (buffer, opts, callback) {
  if (typeof opts === 'function') {
    callback = opts;
    opts = {};
  }
  return zlibBuffer(new DeflateRaw(opts), buffer, callback);
};

exports.deflateRawSync = function (buffer, opts) {
  return zlibBufferSync(new DeflateRaw(opts), buffer);
};

exports.unzip = function (buffer, opts, callback) {
  if (typeof opts === 'function') {
    callback = opts;
    opts = {};
  }
  return zlibBuffer(new Unzip(opts), buffer, callback);
};

exports.unzipSync = function (buffer, opts) {
  return zlibBufferSync(new Unzip(opts), buffer);
};

exports.inflate = function (buffer, opts, callback) {
  if (typeof opts === 'function') {
    callback = opts;
    opts = {};
  }
  return zlibBuffer(new Inflate(opts), buffer, callback);
};

exports.inflateSync = function (buffer, opts) {
  return zlibBufferSync(new Inflate(opts), buffer);
};

exports.gunzip = function (buffer, opts, callback) {
  if (typeof opts === 'function') {
    callback = opts;
    opts = {};
  }
  return zlibBuffer(new Gunzip(opts), buffer, callback);
};

exports.gunzipSync = function (buffer, opts) {
  return zlibBufferSync(new Gunzip(opts), buffer);
};

exports.inflateRaw = function (buffer, opts, callback) {
  if (typeof opts === 'function') {
    callback = opts;
    opts = {};
  }
  return zlibBuffer(new InflateRaw(opts), buffer, callback);
};

exports.inflateRawSync = function (buffer, opts) {
  return zlibBufferSync(new InflateRaw(opts), buffer);
};

function zlibBuffer(engine, buffer, callback) {
  var buffers = [];
  var nread = 0;

  engine.on('error', onError);
  engine.on('end', onEnd);

  engine.end(buffer);
  flow();

  function flow() {
    var chunk;
    while (null !== (chunk = engine.read())) {
      buffers.push(chunk);
      nread += chunk.length;
    }
    engine.once('readable', flow);
  }

  function onError(err) {
    engine.removeListener('end', onEnd);
    engine.removeListener('readable', flow);
    callback(err);
  }

  function onEnd() {
    var buf;
    var err = null;

    if (nread >= kMaxLength) {
      err = new RangeError(kRangeErrorMessage);
    } else {
      buf = Buffer.concat(buffers, nread);
    }

    buffers = [];
    engine.close();
    callback(err, buf);
  }
}

function zlibBufferSync(engine, buffer) {
  if (typeof buffer === 'string') buffer = Buffer.from(buffer);

  if (!Buffer.isBuffer(buffer)) throw new TypeError('Not a string or buffer');

  var flushFlag = engine._finishFlushFlag;

  return engine._processChunk(buffer, flushFlag);
}

// generic zlib
// minimal 2-byte header
function Deflate(opts) {
  if (!(this instanceof Deflate)) return new Deflate(opts);
  Zlib.call(this, opts, binding.DEFLATE);
}

function Inflate(opts) {
  if (!(this instanceof Inflate)) return new Inflate(opts);
  Zlib.call(this, opts, binding.INFLATE);
}

// gzip - bigger header, same deflate compression
function Gzip(opts) {
  if (!(this instanceof Gzip)) return new Gzip(opts);
  Zlib.call(this, opts, binding.GZIP);
}

function Gunzip(opts) {
  if (!(this instanceof Gunzip)) return new Gunzip(opts);
  Zlib.call(this, opts, binding.GUNZIP);
}

// raw - no header
function DeflateRaw(opts) {
  if (!(this instanceof DeflateRaw)) return new DeflateRaw(opts);
  Zlib.call(this, opts, binding.DEFLATERAW);
}

function InflateRaw(opts) {
  if (!(this instanceof InflateRaw)) return new InflateRaw(opts);
  Zlib.call(this, opts, binding.INFLATERAW);
}

// auto-detect header.
function Unzip(opts) {
  if (!(this instanceof Unzip)) return new Unzip(opts);
  Zlib.call(this, opts, binding.UNZIP);
}

function isValidFlushFlag(flag) {
  return flag === binding.Z_NO_FLUSH || flag === binding.Z_PARTIAL_FLUSH || flag === binding.Z_SYNC_FLUSH || flag === binding.Z_FULL_FLUSH || flag === binding.Z_FINISH || flag === binding.Z_BLOCK;
}

// the Zlib class they all inherit from
// This thing manages the queue of requests, and returns
// true or false if there is anything in the queue when
// you call the .write() method.

function Zlib(opts, mode) {
  var _this = this;

  this._opts = opts = opts || {};
  this._chunkSize = opts.chunkSize || exports.Z_DEFAULT_CHUNK;

  Transform.call(this, opts);

  if (opts.flush && !isValidFlushFlag(opts.flush)) {
    throw new Error('Invalid flush flag: ' + opts.flush);
  }
  if (opts.finishFlush && !isValidFlushFlag(opts.finishFlush)) {
    throw new Error('Invalid flush flag: ' + opts.finishFlush);
  }

  this._flushFlag = opts.flush || binding.Z_NO_FLUSH;
  this._finishFlushFlag = typeof opts.finishFlush !== 'undefined' ? opts.finishFlush : binding.Z_FINISH;

  if (opts.chunkSize) {
    if (opts.chunkSize < exports.Z_MIN_CHUNK || opts.chunkSize > exports.Z_MAX_CHUNK) {
      throw new Error('Invalid chunk size: ' + opts.chunkSize);
    }
  }

  if (opts.windowBits) {
    if (opts.windowBits < exports.Z_MIN_WINDOWBITS || opts.windowBits > exports.Z_MAX_WINDOWBITS) {
      throw new Error('Invalid windowBits: ' + opts.windowBits);
    }
  }

  if (opts.level) {
    if (opts.level < exports.Z_MIN_LEVEL || opts.level > exports.Z_MAX_LEVEL) {
      throw new Error('Invalid compression level: ' + opts.level);
    }
  }

  if (opts.memLevel) {
    if (opts.memLevel < exports.Z_MIN_MEMLEVEL || opts.memLevel > exports.Z_MAX_MEMLEVEL) {
      throw new Error('Invalid memLevel: ' + opts.memLevel);
    }
  }

  if (opts.strategy) {
    if (opts.strategy != exports.Z_FILTERED && opts.strategy != exports.Z_HUFFMAN_ONLY && opts.strategy != exports.Z_RLE && opts.strategy != exports.Z_FIXED && opts.strategy != exports.Z_DEFAULT_STRATEGY) {
      throw new Error('Invalid strategy: ' + opts.strategy);
    }
  }

  if (opts.dictionary) {
    if (!Buffer.isBuffer(opts.dictionary)) {
      throw new Error('Invalid dictionary: it should be a Buffer instance');
    }
  }

  this._handle = new binding.Zlib(mode);

  var self = this;
  this._hadError = false;
  this._handle.onerror = function (message, errno) {
    // there is no way to cleanly recover.
    // continuing only obscures problems.
    _close(self);
    self._hadError = true;

    var error = new Error(message);
    error.errno = errno;
    error.code = exports.codes[errno];
    self.emit('error', error);
  };

  var level = exports.Z_DEFAULT_COMPRESSION;
  if (typeof opts.level === 'number') level = opts.level;

  var strategy = exports.Z_DEFAULT_STRATEGY;
  if (typeof opts.strategy === 'number') strategy = opts.strategy;

  this._handle.init(opts.windowBits || exports.Z_DEFAULT_WINDOWBITS, level, opts.memLevel || exports.Z_DEFAULT_MEMLEVEL, strategy, opts.dictionary);

  this._buffer = Buffer.allocUnsafe(this._chunkSize);
  this._offset = 0;
  this._level = level;
  this._strategy = strategy;

  this.once('end', this.close);

  Object.defineProperty(this, '_closed', {
    get: function () {
      return !_this._handle;
    },
    configurable: true,
    enumerable: true
  });
}

util.inherits(Zlib, Transform);

Zlib.prototype.params = function (level, strategy, callback) {
  if (level < exports.Z_MIN_LEVEL || level > exports.Z_MAX_LEVEL) {
    throw new RangeError('Invalid compression level: ' + level);
  }
  if (strategy != exports.Z_FILTERED && strategy != exports.Z_HUFFMAN_ONLY && strategy != exports.Z_RLE && strategy != exports.Z_FIXED && strategy != exports.Z_DEFAULT_STRATEGY) {
    throw new TypeError('Invalid strategy: ' + strategy);
  }

  if (this._level !== level || this._strategy !== strategy) {
    var self = this;
    this.flush(binding.Z_SYNC_FLUSH, function () {
      assert(self._handle, 'zlib binding closed');
      self._handle.params(level, strategy);
      if (!self._hadError) {
        self._level = level;
        self._strategy = strategy;
        if (callback) callback();
      }
    });
  } else {
    process.nextTick(callback);
  }
};

Zlib.prototype.reset = function () {
  assert(this._handle, 'zlib binding closed');
  return this._handle.reset();
};

// This is the _flush function called by the transform class,
// internally, when the last chunk has been written.
Zlib.prototype._flush = function (callback) {
  this._transform(Buffer.alloc(0), '', callback);
};

Zlib.prototype.flush = function (kind, callback) {
  var _this2 = this;

  var ws = this._writableState;

  if (typeof kind === 'function' || kind === undefined && !callback) {
    callback = kind;
    kind = binding.Z_FULL_FLUSH;
  }

  if (ws.ended) {
    if (callback) process.nextTick(callback);
  } else if (ws.ending) {
    if (callback) this.once('end', callback);
  } else if (ws.needDrain) {
    if (callback) {
      this.once('drain', function () {
        return _this2.flush(kind, callback);
      });
    }
  } else {
    this._flushFlag = kind;
    this.write(Buffer.alloc(0), '', callback);
  }
};

Zlib.prototype.close = function (callback) {
  _close(this, callback);
  process.nextTick(emitCloseNT, this);
};

function _close(engine, callback) {
  if (callback) process.nextTick(callback);

  // Caller may invoke .close after a zlib error (which will null _handle).
  if (!engine._handle) return;

  engine._handle.close();
  engine._handle = null;
}

function emitCloseNT(self) {
  self.emit('close');
}

Zlib.prototype._transform = function (chunk, encoding, cb) {
  var flushFlag;
  var ws = this._writableState;
  var ending = ws.ending || ws.ended;
  var last = ending && (!chunk || ws.length === chunk.length);

  if (chunk !== null && !Buffer.isBuffer(chunk)) return cb(new Error('invalid input'));

  if (!this._handle) return cb(new Error('zlib binding closed'));

  // If it's the last chunk, or a final flush, we use the Z_FINISH flush flag
  // (or whatever flag was provided using opts.finishFlush).
  // If it's explicitly flushing at some other time, then we use
  // Z_FULL_FLUSH. Otherwise, use Z_NO_FLUSH for maximum compression
  // goodness.
  if (last) flushFlag = this._finishFlushFlag;else {
    flushFlag = this._flushFlag;
    // once we've flushed the last of the queue, stop flushing and
    // go back to the normal behavior.
    if (chunk.length >= ws.length) {
      this._flushFlag = this._opts.flush || binding.Z_NO_FLUSH;
    }
  }

  this._processChunk(chunk, flushFlag, cb);
};

Zlib.prototype._processChunk = function (chunk, flushFlag, cb) {
  var availInBefore = chunk && chunk.length;
  var availOutBefore = this._chunkSize - this._offset;
  var inOff = 0;

  var self = this;

  var async = typeof cb === 'function';

  if (!async) {
    var buffers = [];
    var nread = 0;

    var error;
    this.on('error', function (er) {
      error = er;
    });

    assert(this._handle, 'zlib binding closed');
    do {
      var res = this._handle.writeSync(flushFlag, chunk, // in
      inOff, // in_off
      availInBefore, // in_len
      this._buffer, // out
      this._offset, //out_off
      availOutBefore); // out_len
    } while (!this._hadError && callback(res[0], res[1]));

    if (this._hadError) {
      throw error;
    }

    if (nread >= kMaxLength) {
      _close(this);
      throw new RangeError(kRangeErrorMessage);
    }

    var buf = Buffer.concat(buffers, nread);
    _close(this);

    return buf;
  }

  assert(this._handle, 'zlib binding closed');
  var req = this._handle.write(flushFlag, chunk, // in
  inOff, // in_off
  availInBefore, // in_len
  this._buffer, // out
  this._offset, //out_off
  availOutBefore); // out_len

  req.buffer = chunk;
  req.callback = callback;

  function callback(availInAfter, availOutAfter) {
    // When the callback is used in an async write, the callback's
    // context is the `req` object that was created. The req object
    // is === this._handle, and that's why it's important to null
    // out the values after they are done being used. `this._handle`
    // can stay in memory longer than the callback and buffer are needed.
    if (this) {
      this.buffer = null;
      this.callback = null;
    }

    if (self._hadError) return;

    var have = availOutBefore - availOutAfter;
    assert(have >= 0, 'have should not go down');

    if (have > 0) {
      var out = self._buffer.slice(self._offset, self._offset + have);
      self._offset += have;
      // serve some output to the consumer.
      if (async) {
        self.push(out);
      } else {
        buffers.push(out);
        nread += out.length;
      }
    }

    // exhausted the output buffer, or used all the input create a new one.
    if (availOutAfter === 0 || self._offset >= self._chunkSize) {
      availOutBefore = self._chunkSize;
      self._offset = 0;
      self._buffer = Buffer.allocUnsafe(self._chunkSize);
    }

    if (availOutAfter === 0) {
      // Not actually done.  Need to reprocess.
      // Also, update the availInBefore to the availInAfter value,
      // so that if we have to hit it a third (fourth, etc.) time,
      // it'll have the correct byte counts.
      inOff += availInBefore - availInAfter;
      availInBefore = availInAfter;

      if (!async) return true;

      var newReq = self._handle.write(flushFlag, chunk, inOff, availInBefore, self._buffer, self._offset, self._chunkSize);
      newReq.callback = callback; // this same function
      newReq.buffer = chunk;
      return;
    }

    if (!async) return false;

    // finished with the chunk.
    cb();
  }
};

util.inherits(Deflate, Zlib);
util.inherits(Inflate, Zlib);
util.inherits(Gzip, Zlib);
util.inherits(Gunzip, Zlib);
util.inherits(DeflateRaw, Zlib);
util.inherits(InflateRaw, Zlib);
util.inherits(Unzip, Zlib);
}).call(this)}).call(this,require('_process'))
},{"./binding":134,"_process":223,"assert":127,"buffer":145,"stream":234,"util":257}],136:[function(require,module,exports){
'use strict';


var TYPED_OK =  (typeof Uint8Array !== 'undefined') &&
                (typeof Uint16Array !== 'undefined') &&
                (typeof Int32Array !== 'undefined');

function _has(obj, key) {
  return Object.prototype.hasOwnProperty.call(obj, key);
}

exports.assign = function (obj /*from1, from2, from3, ...*/) {
  var sources = Array.prototype.slice.call(arguments, 1);
  while (sources.length) {
    var source = sources.shift();
    if (!source) { continue; }

    if (typeof source !== 'object') {
      throw new TypeError(source + 'must be non-object');
    }

    for (var p in source) {
      if (_has(source, p)) {
        obj[p] = source[p];
      }
    }
  }

  return obj;
};


// reduce buffer size, avoiding mem copy
exports.shrinkBuf = function (buf, size) {
  if (buf.length === size) { return buf; }
  if (buf.subarray) { return buf.subarray(0, size); }
  buf.length = size;
  return buf;
};


var fnTyped = {
  arraySet: function (dest, src, src_offs, len, dest_offs) {
    if (src.subarray && dest.subarray) {
      dest.set(src.subarray(src_offs, src_offs + len), dest_offs);
      return;
    }
    // Fallback to ordinary array
    for (var i = 0; i < len; i++) {
      dest[dest_offs + i] = src[src_offs + i];
    }
  },
  // Join array of chunks to single array.
  flattenChunks: function (chunks) {
    var i, l, len, pos, chunk, result;

    // calculate data length
    len = 0;
    for (i = 0, l = chunks.length; i < l; i++) {
      len += chunks[i].length;
    }

    // join chunks
    result = new Uint8Array(len);
    pos = 0;
    for (i = 0, l = chunks.length; i < l; i++) {
      chunk = chunks[i];
      result.set(chunk, pos);
      pos += chunk.length;
    }

    return result;
  }
};

var fnUntyped = {
  arraySet: function (dest, src, src_offs, len, dest_offs) {
    for (var i = 0; i < len; i++) {
      dest[dest_offs + i] = src[src_offs + i];
    }
  },
  // Join array of chunks to single array.
  flattenChunks: function (chunks) {
    return [].concat.apply([], chunks);
  }
};


// Enable/Disable typed arrays use, for testing
//
exports.setTyped = function (on) {
  if (on) {
    exports.Buf8  = Uint8Array;
    exports.Buf16 = Uint16Array;
    exports.Buf32 = Int32Array;
    exports.assign(exports, fnTyped);
  } else {
    exports.Buf8  = Array;
    exports.Buf16 = Array;
    exports.Buf32 = Array;
    exports.assign(exports, fnUntyped);
  }
};

exports.setTyped(TYPED_OK);

},{}],137:[function(require,module,exports){
'use strict';

// Note: adler32 takes 12% for level 0 and 2% for level 6.
// It isn't worth it to make additional optimizations as in original.
// Small size is preferable.

// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

function adler32(adler, buf, len, pos) {
  var s1 = (adler & 0xffff) |0,
      s2 = ((adler >>> 16) & 0xffff) |0,
      n = 0;

  while (len !== 0) {
    // Set limit ~ twice less than 5552, to keep
    // s2 in 31-bits, because we force signed ints.
    // in other case %= will fail.
    n = len > 2000 ? 2000 : len;
    len -= n;

    do {
      s1 = (s1 + buf[pos++]) |0;
      s2 = (s2 + s1) |0;
    } while (--n);

    s1 %= 65521;
    s2 %= 65521;
  }

  return (s1 | (s2 << 16)) |0;
}


module.exports = adler32;

},{}],138:[function(require,module,exports){
'use strict';

// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

module.exports = {

  /* Allowed flush values; see deflate() and inflate() below for details */
  Z_NO_FLUSH:         0,
  Z_PARTIAL_FLUSH:    1,
  Z_SYNC_FLUSH:       2,
  Z_FULL_FLUSH:       3,
  Z_FINISH:           4,
  Z_BLOCK:            5,
  Z_TREES:            6,

  /* Return codes for the compression/decompression functions. Negative values
  * are errors, positive values are used for special but normal events.
  */
  Z_OK:               0,
  Z_STREAM_END:       1,
  Z_NEED_DICT:        2,
  Z_ERRNO:           -1,
  Z_STREAM_ERROR:    -2,
  Z_DATA_ERROR:      -3,
  //Z_MEM_ERROR:     -4,
  Z_BUF_ERROR:       -5,
  //Z_VERSION_ERROR: -6,

  /* compression levels */
  Z_NO_COMPRESSION:         0,
  Z_BEST_SPEED:             1,
  Z_BEST_COMPRESSION:       9,
  Z_DEFAULT_COMPRESSION:   -1,


  Z_FILTERED:               1,
  Z_HUFFMAN_ONLY:           2,
  Z_RLE:                    3,
  Z_FIXED:                  4,
  Z_DEFAULT_STRATEGY:       0,

  /* Possible values of the data_type field (though see inflate()) */
  Z_BINARY:                 0,
  Z_TEXT:                   1,
  //Z_ASCII:                1, // = Z_TEXT (deprecated)
  Z_UNKNOWN:                2,

  /* The deflate compression method */
  Z_DEFLATED:               8
  //Z_NULL:                 null // Use -1 or null inline, depending on var type
};

},{}],139:[function(require,module,exports){
'use strict';

// Note: we can't get significant speed boost here.
// So write code to minimize size - no pregenerated tables
// and array tools dependencies.

// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

// Use ordinary array, since untyped makes no boost here
function makeTable() {
  var c, table = [];

  for (var n = 0; n < 256; n++) {
    c = n;
    for (var k = 0; k < 8; k++) {
      c = ((c & 1) ? (0xEDB88320 ^ (c >>> 1)) : (c >>> 1));
    }
    table[n] = c;
  }

  return table;
}

// Create table on load. Just 255 signed longs. Not a problem.
var crcTable = makeTable();


function crc32(crc, buf, len, pos) {
  var t = crcTable,
      end = pos + len;

  crc ^= -1;

  for (var i = pos; i < end; i++) {
    crc = (crc >>> 8) ^ t[(crc ^ buf[i]) & 0xFF];
  }

  return (crc ^ (-1)); // >>> 0;
}


module.exports = crc32;

},{}],140:[function(require,module,exports){
'use strict';

// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

var utils   = require('../utils/common');
var trees   = require('./trees');
var adler32 = require('./adler32');
var crc32   = require('./crc32');
var msg     = require('./messages');

/* Public constants ==========================================================*/
/* ===========================================================================*/


/* Allowed flush values; see deflate() and inflate() below for details */
var Z_NO_FLUSH      = 0;
var Z_PARTIAL_FLUSH = 1;
//var Z_SYNC_FLUSH    = 2;
var Z_FULL_FLUSH    = 3;
var Z_FINISH        = 4;
var Z_BLOCK         = 5;
//var Z_TREES         = 6;


/* Return codes for the compression/decompression functions. Negative values
 * are errors, positive values are used for special but normal events.
 */
var Z_OK            = 0;
var Z_STREAM_END    = 1;
//var Z_NEED_DICT     = 2;
//var Z_ERRNO         = -1;
var Z_STREAM_ERROR  = -2;
var Z_DATA_ERROR    = -3;
//var Z_MEM_ERROR     = -4;
var Z_BUF_ERROR     = -5;
//var Z_VERSION_ERROR = -6;


/* compression levels */
//var Z_NO_COMPRESSION      = 0;
//var Z_BEST_SPEED          = 1;
//var Z_BEST_COMPRESSION    = 9;
var Z_DEFAULT_COMPRESSION = -1;


var Z_FILTERED            = 1;
var Z_HUFFMAN_ONLY        = 2;
var Z_RLE                 = 3;
var Z_FIXED               = 4;
var Z_DEFAULT_STRATEGY    = 0;

/* Possible values of the data_type field (though see inflate()) */
//var Z_BINARY              = 0;
//var Z_TEXT                = 1;
//var Z_ASCII               = 1; // = Z_TEXT
var Z_UNKNOWN             = 2;


/* The deflate compression method */
var Z_DEFLATED  = 8;

/*============================================================================*/


var MAX_MEM_LEVEL = 9;
/* Maximum value for memLevel in deflateInit2 */
var MAX_WBITS = 15;
/* 32K LZ77 window */
var DEF_MEM_LEVEL = 8;


var LENGTH_CODES  = 29;
/* number of length codes, not counting the special END_BLOCK code */
var LITERALS      = 256;
/* number of literal bytes 0..255 */
var L_CODES       = LITERALS + 1 + LENGTH_CODES;
/* number of Literal or Length codes, including the END_BLOCK code */
var D_CODES       = 30;
/* number of distance codes */
var BL_CODES      = 19;
/* number of codes used to transfer the bit lengths */
var HEAP_SIZE     = 2 * L_CODES + 1;
/* maximum heap size */
var MAX_BITS  = 15;
/* All codes must not exceed MAX_BITS bits */

var MIN_MATCH = 3;
var MAX_MATCH = 258;
var MIN_LOOKAHEAD = (MAX_MATCH + MIN_MATCH + 1);

var PRESET_DICT = 0x20;

var INIT_STATE = 42;
var EXTRA_STATE = 69;
var NAME_STATE = 73;
var COMMENT_STATE = 91;
var HCRC_STATE = 103;
var BUSY_STATE = 113;
var FINISH_STATE = 666;

var BS_NEED_MORE      = 1; /* block not completed, need more input or more output */
var BS_BLOCK_DONE     = 2; /* block flush performed */
var BS_FINISH_STARTED = 3; /* finish started, need only more output at next deflate */
var BS_FINISH_DONE    = 4; /* finish done, accept no more input or output */

var OS_CODE = 0x03; // Unix :) . Don't detect, use this default.

function err(strm, errorCode) {
  strm.msg = msg[errorCode];
  return errorCode;
}

function rank(f) {
  return ((f) << 1) - ((f) > 4 ? 9 : 0);
}

function zero(buf) { var len = buf.length; while (--len >= 0) { buf[len] = 0; } }


/* =========================================================================
 * Flush as much pending output as possible. All deflate() output goes
 * through this function so some applications may wish to modify it
 * to avoid allocating a large strm->output buffer and copying into it.
 * (See also read_buf()).
 */
function flush_pending(strm) {
  var s = strm.state;

  //_tr_flush_bits(s);
  var len = s.pending;
  if (len > strm.avail_out) {
    len = strm.avail_out;
  }
  if (len === 0) { return; }

  utils.arraySet(strm.output, s.pending_buf, s.pending_out, len, strm.next_out);
  strm.next_out += len;
  s.pending_out += len;
  strm.total_out += len;
  strm.avail_out -= len;
  s.pending -= len;
  if (s.pending === 0) {
    s.pending_out = 0;
  }
}


function flush_block_only(s, last) {
  trees._tr_flush_block(s, (s.block_start >= 0 ? s.block_start : -1), s.strstart - s.block_start, last);
  s.block_start = s.strstart;
  flush_pending(s.strm);
}


function put_byte(s, b) {
  s.pending_buf[s.pending++] = b;
}


/* =========================================================================
 * Put a short in the pending buffer. The 16-bit value is put in MSB order.
 * IN assertion: the stream state is correct and there is enough room in
 * pending_buf.
 */
function putShortMSB(s, b) {
//  put_byte(s, (Byte)(b >> 8));
//  put_byte(s, (Byte)(b & 0xff));
  s.pending_buf[s.pending++] = (b >>> 8) & 0xff;
  s.pending_buf[s.pending++] = b & 0xff;
}


/* ===========================================================================
 * Read a new buffer from the current input stream, update the adler32
 * and total number of bytes read.  All deflate() input goes through
 * this function so some applications may wish to modify it to avoid
 * allocating a large strm->input buffer and copying from it.
 * (See also flush_pending()).
 */
function read_buf(strm, buf, start, size) {
  var len = strm.avail_in;

  if (len > size) { len = size; }
  if (len === 0) { return 0; }

  strm.avail_in -= len;

  // zmemcpy(buf, strm->next_in, len);
  utils.arraySet(buf, strm.input, strm.next_in, len, start);
  if (strm.state.wrap === 1) {
    strm.adler = adler32(strm.adler, buf, len, start);
  }

  else if (strm.state.wrap === 2) {
    strm.adler = crc32(strm.adler, buf, len, start);
  }

  strm.next_in += len;
  strm.total_in += len;

  return len;
}


/* ===========================================================================
 * Set match_start to the longest match starting at the given string and
 * return its length. Matches shorter or equal to prev_length are discarded,
 * in which case the result is equal to prev_length and match_start is
 * garbage.
 * IN assertions: cur_match is the head of the hash chain for the current
 *   string (strstart) and its distance is <= MAX_DIST, and prev_length >= 1
 * OUT assertion: the match length is not greater than s->lookahead.
 */
function longest_match(s, cur_match) {
  var chain_length = s.max_chain_length;      /* max hash chain length */
  var scan = s.strstart; /* current string */
  var match;                       /* matched string */
  var len;                           /* length of current match */
  var best_len = s.prev_length;              /* best match length so far */
  var nice_match = s.nice_match;             /* stop if match long enough */
  var limit = (s.strstart > (s.w_size - MIN_LOOKAHEAD)) ?
      s.strstart - (s.w_size - MIN_LOOKAHEAD) : 0/*NIL*/;

  var _win = s.window; // shortcut

  var wmask = s.w_mask;
  var prev  = s.prev;

  /* Stop when cur_match becomes <= limit. To simplify the code,
   * we prevent matches with the string of window index 0.
   */

  var strend = s.strstart + MAX_MATCH;
  var scan_end1  = _win[scan + best_len - 1];
  var scan_end   = _win[scan + best_len];

  /* The code is optimized for HASH_BITS >= 8 and MAX_MATCH-2 multiple of 16.
   * It is easy to get rid of this optimization if necessary.
   */
  // Assert(s->hash_bits >= 8 && MAX_MATCH == 258, "Code too clever");

  /* Do not waste too much time if we already have a good match: */
  if (s.prev_length >= s.good_match) {
    chain_length >>= 2;
  }
  /* Do not look for matches beyond the end of the input. This is necessary
   * to make deflate deterministic.
   */
  if (nice_match > s.lookahead) { nice_match = s.lookahead; }

  // Assert((ulg)s->strstart <= s->window_size-MIN_LOOKAHEAD, "need lookahead");

  do {
    // Assert(cur_match < s->strstart, "no future");
    match = cur_match;

    /* Skip to next match if the match length cannot increase
     * or if the match length is less than 2.  Note that the checks below
     * for insufficient lookahead only occur occasionally for performance
     * reasons.  Therefore uninitialized memory will be accessed, and
     * conditional jumps will be made that depend on those values.
     * However the length of the match is limited to the lookahead, so
     * the output of deflate is not affected by the uninitialized values.
     */

    if (_win[match + best_len]     !== scan_end  ||
        _win[match + best_len - 1] !== scan_end1 ||
        _win[match]                !== _win[scan] ||
        _win[++match]              !== _win[scan + 1]) {
      continue;
    }

    /* The check at best_len-1 can be removed because it will be made
     * again later. (This heuristic is not always a win.)
     * It is not necessary to compare scan[2] and match[2] since they
     * are always equal when the other bytes match, given that
     * the hash keys are equal and that HASH_BITS >= 8.
     */
    scan += 2;
    match++;
    // Assert(*scan == *match, "match[2]?");

    /* We check for insufficient lookahead only every 8th comparison;
     * the 256th check will be made at strstart+258.
     */
    do {
      /*jshint noempty:false*/
    } while (_win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&
             _win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&
             _win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&
             _win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&
             scan < strend);

    // Assert(scan <= s->window+(unsigned)(s->window_size-1), "wild scan");

    len = MAX_MATCH - (strend - scan);
    scan = strend - MAX_MATCH;

    if (len > best_len) {
      s.match_start = cur_match;
      best_len = len;
      if (len >= nice_match) {
        break;
      }
      scan_end1  = _win[scan + best_len - 1];
      scan_end   = _win[scan + best_len];
    }
  } while ((cur_match = prev[cur_match & wmask]) > limit && --chain_length !== 0);

  if (best_len <= s.lookahead) {
    return best_len;
  }
  return s.lookahead;
}


/* ===========================================================================
 * Fill the window when the lookahead becomes insufficient.
 * Updates strstart and lookahead.
 *
 * IN assertion: lookahead < MIN_LOOKAHEAD
 * OUT assertions: strstart <= window_size-MIN_LOOKAHEAD
 *    At least one byte has been read, or avail_in == 0; reads are
 *    performed for at least two bytes (required for the zip translate_eol
 *    option -- not supported here).
 */
function fill_window(s) {
  var _w_size = s.w_size;
  var p, n, m, more, str;

  //Assert(s->lookahead < MIN_LOOKAHEAD, "already enough lookahead");

  do {
    more = s.window_size - s.lookahead - s.strstart;

    // JS ints have 32 bit, block below not needed
    /* Deal with !@#$% 64K limit: */
    //if (sizeof(int) <= 2) {
    //    if (more == 0 && s->strstart == 0 && s->lookahead == 0) {
    //        more = wsize;
    //
    //  } else if (more == (unsigned)(-1)) {
    //        /* Very unlikely, but possible on 16 bit machine if
    //         * strstart == 0 && lookahead == 1 (input done a byte at time)
    //         */
    //        more--;
    //    }
    //}


    /* If the window is almost full and there is insufficient lookahead,
     * move the upper half to the lower one to make room in the upper half.
     */
    if (s.strstart >= _w_size + (_w_size - MIN_LOOKAHEAD)) {

      utils.arraySet(s.window, s.window, _w_size, _w_size, 0);
      s.match_start -= _w_size;
      s.strstart -= _w_size;
      /* we now have strstart >= MAX_DIST */
      s.block_start -= _w_size;

      /* Slide the hash table (could be avoided with 32 bit values
       at the expense of memory usage). We slide even when level == 0
       to keep the hash table consistent if we switch back to level > 0
       later. (Using level 0 permanently is not an optimal usage of
       zlib, so we don't care about this pathological case.)
       */

      n = s.hash_size;
      p = n;
      do {
        m = s.head[--p];
        s.head[p] = (m >= _w_size ? m - _w_size : 0);
      } while (--n);

      n = _w_size;
      p = n;
      do {
        m = s.prev[--p];
        s.prev[p] = (m >= _w_size ? m - _w_size : 0);
        /* If n is not on any hash chain, prev[n] is garbage but
         * its value will never be used.
         */
      } while (--n);

      more += _w_size;
    }
    if (s.strm.avail_in === 0) {
      break;
    }

    /* If there was no sliding:
     *    strstart <= WSIZE+MAX_DIST-1 && lookahead <= MIN_LOOKAHEAD - 1 &&
     *    more == window_size - lookahead - strstart
     * => more >= window_size - (MIN_LOOKAHEAD-1 + WSIZE + MAX_DIST-1)
     * => more >= window_size - 2*WSIZE + 2
     * In the BIG_MEM or MMAP case (not yet supported),
     *   window_size == input_size + MIN_LOOKAHEAD  &&
     *   strstart + s->lookahead <= input_size => more >= MIN_LOOKAHEAD.
     * Otherwise, window_size == 2*WSIZE so more >= 2.
     * If there was sliding, more >= WSIZE. So in all cases, more >= 2.
     */
    //Assert(more >= 2, "more < 2");
    n = read_buf(s.strm, s.window, s.strstart + s.lookahead, more);
    s.lookahead += n;

    /* Initialize the hash value now that we have some input: */
    if (s.lookahead + s.insert >= MIN_MATCH) {
      str = s.strstart - s.insert;
      s.ins_h = s.window[str];

      /* UPDATE_HASH(s, s->ins_h, s->window[str + 1]); */
      s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[str + 1]) & s.hash_mask;
//#if MIN_MATCH != 3
//        Call update_hash() MIN_MATCH-3 more times
//#endif
      while (s.insert) {
        /* UPDATE_HASH(s, s->ins_h, s->window[str + MIN_MATCH-1]); */
        s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[str + MIN_MATCH - 1]) & s.hash_mask;

        s.prev[str & s.w_mask] = s.head[s.ins_h];
        s.head[s.ins_h] = str;
        str++;
        s.insert--;
        if (s.lookahead + s.insert < MIN_MATCH) {
          break;
        }
      }
    }
    /* If the whole input has less than MIN_MATCH bytes, ins_h is garbage,
     * but this is not important since only literal bytes will be emitted.
     */

  } while (s.lookahead < MIN_LOOKAHEAD && s.strm.avail_in !== 0);

  /* If the WIN_INIT bytes after the end of the current data have never been
   * written, then zero those bytes in order to avoid memory check reports of
   * the use of uninitialized (or uninitialised as Julian writes) bytes by
   * the longest match routines.  Update the high water mark for the next
   * time through here.  WIN_INIT is set to MAX_MATCH since the longest match
   * routines allow scanning to strstart + MAX_MATCH, ignoring lookahead.
   */
//  if (s.high_water < s.window_size) {
//    var curr = s.strstart + s.lookahead;
//    var init = 0;
//
//    if (s.high_water < curr) {
//      /* Previous high water mark below current data -- zero WIN_INIT
//       * bytes or up to end of window, whichever is less.
//       */
//      init = s.window_size - curr;
//      if (init > WIN_INIT)
//        init = WIN_INIT;
//      zmemzero(s->window + curr, (unsigned)init);
//      s->high_water = curr + init;
//    }
//    else if (s->high_water < (ulg)curr + WIN_INIT) {
//      /* High water mark at or above current data, but below current data
//       * plus WIN_INIT -- zero out to current data plus WIN_INIT, or up
//       * to end of window, whichever is less.
//       */
//      init = (ulg)curr + WIN_INIT - s->high_water;
//      if (init > s->window_size - s->high_water)
//        init = s->window_size - s->high_water;
//      zmemzero(s->window + s->high_water, (unsigned)init);
//      s->high_water += init;
//    }
//  }
//
//  Assert((ulg)s->strstart <= s->window_size - MIN_LOOKAHEAD,
//    "not enough room for search");
}

/* ===========================================================================
 * Copy without compression as much as possible from the input stream, return
 * the current block state.
 * This function does not insert new strings in the dictionary since
 * uncompressible data is probably not useful. This function is used
 * only for the level=0 compression option.
 * NOTE: this function should be optimized to avoid extra copying from
 * window to pending_buf.
 */
function deflate_stored(s, flush) {
  /* Stored blocks are limited to 0xffff bytes, pending_buf is limited
   * to pending_buf_size, and each stored block has a 5 byte header:
   */
  var max_block_size = 0xffff;

  if (max_block_size > s.pending_buf_size - 5) {
    max_block_size = s.pending_buf_size - 5;
  }

  /* Copy as much as possible from input to output: */
  for (;;) {
    /* Fill the window as much as possible: */
    if (s.lookahead <= 1) {

      //Assert(s->strstart < s->w_size+MAX_DIST(s) ||
      //  s->block_start >= (long)s->w_size, "slide too late");
//      if (!(s.strstart < s.w_size + (s.w_size - MIN_LOOKAHEAD) ||
//        s.block_start >= s.w_size)) {
//        throw  new Error("slide too late");
//      }

      fill_window(s);
      if (s.lookahead === 0 && flush === Z_NO_FLUSH) {
        return BS_NEED_MORE;
      }

      if (s.lookahead === 0) {
        break;
      }
      /* flush the current block */
    }
    //Assert(s->block_start >= 0L, "block gone");
//    if (s.block_start < 0) throw new Error("block gone");

    s.strstart += s.lookahead;
    s.lookahead = 0;

    /* Emit a stored block if pending_buf will be full: */
    var max_start = s.block_start + max_block_size;

    if (s.strstart === 0 || s.strstart >= max_start) {
      /* strstart == 0 is possible when wraparound on 16-bit machine */
      s.lookahead = s.strstart - max_start;
      s.strstart = max_start;
      /*** FLUSH_BLOCK(s, 0); ***/
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
      /***/


    }
    /* Flush if we may have to slide, otherwise block_start may become
     * negative and the data will be gone:
     */
    if (s.strstart - s.block_start >= (s.w_size - MIN_LOOKAHEAD)) {
      /*** FLUSH_BLOCK(s, 0); ***/
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
      /***/
    }
  }

  s.insert = 0;

  if (flush === Z_FINISH) {
    /*** FLUSH_BLOCK(s, 1); ***/
    flush_block_only(s, true);
    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    /***/
    return BS_FINISH_DONE;
  }

  if (s.strstart > s.block_start) {
    /*** FLUSH_BLOCK(s, 0); ***/
    flush_block_only(s, false);
    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
    /***/
  }

  return BS_NEED_MORE;
}

/* ===========================================================================
 * Compress as much as possible from the input stream, return the current
 * block state.
 * This function does not perform lazy evaluation of matches and inserts
 * new strings in the dictionary only for unmatched strings or for short
 * matches. It is used only for the fast compression options.
 */
function deflate_fast(s, flush) {
  var hash_head;        /* head of the hash chain */
  var bflush;           /* set if current block must be flushed */

  for (;;) {
    /* Make sure that we always have enough lookahead, except
     * at the end of the input file. We need MAX_MATCH bytes
     * for the next match, plus MIN_MATCH bytes to insert the
     * string following the next match.
     */
    if (s.lookahead < MIN_LOOKAHEAD) {
      fill_window(s);
      if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {
        return BS_NEED_MORE;
      }
      if (s.lookahead === 0) {
        break; /* flush the current block */
      }
    }

    /* Insert the string window[strstart .. strstart+2] in the
     * dictionary, and set hash_head to the head of the hash chain:
     */
    hash_head = 0/*NIL*/;
    if (s.lookahead >= MIN_MATCH) {
      /*** INSERT_STRING(s, s.strstart, hash_head); ***/
      s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
      hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
      s.head[s.ins_h] = s.strstart;
      /***/
    }

    /* Find the longest match, discarding those <= prev_length.
     * At this point we have always match_length < MIN_MATCH
     */
    if (hash_head !== 0/*NIL*/ && ((s.strstart - hash_head) <= (s.w_size - MIN_LOOKAHEAD))) {
      /* To simplify the code, we prevent matches with the string
       * of window index 0 (in particular we have to avoid a match
       * of the string with itself at the start of the input file).
       */
      s.match_length = longest_match(s, hash_head);
      /* longest_match() sets match_start */
    }
    if (s.match_length >= MIN_MATCH) {
      // check_match(s, s.strstart, s.match_start, s.match_length); // for debug only

      /*** _tr_tally_dist(s, s.strstart - s.match_start,
                     s.match_length - MIN_MATCH, bflush); ***/
      bflush = trees._tr_tally(s, s.strstart - s.match_start, s.match_length - MIN_MATCH);

      s.lookahead -= s.match_length;

      /* Insert new strings in the hash table only if the match length
       * is not too large. This saves time but degrades compression.
       */
      if (s.match_length <= s.max_lazy_match/*max_insert_length*/ && s.lookahead >= MIN_MATCH) {
        s.match_length--; /* string at strstart already in table */
        do {
          s.strstart++;
          /*** INSERT_STRING(s, s.strstart, hash_head); ***/
          s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
          hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
          s.head[s.ins_h] = s.strstart;
          /***/
          /* strstart never exceeds WSIZE-MAX_MATCH, so there are
           * always MIN_MATCH bytes ahead.
           */
        } while (--s.match_length !== 0);
        s.strstart++;
      } else
      {
        s.strstart += s.match_length;
        s.match_length = 0;
        s.ins_h = s.window[s.strstart];
        /* UPDATE_HASH(s, s.ins_h, s.window[s.strstart+1]); */
        s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + 1]) & s.hash_mask;

//#if MIN_MATCH != 3
//                Call UPDATE_HASH() MIN_MATCH-3 more times
//#endif
        /* If lookahead < MIN_MATCH, ins_h is garbage, but it does not
         * matter since it will be recomputed at next deflate call.
         */
      }
    } else {
      /* No match, output a literal byte */
      //Tracevv((stderr,"%c", s.window[s.strstart]));
      /*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/
      bflush = trees._tr_tally(s, 0, s.window[s.strstart]);

      s.lookahead--;
      s.strstart++;
    }
    if (bflush) {
      /*** FLUSH_BLOCK(s, 0); ***/
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
      /***/
    }
  }
  s.insert = ((s.strstart < (MIN_MATCH - 1)) ? s.strstart : MIN_MATCH - 1);
  if (flush === Z_FINISH) {
    /*** FLUSH_BLOCK(s, 1); ***/
    flush_block_only(s, true);
    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    /***/
    return BS_FINISH_DONE;
  }
  if (s.last_lit) {
    /*** FLUSH_BLOCK(s, 0); ***/
    flush_block_only(s, false);
    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
    /***/
  }
  return BS_BLOCK_DONE;
}

/* ===========================================================================
 * Same as above, but achieves better compression. We use a lazy
 * evaluation for matches: a match is finally adopted only if there is
 * no better match at the next window position.
 */
function deflate_slow(s, flush) {
  var hash_head;          /* head of hash chain */
  var bflush;              /* set if current block must be flushed */

  var max_insert;

  /* Process the input block. */
  for (;;) {
    /* Make sure that we always have enough lookahead, except
     * at the end of the input file. We need MAX_MATCH bytes
     * for the next match, plus MIN_MATCH bytes to insert the
     * string following the next match.
     */
    if (s.lookahead < MIN_LOOKAHEAD) {
      fill_window(s);
      if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {
        return BS_NEED_MORE;
      }
      if (s.lookahead === 0) { break; } /* flush the current block */
    }

    /* Insert the string window[strstart .. strstart+2] in the
     * dictionary, and set hash_head to the head of the hash chain:
     */
    hash_head = 0/*NIL*/;
    if (s.lookahead >= MIN_MATCH) {
      /*** INSERT_STRING(s, s.strstart, hash_head); ***/
      s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
      hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
      s.head[s.ins_h] = s.strstart;
      /***/
    }

    /* Find the longest match, discarding those <= prev_length.
     */
    s.prev_length = s.match_length;
    s.prev_match = s.match_start;
    s.match_length = MIN_MATCH - 1;

    if (hash_head !== 0/*NIL*/ && s.prev_length < s.max_lazy_match &&
        s.strstart - hash_head <= (s.w_size - MIN_LOOKAHEAD)/*MAX_DIST(s)*/) {
      /* To simplify the code, we prevent matches with the string
       * of window index 0 (in particular we have to avoid a match
       * of the string with itself at the start of the input file).
       */
      s.match_length = longest_match(s, hash_head);
      /* longest_match() sets match_start */

      if (s.match_length <= 5 &&
         (s.strategy === Z_FILTERED || (s.match_length === MIN_MATCH && s.strstart - s.match_start > 4096/*TOO_FAR*/))) {

        /* If prev_match is also MIN_MATCH, match_start is garbage
         * but we will ignore the current match anyway.
         */
        s.match_length = MIN_MATCH - 1;
      }
    }
    /* If there was a match at the previous step and the current
     * match is not better, output the previous match:
     */
    if (s.prev_length >= MIN_MATCH && s.match_length <= s.prev_length) {
      max_insert = s.strstart + s.lookahead - MIN_MATCH;
      /* Do not insert strings in hash table beyond this. */

      //check_match(s, s.strstart-1, s.prev_match, s.prev_length);

      /***_tr_tally_dist(s, s.strstart - 1 - s.prev_match,
                     s.prev_length - MIN_MATCH, bflush);***/
      bflush = trees._tr_tally(s, s.strstart - 1 - s.prev_match, s.prev_length - MIN_MATCH);
      /* Insert in hash table all strings up to the end of the match.
       * strstart-1 and strstart are already inserted. If there is not
       * enough lookahead, the last two strings are not inserted in
       * the hash table.
       */
      s.lookahead -= s.prev_length - 1;
      s.prev_length -= 2;
      do {
        if (++s.strstart <= max_insert) {
          /*** INSERT_STRING(s, s.strstart, hash_head); ***/
          s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
          hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
          s.head[s.ins_h] = s.strstart;
          /***/
        }
      } while (--s.prev_length !== 0);
      s.match_available = 0;
      s.match_length = MIN_MATCH - 1;
      s.strstart++;

      if (bflush) {
        /*** FLUSH_BLOCK(s, 0); ***/
        flush_block_only(s, false);
        if (s.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
        /***/
      }

    } else if (s.match_available) {
      /* If there was no match at the previous position, output a
       * single literal. If there was a match but the current match
       * is longer, truncate the previous match to a single literal.
       */
      //Tracevv((stderr,"%c", s->window[s->strstart-1]));
      /*** _tr_tally_lit(s, s.window[s.strstart-1], bflush); ***/
      bflush = trees._tr_tally(s, 0, s.window[s.strstart - 1]);

      if (bflush) {
        /*** FLUSH_BLOCK_ONLY(s, 0) ***/
        flush_block_only(s, false);
        /***/
      }
      s.strstart++;
      s.lookahead--;
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
    } else {
      /* There is no previous match to compare with, wait for
       * the next step to decide.
       */
      s.match_available = 1;
      s.strstart++;
      s.lookahead--;
    }
  }
  //Assert (flush != Z_NO_FLUSH, "no flush?");
  if (s.match_available) {
    //Tracevv((stderr,"%c", s->window[s->strstart-1]));
    /*** _tr_tally_lit(s, s.window[s.strstart-1], bflush); ***/
    bflush = trees._tr_tally(s, 0, s.window[s.strstart - 1]);

    s.match_available = 0;
  }
  s.insert = s.strstart < MIN_MATCH - 1 ? s.strstart : MIN_MATCH - 1;
  if (flush === Z_FINISH) {
    /*** FLUSH_BLOCK(s, 1); ***/
    flush_block_only(s, true);
    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    /***/
    return BS_FINISH_DONE;
  }
  if (s.last_lit) {
    /*** FLUSH_BLOCK(s, 0); ***/
    flush_block_only(s, false);
    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
    /***/
  }

  return BS_BLOCK_DONE;
}


/* ===========================================================================
 * For Z_RLE, simply look for runs of bytes, generate matches only of distance
 * one.  Do not maintain a hash table.  (It will be regenerated if this run of
 * deflate switches away from Z_RLE.)
 */
function deflate_rle(s, flush) {
  var bflush;            /* set if current block must be flushed */
  var prev;              /* byte at distance one to match */
  var scan, strend;      /* scan goes up to strend for length of run */

  var _win = s.window;

  for (;;) {
    /* Make sure that we always have enough lookahead, except
     * at the end of the input file. We need MAX_MATCH bytes
     * for the longest run, plus one for the unrolled loop.
     */
    if (s.lookahead <= MAX_MATCH) {
      fill_window(s);
      if (s.lookahead <= MAX_MATCH && flush === Z_NO_FLUSH) {
        return BS_NEED_MORE;
      }
      if (s.lookahead === 0) { break; } /* flush the current block */
    }

    /* See how many times the previous byte repeats */
    s.match_length = 0;
    if (s.lookahead >= MIN_MATCH && s.strstart > 0) {
      scan = s.strstart - 1;
      prev = _win[scan];
      if (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan]) {
        strend = s.strstart + MAX_MATCH;
        do {
          /*jshint noempty:false*/
        } while (prev === _win[++scan] && prev === _win[++scan] &&
                 prev === _win[++scan] && prev === _win[++scan] &&
                 prev === _win[++scan] && prev === _win[++scan] &&
                 prev === _win[++scan] && prev === _win[++scan] &&
                 scan < strend);
        s.match_length = MAX_MATCH - (strend - scan);
        if (s.match_length > s.lookahead) {
          s.match_length = s.lookahead;
        }
      }
      //Assert(scan <= s->window+(uInt)(s->window_size-1), "wild scan");
    }

    /* Emit match if have run of MIN_MATCH or longer, else emit literal */
    if (s.match_length >= MIN_MATCH) {
      //check_match(s, s.strstart, s.strstart - 1, s.match_length);

      /*** _tr_tally_dist(s, 1, s.match_length - MIN_MATCH, bflush); ***/
      bflush = trees._tr_tally(s, 1, s.match_length - MIN_MATCH);

      s.lookahead -= s.match_length;
      s.strstart += s.match_length;
      s.match_length = 0;
    } else {
      /* No match, output a literal byte */
      //Tracevv((stderr,"%c", s->window[s->strstart]));
      /*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/
      bflush = trees._tr_tally(s, 0, s.window[s.strstart]);

      s.lookahead--;
      s.strstart++;
    }
    if (bflush) {
      /*** FLUSH_BLOCK(s, 0); ***/
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
      /***/
    }
  }
  s.insert = 0;
  if (flush === Z_FINISH) {
    /*** FLUSH_BLOCK(s, 1); ***/
    flush_block_only(s, true);
    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    /***/
    return BS_FINISH_DONE;
  }
  if (s.last_lit) {
    /*** FLUSH_BLOCK(s, 0); ***/
    flush_block_only(s, false);
    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
    /***/
  }
  return BS_BLOCK_DONE;
}

/* ===========================================================================
 * For Z_HUFFMAN_ONLY, do not look for matches.  Do not maintain a hash table.
 * (It will be regenerated if this run of deflate switches away from Huffman.)
 */
function deflate_huff(s, flush) {
  var bflush;             /* set if current block must be flushed */

  for (;;) {
    /* Make sure that we have a literal to write. */
    if (s.lookahead === 0) {
      fill_window(s);
      if (s.lookahead === 0) {
        if (flush === Z_NO_FLUSH) {
          return BS_NEED_MORE;
        }
        break;      /* flush the current block */
      }
    }

    /* Output a literal byte */
    s.match_length = 0;
    //Tracevv((stderr,"%c", s->window[s->strstart]));
    /*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/
    bflush = trees._tr_tally(s, 0, s.window[s.strstart]);
    s.lookahead--;
    s.strstart++;
    if (bflush) {
      /*** FLUSH_BLOCK(s, 0); ***/
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
      /***/
    }
  }
  s.insert = 0;
  if (flush === Z_FINISH) {
    /*** FLUSH_BLOCK(s, 1); ***/
    flush_block_only(s, true);
    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    /***/
    return BS_FINISH_DONE;
  }
  if (s.last_lit) {
    /*** FLUSH_BLOCK(s, 0); ***/
    flush_block_only(s, false);
    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
    /***/
  }
  return BS_BLOCK_DONE;
}

/* Values for max_lazy_match, good_match and max_chain_length, depending on
 * the desired pack level (0..9). The values given below have been tuned to
 * exclude worst case performance for pathological files. Better values may be
 * found for specific files.
 */
function Config(good_length, max_lazy, nice_length, max_chain, func) {
  this.good_length = good_length;
  this.max_lazy = max_lazy;
  this.nice_length = nice_length;
  this.max_chain = max_chain;
  this.func = func;
}

var configuration_table;

configuration_table = [
  /*      good lazy nice chain */
  new Config(0, 0, 0, 0, deflate_stored),          /* 0 store only */
  new Config(4, 4, 8, 4, deflate_fast),            /* 1 max speed, no lazy matches */
  new Config(4, 5, 16, 8, deflate_fast),           /* 2 */
  new Config(4, 6, 32, 32, deflate_fast),          /* 3 */

  new Config(4, 4, 16, 16, deflate_slow),          /* 4 lazy matches */
  new Config(8, 16, 32, 32, deflate_slow),         /* 5 */
  new Config(8, 16, 128, 128, deflate_slow),       /* 6 */
  new Config(8, 32, 128, 256, deflate_slow),       /* 7 */
  new Config(32, 128, 258, 1024, deflate_slow),    /* 8 */
  new Config(32, 258, 258, 4096, deflate_slow)     /* 9 max compression */
];


/* ===========================================================================
 * Initialize the "longest match" routines for a new zlib stream
 */
function lm_init(s) {
  s.window_size = 2 * s.w_size;

  /*** CLEAR_HASH(s); ***/
  zero(s.head); // Fill with NIL (= 0);

  /* Set the default configuration parameters:
   */
  s.max_lazy_match = configuration_table[s.level].max_lazy;
  s.good_match = configuration_table[s.level].good_length;
  s.nice_match = configuration_table[s.level].nice_length;
  s.max_chain_length = configuration_table[s.level].max_chain;

  s.strstart = 0;
  s.block_start = 0;
  s.lookahead = 0;
  s.insert = 0;
  s.match_length = s.prev_length = MIN_MATCH - 1;
  s.match_available = 0;
  s.ins_h = 0;
}


function DeflateState() {
  this.strm = null;            /* pointer back to this zlib stream */
  this.status = 0;            /* as the name implies */
  this.pending_buf = null;      /* output still pending */
  this.pending_buf_size = 0;  /* size of pending_buf */
  this.pending_out = 0;       /* next pending byte to output to the stream */
  this.pending = 0;           /* nb of bytes in the pending buffer */
  this.wrap = 0;              /* bit 0 true for zlib, bit 1 true for gzip */
  this.gzhead = null;         /* gzip header information to write */
  this.gzindex = 0;           /* where in extra, name, or comment */
  this.method = Z_DEFLATED; /* can only be DEFLATED */
  this.last_flush = -1;   /* value of flush param for previous deflate call */

  this.w_size = 0;  /* LZ77 window size (32K by default) */
  this.w_bits = 0;  /* log2(w_size)  (8..16) */
  this.w_mask = 0;  /* w_size - 1 */

  this.window = null;
  /* Sliding window. Input bytes are read into the second half of the window,
   * and move to the first half later to keep a dictionary of at least wSize
   * bytes. With this organization, matches are limited to a distance of
   * wSize-MAX_MATCH bytes, but this ensures that IO is always
   * performed with a length multiple of the block size.
   */

  this.window_size = 0;
  /* Actual size of window: 2*wSize, except when the user input buffer
   * is directly used as sliding window.
   */

  this.prev = null;
  /* Link to older string with same hash index. To limit the size of this
   * array to 64K, this link is maintained only for the last 32K strings.
   * An index in this array is thus a window index modulo 32K.
   */

  this.head = null;   /* Heads of the hash chains or NIL. */

  this.ins_h = 0;       /* hash index of string to be inserted */
  this.hash_size = 0;   /* number of elements in hash table */
  this.hash_bits = 0;   /* log2(hash_size) */
  this.hash_mask = 0;   /* hash_size-1 */

  this.hash_shift = 0;
  /* Number of bits by which ins_h must be shifted at each input
   * step. It must be such that after MIN_MATCH steps, the oldest
   * byte no longer takes part in the hash key, that is:
   *   hash_shift * MIN_MATCH >= hash_bits
   */

  this.block_start = 0;
  /* Window position at the beginning of the current output block. Gets
   * negative when the window is moved backwards.
   */

  this.match_length = 0;      /* length of best match */
  this.prev_match = 0;        /* previous match */
  this.match_available = 0;   /* set if previous match exists */
  this.strstart = 0;          /* start of string to insert */
  this.match_start = 0;       /* start of matching string */
  this.lookahead = 0;         /* number of valid bytes ahead in window */

  this.prev_length = 0;
  /* Length of the best match at previous step. Matches not greater than this
   * are discarded. This is used in the lazy match evaluation.
   */

  this.max_chain_length = 0;
  /* To speed up deflation, hash chains are never searched beyond this
   * length.  A higher limit improves compression ratio but degrades the
   * speed.
   */

  this.max_lazy_match = 0;
  /* Attempt to find a better match only when the current match is strictly
   * smaller than this value. This mechanism is used only for compression
   * levels >= 4.
   */
  // That's alias to max_lazy_match, don't use directly
  //this.max_insert_length = 0;
  /* Insert new strings in the hash table only if the match length is not
   * greater than this length. This saves time but degrades compression.
   * max_insert_length is used only for compression levels <= 3.
   */

  this.level = 0;     /* compression level (1..9) */
  this.strategy = 0;  /* favor or force Huffman coding*/

  this.good_match = 0;
  /* Use a faster search when the previous match is longer than this */

  this.nice_match = 0; /* Stop searching when current match exceeds this */

              /* used by trees.c: */

  /* Didn't use ct_data typedef below to suppress compiler warning */

  // struct ct_data_s dyn_ltree[HEAP_SIZE];   /* literal and length tree */
  // struct ct_data_s dyn_dtree[2*D_CODES+1]; /* distance tree */
  // struct ct_data_s bl_tree[2*BL_CODES+1];  /* Huffman tree for bit lengths */

  // Use flat array of DOUBLE size, with interleaved fata,
  // because JS does not support effective
  this.dyn_ltree  = new utils.Buf16(HEAP_SIZE * 2);
  this.dyn_dtree  = new utils.Buf16((2 * D_CODES + 1) * 2);
  this.bl_tree    = new utils.Buf16((2 * BL_CODES + 1) * 2);
  zero(this.dyn_ltree);
  zero(this.dyn_dtree);
  zero(this.bl_tree);

  this.l_desc   = null;         /* desc. for literal tree */
  this.d_desc   = null;         /* desc. for distance tree */
  this.bl_desc  = null;         /* desc. for bit length tree */

  //ush bl_count[MAX_BITS+1];
  this.bl_count = new utils.Buf16(MAX_BITS + 1);
  /* number of codes at each bit length for an optimal tree */

  //int heap[2*L_CODES+1];      /* heap used to build the Huffman trees */
  this.heap = new utils.Buf16(2 * L_CODES + 1);  /* heap used to build the Huffman trees */
  zero(this.heap);

  this.heap_len = 0;               /* number of elements in the heap */
  this.heap_max = 0;               /* element of largest frequency */
  /* The sons of heap[n] are heap[2*n] and heap[2*n+1]. heap[0] is not used.
   * The same heap array is used to build all trees.
   */

  this.depth = new utils.Buf16(2 * L_CODES + 1); //uch depth[2*L_CODES+1];
  zero(this.depth);
  /* Depth of each subtree used as tie breaker for trees of equal frequency
   */

  this.l_buf = 0;          /* buffer index for literals or lengths */

  this.lit_bufsize = 0;
  /* Size of match buffer for literals/lengths.  There are 4 reasons for
   * limiting lit_bufsize to 64K:
   *   - frequencies can be kept in 16 bit counters
   *   - if compression is not successful for the first block, all input
   *     data is still in the window so we can still emit a stored block even
   *     when input comes from standard input.  (This can also be done for
   *     all blocks if lit_bufsize is not greater than 32K.)
   *   - if compression is not successful for a file smaller than 64K, we can
   *     even emit a stored file instead of a stored block (saving 5 bytes).
   *     This is applicable only for zip (not gzip or zlib).
   *   - creating new Huffman trees less frequently may not provide fast
   *     adaptation to changes in the input data statistics. (Take for
   *     example a binary file with poorly compressible code followed by
   *     a highly compressible string table.) Smaller buffer sizes give
   *     fast adaptation but have of course the overhead of transmitting
   *     trees more frequently.
   *   - I can't count above 4
   */

  this.last_lit = 0;      /* running index in l_buf */

  this.d_buf = 0;
  /* Buffer index for distances. To simplify the code, d_buf and l_buf have
   * the same number of elements. To use different lengths, an extra flag
   * array would be necessary.
   */

  this.opt_len = 0;       /* bit length of current block with optimal trees */
  this.static_len = 0;    /* bit length of current block with static trees */
  this.matches = 0;       /* number of string matches in current block */
  this.insert = 0;        /* bytes at end of window left to insert */


  this.bi_buf = 0;
  /* Output buffer. bits are inserted starting at the bottom (least
   * significant bits).
   */
  this.bi_valid = 0;
  /* Number of valid bits in bi_buf.  All bits above the last valid bit
   * are always zero.
   */

  // Used for window memory init. We safely ignore it for JS. That makes
  // sense only for pointers and memory check tools.
  //this.high_water = 0;
  /* High water mark offset in window for initialized bytes -- bytes above
   * this are set to zero in order to avoid memory check warnings when
   * longest match routines access bytes past the input.  This is then
   * updated to the new high water mark.
   */
}


function deflateResetKeep(strm) {
  var s;

  if (!strm || !strm.state) {
    return err(strm, Z_STREAM_ERROR);
  }

  strm.total_in = strm.total_out = 0;
  strm.data_type = Z_UNKNOWN;

  s = strm.state;
  s.pending = 0;
  s.pending_out = 0;

  if (s.wrap < 0) {
    s.wrap = -s.wrap;
    /* was made negative by deflate(..., Z_FINISH); */
  }
  s.status = (s.wrap ? INIT_STATE : BUSY_STATE);
  strm.adler = (s.wrap === 2) ?
    0  // crc32(0, Z_NULL, 0)
  :
    1; // adler32(0, Z_NULL, 0)
  s.last_flush = Z_NO_FLUSH;
  trees._tr_init(s);
  return Z_OK;
}


function deflateReset(strm) {
  var ret = deflateResetKeep(strm);
  if (ret === Z_OK) {
    lm_init(strm.state);
  }
  return ret;
}


function deflateSetHeader(strm, head) {
  if (!strm || !strm.state) { return Z_STREAM_ERROR; }
  if (strm.state.wrap !== 2) { return Z_STREAM_ERROR; }
  strm.state.gzhead = head;
  return Z_OK;
}


function deflateInit2(strm, level, method, windowBits, memLevel, strategy) {
  if (!strm) { // === Z_NULL
    return Z_STREAM_ERROR;
  }
  var wrap = 1;

  if (level === Z_DEFAULT_COMPRESSION) {
    level = 6;
  }

  if (windowBits < 0) { /* suppress zlib wrapper */
    wrap = 0;
    windowBits = -windowBits;
  }

  else if (windowBits > 15) {
    wrap = 2;           /* write gzip wrapper instead */
    windowBits -= 16;
  }


  if (memLevel < 1 || memLevel > MAX_MEM_LEVEL || method !== Z_DEFLATED ||
    windowBits < 8 || windowBits > 15 || level < 0 || level > 9 ||
    strategy < 0 || strategy > Z_FIXED) {
    return err(strm, Z_STREAM_ERROR);
  }


  if (windowBits === 8) {
    windowBits = 9;
  }
  /* until 256-byte window bug fixed */

  var s = new DeflateState();

  strm.state = s;
  s.strm = strm;

  s.wrap = wrap;
  s.gzhead = null;
  s.w_bits = windowBits;
  s.w_size = 1 << s.w_bits;
  s.w_mask = s.w_size - 1;

  s.hash_bits = memLevel + 7;
  s.hash_size = 1 << s.hash_bits;
  s.hash_mask = s.hash_size - 1;
  s.hash_shift = ~~((s.hash_bits + MIN_MATCH - 1) / MIN_MATCH);

  s.window = new utils.Buf8(s.w_size * 2);
  s.head = new utils.Buf16(s.hash_size);
  s.prev = new utils.Buf16(s.w_size);

  // Don't need mem init magic for JS.
  //s.high_water = 0;  /* nothing written to s->window yet */

  s.lit_bufsize = 1 << (memLevel + 6); /* 16K elements by default */

  s.pending_buf_size = s.lit_bufsize * 4;

  //overlay = (ushf *) ZALLOC(strm, s->lit_bufsize, sizeof(ush)+2);
  //s->pending_buf = (uchf *) overlay;
  s.pending_buf = new utils.Buf8(s.pending_buf_size);

  // It is offset from `s.pending_buf` (size is `s.lit_bufsize * 2`)
  //s->d_buf = overlay + s->lit_bufsize/sizeof(ush);
  s.d_buf = 1 * s.lit_bufsize;

  //s->l_buf = s->pending_buf + (1+sizeof(ush))*s->lit_bufsize;
  s.l_buf = (1 + 2) * s.lit_bufsize;

  s.level = level;
  s.strategy = strategy;
  s.method = method;

  return deflateReset(strm);
}

function deflateInit(strm, level) {
  return deflateInit2(strm, level, Z_DEFLATED, MAX_WBITS, DEF_MEM_LEVEL, Z_DEFAULT_STRATEGY);
}


function deflate(strm, flush) {
  var old_flush, s;
  var beg, val; // for gzip header write only

  if (!strm || !strm.state ||
    flush > Z_BLOCK || flush < 0) {
    return strm ? err(strm, Z_STREAM_ERROR) : Z_STREAM_ERROR;
  }

  s = strm.state;

  if (!strm.output ||
      (!strm.input && strm.avail_in !== 0) ||
      (s.status === FINISH_STATE && flush !== Z_FINISH)) {
    return err(strm, (strm.avail_out === 0) ? Z_BUF_ERROR : Z_STREAM_ERROR);
  }

  s.strm = strm; /* just in case */
  old_flush = s.last_flush;
  s.last_flush = flush;

  /* Write the header */
  if (s.status === INIT_STATE) {

    if (s.wrap === 2) { // GZIP header
      strm.adler = 0;  //crc32(0L, Z_NULL, 0);
      put_byte(s, 31);
      put_byte(s, 139);
      put_byte(s, 8);
      if (!s.gzhead) { // s->gzhead == Z_NULL
        put_byte(s, 0);
        put_byte(s, 0);
        put_byte(s, 0);
        put_byte(s, 0);
        put_byte(s, 0);
        put_byte(s, s.level === 9 ? 2 :
                    (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ?
                     4 : 0));
        put_byte(s, OS_CODE);
        s.status = BUSY_STATE;
      }
      else {
        put_byte(s, (s.gzhead.text ? 1 : 0) +
                    (s.gzhead.hcrc ? 2 : 0) +
                    (!s.gzhead.extra ? 0 : 4) +
                    (!s.gzhead.name ? 0 : 8) +
                    (!s.gzhead.comment ? 0 : 16)
        );
        put_byte(s, s.gzhead.time & 0xff);
        put_byte(s, (s.gzhead.time >> 8) & 0xff);
        put_byte(s, (s.gzhead.time >> 16) & 0xff);
        put_byte(s, (s.gzhead.time >> 24) & 0xff);
        put_byte(s, s.level === 9 ? 2 :
                    (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ?
                     4 : 0));
        put_byte(s, s.gzhead.os & 0xff);
        if (s.gzhead.extra && s.gzhead.extra.length) {
          put_byte(s, s.gzhead.extra.length & 0xff);
          put_byte(s, (s.gzhead.extra.length >> 8) & 0xff);
        }
        if (s.gzhead.hcrc) {
          strm.adler = crc32(strm.adler, s.pending_buf, s.pending, 0);
        }
        s.gzindex = 0;
        s.status = EXTRA_STATE;
      }
    }
    else // DEFLATE header
    {
      var header = (Z_DEFLATED + ((s.w_bits - 8) << 4)) << 8;
      var level_flags = -1;

      if (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2) {
        level_flags = 0;
      } else if (s.level < 6) {
        level_flags = 1;
      } else if (s.level === 6) {
        level_flags = 2;
      } else {
        level_flags = 3;
      }
      header |= (level_flags << 6);
      if (s.strstart !== 0) { header |= PRESET_DICT; }
      header += 31 - (header % 31);

      s.status = BUSY_STATE;
      putShortMSB(s, header);

      /* Save the adler32 of the preset dictionary: */
      if (s.strstart !== 0) {
        putShortMSB(s, strm.adler >>> 16);
        putShortMSB(s, strm.adler & 0xffff);
      }
      strm.adler = 1; // adler32(0L, Z_NULL, 0);
    }
  }

//#ifdef GZIP
  if (s.status === EXTRA_STATE) {
    if (s.gzhead.extra/* != Z_NULL*/) {
      beg = s.pending;  /* start of bytes to update crc */

      while (s.gzindex < (s.gzhead.extra.length & 0xffff)) {
        if (s.pending === s.pending_buf_size) {
          if (s.gzhead.hcrc && s.pending > beg) {
            strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
          }
          flush_pending(strm);
          beg = s.pending;
          if (s.pending === s.pending_buf_size) {
            break;
          }
        }
        put_byte(s, s.gzhead.extra[s.gzindex] & 0xff);
        s.gzindex++;
      }
      if (s.gzhead.hcrc && s.pending > beg) {
        strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
      }
      if (s.gzindex === s.gzhead.extra.length) {
        s.gzindex = 0;
        s.status = NAME_STATE;
      }
    }
    else {
      s.status = NAME_STATE;
    }
  }
  if (s.status === NAME_STATE) {
    if (s.gzhead.name/* != Z_NULL*/) {
      beg = s.pending;  /* start of bytes to update crc */
      //int val;

      do {
        if (s.pending === s.pending_buf_size) {
          if (s.gzhead.hcrc && s.pending > beg) {
            strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
          }
          flush_pending(strm);
          beg = s.pending;
          if (s.pending === s.pending_buf_size) {
            val = 1;
            break;
          }
        }
        // JS specific: little magic to add zero terminator to end of string
        if (s.gzindex < s.gzhead.name.length) {
          val = s.gzhead.name.charCodeAt(s.gzindex++) & 0xff;
        } else {
          val = 0;
        }
        put_byte(s, val);
      } while (val !== 0);

      if (s.gzhead.hcrc && s.pending > beg) {
        strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
      }
      if (val === 0) {
        s.gzindex = 0;
        s.status = COMMENT_STATE;
      }
    }
    else {
      s.status = COMMENT_STATE;
    }
  }
  if (s.status === COMMENT_STATE) {
    if (s.gzhead.comment/* != Z_NULL*/) {
      beg = s.pending;  /* start of bytes to update crc */
      //int val;

      do {
        if (s.pending === s.pending_buf_size) {
          if (s.gzhead.hcrc && s.pending > beg) {
            strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
          }
          flush_pending(strm);
          beg = s.pending;
          if (s.pending === s.pending_buf_size) {
            val = 1;
            break;
          }
        }
        // JS specific: little magic to add zero terminator to end of string
        if (s.gzindex < s.gzhead.comment.length) {
          val = s.gzhead.comment.charCodeAt(s.gzindex++) & 0xff;
        } else {
          val = 0;
        }
        put_byte(s, val);
      } while (val !== 0);

      if (s.gzhead.hcrc && s.pending > beg) {
        strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
      }
      if (val === 0) {
        s.status = HCRC_STATE;
      }
    }
    else {
      s.status = HCRC_STATE;
    }
  }
  if (s.status === HCRC_STATE) {
    if (s.gzhead.hcrc) {
      if (s.pending + 2 > s.pending_buf_size) {
        flush_pending(strm);
      }
      if (s.pending + 2 <= s.pending_buf_size) {
        put_byte(s, strm.adler & 0xff);
        put_byte(s, (strm.adler >> 8) & 0xff);
        strm.adler = 0; //crc32(0L, Z_NULL, 0);
        s.status = BUSY_STATE;
      }
    }
    else {
      s.status = BUSY_STATE;
    }
  }
//#endif

  /* Flush as much pending output as possible */
  if (s.pending !== 0) {
    flush_pending(strm);
    if (strm.avail_out === 0) {
      /* Since avail_out is 0, deflate will be called again with
       * more output space, but possibly with both pending and
       * avail_in equal to zero. There won't be anything to do,
       * but this is not an error situation so make sure we
       * return OK instead of BUF_ERROR at next call of deflate:
       */
      s.last_flush = -1;
      return Z_OK;
    }

    /* Make sure there is something to do and avoid duplicate consecutive
     * flushes. For repeated and useless calls with Z_FINISH, we keep
     * returning Z_STREAM_END instead of Z_BUF_ERROR.
     */
  } else if (strm.avail_in === 0 && rank(flush) <= rank(old_flush) &&
    flush !== Z_FINISH) {
    return err(strm, Z_BUF_ERROR);
  }

  /* User must not provide more input after the first FINISH: */
  if (s.status === FINISH_STATE && strm.avail_in !== 0) {
    return err(strm, Z_BUF_ERROR);
  }

  /* Start a new block or continue the current one.
   */
  if (strm.avail_in !== 0 || s.lookahead !== 0 ||
    (flush !== Z_NO_FLUSH && s.status !== FINISH_STATE)) {
    var bstate = (s.strategy === Z_HUFFMAN_ONLY) ? deflate_huff(s, flush) :
      (s.strategy === Z_RLE ? deflate_rle(s, flush) :
        configuration_table[s.level].func(s, flush));

    if (bstate === BS_FINISH_STARTED || bstate === BS_FINISH_DONE) {
      s.status = FINISH_STATE;
    }
    if (bstate === BS_NEED_MORE || bstate === BS_FINISH_STARTED) {
      if (strm.avail_out === 0) {
        s.last_flush = -1;
        /* avoid BUF_ERROR next call, see above */
      }
      return Z_OK;
      /* If flush != Z_NO_FLUSH && avail_out == 0, the next call
       * of deflate should use the same flush parameter to make sure
       * that the flush is complete. So we don't have to output an
       * empty block here, this will be done at next call. This also
       * ensures that for a very small output buffer, we emit at most
       * one empty block.
       */
    }
    if (bstate === BS_BLOCK_DONE) {
      if (flush === Z_PARTIAL_FLUSH) {
        trees._tr_align(s);
      }
      else if (flush !== Z_BLOCK) { /* FULL_FLUSH or SYNC_FLUSH */

        trees._tr_stored_block(s, 0, 0, false);
        /* For a full flush, this empty block will be recognized
         * as a special marker by inflate_sync().
         */
        if (flush === Z_FULL_FLUSH) {
          /*** CLEAR_HASH(s); ***/             /* forget history */
          zero(s.head); // Fill with NIL (= 0);

          if (s.lookahead === 0) {
            s.strstart = 0;
            s.block_start = 0;
            s.insert = 0;
          }
        }
      }
      flush_pending(strm);
      if (strm.avail_out === 0) {
        s.last_flush = -1; /* avoid BUF_ERROR at next call, see above */
        return Z_OK;
      }
    }
  }
  //Assert(strm->avail_out > 0, "bug2");
  //if (strm.avail_out <= 0) { throw new Error("bug2");}

  if (flush !== Z_FINISH) { return Z_OK; }
  if (s.wrap <= 0) { return Z_STREAM_END; }

  /* Write the trailer */
  if (s.wrap === 2) {
    put_byte(s, strm.adler & 0xff);
    put_byte(s, (strm.adler >> 8) & 0xff);
    put_byte(s, (strm.adler >> 16) & 0xff);
    put_byte(s, (strm.adler >> 24) & 0xff);
    put_byte(s, strm.total_in & 0xff);
    put_byte(s, (strm.total_in >> 8) & 0xff);
    put_byte(s, (strm.total_in >> 16) & 0xff);
    put_byte(s, (strm.total_in >> 24) & 0xff);
  }
  else
  {
    putShortMSB(s, strm.adler >>> 16);
    putShortMSB(s, strm.adler & 0xffff);
  }

  flush_pending(strm);
  /* If avail_out is zero, the application will call deflate again
   * to flush the rest.
   */
  if (s.wrap > 0) { s.wrap = -s.wrap; }
  /* write the trailer only once! */
  return s.pending !== 0 ? Z_OK : Z_STREAM_END;
}

function deflateEnd(strm) {
  var status;

  if (!strm/*== Z_NULL*/ || !strm.state/*== Z_NULL*/) {
    return Z_STREAM_ERROR;
  }

  status = strm.state.status;
  if (status !== INIT_STATE &&
    status !== EXTRA_STATE &&
    status !== NAME_STATE &&
    status !== COMMENT_STATE &&
    status !== HCRC_STATE &&
    status !== BUSY_STATE &&
    status !== FINISH_STATE
  ) {
    return err(strm, Z_STREAM_ERROR);
  }

  strm.state = null;

  return status === BUSY_STATE ? err(strm, Z_DATA_ERROR) : Z_OK;
}


/* =========================================================================
 * Initializes the compression dictionary from the given byte
 * sequence without producing any compressed output.
 */
function deflateSetDictionary(strm, dictionary) {
  var dictLength = dictionary.length;

  var s;
  var str, n;
  var wrap;
  var avail;
  var next;
  var input;
  var tmpDict;

  if (!strm/*== Z_NULL*/ || !strm.state/*== Z_NULL*/) {
    return Z_STREAM_ERROR;
  }

  s = strm.state;
  wrap = s.wrap;

  if (wrap === 2 || (wrap === 1 && s.status !== INIT_STATE) || s.lookahead) {
    return Z_STREAM_ERROR;
  }

  /* when using zlib wrappers, compute Adler-32 for provided dictionary */
  if (wrap === 1) {
    /* adler32(strm->adler, dictionary, dictLength); */
    strm.adler = adler32(strm.adler, dictionary, dictLength, 0);
  }

  s.wrap = 0;   /* avoid computing Adler-32 in read_buf */

  /* if dictionary would fill window, just replace the history */
  if (dictLength >= s.w_size) {
    if (wrap === 0) {            /* already empty otherwise */
      /*** CLEAR_HASH(s); ***/
      zero(s.head); // Fill with NIL (= 0);
      s.strstart = 0;
      s.block_start = 0;
      s.insert = 0;
    }
    /* use the tail */
    // dictionary = dictionary.slice(dictLength - s.w_size);
    tmpDict = new utils.Buf8(s.w_size);
    utils.arraySet(tmpDict, dictionary, dictLength - s.w_size, s.w_size, 0);
    dictionary = tmpDict;
    dictLength = s.w_size;
  }
  /* insert dictionary into window and hash */
  avail = strm.avail_in;
  next = strm.next_in;
  input = strm.input;
  strm.avail_in = dictLength;
  strm.next_in = 0;
  strm.input = dictionary;
  fill_window(s);
  while (s.lookahead >= MIN_MATCH) {
    str = s.strstart;
    n = s.lookahead - (MIN_MATCH - 1);
    do {
      /* UPDATE_HASH(s, s->ins_h, s->window[str + MIN_MATCH-1]); */
      s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[str + MIN_MATCH - 1]) & s.hash_mask;

      s.prev[str & s.w_mask] = s.head[s.ins_h];

      s.head[s.ins_h] = str;
      str++;
    } while (--n);
    s.strstart = str;
    s.lookahead = MIN_MATCH - 1;
    fill_window(s);
  }
  s.strstart += s.lookahead;
  s.block_start = s.strstart;
  s.insert = s.lookahead;
  s.lookahead = 0;
  s.match_length = s.prev_length = MIN_MATCH - 1;
  s.match_available = 0;
  strm.next_in = next;
  strm.input = input;
  strm.avail_in = avail;
  s.wrap = wrap;
  return Z_OK;
}


exports.deflateInit = deflateInit;
exports.deflateInit2 = deflateInit2;
exports.deflateReset = deflateReset;
exports.deflateResetKeep = deflateResetKeep;
exports.deflateSetHeader = deflateSetHeader;
exports.deflate = deflate;
exports.deflateEnd = deflateEnd;
exports.deflateSetDictionary = deflateSetDictionary;
exports.deflateInfo = 'pako deflate (from Nodeca project)';

/* Not implemented
exports.deflateBound = deflateBound;
exports.deflateCopy = deflateCopy;
exports.deflateParams = deflateParams;
exports.deflatePending = deflatePending;
exports.deflatePrime = deflatePrime;
exports.deflateTune = deflateTune;
*/

},{"../utils/common":136,"./adler32":137,"./crc32":139,"./messages":141,"./trees":142}],141:[function(require,module,exports){
'use strict';

// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

module.exports = {
  2:      'need dictionary',     /* Z_NEED_DICT       2  */
  1:      'stream end',          /* Z_STREAM_END      1  */
  0:      '',                    /* Z_OK              0  */
  '-1':   'file error',          /* Z_ERRNO         (-1) */
  '-2':   'stream error',        /* Z_STREAM_ERROR  (-2) */
  '-3':   'data error',          /* Z_DATA_ERROR    (-3) */
  '-4':   'insufficient memory', /* Z_MEM_ERROR     (-4) */
  '-5':   'buffer error',        /* Z_BUF_ERROR     (-5) */
  '-6':   'incompatible version' /* Z_VERSION_ERROR (-6) */
};

},{}],142:[function(require,module,exports){
'use strict';

// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

/* eslint-disable space-unary-ops */

var utils = require('../utils/common');

/* Public constants ==========================================================*/
/* ===========================================================================*/


//var Z_FILTERED          = 1;
//var Z_HUFFMAN_ONLY      = 2;
//var Z_RLE               = 3;
var Z_FIXED               = 4;
//var Z_DEFAULT_STRATEGY  = 0;

/* Possible values of the data_type field (though see inflate()) */
var Z_BINARY              = 0;
var Z_TEXT                = 1;
//var Z_ASCII             = 1; // = Z_TEXT
var Z_UNKNOWN             = 2;

/*============================================================================*/


function zero(buf) { var len = buf.length; while (--len >= 0) { buf[len] = 0; } }

// From zutil.h

var STORED_BLOCK = 0;
var STATIC_TREES = 1;
var DYN_TREES    = 2;
/* The three kinds of block type */

var MIN_MATCH    = 3;
var MAX_MATCH    = 258;
/* The minimum and maximum match lengths */

// From deflate.h
/* ===========================================================================
 * Internal compression state.
 */

var LENGTH_CODES  = 29;
/* number of length codes, not counting the special END_BLOCK code */

var LITERALS      = 256;
/* number of literal bytes 0..255 */

var L_CODES       = LITERALS + 1 + LENGTH_CODES;
/* number of Literal or Length codes, including the END_BLOCK code */

var D_CODES       = 30;
/* number of distance codes */

var BL_CODES      = 19;
/* number of codes used to transfer the bit lengths */

var HEAP_SIZE     = 2 * L_CODES + 1;
/* maximum heap size */

var MAX_BITS      = 15;
/* All codes must not exceed MAX_BITS bits */

var Buf_size      = 16;
/* size of bit buffer in bi_buf */


/* ===========================================================================
 * Constants
 */

var MAX_BL_BITS = 7;
/* Bit length codes must not exceed MAX_BL_BITS bits */

var END_BLOCK   = 256;
/* end of block literal code */

var REP_3_6     = 16;
/* repeat previous bit length 3-6 times (2 bits of repeat count) */

var REPZ_3_10   = 17;
/* repeat a zero length 3-10 times  (3 bits of repeat count) */

var REPZ_11_138 = 18;
/* repeat a zero length 11-138 times  (7 bits of repeat count) */

/* eslint-disable comma-spacing,array-bracket-spacing */
var extra_lbits =   /* extra bits for each length code */
  [0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0];

var extra_dbits =   /* extra bits for each distance code */
  [0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13];

var extra_blbits =  /* extra bits for each bit length code */
  [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,3,7];

var bl_order =
  [16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15];
/* eslint-enable comma-spacing,array-bracket-spacing */

/* The lengths of the bit length codes are sent in order of decreasing
 * probability, to avoid transmitting the lengths for unused bit length codes.
 */

/* ===========================================================================
 * Local data. These are initialized only once.
 */

// We pre-fill arrays with 0 to avoid uninitialized gaps

var DIST_CODE_LEN = 512; /* see definition of array dist_code below */

// !!!! Use flat array instead of structure, Freq = i*2, Len = i*2+1
var static_ltree  = new Array((L_CODES + 2) * 2);
zero(static_ltree);
/* The static literal tree. Since the bit lengths are imposed, there is no
 * need for the L_CODES extra codes used during heap construction. However
 * The codes 286 and 287 are needed to build a canonical tree (see _tr_init
 * below).
 */

var static_dtree  = new Array(D_CODES * 2);
zero(static_dtree);
/* The static distance tree. (Actually a trivial tree since all codes use
 * 5 bits.)
 */

var _dist_code    = new Array(DIST_CODE_LEN);
zero(_dist_code);
/* Distance codes. The first 256 values correspond to the distances
 * 3 .. 258, the last 256 values correspond to the top 8 bits of
 * the 15 bit distances.
 */

var _length_code  = new Array(MAX_MATCH - MIN_MATCH + 1);
zero(_length_code);
/* length code for each normalized match length (0 == MIN_MATCH) */

var base_length   = new Array(LENGTH_CODES);
zero(base_length);
/* First normalized length for each code (0 = MIN_MATCH) */

var base_dist     = new Array(D_CODES);
zero(base_dist);
/* First normalized distance for each code (0 = distance of 1) */


function StaticTreeDesc(static_tree, extra_bits, extra_base, elems, max_length) {

  this.static_tree  = static_tree;  /* static tree or NULL */
  this.extra_bits   = extra_bits;   /* extra bits for each code or NULL */
  this.extra_base   = extra_base;   /* base index for extra_bits */
  this.elems        = elems;        /* max number of elements in the tree */
  this.max_length   = max_length;   /* max bit length for the codes */

  // show if `static_tree` has data or dummy - needed for monomorphic objects
  this.has_stree    = static_tree && static_tree.length;
}


var static_l_desc;
var static_d_desc;
var static_bl_desc;


function TreeDesc(dyn_tree, stat_desc) {
  this.dyn_tree = dyn_tree;     /* the dynamic tree */
  this.max_code = 0;            /* largest code with non zero frequency */
  this.stat_desc = stat_desc;   /* the corresponding static tree */
}



function d_code(dist) {
  return dist < 256 ? _dist_code[dist] : _dist_code[256 + (dist >>> 7)];
}


/* ===========================================================================
 * Output a short LSB first on the stream.
 * IN assertion: there is enough room in pendingBuf.
 */
function put_short(s, w) {
//    put_byte(s, (uch)((w) & 0xff));
//    put_byte(s, (uch)((ush)(w) >> 8));
  s.pending_buf[s.pending++] = (w) & 0xff;
  s.pending_buf[s.pending++] = (w >>> 8) & 0xff;
}


/* ===========================================================================
 * Send a value on a given number of bits.
 * IN assertion: length <= 16 and value fits in length bits.
 */
function send_bits(s, value, length) {
  if (s.bi_valid > (Buf_size - length)) {
    s.bi_buf |= (value << s.bi_valid) & 0xffff;
    put_short(s, s.bi_buf);
    s.bi_buf = value >> (Buf_size - s.bi_valid);
    s.bi_valid += length - Buf_size;
  } else {
    s.bi_buf |= (value << s.bi_valid) & 0xffff;
    s.bi_valid += length;
  }
}


function send_code(s, c, tree) {
  send_bits(s, tree[c * 2]/*.Code*/, tree[c * 2 + 1]/*.Len*/);
}


/* ===========================================================================
 * Reverse the first len bits of a code, using straightforward code (a faster
 * method would use a table)
 * IN assertion: 1 <= len <= 15
 */
function bi_reverse(code, len) {
  var res = 0;
  do {
    res |= code & 1;
    code >>>= 1;
    res <<= 1;
  } while (--len > 0);
  return res >>> 1;
}


/* ===========================================================================
 * Flush the bit buffer, keeping at most 7 bits in it.
 */
function bi_flush(s) {
  if (s.bi_valid === 16) {
    put_short(s, s.bi_buf);
    s.bi_buf = 0;
    s.bi_valid = 0;

  } else if (s.bi_valid >= 8) {
    s.pending_buf[s.pending++] = s.bi_buf & 0xff;
    s.bi_buf >>= 8;
    s.bi_valid -= 8;
  }
}


/* ===========================================================================
 * Compute the optimal bit lengths for a tree and update the total bit length
 * for the current block.
 * IN assertion: the fields freq and dad are set, heap[heap_max] and
 *    above are the tree nodes sorted by increasing frequency.
 * OUT assertions: the field len is set to the optimal bit length, the
 *     array bl_count contains the frequencies for each bit length.
 *     The length opt_len is updated; static_len is also updated if stree is
 *     not null.
 */
function gen_bitlen(s, desc)
//    deflate_state *s;
//    tree_desc *desc;    /* the tree descriptor */
{
  var tree            = desc.dyn_tree;
  var max_code        = desc.max_code;
  var stree           = desc.stat_desc.static_tree;
  var has_stree       = desc.stat_desc.has_stree;
  var extra           = desc.stat_desc.extra_bits;
  var base            = desc.stat_desc.extra_base;
  var max_length      = desc.stat_desc.max_length;
  var h;              /* heap index */
  var n, m;           /* iterate over the tree elements */
  var bits;           /* bit length */
  var xbits;          /* extra bits */
  var f;              /* frequency */
  var overflow = 0;   /* number of elements with bit length too large */

  for (bits = 0; bits <= MAX_BITS; bits++) {
    s.bl_count[bits] = 0;
  }

  /* In a first pass, compute the optimal bit lengths (which may
   * overflow in the case of the bit length tree).
   */
  tree[s.heap[s.heap_max] * 2 + 1]/*.Len*/ = 0; /* root of the heap */

  for (h = s.heap_max + 1; h < HEAP_SIZE; h++) {
    n = s.heap[h];
    bits = tree[tree[n * 2 + 1]/*.Dad*/ * 2 + 1]/*.Len*/ + 1;
    if (bits > max_length) {
      bits = max_length;
      overflow++;
    }
    tree[n * 2 + 1]/*.Len*/ = bits;
    /* We overwrite tree[n].Dad which is no longer needed */

    if (n > max_code) { continue; } /* not a leaf node */

    s.bl_count[bits]++;
    xbits = 0;
    if (n >= base) {
      xbits = extra[n - base];
    }
    f = tree[n * 2]/*.Freq*/;
    s.opt_len += f * (bits + xbits);
    if (has_stree) {
      s.static_len += f * (stree[n * 2 + 1]/*.Len*/ + xbits);
    }
  }
  if (overflow === 0) { return; }

  // Trace((stderr,"\nbit length overflow\n"));
  /* This happens for example on obj2 and pic of the Calgary corpus */

  /* Find the first bit length which could increase: */
  do {
    bits = max_length - 1;
    while (s.bl_count[bits] === 0) { bits--; }
    s.bl_count[bits]--;      /* move one leaf down the tree */
    s.bl_count[bits + 1] += 2; /* move one overflow item as its brother */
    s.bl_count[max_length]--;
    /* The brother of the overflow item also moves one step up,
     * but this does not affect bl_count[max_length]
     */
    overflow -= 2;
  } while (overflow > 0);

  /* Now recompute all bit lengths, scanning in increasing frequency.
   * h is still equal to HEAP_SIZE. (It is simpler to reconstruct all
   * lengths instead of fixing only the wrong ones. This idea is taken
   * from 'ar' written by Haruhiko Okumura.)
   */
  for (bits = max_length; bits !== 0; bits--) {
    n = s.bl_count[bits];
    while (n !== 0) {
      m = s.heap[--h];
      if (m > max_code) { continue; }
      if (tree[m * 2 + 1]/*.Len*/ !== bits) {
        // Trace((stderr,"code %d bits %d->%d\n", m, tree[m].Len, bits));
        s.opt_len += (bits - tree[m * 2 + 1]/*.Len*/) * tree[m * 2]/*.Freq*/;
        tree[m * 2 + 1]/*.Len*/ = bits;
      }
      n--;
    }
  }
}


/* ===========================================================================
 * Generate the codes for a given tree and bit counts (which need not be
 * optimal).
 * IN assertion: the array bl_count contains the bit length statistics for
 * the given tree and the field len is set for all tree elements.
 * OUT assertion: the field code is set for all tree elements of non
 *     zero code length.
 */
function gen_codes(tree, max_code, bl_count)
//    ct_data *tree;             /* the tree to decorate */
//    int max_code;              /* largest code with non zero frequency */
//    ushf *bl_count;            /* number of codes at each bit length */
{
  var next_code = new Array(MAX_BITS + 1); /* next code value for each bit length */
  var code = 0;              /* running code value */
  var bits;                  /* bit index */
  var n;                     /* code index */

  /* The distribution counts are first used to generate the code values
   * without bit reversal.
   */
  for (bits = 1; bits <= MAX_BITS; bits++) {
    next_code[bits] = code = (code + bl_count[bits - 1]) << 1;
  }
  /* Check that the bit counts in bl_count are consistent. The last code
   * must be all ones.
   */
  //Assert (code + bl_count[MAX_BITS]-1 == (1<<MAX_BITS)-1,
  //        "inconsistent bit counts");
  //Tracev((stderr,"\ngen_codes: max_code %d ", max_code));

  for (n = 0;  n <= max_code; n++) {
    var len = tree[n * 2 + 1]/*.Len*/;
    if (len === 0) { continue; }
    /* Now reverse the bits */
    tree[n * 2]/*.Code*/ = bi_reverse(next_code[len]++, len);

    //Tracecv(tree != static_ltree, (stderr,"\nn %3d %c l %2d c %4x (%x) ",
    //     n, (isgraph(n) ? n : ' '), len, tree[n].Code, next_code[len]-1));
  }
}


/* ===========================================================================
 * Initialize the various 'constant' tables.
 */
function tr_static_init() {
  var n;        /* iterates over tree elements */
  var bits;     /* bit counter */
  var length;   /* length value */
  var code;     /* code value */
  var dist;     /* distance index */
  var bl_count = new Array(MAX_BITS + 1);
  /* number of codes at each bit length for an optimal tree */

  // do check in _tr_init()
  //if (static_init_done) return;

  /* For some embedded targets, global variables are not initialized: */
/*#ifdef NO_INIT_GLOBAL_POINTERS
  static_l_desc.static_tree = static_ltree;
  static_l_desc.extra_bits = extra_lbits;
  static_d_desc.static_tree = static_dtree;
  static_d_desc.extra_bits = extra_dbits;
  static_bl_desc.extra_bits = extra_blbits;
#endif*/

  /* Initialize the mapping length (0..255) -> length code (0..28) */
  length = 0;
  for (code = 0; code < LENGTH_CODES - 1; code++) {
    base_length[code] = length;
    for (n = 0; n < (1 << extra_lbits[code]); n++) {
      _length_code[length++] = code;
    }
  }
  //Assert (length == 256, "tr_static_init: length != 256");
  /* Note that the length 255 (match length 258) can be represented
   * in two different ways: code 284 + 5 bits or code 285, so we
   * overwrite length_code[255] to use the best encoding:
   */
  _length_code[length - 1] = code;

  /* Initialize the mapping dist (0..32K) -> dist code (0..29) */
  dist = 0;
  for (code = 0; code < 16; code++) {
    base_dist[code] = dist;
    for (n = 0; n < (1 << extra_dbits[code]); n++) {
      _dist_code[dist++] = code;
    }
  }
  //Assert (dist == 256, "tr_static_init: dist != 256");
  dist >>= 7; /* from now on, all distances are divided by 128 */
  for (; code < D_CODES; code++) {
    base_dist[code] = dist << 7;
    for (n = 0; n < (1 << (extra_dbits[code] - 7)); n++) {
      _dist_code[256 + dist++] = code;
    }
  }
  //Assert (dist == 256, "tr_static_init: 256+dist != 512");

  /* Construct the codes of the static literal tree */
  for (bits = 0; bits <= MAX_BITS; bits++) {
    bl_count[bits] = 0;
  }

  n = 0;
  while (n <= 143) {
    static_ltree[n * 2 + 1]/*.Len*/ = 8;
    n++;
    bl_count[8]++;
  }
  while (n <= 255) {
    static_ltree[n * 2 + 1]/*.Len*/ = 9;
    n++;
    bl_count[9]++;
  }
  while (n <= 279) {
    static_ltree[n * 2 + 1]/*.Len*/ = 7;
    n++;
    bl_count[7]++;
  }
  while (n <= 287) {
    static_ltree[n * 2 + 1]/*.Len*/ = 8;
    n++;
    bl_count[8]++;
  }
  /* Codes 286 and 287 do not exist, but we must include them in the
   * tree construction to get a canonical Huffman tree (longest code
   * all ones)
   */
  gen_codes(static_ltree, L_CODES + 1, bl_count);

  /* The static distance tree is trivial: */
  for (n = 0; n < D_CODES; n++) {
    static_dtree[n * 2 + 1]/*.Len*/ = 5;
    static_dtree[n * 2]/*.Code*/ = bi_reverse(n, 5);
  }

  // Now data ready and we can init static trees
  static_l_desc = new StaticTreeDesc(static_ltree, extra_lbits, LITERALS + 1, L_CODES, MAX_BITS);
  static_d_desc = new StaticTreeDesc(static_dtree, extra_dbits, 0,          D_CODES, MAX_BITS);
  static_bl_desc = new StaticTreeDesc(new Array(0), extra_blbits, 0,         BL_CODES, MAX_BL_BITS);

  //static_init_done = true;
}


/* ===========================================================================
 * Initialize a new block.
 */
function init_block(s) {
  var n; /* iterates over tree elements */

  /* Initialize the trees. */
  for (n = 0; n < L_CODES;  n++) { s.dyn_ltree[n * 2]/*.Freq*/ = 0; }
  for (n = 0; n < D_CODES;  n++) { s.dyn_dtree[n * 2]/*.Freq*/ = 0; }
  for (n = 0; n < BL_CODES; n++) { s.bl_tree[n * 2]/*.Freq*/ = 0; }

  s.dyn_ltree[END_BLOCK * 2]/*.Freq*/ = 1;
  s.opt_len = s.static_len = 0;
  s.last_lit = s.matches = 0;
}


/* ===========================================================================
 * Flush the bit buffer and align the output on a byte boundary
 */
function bi_windup(s)
{
  if (s.bi_valid > 8) {
    put_short(s, s.bi_buf);
  } else if (s.bi_valid > 0) {
    //put_byte(s, (Byte)s->bi_buf);
    s.pending_buf[s.pending++] = s.bi_buf;
  }
  s.bi_buf = 0;
  s.bi_valid = 0;
}

/* ===========================================================================
 * Copy a stored block, storing first the length and its
 * one's complement if requested.
 */
function copy_block(s, buf, len, header)
//DeflateState *s;
//charf    *buf;    /* the input data */
//unsigned len;     /* its length */
//int      header;  /* true if block header must be written */
{
  bi_windup(s);        /* align on byte boundary */

  if (header) {
    put_short(s, len);
    put_short(s, ~len);
  }
//  while (len--) {
//    put_byte(s, *buf++);
//  }
  utils.arraySet(s.pending_buf, s.window, buf, len, s.pending);
  s.pending += len;
}

/* ===========================================================================
 * Compares to subtrees, using the tree depth as tie breaker when
 * the subtrees have equal frequency. This minimizes the worst case length.
 */
function smaller(tree, n, m, depth) {
  var _n2 = n * 2;
  var _m2 = m * 2;
  return (tree[_n2]/*.Freq*/ < tree[_m2]/*.Freq*/ ||
         (tree[_n2]/*.Freq*/ === tree[_m2]/*.Freq*/ && depth[n] <= depth[m]));
}

/* ===========================================================================
 * Restore the heap property by moving down the tree starting at node k,
 * exchanging a node with the smallest of its two sons if necessary, stopping
 * when the heap property is re-established (each father smaller than its
 * two sons).
 */
function pqdownheap(s, tree, k)
//    deflate_state *s;
//    ct_data *tree;  /* the tree to restore */
//    int k;               /* node to move down */
{
  var v = s.heap[k];
  var j = k << 1;  /* left son of k */
  while (j <= s.heap_len) {
    /* Set j to the smallest of the two sons: */
    if (j < s.heap_len &&
      smaller(tree, s.heap[j + 1], s.heap[j], s.depth)) {
      j++;
    }
    /* Exit if v is smaller than both sons */
    if (smaller(tree, v, s.heap[j], s.depth)) { break; }

    /* Exchange v with the smallest son */
    s.heap[k] = s.heap[j];
    k = j;

    /* And continue down the tree, setting j to the left son of k */
    j <<= 1;
  }
  s.heap[k] = v;
}


// inlined manually
// var SMALLEST = 1;

/* ===========================================================================
 * Send the block data compressed using the given Huffman trees
 */
function compress_block(s, ltree, dtree)
//    deflate_state *s;
//    const ct_data *ltree; /* literal tree */
//    const ct_data *dtree; /* distance tree */
{
  var dist;           /* distance of matched string */
  var lc;             /* match length or unmatched char (if dist == 0) */
  var lx = 0;         /* running index in l_buf */
  var code;           /* the code to send */
  var extra;          /* number of extra bits to send */

  if (s.last_lit !== 0) {
    do {
      dist = (s.pending_buf[s.d_buf + lx * 2] << 8) | (s.pending_buf[s.d_buf + lx * 2 + 1]);
      lc = s.pending_buf[s.l_buf + lx];
      lx++;

      if (dist === 0) {
        send_code(s, lc, ltree); /* send a literal byte */
        //Tracecv(isgraph(lc), (stderr," '%c' ", lc));
      } else {
        /* Here, lc is the match length - MIN_MATCH */
        code = _length_code[lc];
        send_code(s, code + LITERALS + 1, ltree); /* send the length code */
        extra = extra_lbits[code];
        if (extra !== 0) {
          lc -= base_length[code];
          send_bits(s, lc, extra);       /* send the extra length bits */
        }
        dist--; /* dist is now the match distance - 1 */
        code = d_code(dist);
        //Assert (code < D_CODES, "bad d_code");

        send_code(s, code, dtree);       /* send the distance code */
        extra = extra_dbits[code];
        if (extra !== 0) {
          dist -= base_dist[code];
          send_bits(s, dist, extra);   /* send the extra distance bits */
        }
      } /* literal or match pair ? */

      /* Check that the overlay between pending_buf and d_buf+l_buf is ok: */
      //Assert((uInt)(s->pending) < s->lit_bufsize + 2*lx,
      //       "pendingBuf overflow");

    } while (lx < s.last_lit);
  }

  send_code(s, END_BLOCK, ltree);
}


/* ===========================================================================
 * Construct one Huffman tree and assigns the code bit strings and lengths.
 * Update the total bit length for the current block.
 * IN assertion: the field freq is set for all tree elements.
 * OUT assertions: the fields len and code are set to the optimal bit length
 *     and corresponding code. The length opt_len is updated; static_len is
 *     also updated if stree is not null. The field max_code is set.
 */
function build_tree(s, desc)
//    deflate_state *s;
//    tree_desc *desc; /* the tree descriptor */
{
  var tree     = desc.dyn_tree;
  var stree    = desc.stat_desc.static_tree;
  var has_stree = desc.stat_desc.has_stree;
  var elems    = desc.stat_desc.elems;
  var n, m;          /* iterate over heap elements */
  var max_code = -1; /* largest code with non zero frequency */
  var node;          /* new node being created */

  /* Construct the initial heap, with least frequent element in
   * heap[SMALLEST]. The sons of heap[n] are heap[2*n] and heap[2*n+1].
   * heap[0] is not used.
   */
  s.heap_len = 0;
  s.heap_max = HEAP_SIZE;

  for (n = 0; n < elems; n++) {
    if (tree[n * 2]/*.Freq*/ !== 0) {
      s.heap[++s.heap_len] = max_code = n;
      s.depth[n] = 0;

    } else {
      tree[n * 2 + 1]/*.Len*/ = 0;
    }
  }

  /* The pkzip format requires that at least one distance code exists,
   * and that at least one bit should be sent even if there is only one
   * possible code. So to avoid special checks later on we force at least
   * two codes of non zero frequency.
   */
  while (s.heap_len < 2) {
    node = s.heap[++s.heap_len] = (max_code < 2 ? ++max_code : 0);
    tree[node * 2]/*.Freq*/ = 1;
    s.depth[node] = 0;
    s.opt_len--;

    if (has_stree) {
      s.static_len -= stree[node * 2 + 1]/*.Len*/;
    }
    /* node is 0 or 1 so it does not have extra bits */
  }
  desc.max_code = max_code;

  /* The elements heap[heap_len/2+1 .. heap_len] are leaves of the tree,
   * establish sub-heaps of increasing lengths:
   */
  for (n = (s.heap_len >> 1/*int /2*/); n >= 1; n--) { pqdownheap(s, tree, n); }

  /* Construct the Huffman tree by repeatedly combining the least two
   * frequent nodes.
   */
  node = elems;              /* next internal node of the tree */
  do {
    //pqremove(s, tree, n);  /* n = node of least frequency */
    /*** pqremove ***/
    n = s.heap[1/*SMALLEST*/];
    s.heap[1/*SMALLEST*/] = s.heap[s.heap_len--];
    pqdownheap(s, tree, 1/*SMALLEST*/);
    /***/

    m = s.heap[1/*SMALLEST*/]; /* m = node of next least frequency */

    s.heap[--s.heap_max] = n; /* keep the nodes sorted by frequency */
    s.heap[--s.heap_max] = m;

    /* Create a new node father of n and m */
    tree[node * 2]/*.Freq*/ = tree[n * 2]/*.Freq*/ + tree[m * 2]/*.Freq*/;
    s.depth[node] = (s.depth[n] >= s.depth[m] ? s.depth[n] : s.depth[m]) + 1;
    tree[n * 2 + 1]/*.Dad*/ = tree[m * 2 + 1]/*.Dad*/ = node;

    /* and insert the new node in the heap */
    s.heap[1/*SMALLEST*/] = node++;
    pqdownheap(s, tree, 1/*SMALLEST*/);

  } while (s.heap_len >= 2);

  s.heap[--s.heap_max] = s.heap[1/*SMALLEST*/];

  /* At this point, the fields freq and dad are set. We can now
   * generate the bit lengths.
   */
  gen_bitlen(s, desc);

  /* The field len is now set, we can generate the bit codes */
  gen_codes(tree, max_code, s.bl_count);
}


/* ===========================================================================
 * Scan a literal or distance tree to determine the frequencies of the codes
 * in the bit length tree.
 */
function scan_tree(s, tree, max_code)
//    deflate_state *s;
//    ct_data *tree;   /* the tree to be scanned */
//    int max_code;    /* and its largest code of non zero frequency */
{
  var n;                     /* iterates over all tree elements */
  var prevlen = -1;          /* last emitted length */
  var curlen;                /* length of current code */

  var nextlen = tree[0 * 2 + 1]/*.Len*/; /* length of next code */

  var count = 0;             /* repeat count of the current code */
  var max_count = 7;         /* max repeat count */
  var min_count = 4;         /* min repeat count */

  if (nextlen === 0) {
    max_count = 138;
    min_count = 3;
  }
  tree[(max_code + 1) * 2 + 1]/*.Len*/ = 0xffff; /* guard */

  for (n = 0; n <= max_code; n++) {
    curlen = nextlen;
    nextlen = tree[(n + 1) * 2 + 1]/*.Len*/;

    if (++count < max_count && curlen === nextlen) {
      continue;

    } else if (count < min_count) {
      s.bl_tree[curlen * 2]/*.Freq*/ += count;

    } else if (curlen !== 0) {

      if (curlen !== prevlen) { s.bl_tree[curlen * 2]/*.Freq*/++; }
      s.bl_tree[REP_3_6 * 2]/*.Freq*/++;

    } else if (count <= 10) {
      s.bl_tree[REPZ_3_10 * 2]/*.Freq*/++;

    } else {
      s.bl_tree[REPZ_11_138 * 2]/*.Freq*/++;
    }

    count = 0;
    prevlen = curlen;

    if (nextlen === 0) {
      max_count = 138;
      min_count = 3;

    } else if (curlen === nextlen) {
      max_count = 6;
      min_count = 3;

    } else {
      max_count = 7;
      min_count = 4;
    }
  }
}


/* ===========================================================================
 * Send a literal or distance tree in compressed form, using the codes in
 * bl_tree.
 */
function send_tree(s, tree, max_code)
//    deflate_state *s;
//    ct_data *tree; /* the tree to be scanned */
//    int max_code;       /* and its largest code of non zero frequency */
{
  var n;                     /* iterates over all tree elements */
  var prevlen = -1;          /* last emitted length */
  var curlen;                /* length of current code */

  var nextlen = tree[0 * 2 + 1]/*.Len*/; /* length of next code */

  var count = 0;             /* repeat count of the current code */
  var max_count = 7;         /* max repeat count */
  var min_count = 4;         /* min repeat count */

  /* tree[max_code+1].Len = -1; */  /* guard already set */
  if (nextlen === 0) {
    max_count = 138;
    min_count = 3;
  }

  for (n = 0; n <= max_code; n++) {
    curlen = nextlen;
    nextlen = tree[(n + 1) * 2 + 1]/*.Len*/;

    if (++count < max_count && curlen === nextlen) {
      continue;

    } else if (count < min_count) {
      do { send_code(s, curlen, s.bl_tree); } while (--count !== 0);

    } else if (curlen !== 0) {
      if (curlen !== prevlen) {
        send_code(s, curlen, s.bl_tree);
        count--;
      }
      //Assert(count >= 3 && count <= 6, " 3_6?");
      send_code(s, REP_3_6, s.bl_tree);
      send_bits(s, count - 3, 2);

    } else if (count <= 10) {
      send_code(s, REPZ_3_10, s.bl_tree);
      send_bits(s, count - 3, 3);

    } else {
      send_code(s, REPZ_11_138, s.bl_tree);
      send_bits(s, count - 11, 7);
    }

    count = 0;
    prevlen = curlen;
    if (nextlen === 0) {
      max_count = 138;
      min_count = 3;

    } else if (curlen === nextlen) {
      max_count = 6;
      min_count = 3;

    } else {
      max_count = 7;
      min_count = 4;
    }
  }
}


/* ===========================================================================
 * Construct the Huffman tree for the bit lengths and return the index in
 * bl_order of the last bit length code to send.
 */
function build_bl_tree(s) {
  var max_blindex;  /* index of last bit length code of non zero freq */

  /* Determine the bit length frequencies for literal and distance trees */
  scan_tree(s, s.dyn_ltree, s.l_desc.max_code);
  scan_tree(s, s.dyn_dtree, s.d_desc.max_code);

  /* Build the bit length tree: */
  build_tree(s, s.bl_desc);
  /* opt_len now includes the length of the tree representations, except
   * the lengths of the bit lengths codes and the 5+5+4 bits for the counts.
   */

  /* Determine the number of bit length codes to send. The pkzip format
   * requires that at least 4 bit length codes be sent. (appnote.txt says
   * 3 but the actual value used is 4.)
   */
  for (max_blindex = BL_CODES - 1; max_blindex >= 3; max_blindex--) {
    if (s.bl_tree[bl_order[max_blindex] * 2 + 1]/*.Len*/ !== 0) {
      break;
    }
  }
  /* Update opt_len to include the bit length tree and counts */
  s.opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4;
  //Tracev((stderr, "\ndyn trees: dyn %ld, stat %ld",
  //        s->opt_len, s->static_len));

  return max_blindex;
}


/* ===========================================================================
 * Send the header for a block using dynamic Huffman trees: the counts, the
 * lengths of the bit length codes, the literal tree and the distance tree.
 * IN assertion: lcodes >= 257, dcodes >= 1, blcodes >= 4.
 */
function send_all_trees(s, lcodes, dcodes, blcodes)
//    deflate_state *s;
//    int lcodes, dcodes, blcodes; /* number of codes for each tree */
{
  var rank;                    /* index in bl_order */

  //Assert (lcodes >= 257 && dcodes >= 1 && blcodes >= 4, "not enough codes");
  //Assert (lcodes <= L_CODES && dcodes <= D_CODES && blcodes <= BL_CODES,
  //        "too many codes");
  //Tracev((stderr, "\nbl counts: "));
  send_bits(s, lcodes - 257, 5); /* not +255 as stated in appnote.txt */
  send_bits(s, dcodes - 1,   5);
  send_bits(s, blcodes - 4,  4); /* not -3 as stated in appnote.txt */
  for (rank = 0; rank < blcodes; rank++) {
    //Tracev((stderr, "\nbl code %2d ", bl_order[rank]));
    send_bits(s, s.bl_tree[bl_order[rank] * 2 + 1]/*.Len*/, 3);
  }
  //Tracev((stderr, "\nbl tree: sent %ld", s->bits_sent));

  send_tree(s, s.dyn_ltree, lcodes - 1); /* literal tree */
  //Tracev((stderr, "\nlit tree: sent %ld", s->bits_sent));

  send_tree(s, s.dyn_dtree, dcodes - 1); /* distance tree */
  //Tracev((stderr, "\ndist tree: sent %ld", s->bits_sent));
}


/* ===========================================================================
 * Check if the data type is TEXT or BINARY, using the following algorithm:
 * - TEXT if the two conditions below are satisfied:
 *    a) There are no non-portable control characters belonging to the
 *       "black list" (0..6, 14..25, 28..31).
 *    b) There is at least one printable character belonging to the
 *       "white list" (9 {TAB}, 10 {LF}, 13 {CR}, 32..255).
 * - BINARY otherwise.
 * - The following partially-portable control characters form a
 *   "gray list" that is ignored in this detection algorithm:
 *   (7 {BEL}, 8 {BS}, 11 {VT}, 12 {FF}, 26 {SUB}, 27 {ESC}).
 * IN assertion: the fields Freq of dyn_ltree are set.
 */
function detect_data_type(s) {
  /* black_mask is the bit mask of black-listed bytes
   * set bits 0..6, 14..25, and 28..31
   * 0xf3ffc07f = binary 11110011111111111100000001111111
   */
  var black_mask = 0xf3ffc07f;
  var n;

  /* Check for non-textual ("black-listed") bytes. */
  for (n = 0; n <= 31; n++, black_mask >>>= 1) {
    if ((black_mask & 1) && (s.dyn_ltree[n * 2]/*.Freq*/ !== 0)) {
      return Z_BINARY;
    }
  }

  /* Check for textual ("white-listed") bytes. */
  if (s.dyn_ltree[9 * 2]/*.Freq*/ !== 0 || s.dyn_ltree[10 * 2]/*.Freq*/ !== 0 ||
      s.dyn_ltree[13 * 2]/*.Freq*/ !== 0) {
    return Z_TEXT;
  }
  for (n = 32; n < LITERALS; n++) {
    if (s.dyn_ltree[n * 2]/*.Freq*/ !== 0) {
      return Z_TEXT;
    }
  }

  /* There are no "black-listed" or "white-listed" bytes:
   * this stream either is empty or has tolerated ("gray-listed") bytes only.
   */
  return Z_BINARY;
}


var static_init_done = false;

/* ===========================================================================
 * Initialize the tree data structures for a new zlib stream.
 */
function _tr_init(s)
{

  if (!static_init_done) {
    tr_static_init();
    static_init_done = true;
  }

  s.l_desc  = new TreeDesc(s.dyn_ltree, static_l_desc);
  s.d_desc  = new TreeDesc(s.dyn_dtree, static_d_desc);
  s.bl_desc = new TreeDesc(s.bl_tree, static_bl_desc);

  s.bi_buf = 0;
  s.bi_valid = 0;

  /* Initialize the first block of the first file: */
  init_block(s);
}


/* ===========================================================================
 * Send a stored block
 */
function _tr_stored_block(s, buf, stored_len, last)
//DeflateState *s;
//charf *buf;       /* input block */
//ulg stored_len;   /* length of input block */
//int last;         /* one if this is the last block for a file */
{
  send_bits(s, (STORED_BLOCK << 1) + (last ? 1 : 0), 3);    /* send block type */
  copy_block(s, buf, stored_len, true); /* with header */
}


/* ===========================================================================
 * Send one empty static block to give enough lookahead for inflate.
 * This takes 10 bits, of which 7 may remain in the bit buffer.
 */
function _tr_align(s) {
  send_bits(s, STATIC_TREES << 1, 3);
  send_code(s, END_BLOCK, static_ltree);
  bi_flush(s);
}


/* ===========================================================================
 * Determine the best encoding for the current block: dynamic trees, static
 * trees or store, and output the encoded block to the zip file.
 */
function _tr_flush_block(s, buf, stored_len, last)
//DeflateState *s;
//charf *buf;       /* input block, or NULL if too old */
//ulg stored_len;   /* length of input block */
//int last;         /* one if this is the last block for a file */
{
  var opt_lenb, static_lenb;  /* opt_len and static_len in bytes */
  var max_blindex = 0;        /* index of last bit length code of non zero freq */

  /* Build the Huffman trees unless a stored block is forced */
  if (s.level > 0) {

    /* Check if the file is binary or text */
    if (s.strm.data_type === Z_UNKNOWN) {
      s.strm.data_type = detect_data_type(s);
    }

    /* Construct the literal and distance trees */
    build_tree(s, s.l_desc);
    // Tracev((stderr, "\nlit data: dyn %ld, stat %ld", s->opt_len,
    //        s->static_len));

    build_tree(s, s.d_desc);
    // Tracev((stderr, "\ndist data: dyn %ld, stat %ld", s->opt_len,
    //        s->static_len));
    /* At this point, opt_len and static_len are the total bit lengths of
     * the compressed block data, excluding the tree representations.
     */

    /* Build the bit length tree for the above two trees, and get the index
     * in bl_order of the last bit length code to send.
     */
    max_blindex = build_bl_tree(s);

    /* Determine the best encoding. Compute the block lengths in bytes. */
    opt_lenb = (s.opt_len + 3 + 7) >>> 3;
    static_lenb = (s.static_len + 3 + 7) >>> 3;

    // Tracev((stderr, "\nopt %lu(%lu) stat %lu(%lu) stored %lu lit %u ",
    //        opt_lenb, s->opt_len, static_lenb, s->static_len, stored_len,
    //        s->last_lit));

    if (static_lenb <= opt_lenb) { opt_lenb = static_lenb; }

  } else {
    // Assert(buf != (char*)0, "lost buf");
    opt_lenb = static_lenb = stored_len + 5; /* force a stored block */
  }

  if ((stored_len + 4 <= opt_lenb) && (buf !== -1)) {
    /* 4: two words for the lengths */

    /* The test buf != NULL is only necessary if LIT_BUFSIZE > WSIZE.
     * Otherwise we can't have processed more than WSIZE input bytes since
     * the last block flush, because compression would have been
     * successful. If LIT_BUFSIZE <= WSIZE, it is never too late to
     * transform a block into a stored block.
     */
    _tr_stored_block(s, buf, stored_len, last);

  } else if (s.strategy === Z_FIXED || static_lenb === opt_lenb) {

    send_bits(s, (STATIC_TREES << 1) + (last ? 1 : 0), 3);
    compress_block(s, static_ltree, static_dtree);

  } else {
    send_bits(s, (DYN_TREES << 1) + (last ? 1 : 0), 3);
    send_all_trees(s, s.l_desc.max_code + 1, s.d_desc.max_code + 1, max_blindex + 1);
    compress_block(s, s.dyn_ltree, s.dyn_dtree);
  }
  // Assert (s->compressed_len == s->bits_sent, "bad compressed size");
  /* The above check is made mod 2^32, for files larger than 512 MB
   * and uLong implemented on 32 bits.
   */
  init_block(s);

  if (last) {
    bi_windup(s);
  }
  // Tracev((stderr,"\ncomprlen %lu(%lu) ", s->compressed_len>>3,
  //       s->compressed_len-7*last));
}

/* ===========================================================================
 * Save the match info and tally the frequency counts. Return true if
 * the current block must be flushed.
 */
function _tr_tally(s, dist, lc)
//    deflate_state *s;
//    unsigned dist;  /* distance of matched string */
//    unsigned lc;    /* match length-MIN_MATCH or unmatched char (if dist==0) */
{
  //var out_length, in_length, dcode;

  s.pending_buf[s.d_buf + s.last_lit * 2]     = (dist >>> 8) & 0xff;
  s.pending_buf[s.d_buf + s.last_lit * 2 + 1] = dist & 0xff;

  s.pending_buf[s.l_buf + s.last_lit] = lc & 0xff;
  s.last_lit++;

  if (dist === 0) {
    /* lc is the unmatched char */
    s.dyn_ltree[lc * 2]/*.Freq*/++;
  } else {
    s.matches++;
    /* Here, lc is the match length - MIN_MATCH */
    dist--;             /* dist = match distance - 1 */
    //Assert((ush)dist < (ush)MAX_DIST(s) &&
    //       (ush)lc <= (ush)(MAX_MATCH-MIN_MATCH) &&
    //       (ush)d_code(dist) < (ush)D_CODES,  "_tr_tally: bad match");

    s.dyn_ltree[(_length_code[lc] + LITERALS + 1) * 2]/*.Freq*/++;
    s.dyn_dtree[d_code(dist) * 2]/*.Freq*/++;
  }

// (!) This block is disabled in zlib defaults,
// don't enable it for binary compatibility

//#ifdef TRUNCATE_BLOCK
//  /* Try to guess if it is profitable to stop the current block here */
//  if ((s.last_lit & 0x1fff) === 0 && s.level > 2) {
//    /* Compute an upper bound for the compressed length */
//    out_length = s.last_lit*8;
//    in_length = s.strstart - s.block_start;
//
//    for (dcode = 0; dcode < D_CODES; dcode++) {
//      out_length += s.dyn_dtree[dcode*2]/*.Freq*/ * (5 + extra_dbits[dcode]);
//    }
//    out_length >>>= 3;
//    //Tracev((stderr,"\nlast_lit %u, in %ld, out ~%ld(%ld%%) ",
//    //       s->last_lit, in_length, out_length,
//    //       100L - out_length*100L/in_length));
//    if (s.matches < (s.last_lit>>1)/*int /2*/ && out_length < (in_length>>1)/*int /2*/) {
//      return true;
//    }
//  }
//#endif

  return (s.last_lit === s.lit_bufsize - 1);
  /* We avoid equality with lit_bufsize because of wraparound at 64K
   * on 16 bit machines and because stored blocks are restricted to
   * 64K-1 bytes.
   */
}

exports._tr_init  = _tr_init;
exports._tr_stored_block = _tr_stored_block;
exports._tr_flush_block  = _tr_flush_block;
exports._tr_tally = _tr_tally;
exports._tr_align = _tr_align;

},{"../utils/common":136}],143:[function(require,module,exports){
'use strict';

// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

function ZStream() {
  /* next input byte */
  this.input = null; // JS specific, because we have no pointers
  this.next_in = 0;
  /* number of bytes available at input */
  this.avail_in = 0;
  /* total number of input bytes read so far */
  this.total_in = 0;
  /* next output byte should be put there */
  this.output = null; // JS specific, because we have no pointers
  this.next_out = 0;
  /* remaining free space at output */
  this.avail_out = 0;
  /* total number of bytes output so far */
  this.total_out = 0;
  /* last error message, NULL if no error */
  this.msg = ''/*Z_NULL*/;
  /* not visible by applications */
  this.state = null;
  /* best guess about the data type: binary or text */
  this.data_type = 2/*Z_UNKNOWN*/;
  /* adler32 value of the uncompressed data */
  this.adler = 0;
}

module.exports = ZStream;

},{}],144:[function(require,module,exports){
arguments[4][133][0].apply(exports,arguments)
},{"dup":133}],145:[function(require,module,exports){
(function (Buffer){(function (){
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
/* eslint-disable no-proto */

'use strict'

var base64 = require('base64-js')
var ieee754 = require('ieee754')

exports.Buffer = Buffer
exports.SlowBuffer = SlowBuffer
exports.INSPECT_MAX_BYTES = 50

var K_MAX_LENGTH = 0x7fffffff
exports.kMaxLength = K_MAX_LENGTH

/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Print warning and recommend using `buffer` v4.x which has an Object
 *               implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * We report that the browser does not support typed arrays if the are not subclassable
 * using __proto__. Firefox 4-29 lacks support for adding new properties to `Uint8Array`
 * (See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438). IE 10 lacks support
 * for __proto__ and has a buggy typed array implementation.
 */
Buffer.TYPED_ARRAY_SUPPORT = typedArraySupport()

if (!Buffer.TYPED_ARRAY_SUPPORT && typeof console !== 'undefined' &&
    typeof console.error === 'function') {
  console.error(
    'This browser lacks typed array (Uint8Array) support which is required by ' +
    '`buffer` v5.x. Use `buffer` v4.x if you require old browser support.'
  )
}

function typedArraySupport () {
  // Can typed array instances can be augmented?
  try {
    var arr = new Uint8Array(1)
    arr.__proto__ = { __proto__: Uint8Array.prototype, foo: function () { return 42 } }
    return arr.foo() === 42
  } catch (e) {
    return false
  }
}

Object.defineProperty(Buffer.prototype, 'parent', {
  enumerable: true,
  get: function () {
    if (!Buffer.isBuffer(this)) return undefined
    return this.buffer
  }
})

Object.defineProperty(Buffer.prototype, 'offset', {
  enumerable: true,
  get: function () {
    if (!Buffer.isBuffer(this)) return undefined
    return this.byteOffset
  }
})

function createBuffer (length) {
  if (length > K_MAX_LENGTH) {
    throw new RangeError('The value "' + length + '" is invalid for option "size"')
  }
  // Return an augmented `Uint8Array` instance
  var buf = new Uint8Array(length)
  buf.__proto__ = Buffer.prototype
  return buf
}

/**
 * The Buffer constructor returns instances of `Uint8Array` that have their
 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
 * returns a single octet.
 *
 * The `Uint8Array` prototype remains unmodified.
 */

function Buffer (arg, encodingOrOffset, length) {
  // Common case.
  if (typeof arg === 'number') {
    if (typeof encodingOrOffset === 'string') {
      throw new TypeError(
        'The "string" argument must be of type string. Received type number'
      )
    }
    return allocUnsafe(arg)
  }
  return from(arg, encodingOrOffset, length)
}

// Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97
if (typeof Symbol !== 'undefined' && Symbol.species != null &&
    Buffer[Symbol.species] === Buffer) {
  Object.defineProperty(Buffer, Symbol.species, {
    value: null,
    configurable: true,
    enumerable: false,
    writable: false
  })
}

Buffer.poolSize = 8192 // not used by this implementation

function from (value, encodingOrOffset, length) {
  if (typeof value === 'string') {
    return fromString(value, encodingOrOffset)
  }

  if (ArrayBuffer.isView(value)) {
    return fromArrayLike(value)
  }

  if (value == null) {
    throw TypeError(
      'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +
      'or Array-like Object. Received type ' + (typeof value)
    )
  }

  if (isInstance(value, ArrayBuffer) ||
      (value && isInstance(value.buffer, ArrayBuffer))) {
    return fromArrayBuffer(value, encodingOrOffset, length)
  }

  if (typeof value === 'number') {
    throw new TypeError(
      'The "value" argument must not be of type number. Received type number'
    )
  }

  var valueOf = value.valueOf && value.valueOf()
  if (valueOf != null && valueOf !== value) {
    return Buffer.from(valueOf, encodingOrOffset, length)
  }

  var b = fromObject(value)
  if (b) return b

  if (typeof Symbol !== 'undefined' && Symbol.toPrimitive != null &&
      typeof value[Symbol.toPrimitive] === 'function') {
    return Buffer.from(
      value[Symbol.toPrimitive]('string'), encodingOrOffset, length
    )
  }

  throw new TypeError(
    'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +
    'or Array-like Object. Received type ' + (typeof value)
  )
}

/**
 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
 * if value is a number.
 * Buffer.from(str[, encoding])
 * Buffer.from(array)
 * Buffer.from(buffer)
 * Buffer.from(arrayBuffer[, byteOffset[, length]])
 **/
Buffer.from = function (value, encodingOrOffset, length) {
  return from(value, encodingOrOffset, length)
}

// Note: Change prototype *after* Buffer.from is defined to workaround Chrome bug:
// https://github.com/feross/buffer/pull/148
Buffer.prototype.__proto__ = Uint8Array.prototype
Buffer.__proto__ = Uint8Array

function assertSize (size) {
  if (typeof size !== 'number') {
    throw new TypeError('"size" argument must be of type number')
  } else if (size < 0) {
    throw new RangeError('The value "' + size + '" is invalid for option "size"')
  }
}

function alloc (size, fill, encoding) {
  assertSize(size)
  if (size <= 0) {
    return createBuffer(size)
  }
  if (fill !== undefined) {
    // Only pay attention to encoding if it's a string. This
    // prevents accidentally sending in a number that would
    // be interpretted as a start offset.
    return typeof encoding === 'string'
      ? createBuffer(size).fill(fill, encoding)
      : createBuffer(size).fill(fill)
  }
  return createBuffer(size)
}

/**
 * Creates a new filled Buffer instance.
 * alloc(size[, fill[, encoding]])
 **/
Buffer.alloc = function (size, fill, encoding) {
  return alloc(size, fill, encoding)
}

function allocUnsafe (size) {
  assertSize(size)
  return createBuffer(size < 0 ? 0 : checked(size) | 0)
}

/**
 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
 * */
Buffer.allocUnsafe = function (size) {
  return allocUnsafe(size)
}
/**
 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
 */
Buffer.allocUnsafeSlow = function (size) {
  return allocUnsafe(size)
}

function fromString (string, encoding) {
  if (typeof encoding !== 'string' || encoding === '') {
    encoding = 'utf8'
  }

  if (!Buffer.isEncoding(encoding)) {
    throw new TypeError('Unknown encoding: ' + encoding)
  }

  var length = byteLength(string, encoding) | 0
  var buf = createBuffer(length)

  var actual = buf.write(string, encoding)

  if (actual !== length) {
    // Writing a hex string, for example, that contains invalid characters will
    // cause everything after the first invalid character to be ignored. (e.g.
    // 'abxxcd' will be treated as 'ab')
    buf = buf.slice(0, actual)
  }

  return buf
}

function fromArrayLike (array) {
  var length = array.length < 0 ? 0 : checked(array.length) | 0
  var buf = createBuffer(length)
  for (var i = 0; i < length; i += 1) {
    buf[i] = array[i] & 255
  }
  return buf
}

function fromArrayBuffer (array, byteOffset, length) {
  if (byteOffset < 0 || array.byteLength < byteOffset) {
    throw new RangeError('"offset" is outside of buffer bounds')
  }

  if (array.byteLength < byteOffset + (length || 0)) {
    throw new RangeError('"length" is outside of buffer bounds')
  }

  var buf
  if (byteOffset === undefined && length === undefined) {
    buf = new Uint8Array(array)
  } else if (length === undefined) {
    buf = new Uint8Array(array, byteOffset)
  } else {
    buf = new Uint8Array(array, byteOffset, length)
  }

  // Return an augmented `Uint8Array` instance
  buf.__proto__ = Buffer.prototype
  return buf
}

function fromObject (obj) {
  if (Buffer.isBuffer(obj)) {
    var len = checked(obj.length) | 0
    var buf = createBuffer(len)

    if (buf.length === 0) {
      return buf
    }

    obj.copy(buf, 0, 0, len)
    return buf
  }

  if (obj.length !== undefined) {
    if (typeof obj.length !== 'number' || numberIsNaN(obj.length)) {
      return createBuffer(0)
    }
    return fromArrayLike(obj)
  }

  if (obj.type === 'Buffer' && Array.isArray(obj.data)) {
    return fromArrayLike(obj.data)
  }
}

function checked (length) {
  // Note: cannot use `length < K_MAX_LENGTH` here because that fails when
  // length is NaN (which is otherwise coerced to zero.)
  if (length >= K_MAX_LENGTH) {
    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
                         'size: 0x' + K_MAX_LENGTH.toString(16) + ' bytes')
  }
  return length | 0
}

function SlowBuffer (length) {
  if (+length != length) { // eslint-disable-line eqeqeq
    length = 0
  }
  return Buffer.alloc(+length)
}

Buffer.isBuffer = function isBuffer (b) {
  return b != null && b._isBuffer === true &&
    b !== Buffer.prototype // so Buffer.isBuffer(Buffer.prototype) will be false
}

Buffer.compare = function compare (a, b) {
  if (isInstance(a, Uint8Array)) a = Buffer.from(a, a.offset, a.byteLength)
  if (isInstance(b, Uint8Array)) b = Buffer.from(b, b.offset, b.byteLength)
  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
    throw new TypeError(
      'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
    )
  }

  if (a === b) return 0

  var x = a.length
  var y = b.length

  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i]
      y = b[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

Buffer.isEncoding = function isEncoding (encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'latin1':
    case 'binary':
    case 'base64':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true
    default:
      return false
  }
}

Buffer.concat = function concat (list, length) {
  if (!Array.isArray(list)) {
    throw new TypeError('"list" argument must be an Array of Buffers')
  }

  if (list.length === 0) {
    return Buffer.alloc(0)
  }

  var i
  if (length === undefined) {
    length = 0
    for (i = 0; i < list.length; ++i) {
      length += list[i].length
    }
  }

  var buffer = Buffer.allocUnsafe(length)
  var pos = 0
  for (i = 0; i < list.length; ++i) {
    var buf = list[i]
    if (isInstance(buf, Uint8Array)) {
      buf = Buffer.from(buf)
    }
    if (!Buffer.isBuffer(buf)) {
      throw new TypeError('"list" argument must be an Array of Buffers')
    }
    buf.copy(buffer, pos)
    pos += buf.length
  }
  return buffer
}

function byteLength (string, encoding) {
  if (Buffer.isBuffer(string)) {
    return string.length
  }
  if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {
    return string.byteLength
  }
  if (typeof string !== 'string') {
    throw new TypeError(
      'The "string" argument must be one of type string, Buffer, or ArrayBuffer. ' +
      'Received type ' + typeof string
    )
  }

  var len = string.length
  var mustMatch = (arguments.length > 2 && arguments[2] === true)
  if (!mustMatch && len === 0) return 0

  // Use a for loop to avoid recursion
  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'ascii':
      case 'latin1':
      case 'binary':
        return len
      case 'utf8':
      case 'utf-8':
        return utf8ToBytes(string).length
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return len * 2
      case 'hex':
        return len >>> 1
      case 'base64':
        return base64ToBytes(string).length
      default:
        if (loweredCase) {
          return mustMatch ? -1 : utf8ToBytes(string).length // assume utf8
        }
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}
Buffer.byteLength = byteLength

function slowToString (encoding, start, end) {
  var loweredCase = false

  // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
  // property of a typed array.

  // This behaves neither like String nor Uint8Array in that we set start/end
  // to their upper/lower bounds if the value passed is out of range.
  // undefined is handled specially as per ECMA-262 6th Edition,
  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
  if (start === undefined || start < 0) {
    start = 0
  }
  // Return early if start > this.length. Done here to prevent potential uint32
  // coercion fail below.
  if (start > this.length) {
    return ''
  }

  if (end === undefined || end > this.length) {
    end = this.length
  }

  if (end <= 0) {
    return ''
  }

  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.
  end >>>= 0
  start >>>= 0

  if (end <= start) {
    return ''
  }

  if (!encoding) encoding = 'utf8'

  while (true) {
    switch (encoding) {
      case 'hex':
        return hexSlice(this, start, end)

      case 'utf8':
      case 'utf-8':
        return utf8Slice(this, start, end)

      case 'ascii':
        return asciiSlice(this, start, end)

      case 'latin1':
      case 'binary':
        return latin1Slice(this, start, end)

      case 'base64':
        return base64Slice(this, start, end)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return utf16leSlice(this, start, end)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = (encoding + '').toLowerCase()
        loweredCase = true
    }
  }
}

// This property is used by `Buffer.isBuffer` (and the `is-buffer` npm package)
// to detect a Buffer instance. It's not possible to use `instanceof Buffer`
// reliably in a browserify context because there could be multiple different
// copies of the 'buffer' package in use. This method works even for Buffer
// instances that were created from another copy of the `buffer` package.
// See: https://github.com/feross/buffer/issues/154
Buffer.prototype._isBuffer = true

function swap (b, n, m) {
  var i = b[n]
  b[n] = b[m]
  b[m] = i
}

Buffer.prototype.swap16 = function swap16 () {
  var len = this.length
  if (len % 2 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 16-bits')
  }
  for (var i = 0; i < len; i += 2) {
    swap(this, i, i + 1)
  }
  return this
}

Buffer.prototype.swap32 = function swap32 () {
  var len = this.length
  if (len % 4 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 32-bits')
  }
  for (var i = 0; i < len; i += 4) {
    swap(this, i, i + 3)
    swap(this, i + 1, i + 2)
  }
  return this
}

Buffer.prototype.swap64 = function swap64 () {
  var len = this.length
  if (len % 8 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 64-bits')
  }
  for (var i = 0; i < len; i += 8) {
    swap(this, i, i + 7)
    swap(this, i + 1, i + 6)
    swap(this, i + 2, i + 5)
    swap(this, i + 3, i + 4)
  }
  return this
}

Buffer.prototype.toString = function toString () {
  var length = this.length
  if (length === 0) return ''
  if (arguments.length === 0) return utf8Slice(this, 0, length)
  return slowToString.apply(this, arguments)
}

Buffer.prototype.toLocaleString = Buffer.prototype.toString

Buffer.prototype.equals = function equals (b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
  if (this === b) return true
  return Buffer.compare(this, b) === 0
}

Buffer.prototype.inspect = function inspect () {
  var str = ''
  var max = exports.INSPECT_MAX_BYTES
  str = this.toString('hex', 0, max).replace(/(.{2})/g, '$1 ').trim()
  if (this.length > max) str += ' ... '
  return '<Buffer ' + str + '>'
}

Buffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {
  if (isInstance(target, Uint8Array)) {
    target = Buffer.from(target, target.offset, target.byteLength)
  }
  if (!Buffer.isBuffer(target)) {
    throw new TypeError(
      'The "target" argument must be one of type Buffer or Uint8Array. ' +
      'Received type ' + (typeof target)
    )
  }

  if (start === undefined) {
    start = 0
  }
  if (end === undefined) {
    end = target ? target.length : 0
  }
  if (thisStart === undefined) {
    thisStart = 0
  }
  if (thisEnd === undefined) {
    thisEnd = this.length
  }

  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
    throw new RangeError('out of range index')
  }

  if (thisStart >= thisEnd && start >= end) {
    return 0
  }
  if (thisStart >= thisEnd) {
    return -1
  }
  if (start >= end) {
    return 1
  }

  start >>>= 0
  end >>>= 0
  thisStart >>>= 0
  thisEnd >>>= 0

  if (this === target) return 0

  var x = thisEnd - thisStart
  var y = end - start
  var len = Math.min(x, y)

  var thisCopy = this.slice(thisStart, thisEnd)
  var targetCopy = target.slice(start, end)

  for (var i = 0; i < len; ++i) {
    if (thisCopy[i] !== targetCopy[i]) {
      x = thisCopy[i]
      y = targetCopy[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
//
// Arguments:
// - buffer - a Buffer to search
// - val - a string, Buffer, or number
// - byteOffset - an index into `buffer`; will be clamped to an int32
// - encoding - an optional encoding, relevant is val is a string
// - dir - true for indexOf, false for lastIndexOf
function bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {
  // Empty buffer means no match
  if (buffer.length === 0) return -1

  // Normalize byteOffset
  if (typeof byteOffset === 'string') {
    encoding = byteOffset
    byteOffset = 0
  } else if (byteOffset > 0x7fffffff) {
    byteOffset = 0x7fffffff
  } else if (byteOffset < -0x80000000) {
    byteOffset = -0x80000000
  }
  byteOffset = +byteOffset // Coerce to Number.
  if (numberIsNaN(byteOffset)) {
    // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
    byteOffset = dir ? 0 : (buffer.length - 1)
  }

  // Normalize byteOffset: negative offsets start from the end of the buffer
  if (byteOffset < 0) byteOffset = buffer.length + byteOffset
  if (byteOffset >= buffer.length) {
    if (dir) return -1
    else byteOffset = buffer.length - 1
  } else if (byteOffset < 0) {
    if (dir) byteOffset = 0
    else return -1
  }

  // Normalize val
  if (typeof val === 'string') {
    val = Buffer.from(val, encoding)
  }

  // Finally, search either indexOf (if dir is true) or lastIndexOf
  if (Buffer.isBuffer(val)) {
    // Special case: looking for empty string/buffer always fails
    if (val.length === 0) {
      return -1
    }
    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)
  } else if (typeof val === 'number') {
    val = val & 0xFF // Search for a byte value [0-255]
    if (typeof Uint8Array.prototype.indexOf === 'function') {
      if (dir) {
        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)
      } else {
        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)
      }
    }
    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)
  }

  throw new TypeError('val must be string, number or Buffer')
}

function arrayIndexOf (arr, val, byteOffset, encoding, dir) {
  var indexSize = 1
  var arrLength = arr.length
  var valLength = val.length

  if (encoding !== undefined) {
    encoding = String(encoding).toLowerCase()
    if (encoding === 'ucs2' || encoding === 'ucs-2' ||
        encoding === 'utf16le' || encoding === 'utf-16le') {
      if (arr.length < 2 || val.length < 2) {
        return -1
      }
      indexSize = 2
      arrLength /= 2
      valLength /= 2
      byteOffset /= 2
    }
  }

  function read (buf, i) {
    if (indexSize === 1) {
      return buf[i]
    } else {
      return buf.readUInt16BE(i * indexSize)
    }
  }

  var i
  if (dir) {
    var foundIndex = -1
    for (i = byteOffset; i < arrLength; i++) {
      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
        if (foundIndex === -1) foundIndex = i
        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize
      } else {
        if (foundIndex !== -1) i -= i - foundIndex
        foundIndex = -1
      }
    }
  } else {
    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength
    for (i = byteOffset; i >= 0; i--) {
      var found = true
      for (var j = 0; j < valLength; j++) {
        if (read(arr, i + j) !== read(val, j)) {
          found = false
          break
        }
      }
      if (found) return i
    }
  }

  return -1
}

Buffer.prototype.includes = function includes (val, byteOffset, encoding) {
  return this.indexOf(val, byteOffset, encoding) !== -1
}

Buffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)
}

Buffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)
}

function hexWrite (buf, string, offset, length) {
  offset = Number(offset) || 0
  var remaining = buf.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }

  var strLen = string.length

  if (length > strLen / 2) {
    length = strLen / 2
  }
  for (var i = 0; i < length; ++i) {
    var parsed = parseInt(string.substr(i * 2, 2), 16)
    if (numberIsNaN(parsed)) return i
    buf[offset + i] = parsed
  }
  return i
}

function utf8Write (buf, string, offset, length) {
  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
}

function asciiWrite (buf, string, offset, length) {
  return blitBuffer(asciiToBytes(string), buf, offset, length)
}

function latin1Write (buf, string, offset, length) {
  return asciiWrite(buf, string, offset, length)
}

function base64Write (buf, string, offset, length) {
  return blitBuffer(base64ToBytes(string), buf, offset, length)
}

function ucs2Write (buf, string, offset, length) {
  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
}

Buffer.prototype.write = function write (string, offset, length, encoding) {
  // Buffer#write(string)
  if (offset === undefined) {
    encoding = 'utf8'
    length = this.length
    offset = 0
  // Buffer#write(string, encoding)
  } else if (length === undefined && typeof offset === 'string') {
    encoding = offset
    length = this.length
    offset = 0
  // Buffer#write(string, offset[, length][, encoding])
  } else if (isFinite(offset)) {
    offset = offset >>> 0
    if (isFinite(length)) {
      length = length >>> 0
      if (encoding === undefined) encoding = 'utf8'
    } else {
      encoding = length
      length = undefined
    }
  } else {
    throw new Error(
      'Buffer.write(string, encoding, offset[, length]) is no longer supported'
    )
  }

  var remaining = this.length - offset
  if (length === undefined || length > remaining) length = remaining

  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
    throw new RangeError('Attempt to write outside buffer bounds')
  }

  if (!encoding) encoding = 'utf8'

  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'hex':
        return hexWrite(this, string, offset, length)

      case 'utf8':
      case 'utf-8':
        return utf8Write(this, string, offset, length)

      case 'ascii':
        return asciiWrite(this, string, offset, length)

      case 'latin1':
      case 'binary':
        return latin1Write(this, string, offset, length)

      case 'base64':
        // Warning: maxLength not taken into account in base64Write
        return base64Write(this, string, offset, length)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return ucs2Write(this, string, offset, length)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}

Buffer.prototype.toJSON = function toJSON () {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  }
}

function base64Slice (buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf)
  } else {
    return base64.fromByteArray(buf.slice(start, end))
  }
}

function utf8Slice (buf, start, end) {
  end = Math.min(buf.length, end)
  var res = []

  var i = start
  while (i < end) {
    var firstByte = buf[i]
    var codePoint = null
    var bytesPerSequence = (firstByte > 0xEF) ? 4
      : (firstByte > 0xDF) ? 3
        : (firstByte > 0xBF) ? 2
          : 1

    if (i + bytesPerSequence <= end) {
      var secondByte, thirdByte, fourthByte, tempCodePoint

      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 0x80) {
            codePoint = firstByte
          }
          break
        case 2:
          secondByte = buf[i + 1]
          if ((secondByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)
            if (tempCodePoint > 0x7F) {
              codePoint = tempCodePoint
            }
          }
          break
        case 3:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)
            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
              codePoint = tempCodePoint
            }
          }
          break
        case 4:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          fourthByte = buf[i + 3]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)
            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
              codePoint = tempCodePoint
            }
          }
      }
    }

    if (codePoint === null) {
      // we did not generate a valid codePoint so insert a
      // replacement char (U+FFFD) and advance only 1 byte
      codePoint = 0xFFFD
      bytesPerSequence = 1
    } else if (codePoint > 0xFFFF) {
      // encode to utf16 (surrogate pair dance)
      codePoint -= 0x10000
      res.push(codePoint >>> 10 & 0x3FF | 0xD800)
      codePoint = 0xDC00 | codePoint & 0x3FF
    }

    res.push(codePoint)
    i += bytesPerSequence
  }

  return decodeCodePointsArray(res)
}

// Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety
var MAX_ARGUMENTS_LENGTH = 0x1000

function decodeCodePointsArray (codePoints) {
  var len = codePoints.length
  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
  }

  // Decode in chunks to avoid "call stack size exceeded".
  var res = ''
  var i = 0
  while (i < len) {
    res += String.fromCharCode.apply(
      String,
      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
    )
  }
  return res
}

function asciiSlice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i] & 0x7F)
  }
  return ret
}

function latin1Slice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i])
  }
  return ret
}

function hexSlice (buf, start, end) {
  var len = buf.length

  if (!start || start < 0) start = 0
  if (!end || end < 0 || end > len) end = len

  var out = ''
  for (var i = start; i < end; ++i) {
    out += toHex(buf[i])
  }
  return out
}

function utf16leSlice (buf, start, end) {
  var bytes = buf.slice(start, end)
  var res = ''
  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + (bytes[i + 1] * 256))
  }
  return res
}

Buffer.prototype.slice = function slice (start, end) {
  var len = this.length
  start = ~~start
  end = end === undefined ? len : ~~end

  if (start < 0) {
    start += len
    if (start < 0) start = 0
  } else if (start > len) {
    start = len
  }

  if (end < 0) {
    end += len
    if (end < 0) end = 0
  } else if (end > len) {
    end = len
  }

  if (end < start) end = start

  var newBuf = this.subarray(start, end)
  // Return an augmented `Uint8Array` instance
  newBuf.__proto__ = Buffer.prototype
  return newBuf
}

/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */
function checkOffset (offset, ext, length) {
  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
}

Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }

  return val
}

Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    checkOffset(offset, byteLength, this.length)
  }

  var val = this[offset + --byteLength]
  var mul = 1
  while (byteLength > 0 && (mul *= 0x100)) {
    val += this[offset + --byteLength] * mul
  }

  return val
}

Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 1, this.length)
  return this[offset]
}

Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  return this[offset] | (this[offset + 1] << 8)
}

Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  return (this[offset] << 8) | this[offset + 1]
}

Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return ((this[offset]) |
      (this[offset + 1] << 8) |
      (this[offset + 2] << 16)) +
      (this[offset + 3] * 0x1000000)
}

Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] * 0x1000000) +
    ((this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    this[offset + 3])
}

Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var i = byteLength
  var mul = 1
  var val = this[offset + --i]
  while (i > 0 && (mul *= 0x100)) {
    val += this[offset + --i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 1, this.length)
  if (!(this[offset] & 0x80)) return (this[offset])
  return ((0xff - this[offset] + 1) * -1)
}

Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset] | (this[offset + 1] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset + 1] | (this[offset] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset]) |
    (this[offset + 1] << 8) |
    (this[offset + 2] << 16) |
    (this[offset + 3] << 24)
}

Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] << 24) |
    (this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    (this[offset + 3])
}

Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, true, 23, 4)
}

Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, false, 23, 4)
}

Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, true, 52, 8)
}

Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, false, 52, 8)
}

function checkInt (buf, value, offset, ext, max, min) {
  if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance')
  if (value > max || value < min) throw new RangeError('"value" argument is out of bounds')
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
}

Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var mul = 1
  var i = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var i = byteLength - 1
  var mul = 1
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  return offset + 2
}

Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  this[offset] = (value >>> 8)
  this[offset + 1] = (value & 0xff)
  return offset + 2
}

Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  this[offset + 3] = (value >>> 24)
  this[offset + 2] = (value >>> 16)
  this[offset + 1] = (value >>> 8)
  this[offset] = (value & 0xff)
  return offset + 4
}

Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  this[offset] = (value >>> 24)
  this[offset + 1] = (value >>> 16)
  this[offset + 2] = (value >>> 8)
  this[offset + 3] = (value & 0xff)
  return offset + 4
}

Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    var limit = Math.pow(2, (8 * byteLength) - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = 0
  var mul = 1
  var sub = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    var limit = Math.pow(2, (8 * byteLength) - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = byteLength - 1
  var mul = 1
  var sub = 0
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)
  if (value < 0) value = 0xff + value + 1
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  return offset + 2
}

Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  this[offset] = (value >>> 8)
  this[offset + 1] = (value & 0xff)
  return offset + 2
}

Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  this[offset + 2] = (value >>> 16)
  this[offset + 3] = (value >>> 24)
  return offset + 4
}

Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (value < 0) value = 0xffffffff + value + 1
  this[offset] = (value >>> 24)
  this[offset + 1] = (value >>> 16)
  this[offset + 2] = (value >>> 8)
  this[offset + 3] = (value & 0xff)
  return offset + 4
}

function checkIEEE754 (buf, value, offset, ext, max, min) {
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
  if (offset < 0) throw new RangeError('Index out of range')
}

function writeFloat (buf, value, offset, littleEndian, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
  }
  ieee754.write(buf, value, offset, littleEndian, 23, 4)
  return offset + 4
}

Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert)
}

Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert)
}

function writeDouble (buf, value, offset, littleEndian, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
  }
  ieee754.write(buf, value, offset, littleEndian, 52, 8)
  return offset + 8
}

Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert)
}

Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert)
}

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function copy (target, targetStart, start, end) {
  if (!Buffer.isBuffer(target)) throw new TypeError('argument should be a Buffer')
  if (!start) start = 0
  if (!end && end !== 0) end = this.length
  if (targetStart >= target.length) targetStart = target.length
  if (!targetStart) targetStart = 0
  if (end > 0 && end < start) end = start

  // Copy 0 bytes; we're done
  if (end === start) return 0
  if (target.length === 0 || this.length === 0) return 0

  // Fatal error conditions
  if (targetStart < 0) {
    throw new RangeError('targetStart out of bounds')
  }
  if (start < 0 || start >= this.length) throw new RangeError('Index out of range')
  if (end < 0) throw new RangeError('sourceEnd out of bounds')

  // Are we oob?
  if (end > this.length) end = this.length
  if (target.length - targetStart < end - start) {
    end = target.length - targetStart + start
  }

  var len = end - start

  if (this === target && typeof Uint8Array.prototype.copyWithin === 'function') {
    // Use built-in when available, missing from IE11
    this.copyWithin(targetStart, start, end)
  } else if (this === target && start < targetStart && targetStart < end) {
    // descending copy from end
    for (var i = len - 1; i >= 0; --i) {
      target[i + targetStart] = this[i + start]
    }
  } else {
    Uint8Array.prototype.set.call(
      target,
      this.subarray(start, end),
      targetStart
    )
  }

  return len
}

// Usage:
//    buffer.fill(number[, offset[, end]])
//    buffer.fill(buffer[, offset[, end]])
//    buffer.fill(string[, offset[, end]][, encoding])
Buffer.prototype.fill = function fill (val, start, end, encoding) {
  // Handle string cases:
  if (typeof val === 'string') {
    if (typeof start === 'string') {
      encoding = start
      start = 0
      end = this.length
    } else if (typeof end === 'string') {
      encoding = end
      end = this.length
    }
    if (encoding !== undefined && typeof encoding !== 'string') {
      throw new TypeError('encoding must be a string')
    }
    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
      throw new TypeError('Unknown encoding: ' + encoding)
    }
    if (val.length === 1) {
      var code = val.charCodeAt(0)
      if ((encoding === 'utf8' && code < 128) ||
          encoding === 'latin1') {
        // Fast path: If `val` fits into a single byte, use that numeric value.
        val = code
      }
    }
  } else if (typeof val === 'number') {
    val = val & 255
  }

  // Invalid ranges are not set to a default, so can range check early.
  if (start < 0 || this.length < start || this.length < end) {
    throw new RangeError('Out of range index')
  }

  if (end <= start) {
    return this
  }

  start = start >>> 0
  end = end === undefined ? this.length : end >>> 0

  if (!val) val = 0

  var i
  if (typeof val === 'number') {
    for (i = start; i < end; ++i) {
      this[i] = val
    }
  } else {
    var bytes = Buffer.isBuffer(val)
      ? val
      : Buffer.from(val, encoding)
    var len = bytes.length
    if (len === 0) {
      throw new TypeError('The value "' + val +
        '" is invalid for argument "value"')
    }
    for (i = 0; i < end - start; ++i) {
      this[i + start] = bytes[i % len]
    }
  }

  return this
}

// HELPER FUNCTIONS
// ================

var INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g

function base64clean (str) {
  // Node takes equal signs as end of the Base64 encoding
  str = str.split('=')[0]
  // Node strips out invalid characters like \n and \t from the string, base64-js does not
  str = str.trim().replace(INVALID_BASE64_RE, '')
  // Node converts strings with length < 2 to ''
  if (str.length < 2) return ''
  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
  while (str.length % 4 !== 0) {
    str = str + '='
  }
  return str
}

function toHex (n) {
  if (n < 16) return '0' + n.toString(16)
  return n.toString(16)
}

function utf8ToBytes (string, units) {
  units = units || Infinity
  var codePoint
  var length = string.length
  var leadSurrogate = null
  var bytes = []

  for (var i = 0; i < length; ++i) {
    codePoint = string.charCodeAt(i)

    // is surrogate component
    if (codePoint > 0xD7FF && codePoint < 0xE000) {
      // last char was a lead
      if (!leadSurrogate) {
        // no lead yet
        if (codePoint > 0xDBFF) {
          // unexpected trail
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        } else if (i + 1 === length) {
          // unpaired lead
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        }

        // valid lead
        leadSurrogate = codePoint

        continue
      }

      // 2 leads in a row
      if (codePoint < 0xDC00) {
        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
        leadSurrogate = codePoint
        continue
      }

      // valid surrogate pair
      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000
    } else if (leadSurrogate) {
      // valid bmp char, but last char was a lead
      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
    }

    leadSurrogate = null

    // encode utf8
    if (codePoint < 0x80) {
      if ((units -= 1) < 0) break
      bytes.push(codePoint)
    } else if (codePoint < 0x800) {
      if ((units -= 2) < 0) break
      bytes.push(
        codePoint >> 0x6 | 0xC0,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x10000) {
      if ((units -= 3) < 0) break
      bytes.push(
        codePoint >> 0xC | 0xE0,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x110000) {
      if ((units -= 4) < 0) break
      bytes.push(
        codePoint >> 0x12 | 0xF0,
        codePoint >> 0xC & 0x3F | 0x80,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else {
      throw new Error('Invalid code point')
    }
  }

  return bytes
}

function asciiToBytes (str) {
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF)
  }
  return byteArray
}

function utf16leToBytes (str, units) {
  var c, hi, lo
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    if ((units -= 2) < 0) break

    c = str.charCodeAt(i)
    hi = c >> 8
    lo = c % 256
    byteArray.push(lo)
    byteArray.push(hi)
  }

  return byteArray
}

function base64ToBytes (str) {
  return base64.toByteArray(base64clean(str))
}

function blitBuffer (src, dst, offset, length) {
  for (var i = 0; i < length; ++i) {
    if ((i + offset >= dst.length) || (i >= src.length)) break
    dst[i + offset] = src[i]
  }
  return i
}

// ArrayBuffer or Uint8Array objects from other contexts (i.e. iframes) do not pass
// the `instanceof` check but they should be treated as of that type.
// See: https://github.com/feross/buffer/issues/166
function isInstance (obj, type) {
  return obj instanceof type ||
    (obj != null && obj.constructor != null && obj.constructor.name != null &&
      obj.constructor.name === type.name)
}
function numberIsNaN (obj) {
  // For IE11 support
  return obj !== obj // eslint-disable-line no-self-compare
}

}).call(this)}).call(this,require("buffer").Buffer)
},{"base64-js":132,"buffer":145,"ieee754":172}],146:[function(require,module,exports){
'use strict';

var GetIntrinsic = require('get-intrinsic');

var callBind = require('./');

var $indexOf = callBind(GetIntrinsic('String.prototype.indexOf'));

module.exports = function callBoundIntrinsic(name, allowMissing) {
	var intrinsic = GetIntrinsic(name, !!allowMissing);
	if (typeof intrinsic === 'function' && $indexOf(name, '.prototype.') > -1) {
		return callBind(intrinsic);
	}
	return intrinsic;
};

},{"./":147,"get-intrinsic":166}],147:[function(require,module,exports){
'use strict';

var bind = require('function-bind');
var GetIntrinsic = require('get-intrinsic');

var $apply = GetIntrinsic('%Function.prototype.apply%');
var $call = GetIntrinsic('%Function.prototype.call%');
var $reflectApply = GetIntrinsic('%Reflect.apply%', true) || bind.call($call, $apply);

var $gOPD = GetIntrinsic('%Object.getOwnPropertyDescriptor%', true);
var $defineProperty = GetIntrinsic('%Object.defineProperty%', true);
var $max = GetIntrinsic('%Math.max%');

if ($defineProperty) {
	try {
		$defineProperty({}, 'a', { value: 1 });
	} catch (e) {
		// IE 8 has a broken defineProperty
		$defineProperty = null;
	}
}

module.exports = function callBind(originalFunction) {
	var func = $reflectApply(bind, $call, arguments);
	if ($gOPD && $defineProperty) {
		var desc = $gOPD(func, 'length');
		if (desc.configurable) {
			// original length, plus the receiver, minus any additional arguments (after the receiver)
			$defineProperty(
				func,
				'length',
				{ value: 1 + $max(0, originalFunction.length - (arguments.length - 1)) }
			);
		}
	}
	return func;
};

var applyBind = function applyBind() {
	return $reflectApply(bind, $apply, arguments);
};

if ($defineProperty) {
	$defineProperty(module.exports, 'apply', { value: applyBind });
} else {
	module.exports.apply = applyBind;
}

},{"function-bind":165,"get-intrinsic":166}],148:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.URLS = void 0;
exports.URLS = [
    '//gstatic.com/fsn/angular_js-bundle1.js',
    '//www.gstatic.com/fsn/angular_js-bundle1.js',
    '//www.googleadservices.com/pageadimg/imgad',
    '//yandex.st/angularjs/1.2.16/angular-cookies.min.js',
    '//yastatic.net/angularjs/1.2.23/angular.min.js',
    '//yuedust.yuedu.126.net/js/components/angular/angular.js',
    '//art.jobs.netease.com/script/angular.js',
    '//csu-c45.kxcdn.com/angular/angular.js',
    '//elysiumwebsite.s3.amazonaws.com/uploads/blog-media/rockstar/angular.min.js',
    '//inno.blob.core.windows.net/new/libs/AngularJS/1.2.1/angular.min.js',
    '//gift-talk.kakao.com/public/javascripts/angular.min.js',
    '//ajax.googleapis.com/ajax/libs/angularjs/1.2.0rc1/angular-route.min.js',
    '//master-sumok.ru/vendors/angular/angular-cookies.js',
    '//ayicommon-a.akamaihd.net/static/vendor/angular-1.4.2.min.js',
    '//pangxiehaitao.com/framework/angular-1.3.9/angular-animate.min.js',
    '//cdnjs.cloudflare.com/ajax/libs/angular.js/1.2.16/angular.min.js',
    '//96fe3ee995e96e922b6b-d10c35bd0a0de2c718b252bc575fdb73.ssl.cf1.rackcdn.com/angular.js',
    '//oss.maxcdn.com/angularjs/1.2.20/angular.min.js',
    '//reports.zemanta.com/smedia/common/angularjs/1.2.11/angular.js',
    '//cdn.shopify.com/s/files/1/0225/6463/t/1/assets/angular-animate.min.js',
    '//parademanagement.com.s3-website-ap-southeast-1.amazonaws.com/js/angular.min.js',
    '//cdn.jsdelivr.net/angularjs/1.1.2/angular.min.js',
    '//eb2883ede55c53e09fd5-9c145fb03d93709ea57875d307e2d82e.ssl.cf3.rackcdn.com/components/angular-resource.min.js',
    '//andors-trail.googlecode.com/git/AndorsTrailEdit/lib/angular.min.js',
    '//cdn.walkme.com/General/EnvironmentTests/angular/angular.min.js',
    '//laundrymail.com/angular/angular.js',
    '//s3-eu-west-1.amazonaws.com/staticancpa/js/angular-cookies.min.js',
    '//collade.demo.stswp.com/js/vendor/angular.min.js',
    '//mrfishie.github.io/sailor/bower_components/angular/angular.min.js',
    '//askgithub.com/static/js/angular.min.js',
    '//services.amazon.com/solution-providers/assets/vendor/angular-cookies.min.js',
    '//raw.githubusercontent.com/angular/code.angularjs.org/master/1.0.7/angular-resource.js',
    '//prb-resume.appspot.com/bower_components/angular-animate/angular-animate.js',
    '//dl.dropboxusercontent.com/u/30877786/angular.min.js',
    '//static.tumblr.com/x5qdx0r/nPOnngtff/angular-resource.min_1_.js',
    '//storage.googleapis.com/assets-prod.urbansitter.net/us-sym/assets/vendor/angular-sanitize/angular-sanitize.min.js',
    '//twitter.github.io/labella.js/bower_components/angular/angular.min.js',
    '//cdn2-casinoroom.global.ssl.fastly.net/js/lib/angular-animate.min.js',
    '//www.adobe.com/devnet-apps/flashshowcase/lib/angular/angular.1.1.5.min.js',
    '//eternal-sunset.herokuapp.com/bower_components/angular/angular.js',
    '//cdn.bootcss.com/angular.js/1.2.0/angular.min.js'
];

},{}],149:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.URLS = void 0;
exports.URLS = [
    '//vk.com/swf/video.swf',
    '//ajax.googleapis.com/ajax/libs/yui/2.8.0r4/build/charts/assets/charts.swf'
];

},{}],150:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.URLS = exports.NEEDS_EVAL = void 0;
exports.NEEDS_EVAL = [
    'googletagmanager.com', 'www.googletagmanager.com',
    'www.googleadservices.com', 'google-analytics.com',
    'ssl.google-analytics.com', 'www.google-analytics.com'
];
exports.URLS = [
    '//bebezoo.1688.com/fragment/index.htm',
    '//www.google-analytics.com/gtm/js',
    '//googleads.g.doubleclick.net/pagead/conversion/1036918760/wcm',
    '//www.googleadservices.com/pagead/conversion/1070110417/wcm',
    '//www.google.com/tools/feedback/escalation-options',
    '//pin.aliyun.com/check_audio',
    '//offer.alibaba.com/market/CID100002954/5/fetchKeyword.do',
    '//ccrprod.alipay.com/ccr/arriveTime.json',
    '//group.aliexpress.com/ajaxAcquireGroupbuyProduct.do',
    '//detector.alicdn.com/2.7.3/index.php',
    '//suggest.taobao.com/sug',
    '//translate.google.com/translate_a/l',
    '//count.tbcdn.cn//counter3',
    '//wb.amap.com/channel.php',
    '//translate.googleapis.com/translate_a/l',
    '//afpeng.alimama.com/ex',
    '//accounts.google.com/o/oauth2/revoke',
    '//pagead2.googlesyndication.com/relatedsearch',
    '//yandex.ru/soft/browsers/check',
    '//api.facebook.com/restserver.php',
    '//mts0.googleapis.com/maps/vt',
    '//syndication.twitter.com/widgets/timelines/765840589183213568',
    '//www.youtube.com/profile_style',
    '//googletagmanager.com/gtm/js',
    '//mc.yandex.ru/watch/24306916/1',
    '//share.yandex.net/counter/gpp/',
    '//ok.go.mail.ru/lady_on_lady_recipes_r.json',
    '//d1f69o4buvlrj5.cloudfront.net/__efa_15_1_ornpba.xekq.arg/optout_check',
    '//www.googletagmanager.com/gtm/js',
    '//api.vk.com/method/wall.get',
    '//www.sharethis.com/get-publisher-info.php',
    '//google.ru/maps/vt',
    '//pro.netrox.sc/oapi/h_checksite.ashx',
    '//vimeo.com/api/oembed.json/',
    '//de.blog.newrelic.com/wp-admin/admin-ajax.php',
    '//ajax.googleapis.com/ajax/services/search/news',
    '//ssl.google-analytics.com/gtm/js',
    '//pubsub.pubnub.com/subscribe/demo/hello_world/',
    '//pass.yandex.ua/services',
    '//id.rambler.ru/script/topline_info.js',
    '//m.addthis.com/live/red_lojson/100eng.json',
    '//passport.ngs.ru/ajax/check',
    '//catalog.api.2gis.ru/ads/search',
    '//gum.criteo.com/sync',
    '//maps.google.com/maps/vt',
    '//ynuf.alipay.com/service/um.json',
    '//securepubads.g.doubleclick.net/gampad/ads',
    '//c.tiles.mapbox.com/v3/texastribune.tx-congress-cvap/6/15/26.grid.json',
    '//rexchange.begun.ru/banners',
    '//an.yandex.ru/page/147484',
    '//links.services.disqus.com/api/ping',
    '//api.map.baidu.com/',
    '//tj.gongchang.com/api/keywordrecomm/',
    '//data.gongchang.com/livegrail/',
    '//ulogin.ru/token.php',
    '//beta.gismeteo.ru/api/informer/layout.js/120x240-3/ru/',
    '//maps.googleapis.com/maps/api/js/GeoPhotoService.GetMetadata',
    '//a.config.skype.com/config/v1/Skype/908_1.33.0.111/SkypePersonalization',
    '//maps.beeline.ru/w',
    '//target.ukr.net/',
    '//www.meteoprog.ua/data/weather/informer/Poltava.js',
    '//cdn.syndication.twimg.com/widgets/timelines/599200054310604802',
    '//wslocker.ru/client/user.chk.php',
    '//community.adobe.com/CommunityPod/getJSON',
    '//maps.google.lv/maps/vt',
    '//dev.virtualearth.net/REST/V1/Imagery/Metadata/AerialWithLabels/26.318581',
    '//awaps.yandex.ru/10/8938/02400400.',
    '//a248.e.akamai.net/h5.hulu.com/h5.mp4',
    '//nominatim.openstreetmap.org/',
    '//plugins.mozilla.org/en-us/plugins_list.json',
    '//h.cackle.me/widget/32153/bootstrap',
    '//graph.facebook.com/1/',
    '//fellowes.ugc.bazaarvoice.com/data/reviews.json',
    '//widgets.pinterest.com/v3/pidgets/boards/ciciwin/hedgehog-squirrel-crafts/pins/',
    '//appcenter.intuit.com/Account/LogoutJSONP',
    '//www.linkedin.com/countserv/count/share',
    '//se.wikipedia.org/w/api.php',
    '//cse.google.com/api/007627024705277327428/cse/r3vs7b0fcli/queries/js',
    '//relap.io/api/v2/similar_pages_jsonp.js',
    '//c1n3.hypercomments.com/stream/subscribe',
    '//maps.google.de/maps/vt',
    '//books.google.com/books',
    '//connect.mail.ru/share_count',
    '//tr.indeed.com/m/newjobs',
    '//www-onepick-opensocial.googleusercontent.com/gadgets/proxy',
    '//www.panoramio.com/map/get_panoramas.php',
    '//client.siteheart.com/streamcli/client',
    '//www.facebook.com/restserver.php',
    '//autocomplete.travelpayouts.com/avia',
    '//www.googleapis.com/freebase/v1/topic/m/0344_',
    '//mts1.googleapis.com/mapslt/ft',
    '//api.twitter.com/1/statuses/oembed.json',
    '//fast.wistia.com/embed/medias/o75jtw7654.json',
    '//partner.googleadservices.com/gampad/ads',
    '//pass.yandex.ru/services',
    '//gupiao.baidu.com/stocks/stockbets',
    '//widget.admitad.com/widget/init',
    '//api.instagram.com/v1/tags/partykungen23328/media/recent',
    '//video.media.yql.yahoo.com/v1/video/sapi/streams/063fb76c-6c70-38c5-9bbc-04b7c384de2b',
    '//ib.adnxs.com/jpt',
    '//pass.yandex.com/services',
    '//www.google.de/maps/vt',
    '//clients1.google.com/complete/search',
    '//api.userlike.com/api/chat/slot/proactive/',
    '//www.youku.com/index_cookielist/s/jsonp',
    '//mt1.googleapis.com/mapslt/ft',
    '//api.mixpanel.com/track/',
    '//wpd.b.qq.com/cgi/get_sign.php',
    '//pipes.yahooapis.com/pipes/pipe.run',
    '//gdata.youtube.com/feeds/api/videos/WsJIHN1kNWc',
    '//9.chart.apis.google.com/chart',
    '//cdn.syndication.twitter.com/moments/709229296800440320',
    '//api.flickr.com/services/feeds/photos_friends.gne',
    '//cbks0.googleapis.com/cbk',
    '//www.blogger.com/feeds/5578653387562324002/posts/summary/4427562025302749269',
    '//query.yahooapis.com/v1/public/yql',
    '//kecngantang.blogspot.com/feeds/posts/default/-/Komik',
    '//www.travelpayouts.com/widgets/50f53ce9ada1b54bcc000031.json',
    '//i.cackle.me/widget/32586/bootstrap',
    '//translate.yandex.net/api/v1.5/tr.json/detect',
    '//a.tiles.mapbox.com/v3/zentralmedia.map-n2raeauc.jsonp',
    '//maps.google.ru/maps/vt',
    '//c1n2.hypercomments.com/stream/subscribe',
    '//rec.ydf.yandex.ru/cookie',
    '//cdn.jsdelivr.net'
];

},{}],151:[function(require,module,exports){
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.checkInvalidKeyword = exports.checkMissingSemicolon = exports.checkUnknownDirective = void 0;
const csp = __importStar(require("../csp"));
const csp_1 = require("../csp");
const finding_1 = require("../finding");
function checkUnknownDirective(parsedCsp) {
    const findings = [];
    for (const directive of Object.keys(parsedCsp.directives)) {
        if (csp.isDirective(directive)) {
            continue;
        }
        if (directive.endsWith(':')) {
            findings.push(new finding_1.Finding(finding_1.Type.UNKNOWN_DIRECTIVE, 'CSP directives don\'t end with a colon.', finding_1.Severity.SYNTAX, directive));
        }
        else {
            findings.push(new finding_1.Finding(finding_1.Type.UNKNOWN_DIRECTIVE, 'Directive "' + directive + '" is not a known CSP directive.', finding_1.Severity.SYNTAX, directive));
        }
    }
    return findings;
}
exports.checkUnknownDirective = checkUnknownDirective;
function checkMissingSemicolon(parsedCsp) {
    const findings = [];
    for (const [directive, directiveValues] of Object.entries(parsedCsp.directives)) {
        if (directiveValues === undefined) {
            continue;
        }
        for (const value of directiveValues) {
            if (csp.isDirective(value)) {
                findings.push(new finding_1.Finding(finding_1.Type.MISSING_SEMICOLON, 'Did you forget the semicolon? ' +
                    '"' + value + '" seems to be a directive, not a value.', finding_1.Severity.SYNTAX, directive, value));
            }
        }
    }
    return findings;
}
exports.checkMissingSemicolon = checkMissingSemicolon;
function checkInvalidKeyword(parsedCsp) {
    const findings = [];
    const keywordsNoTicks = Object.values(csp_1.Keyword).map((k) => k.replace(/'/g, ''));
    for (const [directive, directiveValues] of Object.entries(parsedCsp.directives)) {
        if (directiveValues === undefined) {
            continue;
        }
        for (const value of directiveValues) {
            if (keywordsNoTicks.some((k) => k === value) ||
                value.startsWith('nonce-') ||
                value.match(/^(sha256|sha384|sha512)-/)) {
                findings.push(new finding_1.Finding(finding_1.Type.INVALID_KEYWORD, 'Did you forget to surround "' + value + '" with single-ticks?', finding_1.Severity.SYNTAX, directive, value));
                continue;
            }
            if (!value.startsWith('\'')) {
                continue;
            }
            if (directive === csp.Directive.REQUIRE_TRUSTED_TYPES_FOR) {
                if (value === csp.TrustedTypesSink.SCRIPT) {
                    continue;
                }
            }
            else if (directive === csp.Directive.TRUSTED_TYPES) {
                if (value === '\'allow-duplicates\'') {
                    continue;
                }
            }
            else {
                if (csp.isKeyword(value) || csp.isHash(value) || csp.isNonce(value)) {
                    continue;
                }
            }
            findings.push(new finding_1.Finding(finding_1.Type.INVALID_KEYWORD, value + ' seems to be an invalid CSP keyword.', finding_1.Severity.SYNTAX, directive, value));
        }
    }
    return findings;
}
exports.checkInvalidKeyword = checkInvalidKeyword;

},{"../csp":154,"../finding":155}],152:[function(require,module,exports){
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.checkHasConfiguredReporting = exports.checkSrcHttp = exports.checkNonceLength = exports.checkDeprecatedDirective = exports.checkIpSource = exports.looksLikeIpAddress = exports.checkFlashObjectAllowlistBypass = exports.checkScriptAllowlistBypass = exports.checkMissingDirectives = exports.checkMultipleMissingBaseUriDirective = exports.checkMissingBaseUriDirective = exports.checkMissingScriptSrcDirective = exports.checkMissingObjectSrcDirective = exports.checkWildcards = exports.checkPlainUrlSchemes = exports.checkScriptUnsafeEval = exports.checkScriptUnsafeInline = exports.URL_SCHEMES_CAUSING_XSS = exports.DIRECTIVES_CAUSING_XSS = void 0;
const angular = __importStar(require("../allowlist_bypasses/angular"));
const flash = __importStar(require("../allowlist_bypasses/flash"));
const jsonp = __importStar(require("../allowlist_bypasses/jsonp"));
const csp = __importStar(require("../csp"));
const csp_1 = require("../csp");
const finding_1 = require("../finding");
const utils = __importStar(require("../utils"));
exports.DIRECTIVES_CAUSING_XSS = [csp_1.Directive.SCRIPT_SRC, csp_1.Directive.OBJECT_SRC, csp_1.Directive.BASE_URI];
exports.URL_SCHEMES_CAUSING_XSS = ['data:', 'http:', 'https:'];
function checkScriptUnsafeInline(effectiveCsp) {
    const directiveName = effectiveCsp.getEffectiveDirective(csp_1.Directive.SCRIPT_SRC);
    const values = effectiveCsp.directives[directiveName] || [];
    if (values.includes(csp_1.Keyword.UNSAFE_INLINE)) {
        return [new finding_1.Finding(finding_1.Type.SCRIPT_UNSAFE_INLINE, `'unsafe-inline' allows the execution of unsafe in-page scripts ` +
                'and event handlers.', finding_1.Severity.HIGH, directiveName, csp_1.Keyword.UNSAFE_INLINE)];
    }
    return [];
}
exports.checkScriptUnsafeInline = checkScriptUnsafeInline;
function checkScriptUnsafeEval(parsedCsp) {
    const directiveName = parsedCsp.getEffectiveDirective(csp_1.Directive.SCRIPT_SRC);
    const values = parsedCsp.directives[directiveName] || [];
    if (values.includes(csp_1.Keyword.UNSAFE_EVAL)) {
        return [new finding_1.Finding(finding_1.Type.SCRIPT_UNSAFE_EVAL, `'unsafe-eval' allows the execution of code injected into DOM APIs ` +
                'such as eval().', finding_1.Severity.MEDIUM_MAYBE, directiveName, csp_1.Keyword.UNSAFE_EVAL)];
    }
    return [];
}
exports.checkScriptUnsafeEval = checkScriptUnsafeEval;
function checkPlainUrlSchemes(parsedCsp) {
    const violations = [];
    const directivesToCheck = parsedCsp.getEffectiveDirectives(exports.DIRECTIVES_CAUSING_XSS);
    for (const directive of directivesToCheck) {
        const values = parsedCsp.directives[directive] || [];
        for (const value of values) {
            if (exports.URL_SCHEMES_CAUSING_XSS.includes(value)) {
                violations.push(new finding_1.Finding(finding_1.Type.PLAIN_URL_SCHEMES, value + ' URI in ' + directive + ' allows the execution of ' +
                    'unsafe scripts.', finding_1.Severity.HIGH, directive, value));
            }
        }
    }
    return violations;
}
exports.checkPlainUrlSchemes = checkPlainUrlSchemes;
function checkWildcards(parsedCsp) {
    const violations = [];
    const directivesToCheck = parsedCsp.getEffectiveDirectives(exports.DIRECTIVES_CAUSING_XSS);
    for (const directive of directivesToCheck) {
        const values = parsedCsp.directives[directive] || [];
        for (const value of values) {
            const url = utils.getSchemeFreeUrl(value);
            if (url === '*') {
                violations.push(new finding_1.Finding(finding_1.Type.PLAIN_WILDCARD, directive + ` should not allow '*' as source`, finding_1.Severity.HIGH, directive, value));
                continue;
            }
        }
    }
    return violations;
}
exports.checkWildcards = checkWildcards;
function checkMissingObjectSrcDirective(parsedCsp) {
    let objectRestrictions = [];
    if (csp_1.Directive.OBJECT_SRC in parsedCsp.directives) {
        objectRestrictions = parsedCsp.directives[csp_1.Directive.OBJECT_SRC];
    }
    else if (csp_1.Directive.DEFAULT_SRC in parsedCsp.directives) {
        objectRestrictions = parsedCsp.directives[csp_1.Directive.DEFAULT_SRC];
    }
    if (objectRestrictions !== undefined && objectRestrictions.length === 1 &&
        objectRestrictions[0] === csp_1.Keyword.NONE) {
        return [];
    }
    return [new finding_1.Finding(finding_1.Type.MISSING_DIRECTIVES, `Missing object-src allows the injection of plugins which can execute JavaScript. Can you set it to 'none'?`, finding_1.Severity.HIGH, csp_1.Directive.OBJECT_SRC)];
}
exports.checkMissingObjectSrcDirective = checkMissingObjectSrcDirective;
function checkMissingScriptSrcDirective(parsedCsp) {
    if (csp_1.Directive.SCRIPT_SRC in parsedCsp.directives ||
        csp_1.Directive.DEFAULT_SRC in parsedCsp.directives) {
        return [];
    }
    return [new finding_1.Finding(finding_1.Type.MISSING_DIRECTIVES, 'script-src directive is missing.', finding_1.Severity.HIGH, csp_1.Directive.SCRIPT_SRC)];
}
exports.checkMissingScriptSrcDirective = checkMissingScriptSrcDirective;
function checkMissingBaseUriDirective(parsedCsp) {
    return checkMultipleMissingBaseUriDirective([parsedCsp]);
}
exports.checkMissingBaseUriDirective = checkMissingBaseUriDirective;
function checkMultipleMissingBaseUriDirective(parsedCsps) {
    const needsBaseUri = (csp) => (csp.policyHasScriptNonces() ||
        (csp.policyHasScriptHashes() && csp.policyHasStrictDynamic()));
    const hasBaseUri = (csp) => csp_1.Directive.BASE_URI in csp.directives;
    if (parsedCsps.some(needsBaseUri) && !parsedCsps.some(hasBaseUri)) {
        const description = 'Missing base-uri allows the injection of base tags. ' +
            'They can be used to set the base URL for all relative (script) ' +
            'URLs to an attacker controlled domain. ' +
            `Can you set it to 'none' or 'self'?`;
        return [new finding_1.Finding(finding_1.Type.MISSING_DIRECTIVES, description, finding_1.Severity.HIGH, csp_1.Directive.BASE_URI)];
    }
    return [];
}
exports.checkMultipleMissingBaseUriDirective = checkMultipleMissingBaseUriDirective;
function checkMissingDirectives(parsedCsp) {
    return [
        ...checkMissingObjectSrcDirective(parsedCsp),
        ...checkMissingScriptSrcDirective(parsedCsp),
        ...checkMissingBaseUriDirective(parsedCsp),
    ];
}
exports.checkMissingDirectives = checkMissingDirectives;
function checkScriptAllowlistBypass(parsedCsp) {
    const violations = [];
    const effectiveScriptSrcDirective = parsedCsp.getEffectiveDirective(csp_1.Directive.SCRIPT_SRC);
    const scriptSrcValues = parsedCsp.directives[effectiveScriptSrcDirective] || [];
    if (scriptSrcValues.includes(csp_1.Keyword.NONE)) {
        return violations;
    }
    for (const value of scriptSrcValues) {
        if (value === csp_1.Keyword.SELF) {
            violations.push(new finding_1.Finding(finding_1.Type.SCRIPT_ALLOWLIST_BYPASS, `'self' can be problematic if you host JSONP, Angular or user ` +
                'uploaded files.', finding_1.Severity.MEDIUM_MAYBE, effectiveScriptSrcDirective, value));
            continue;
        }
        if (value.startsWith('\'')) {
            continue;
        }
        if (csp.isUrlScheme(value) || value.indexOf('.') === -1) {
            continue;
        }
        const url = '//' + utils.getSchemeFreeUrl(value);
        const angularBypass = utils.matchWildcardUrls(url, angular.URLS);
        let jsonpBypass = utils.matchWildcardUrls(url, jsonp.URLS);
        if (jsonpBypass) {
            const evalRequired = jsonp.NEEDS_EVAL.includes(jsonpBypass.hostname);
            const evalPresent = scriptSrcValues.includes(csp_1.Keyword.UNSAFE_EVAL);
            if (evalRequired && !evalPresent) {
                jsonpBypass = null;
            }
        }
        if (jsonpBypass || angularBypass) {
            let bypassDomain = '';
            let bypassTxt = '';
            if (jsonpBypass) {
                bypassDomain = jsonpBypass.hostname;
                bypassTxt = ' JSONP endpoints';
            }
            if (angularBypass) {
                bypassDomain = angularBypass.hostname;
                bypassTxt += (bypassTxt.trim() === '') ? '' : ' and';
                bypassTxt += ' Angular libraries';
            }
            violations.push(new finding_1.Finding(finding_1.Type.SCRIPT_ALLOWLIST_BYPASS, bypassDomain + ' is known to host' + bypassTxt +
                ' which allow to bypass this CSP.', finding_1.Severity.HIGH, effectiveScriptSrcDirective, value));
        }
        else {
            violations.push(new finding_1.Finding(finding_1.Type.SCRIPT_ALLOWLIST_BYPASS, `No bypass found; make sure that this URL doesn't serve JSONP ` +
                'replies or Angular libraries.', finding_1.Severity.MEDIUM_MAYBE, effectiveScriptSrcDirective, value));
        }
    }
    return violations;
}
exports.checkScriptAllowlistBypass = checkScriptAllowlistBypass;
function checkFlashObjectAllowlistBypass(parsedCsp) {
    const violations = [];
    const effectiveObjectSrcDirective = parsedCsp.getEffectiveDirective(csp_1.Directive.OBJECT_SRC);
    const objectSrcValues = parsedCsp.directives[effectiveObjectSrcDirective] || [];
    const pluginTypes = parsedCsp.directives[csp_1.Directive.PLUGIN_TYPES];
    if (pluginTypes && !pluginTypes.includes('application/x-shockwave-flash')) {
        return [];
    }
    for (const value of objectSrcValues) {
        if (value === csp_1.Keyword.NONE) {
            return [];
        }
        const url = '//' + utils.getSchemeFreeUrl(value);
        const flashBypass = utils.matchWildcardUrls(url, flash.URLS);
        if (flashBypass) {
            violations.push(new finding_1.Finding(finding_1.Type.OBJECT_ALLOWLIST_BYPASS, flashBypass.hostname +
                ' is known to host Flash files which allow to bypass this CSP.', finding_1.Severity.HIGH, effectiveObjectSrcDirective, value));
        }
        else if (effectiveObjectSrcDirective === csp_1.Directive.OBJECT_SRC) {
            violations.push(new finding_1.Finding(finding_1.Type.OBJECT_ALLOWLIST_BYPASS, `Can you restrict object-src to 'none' only?`, finding_1.Severity.MEDIUM_MAYBE, effectiveObjectSrcDirective, value));
        }
    }
    return violations;
}
exports.checkFlashObjectAllowlistBypass = checkFlashObjectAllowlistBypass;
function looksLikeIpAddress(maybeIp) {
    if (maybeIp.startsWith('[') && maybeIp.endsWith(']')) {
        return true;
    }
    if (/^[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}$/.test(maybeIp)) {
        return true;
    }
    return false;
}
exports.looksLikeIpAddress = looksLikeIpAddress;
function checkIpSource(parsedCsp) {
    const violations = [];
    const checkIp = (directive, directiveValues) => {
        for (const value of directiveValues) {
            const host = utils.getHostname(value);
            if (looksLikeIpAddress(host)) {
                if (host === '127.0.0.1') {
                    violations.push(new finding_1.Finding(finding_1.Type.IP_SOURCE, directive + ' directive allows localhost as source. ' +
                        'Please make sure to remove this in production environments.', finding_1.Severity.INFO, directive, value));
                }
                else {
                    violations.push(new finding_1.Finding(finding_1.Type.IP_SOURCE, directive + ' directive has an IP-Address as source: ' + host +
                        ' (will be ignored by browsers!). ', finding_1.Severity.INFO, directive, value));
                }
            }
        }
    };
    utils.applyCheckFunktionToDirectives(parsedCsp, checkIp);
    return violations;
}
exports.checkIpSource = checkIpSource;
function checkDeprecatedDirective(parsedCsp) {
    const violations = [];
    if (csp_1.Directive.REFLECTED_XSS in parsedCsp.directives) {
        violations.push(new finding_1.Finding(finding_1.Type.DEPRECATED_DIRECTIVE, 'reflected-xss is deprecated since CSP2. ' +
            'Please, use the X-XSS-Protection header instead.', finding_1.Severity.INFO, csp_1.Directive.REFLECTED_XSS));
    }
    if (csp_1.Directive.REFERRER in parsedCsp.directives) {
        violations.push(new finding_1.Finding(finding_1.Type.DEPRECATED_DIRECTIVE, 'referrer is deprecated since CSP2. ' +
            'Please, use the Referrer-Policy header instead.', finding_1.Severity.INFO, csp_1.Directive.REFERRER));
    }
    if (csp_1.Directive.DISOWN_OPENER in parsedCsp.directives) {
        violations.push(new finding_1.Finding(finding_1.Type.DEPRECATED_DIRECTIVE, 'disown-opener is deprecated since CSP3. ' +
            'Please, use the Cross Origin Opener Policy header instead.', finding_1.Severity.INFO, csp_1.Directive.DISOWN_OPENER));
    }
    return violations;
}
exports.checkDeprecatedDirective = checkDeprecatedDirective;
function checkNonceLength(parsedCsp) {
    const noncePattern = new RegExp('^\'nonce-(.+)\'$');
    const violations = [];
    utils.applyCheckFunktionToDirectives(parsedCsp, (directive, directiveValues) => {
        for (const value of directiveValues) {
            const match = value.match(noncePattern);
            if (!match) {
                continue;
            }
            const nonceValue = match[1];
            if (nonceValue.length < 8) {
                violations.push(new finding_1.Finding(finding_1.Type.NONCE_LENGTH, 'Nonces should be at least 8 characters long.', finding_1.Severity.MEDIUM, directive, value));
            }
            if (!csp.isNonce(value, true)) {
                violations.push(new finding_1.Finding(finding_1.Type.NONCE_CHARSET, 'Nonces should only use the base64 charset.', finding_1.Severity.INFO, directive, value));
            }
        }
    });
    return violations;
}
exports.checkNonceLength = checkNonceLength;
function checkSrcHttp(parsedCsp) {
    const violations = [];
    utils.applyCheckFunktionToDirectives(parsedCsp, (directive, directiveValues) => {
        for (const value of directiveValues) {
            const description = directive === csp_1.Directive.REPORT_URI ?
                'Use HTTPS to send violation reports securely.' :
                'Allow only resources downloaded over HTTPS.';
            if (value.startsWith('http://')) {
                violations.push(new finding_1.Finding(finding_1.Type.SRC_HTTP, description, finding_1.Severity.MEDIUM, directive, value));
            }
        }
    });
    return violations;
}
exports.checkSrcHttp = checkSrcHttp;
function checkHasConfiguredReporting(parsedCsp) {
    const reportUriValues = parsedCsp.directives[csp_1.Directive.REPORT_URI] || [];
    if (reportUriValues.length > 0) {
        return [];
    }
    const reportToValues = parsedCsp.directives[csp_1.Directive.REPORT_TO] || [];
    if (reportToValues.length > 0) {
        return [new finding_1.Finding(finding_1.Type.REPORT_TO_ONLY, `This CSP policy only provides a reporting destination via the 'report-to' directive. This directive is only supported in Chromium-based browsers so it is recommended to also use a 'report-uri' directive.`, finding_1.Severity.INFO, csp_1.Directive.REPORT_TO)];
    }
    return [new finding_1.Finding(finding_1.Type.REPORTING_DESTINATION_MISSING, 'This CSP policy does not configure a reporting destination. This makes it difficult to maintain the CSP policy over time and monitor for any breakages.', finding_1.Severity.INFO, csp_1.Directive.REPORT_URI)];
}
exports.checkHasConfiguredReporting = checkHasConfiguredReporting;

},{"../allowlist_bypasses/angular":148,"../allowlist_bypasses/flash":149,"../allowlist_bypasses/jsonp":150,"../csp":154,"../finding":155,"../utils":158}],153:[function(require,module,exports){
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.checkRequiresTrustedTypesForScripts = exports.checkAllowlistFallback = exports.checkUnsafeInlineFallback = exports.checkStrictDynamicNotStandalone = exports.checkStrictDynamic = void 0;
const csp = __importStar(require("../csp"));
const csp_1 = require("../csp");
const finding_1 = require("../finding");
function checkStrictDynamic(parsedCsp) {
    const directiveName = parsedCsp.getEffectiveDirective(csp.Directive.SCRIPT_SRC);
    const values = parsedCsp.directives[directiveName] || [];
    const schemeOrHostPresent = values.some((v) => !v.startsWith('\''));
    if (schemeOrHostPresent && !values.includes(csp_1.Keyword.STRICT_DYNAMIC)) {
        return [new finding_1.Finding(finding_1.Type.STRICT_DYNAMIC, 'Host allowlists can frequently be bypassed. Consider using ' +
                '\'strict-dynamic\' in combination with CSP nonces or hashes.', finding_1.Severity.STRICT_CSP, directiveName)];
    }
    return [];
}
exports.checkStrictDynamic = checkStrictDynamic;
function checkStrictDynamicNotStandalone(parsedCsp) {
    const directiveName = parsedCsp.getEffectiveDirective(csp.Directive.SCRIPT_SRC);
    const values = parsedCsp.directives[directiveName] || [];
    if (values.includes(csp_1.Keyword.STRICT_DYNAMIC) &&
        (!parsedCsp.policyHasScriptNonces() &&
            !parsedCsp.policyHasScriptHashes())) {
        return [new finding_1.Finding(finding_1.Type.STRICT_DYNAMIC_NOT_STANDALONE, '\'strict-dynamic\' without a CSP nonce/hash will block all scripts.', finding_1.Severity.INFO, directiveName)];
    }
    return [];
}
exports.checkStrictDynamicNotStandalone = checkStrictDynamicNotStandalone;
function checkUnsafeInlineFallback(parsedCsp) {
    if (!parsedCsp.policyHasScriptNonces() &&
        !parsedCsp.policyHasScriptHashes()) {
        return [];
    }
    const directiveName = parsedCsp.getEffectiveDirective(csp.Directive.SCRIPT_SRC);
    const values = parsedCsp.directives[directiveName] || [];
    if (!values.includes(csp_1.Keyword.UNSAFE_INLINE)) {
        return [new finding_1.Finding(finding_1.Type.UNSAFE_INLINE_FALLBACK, 'Consider adding \'unsafe-inline\' (ignored by browsers supporting ' +
                'nonces/hashes) to be backward compatible with older browsers.', finding_1.Severity.STRICT_CSP, directiveName)];
    }
    return [];
}
exports.checkUnsafeInlineFallback = checkUnsafeInlineFallback;
function checkAllowlistFallback(parsedCsp) {
    const directiveName = parsedCsp.getEffectiveDirective(csp.Directive.SCRIPT_SRC);
    const values = parsedCsp.directives[directiveName] || [];
    if (!values.includes(csp_1.Keyword.STRICT_DYNAMIC)) {
        return [];
    }
    if (!values.some((v) => ['http:', 'https:', '*'].includes(v) || v.includes('.'))) {
        return [new finding_1.Finding(finding_1.Type.ALLOWLIST_FALLBACK, 'Consider adding https: and http: url schemes (ignored by browsers ' +
                'supporting \'strict-dynamic\') to be backward compatible with older ' +
                'browsers.', finding_1.Severity.STRICT_CSP, directiveName)];
    }
    return [];
}
exports.checkAllowlistFallback = checkAllowlistFallback;
function checkRequiresTrustedTypesForScripts(parsedCsp) {
    const directiveName = parsedCsp.getEffectiveDirective(csp.Directive.REQUIRE_TRUSTED_TYPES_FOR);
    const values = parsedCsp.directives[directiveName] || [];
    if (!values.includes(csp.TrustedTypesSink.SCRIPT)) {
        return [new finding_1.Finding(finding_1.Type.REQUIRE_TRUSTED_TYPES_FOR_SCRIPTS, 'Consider requiring Trusted Types for scripts to lock down DOM XSS ' +
                'injection sinks. You can do this by adding ' +
                '"require-trusted-types-for \'script\'" to your policy.', finding_1.Severity.INFO, csp.Directive.REQUIRE_TRUSTED_TYPES_FOR)];
    }
    return [];
}
exports.checkRequiresTrustedTypesForScripts = checkRequiresTrustedTypesForScripts;

},{"../csp":154,"../finding":155}],154:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.CspError = exports.isHash = exports.HASH_PATTERN = exports.STRICT_HASH_PATTERN = exports.isNonce = exports.NONCE_PATTERN = exports.STRICT_NONCE_PATTERN = exports.isUrlScheme = exports.isKeyword = exports.isDirective = exports.Version = exports.FETCH_DIRECTIVES = exports.Directive = exports.TrustedTypesSink = exports.Keyword = exports.Csp = void 0;
const finding_1 = require("./finding");
class Csp {
    constructor() {
        this.directives = {};
    }
    clone() {
        const clone = new Csp();
        for (const [directive, directiveValues] of Object.entries(this.directives)) {
            if (directiveValues) {
                clone.directives[directive] = [...directiveValues];
            }
        }
        return clone;
    }
    convertToString() {
        let cspString = '';
        for (const [directive, directiveValues] of Object.entries(this.directives)) {
            cspString += directive;
            if (directiveValues !== undefined) {
                for (let value, i = 0; (value = directiveValues[i]); i++) {
                    cspString += ' ';
                    cspString += value;
                }
            }
            cspString += '; ';
        }
        return cspString;
    }
    getEffectiveCsp(cspVersion, optFindings) {
        const findings = optFindings || [];
        const effectiveCsp = this.clone();
        const directive = effectiveCsp.getEffectiveDirective(Directive.SCRIPT_SRC);
        const values = this.directives[directive] || [];
        const effectiveCspValues = effectiveCsp.directives[directive];
        if (effectiveCspValues &&
            (effectiveCsp.policyHasScriptNonces() ||
                effectiveCsp.policyHasScriptHashes())) {
            if (cspVersion >= Version.CSP2) {
                if (values.includes(Keyword.UNSAFE_INLINE)) {
                    arrayRemove(effectiveCspValues, Keyword.UNSAFE_INLINE);
                    findings.push(new finding_1.Finding(finding_1.Type.IGNORED, 'unsafe-inline is ignored if a nonce or a hash is present. ' +
                        '(CSP2 and above)', finding_1.Severity.NONE, directive, Keyword.UNSAFE_INLINE));
                }
            }
            else {
                for (const value of values) {
                    if (value.startsWith('\'nonce-') || value.startsWith('\'sha')) {
                        arrayRemove(effectiveCspValues, value);
                    }
                }
            }
        }
        if (effectiveCspValues && this.policyHasStrictDynamic()) {
            if (cspVersion >= Version.CSP3) {
                for (const value of values) {
                    if (!value.startsWith('\'') || value === Keyword.SELF ||
                        value === Keyword.UNSAFE_INLINE) {
                        arrayRemove(effectiveCspValues, value);
                        findings.push(new finding_1.Finding(finding_1.Type.IGNORED, 'Because of strict-dynamic this entry is ignored in CSP3 and above', finding_1.Severity.NONE, directive, value));
                    }
                }
            }
            else {
                arrayRemove(effectiveCspValues, Keyword.STRICT_DYNAMIC);
            }
        }
        if (cspVersion < Version.CSP3) {
            delete effectiveCsp.directives[Directive.REPORT_TO];
            delete effectiveCsp.directives[Directive.WORKER_SRC];
            delete effectiveCsp.directives[Directive.MANIFEST_SRC];
            delete effectiveCsp.directives[Directive.TRUSTED_TYPES];
            delete effectiveCsp.directives[Directive.REQUIRE_TRUSTED_TYPES_FOR];
        }
        return effectiveCsp;
    }
    getEffectiveDirective(directive) {
        if (!(directive in this.directives) &&
            exports.FETCH_DIRECTIVES.includes(directive)) {
            return Directive.DEFAULT_SRC;
        }
        return directive;
    }
    getEffectiveDirectives(directives) {
        const effectiveDirectives = new Set(directives.map((val) => this.getEffectiveDirective(val)));
        return [...effectiveDirectives];
    }
    policyHasScriptNonces() {
        const directiveName = this.getEffectiveDirective(Directive.SCRIPT_SRC);
        const values = this.directives[directiveName] || [];
        return values.some((val) => isNonce(val));
    }
    policyHasScriptHashes() {
        const directiveName = this.getEffectiveDirective(Directive.SCRIPT_SRC);
        const values = this.directives[directiveName] || [];
        return values.some((val) => isHash(val));
    }
    policyHasStrictDynamic() {
        const directiveName = this.getEffectiveDirective(Directive.SCRIPT_SRC);
        const values = this.directives[directiveName] || [];
        return values.includes(Keyword.STRICT_DYNAMIC);
    }
}
exports.Csp = Csp;
var Keyword;
(function (Keyword) {
    Keyword["SELF"] = "'self'";
    Keyword["NONE"] = "'none'";
    Keyword["UNSAFE_INLINE"] = "'unsafe-inline'";
    Keyword["UNSAFE_EVAL"] = "'unsafe-eval'";
    Keyword["WASM_EVAL"] = "'wasm-eval'";
    Keyword["WASM_UNSAFE_EVAL"] = "'wasm-unsafe-eval'";
    Keyword["STRICT_DYNAMIC"] = "'strict-dynamic'";
    Keyword["UNSAFE_HASHED_ATTRIBUTES"] = "'unsafe-hashed-attributes'";
    Keyword["UNSAFE_HASHES"] = "'unsafe-hashes'";
    Keyword["REPORT_SAMPLE"] = "'report-sample'";
})(Keyword = exports.Keyword || (exports.Keyword = {}));
var TrustedTypesSink;
(function (TrustedTypesSink) {
    TrustedTypesSink["SCRIPT"] = "'script'";
})(TrustedTypesSink = exports.TrustedTypesSink || (exports.TrustedTypesSink = {}));
var Directive;
(function (Directive) {
    Directive["CHILD_SRC"] = "child-src";
    Directive["CONNECT_SRC"] = "connect-src";
    Directive["DEFAULT_SRC"] = "default-src";
    Directive["FONT_SRC"] = "font-src";
    Directive["FRAME_SRC"] = "frame-src";
    Directive["IMG_SRC"] = "img-src";
    Directive["MEDIA_SRC"] = "media-src";
    Directive["OBJECT_SRC"] = "object-src";
    Directive["SCRIPT_SRC"] = "script-src";
    Directive["SCRIPT_SRC_ATTR"] = "script-src-attr";
    Directive["SCRIPT_SRC_ELEM"] = "script-src-elem";
    Directive["STYLE_SRC"] = "style-src";
    Directive["STYLE_SRC_ATTR"] = "style-src-attr";
    Directive["STYLE_SRC_ELEM"] = "style-src-elem";
    Directive["PREFETCH_SRC"] = "prefetch-src";
    Directive["MANIFEST_SRC"] = "manifest-src";
    Directive["WORKER_SRC"] = "worker-src";
    Directive["BASE_URI"] = "base-uri";
    Directive["PLUGIN_TYPES"] = "plugin-types";
    Directive["SANDBOX"] = "sandbox";
    Directive["DISOWN_OPENER"] = "disown-opener";
    Directive["FORM_ACTION"] = "form-action";
    Directive["FRAME_ANCESTORS"] = "frame-ancestors";
    Directive["REPORT_TO"] = "report-to";
    Directive["REPORT_URI"] = "report-uri";
    Directive["BLOCK_ALL_MIXED_CONTENT"] = "block-all-mixed-content";
    Directive["UPGRADE_INSECURE_REQUESTS"] = "upgrade-insecure-requests";
    Directive["REFLECTED_XSS"] = "reflected-xss";
    Directive["REFERRER"] = "referrer";
    Directive["REQUIRE_SRI_FOR"] = "require-sri-for";
    Directive["TRUSTED_TYPES"] = "trusted-types";
    Directive["REQUIRE_TRUSTED_TYPES_FOR"] = "require-trusted-types-for";
})(Directive = exports.Directive || (exports.Directive = {}));
exports.FETCH_DIRECTIVES = [
    Directive.CHILD_SRC, Directive.CONNECT_SRC, Directive.DEFAULT_SRC,
    Directive.FONT_SRC, Directive.FRAME_SRC, Directive.IMG_SRC,
    Directive.MANIFEST_SRC, Directive.MEDIA_SRC, Directive.OBJECT_SRC,
    Directive.SCRIPT_SRC, Directive.SCRIPT_SRC_ATTR, Directive.SCRIPT_SRC_ELEM,
    Directive.STYLE_SRC, Directive.STYLE_SRC_ATTR, Directive.STYLE_SRC_ELEM,
    Directive.WORKER_SRC
];
var Version;
(function (Version) {
    Version[Version["CSP1"] = 1] = "CSP1";
    Version[Version["CSP2"] = 2] = "CSP2";
    Version[Version["CSP3"] = 3] = "CSP3";
})(Version = exports.Version || (exports.Version = {}));
function isDirective(directive) {
    return Object.values(Directive).includes(directive);
}
exports.isDirective = isDirective;
function isKeyword(keyword) {
    return Object.values(Keyword).includes(keyword);
}
exports.isKeyword = isKeyword;
function isUrlScheme(urlScheme) {
    const pattern = new RegExp('^[a-zA-Z][+a-zA-Z0-9.-]*:$');
    return pattern.test(urlScheme);
}
exports.isUrlScheme = isUrlScheme;
exports.STRICT_NONCE_PATTERN = new RegExp('^\'nonce-[a-zA-Z0-9+/_-]+[=]{0,2}\'$');
exports.NONCE_PATTERN = new RegExp('^\'nonce-(.+)\'$');
function isNonce(nonce, strictCheck) {
    const pattern = strictCheck ? exports.STRICT_NONCE_PATTERN : exports.NONCE_PATTERN;
    return pattern.test(nonce);
}
exports.isNonce = isNonce;
exports.STRICT_HASH_PATTERN = new RegExp('^\'(sha256|sha384|sha512)-[a-zA-Z0-9+/]+[=]{0,2}\'$');
exports.HASH_PATTERN = new RegExp('^\'(sha256|sha384|sha512)-(.+)\'$');
function isHash(hash, strictCheck) {
    const pattern = strictCheck ? exports.STRICT_HASH_PATTERN : exports.HASH_PATTERN;
    return pattern.test(hash);
}
exports.isHash = isHash;
class CspError extends Error {
    constructor(message) {
        super(message);
    }
}
exports.CspError = CspError;
function arrayRemove(arr, item) {
    if (arr.includes(item)) {
        const idx = arr.findIndex(elem => item === elem);
        arr.splice(idx, 1);
    }
}

},{"./finding":155}],155:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Type = exports.Severity = exports.Finding = void 0;
class Finding {
    constructor(type, description, severity, directive, value) {
        this.type = type;
        this.description = description;
        this.severity = severity;
        this.directive = directive;
        this.value = value;
    }
    static getHighestSeverity(findings) {
        if (findings.length === 0) {
            return Severity.NONE;
        }
        const severities = findings.map((finding) => finding.severity);
        const min = (prev, cur) => prev < cur ? prev : cur;
        return severities.reduce(min, Severity.NONE);
    }
    equals(obj) {
        if (!(obj instanceof Finding)) {
            return false;
        }
        return obj.type === this.type && obj.description === this.description &&
            obj.severity === this.severity && obj.directive === this.directive &&
            obj.value === this.value;
    }
}
exports.Finding = Finding;
var Severity;
(function (Severity) {
    Severity[Severity["HIGH"] = 10] = "HIGH";
    Severity[Severity["SYNTAX"] = 20] = "SYNTAX";
    Severity[Severity["MEDIUM"] = 30] = "MEDIUM";
    Severity[Severity["HIGH_MAYBE"] = 40] = "HIGH_MAYBE";
    Severity[Severity["STRICT_CSP"] = 45] = "STRICT_CSP";
    Severity[Severity["MEDIUM_MAYBE"] = 50] = "MEDIUM_MAYBE";
    Severity[Severity["INFO"] = 60] = "INFO";
    Severity[Severity["NONE"] = 100] = "NONE";
})(Severity = exports.Severity || (exports.Severity = {}));
var Type;
(function (Type) {
    Type[Type["MISSING_SEMICOLON"] = 100] = "MISSING_SEMICOLON";
    Type[Type["UNKNOWN_DIRECTIVE"] = 101] = "UNKNOWN_DIRECTIVE";
    Type[Type["INVALID_KEYWORD"] = 102] = "INVALID_KEYWORD";
    Type[Type["NONCE_CHARSET"] = 106] = "NONCE_CHARSET";
    Type[Type["MISSING_DIRECTIVES"] = 300] = "MISSING_DIRECTIVES";
    Type[Type["SCRIPT_UNSAFE_INLINE"] = 301] = "SCRIPT_UNSAFE_INLINE";
    Type[Type["SCRIPT_UNSAFE_EVAL"] = 302] = "SCRIPT_UNSAFE_EVAL";
    Type[Type["PLAIN_URL_SCHEMES"] = 303] = "PLAIN_URL_SCHEMES";
    Type[Type["PLAIN_WILDCARD"] = 304] = "PLAIN_WILDCARD";
    Type[Type["SCRIPT_ALLOWLIST_BYPASS"] = 305] = "SCRIPT_ALLOWLIST_BYPASS";
    Type[Type["OBJECT_ALLOWLIST_BYPASS"] = 306] = "OBJECT_ALLOWLIST_BYPASS";
    Type[Type["NONCE_LENGTH"] = 307] = "NONCE_LENGTH";
    Type[Type["IP_SOURCE"] = 308] = "IP_SOURCE";
    Type[Type["DEPRECATED_DIRECTIVE"] = 309] = "DEPRECATED_DIRECTIVE";
    Type[Type["SRC_HTTP"] = 310] = "SRC_HTTP";
    Type[Type["STRICT_DYNAMIC"] = 400] = "STRICT_DYNAMIC";
    Type[Type["STRICT_DYNAMIC_NOT_STANDALONE"] = 401] = "STRICT_DYNAMIC_NOT_STANDALONE";
    Type[Type["NONCE_HASH"] = 402] = "NONCE_HASH";
    Type[Type["UNSAFE_INLINE_FALLBACK"] = 403] = "UNSAFE_INLINE_FALLBACK";
    Type[Type["ALLOWLIST_FALLBACK"] = 404] = "ALLOWLIST_FALLBACK";
    Type[Type["IGNORED"] = 405] = "IGNORED";
    Type[Type["REQUIRE_TRUSTED_TYPES_FOR_SCRIPTS"] = 500] = "REQUIRE_TRUSTED_TYPES_FOR_SCRIPTS";
    Type[Type["REPORTING_DESTINATION_MISSING"] = 600] = "REPORTING_DESTINATION_MISSING";
    Type[Type["REPORT_TO_ONLY"] = 601] = "REPORT_TO_ONLY";
})(Type = exports.Type || (exports.Type = {}));

},{}],156:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.evaluateForSyntaxErrors = exports.evaluateForWarnings = exports.evaluateForFailure = void 0;
const parser_checks_1 = require("../checks/parser_checks");
const security_checks_1 = require("../checks/security_checks");
const strictcsp_checks_1 = require("../checks/strictcsp_checks");
const csp_1 = require("../csp");
function arrayContains(arr, elem) {
    return arr.some(e => e.equals(elem));
}
function setIntersection(sets) {
    const intersection = [];
    if (sets.length === 0) {
        return intersection;
    }
    const firstSet = sets[0];
    for (const elem of firstSet) {
        if (sets.every(set => arrayContains(set, elem))) {
            intersection.push(elem);
        }
    }
    return intersection;
}
function setUnion(sets) {
    const union = [];
    for (const set of sets) {
        for (const elem of set) {
            if (!arrayContains(union, elem)) {
                union.push(elem);
            }
        }
    }
    return union;
}
function atLeastOnePasses(parsedCsps, checker) {
    const findings = [];
    for (const parsedCsp of parsedCsps) {
        findings.push(checker(parsedCsp));
    }
    return setIntersection(findings);
}
function atLeastOneFails(parsedCsps, checker) {
    const findings = [];
    for (const parsedCsp of parsedCsps) {
        findings.push(checker(parsedCsp));
    }
    return setUnion(findings);
}
function evaluateForFailure(parsedCsps) {
    const targetsXssFindings = [
        ...atLeastOnePasses(parsedCsps, security_checks_1.checkMissingScriptSrcDirective),
        ...atLeastOnePasses(parsedCsps, security_checks_1.checkMissingObjectSrcDirective),
        ...security_checks_1.checkMultipleMissingBaseUriDirective(parsedCsps),
    ];
    const effectiveCsps = parsedCsps.map(csp => csp.getEffectiveCsp(csp_1.Version.CSP3)).filter(csp => {
        const directiveName = csp.getEffectiveDirective(csp_1.Directive.SCRIPT_SRC);
        return csp.directives[directiveName];
    });
    const robust = [
        ...atLeastOnePasses(effectiveCsps, strictcsp_checks_1.checkStrictDynamic),
        ...atLeastOnePasses(effectiveCsps, security_checks_1.checkScriptUnsafeInline),
    ];
    return [...targetsXssFindings, ...robust];
}
exports.evaluateForFailure = evaluateForFailure;
function evaluateForWarnings(parsedCsps) {
    const hasReportingFindings = atLeastOnePasses(parsedCsps, security_checks_1.checkHasConfiguredReporting);
    const compatibleWithNonCompliantBrowsersFindings = [
        ...atLeastOneFails(parsedCsps, strictcsp_checks_1.checkUnsafeInlineFallback),
        ...atLeastOneFails(parsedCsps, strictcsp_checks_1.checkAllowlistFallback)
    ];
    return [
        ...hasReportingFindings, ...compatibleWithNonCompliantBrowsersFindings
    ];
}
exports.evaluateForWarnings = evaluateForWarnings;
function evaluateForSyntaxErrors(parsedCsps) {
    const allFindings = [];
    for (const csp of parsedCsps) {
        const findings = [
            ...security_checks_1.checkNonceLength(csp), ...parser_checks_1.checkUnknownDirective(csp),
            ...security_checks_1.checkDeprecatedDirective(csp), ...parser_checks_1.checkMissingSemicolon(csp),
            ...parser_checks_1.checkInvalidKeyword(csp)
        ];
        allFindings.push(findings);
    }
    return allFindings;
}
exports.evaluateForSyntaxErrors = evaluateForSyntaxErrors;

},{"../checks/parser_checks":151,"../checks/security_checks":152,"../checks/strictcsp_checks":153,"../csp":154}],157:[function(require,module,exports){
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.TEST_ONLY = exports.CspParser = void 0;
const csp = __importStar(require("./csp"));
class CspParser {
    constructor(unparsedCsp) {
        this.csp = new csp.Csp();
        this.parse(unparsedCsp);
    }
    parse(unparsedCsp) {
        this.csp = new csp.Csp();
        const directiveTokens = unparsedCsp.split(';');
        for (let i = 0; i < directiveTokens.length; i++) {
            const directiveToken = directiveTokens[i].trim();
            const directiveParts = directiveToken.match(/\S+/g);
            if (Array.isArray(directiveParts)) {
                const directiveName = directiveParts[0].toLowerCase();
                if (directiveName in this.csp.directives) {
                    continue;
                }
                if (!csp.isDirective(directiveName)) {
                }
                const directiveValues = [];
                for (let directiveValue, j = 1; (directiveValue = directiveParts[j]); j++) {
                    directiveValue = normalizeDirectiveValue(directiveValue);
                    if (!directiveValues.includes(directiveValue)) {
                        directiveValues.push(directiveValue);
                    }
                }
                this.csp.directives[directiveName] = directiveValues;
            }
        }
        return this.csp;
    }
}
exports.CspParser = CspParser;
function normalizeDirectiveValue(directiveValue) {
    directiveValue = directiveValue.trim();
    const directiveValueLower = directiveValue.toLowerCase();
    if (csp.isKeyword(directiveValueLower) || csp.isUrlScheme(directiveValue)) {
        return directiveValueLower;
    }
    return directiveValue;
}
exports.TEST_ONLY = { normalizeDirectiveValue };

},{"./csp":154}],158:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.applyCheckFunktionToDirectives = exports.matchWildcardUrls = exports.getHostname = exports.getSchemeFreeUrl = void 0;
function getSchemeFreeUrl(url) {
    url = url.replace(/^\w[+\w.-]*:\/\//i, '');
    url = url.replace(/^\/\//, '');
    return url;
}
exports.getSchemeFreeUrl = getSchemeFreeUrl;
function getHostname(url) {
    const hostname = new URL('https://' +
        getSchemeFreeUrl(url).replace('*', 'wildcard_placeholder'))
        .hostname.replace('wildcard_placeholder', '*');
    const ipv6Regex = /^\[[\d:]+\]/;
    if (getSchemeFreeUrl(url).match(ipv6Regex) && !hostname.match(ipv6Regex)) {
        return '[' + hostname + ']';
    }
    return hostname;
}
exports.getHostname = getHostname;
function setScheme(u) {
    if (u.startsWith('//')) {
        return u.replace('//', 'https://');
    }
    return u;
}
function matchWildcardUrls(cspUrlString, listOfUrlStrings) {
    const cspUrl = new URL(setScheme(cspUrlString.replace('*', 'wildcard_placeholder')));
    const listOfUrls = listOfUrlStrings.map(u => new URL(setScheme(u)));
    const host = cspUrl.hostname.toLowerCase();
    const hostHasWildcard = host.startsWith('wildcard_placeholder.');
    const wildcardFreeHost = host.replace(/^\wildcard_placeholder/i, '');
    const path = cspUrl.pathname;
    const hasPath = path !== '/';
    for (const url of listOfUrls) {
        const domain = url.hostname;
        if (!domain.endsWith(wildcardFreeHost)) {
            continue;
        }
        if (!hostHasWildcard && host !== domain) {
            continue;
        }
        if (hasPath) {
            if (path.endsWith('/')) {
                if (!url.pathname.startsWith(path)) {
                    continue;
                }
            }
            else {
                if (url.pathname !== path) {
                    continue;
                }
            }
        }
        return url;
    }
    return null;
}
exports.matchWildcardUrls = matchWildcardUrls;
function applyCheckFunktionToDirectives(parsedCsp, check) {
    const directiveNames = Object.keys(parsedCsp.directives);
    for (const directive of directiveNames) {
        const directiveValues = parsedCsp.directives[directive];
        if (directiveValues) {
            check(directive, directiveValues);
        }
    }
}
exports.applyCheckFunktionToDirectives = applyCheckFunktionToDirectives;

},{}],159:[function(require,module,exports){
module.exports=[
  "aliceblue",
  "antiquewhite",
  "aqua",
  "aquamarine",
  "azure",
  "beige",
  "bisque",
  "black",
  "blanchedalmond",
  "blue",
  "blueviolet",
  "brown",
  "burlywood",
  "cadetblue",
  "chartreuse",
  "chocolate",
  "coral",
  "cornflowerblue",
  "cornsilk",
  "crimson",
  "cyan",
  "darkblue",
  "darkcyan",
  "darkgoldenrod",
  "darkgray",
  "darkgreen",
  "darkgrey",
  "darkkhaki",
  "darkmagenta",
  "darkolivegreen",
  "darkorange",
  "darkorchid",
  "darkred",
  "darksalmon",
  "darkseagreen",
  "darkslateblue",
  "darkslategray",
  "darkslategrey",
  "darkturquoise",
  "darkviolet",
  "deeppink",
  "deepskyblue",
  "dimgray",
  "dimgrey",
  "dodgerblue",
  "firebrick",
  "floralwhite",
  "forestgreen",
  "fuchsia",
  "gainsboro",
  "ghostwhite",
  "gold",
  "goldenrod",
  "gray",
  "green",
  "greenyellow",
  "grey",
  "honeydew",
  "hotpink",
  "indianred",
  "indigo",
  "ivory",
  "khaki",
  "lavender",
  "lavenderblush",
  "lawngreen",
  "lemonchiffon",
  "lightblue",
  "lightcoral",
  "lightcyan",
  "lightgoldenrodyellow",
  "lightgray",
  "lightgreen",
  "lightgrey",
  "lightpink",
  "lightsalmon",
  "lightseagreen",
  "lightskyblue",
  "lightslategray",
  "lightslategrey",
  "lightsteelblue",
  "lightyellow",
  "lime",
  "limegreen",
  "linen",
  "magenta",
  "maroon",
  "mediumaquamarine",
  "mediumblue",
  "mediumorchid",
  "mediumpurple",
  "mediumseagreen",
  "mediumslateblue",
  "mediumspringgreen",
  "mediumturquoise",
  "mediumvioletred",
  "midnightblue",
  "mintcream",
  "mistyrose",
  "moccasin",
  "navajowhite",
  "navy",
  "oldlace",
  "olive",
  "olivedrab",
  "orange",
  "orangered",
  "orchid",
  "palegoldenrod",
  "palegreen",
  "paleturquoise",
  "palevioletred",
  "papayawhip",
  "peachpuff",
  "peru",
  "pink",
  "plum",
  "powderblue",
  "purple",
  "rebeccapurple",
  "red",
  "rosybrown",
  "royalblue",
  "saddlebrown",
  "salmon",
  "sandybrown",
  "seagreen",
  "seashell",
  "sienna",
  "silver",
  "skyblue",
  "slateblue",
  "slategray",
  "slategrey",
  "snow",
  "springgreen",
  "steelblue",
  "tan",
  "teal",
  "thistle",
  "tomato",
  "turquoise",
  "violet",
  "wheat",
  "white",
  "whitesmoke",
  "yellow",
  "yellowgreen"
]

},{}],160:[function(require,module,exports){
/*********************************************************************
 * These are commonly used parsers for CSS Values they take a string *
 * to parse and return a string after it's been converted, if needed *
 ********************************************************************/
'use strict';

const namedColors = require('./named_colors.json');

exports.TYPES = {
  INTEGER: 1,
  NUMBER: 2,
  LENGTH: 3,
  PERCENT: 4,
  URL: 5,
  COLOR: 6,
  STRING: 7,
  ANGLE: 8,
  KEYWORD: 9,
  NULL_OR_EMPTY_STR: 10,
};

// rough regular expressions
var integerRegEx = /^[-+]?[0-9]+$/;
var numberRegEx = /^[-+]?[0-9]*\.[0-9]+$/;
var lengthRegEx = /^(0|[-+]?[0-9]*\.?[0-9]+(in|cm|em|mm|pt|pc|px|ex|rem|vh|vw))$/;
var percentRegEx = /^[-+]?[0-9]*\.?[0-9]+%$/;
var urlRegEx = /^url\(\s*([^)]*)\s*\)$/;
var stringRegEx = /^("[^"]*"|'[^']*')$/;
var colorRegEx1 = /^#[0-9a-fA-F][0-9a-fA-F][0-9a-fA-F]([0-9a-fA-F][0-9a-fA-F][0-9a-fA-F])?$/;
var colorRegEx2 = /^rgb\(([^)]*)\)$/;
var colorRegEx3 = /^rgba\(([^)]*)\)$/;
var colorRegEx4 = /^hsla?\(\s*(-?\d+|-?\d*.\d+)\s*,\s*(-?\d+|-?\d*.\d+)%\s*,\s*(-?\d+|-?\d*.\d+)%\s*(,\s*(-?\d+|-?\d*.\d+)\s*)?\)/;
var angleRegEx = /^([-+]?[0-9]*\.?[0-9]+)(deg|grad|rad)$/;

// This will return one of the above types based on the passed in string
exports.valueType = function valueType(val) {
  if (val === '' || val === null) {
    return exports.TYPES.NULL_OR_EMPTY_STR;
  }
  if (typeof val === 'number') {
    val = val.toString();
  }

  if (typeof val !== 'string') {
    return undefined;
  }

  if (integerRegEx.test(val)) {
    return exports.TYPES.INTEGER;
  }
  if (numberRegEx.test(val)) {
    return exports.TYPES.NUMBER;
  }
  if (lengthRegEx.test(val)) {
    return exports.TYPES.LENGTH;
  }
  if (percentRegEx.test(val)) {
    return exports.TYPES.PERCENT;
  }
  if (urlRegEx.test(val)) {
    return exports.TYPES.URL;
  }
  if (stringRegEx.test(val)) {
    return exports.TYPES.STRING;
  }
  if (angleRegEx.test(val)) {
    return exports.TYPES.ANGLE;
  }
  if (colorRegEx1.test(val)) {
    return exports.TYPES.COLOR;
  }
  var res = colorRegEx2.exec(val);
  var parts;
  if (res !== null) {
    parts = res[1].split(/\s*,\s*/);
    if (parts.length !== 3) {
      return undefined;
    }
    if (
      parts.every(percentRegEx.test.bind(percentRegEx)) ||
      parts.every(integerRegEx.test.bind(integerRegEx))
    ) {
      return exports.TYPES.COLOR;
    }
    return undefined;
  }
  res = colorRegEx3.exec(val);
  if (res !== null) {
    parts = res[1].split(/\s*,\s*/);
    if (parts.length !== 4) {
      return undefined;
    }
    if (
      parts.slice(0, 3).every(percentRegEx.test.bind(percentRegEx)) ||
      parts.every(integerRegEx.test.bind(integerRegEx))
    ) {
      if (numberRegEx.test(parts[3])) {
        return exports.TYPES.COLOR;
      }
    }
    return undefined;
  }

  if (colorRegEx4.test(val)) {
    return exports.TYPES.COLOR;
  }

  // could still be a color, one of the standard keyword colors
  val = val.toLowerCase();

  if (namedColors.includes(val)) {
    return exports.TYPES.COLOR;
  }

  switch (val) {
    // the following are deprecated in CSS3
    case 'activeborder':
    case 'activecaption':
    case 'appworkspace':
    case 'background':
    case 'buttonface':
    case 'buttonhighlight':
    case 'buttonshadow':
    case 'buttontext':
    case 'captiontext':
    case 'graytext':
    case 'highlight':
    case 'highlighttext':
    case 'inactiveborder':
    case 'inactivecaption':
    case 'inactivecaptiontext':
    case 'infobackground':
    case 'infotext':
    case 'menu':
    case 'menutext':
    case 'scrollbar':
    case 'threeddarkshadow':
    case 'threedface':
    case 'threedhighlight':
    case 'threedlightshadow':
    case 'threedshadow':
    case 'window':
    case 'windowframe':
    case 'windowtext':
      return exports.TYPES.COLOR;
    default:
      return exports.TYPES.KEYWORD;
  }
};

exports.parseInteger = function parseInteger(val) {
  var type = exports.valueType(val);
  if (type === exports.TYPES.NULL_OR_EMPTY_STR) {
    return val;
  }
  if (type !== exports.TYPES.INTEGER) {
    return undefined;
  }
  return String(parseInt(val, 10));
};

exports.parseNumber = function parseNumber(val) {
  var type = exports.valueType(val);
  if (type === exports.TYPES.NULL_OR_EMPTY_STR) {
    return val;
  }
  if (type !== exports.TYPES.NUMBER && type !== exports.TYPES.INTEGER) {
    return undefined;
  }
  return String(parseFloat(val));
};

exports.parseLength = function parseLength(val) {
  if (val === 0 || val === '0') {
    return '0px';
  }
  var type = exports.valueType(val);
  if (type === exports.TYPES.NULL_OR_EMPTY_STR) {
    return val;
  }
  if (type !== exports.TYPES.LENGTH) {
    return undefined;
  }
  return val;
};

exports.parsePercent = function parsePercent(val) {
  if (val === 0 || val === '0') {
    return '0%';
  }
  var type = exports.valueType(val);
  if (type === exports.TYPES.NULL_OR_EMPTY_STR) {
    return val;
  }
  if (type !== exports.TYPES.PERCENT) {
    return undefined;
  }
  return val;
};

// either a length or a percent
exports.parseMeasurement = function parseMeasurement(val) {
  var length = exports.parseLength(val);
  if (length !== undefined) {
    return length;
  }
  return exports.parsePercent(val);
};

exports.parseUrl = function parseUrl(val) {
  var type = exports.valueType(val);
  if (type === exports.TYPES.NULL_OR_EMPTY_STR) {
    return val;
  }
  var res = urlRegEx.exec(val);
  // does it match the regex?
  if (!res) {
    return undefined;
  }
  var str = res[1];
  // if it starts with single or double quotes, does it end with the same?
  if ((str[0] === '"' || str[0] === "'") && str[0] !== str[str.length - 1]) {
    return undefined;
  }
  if (str[0] === '"' || str[0] === "'") {
    str = str.substr(1, str.length - 2);
  }

  var i;
  for (i = 0; i < str.length; i++) {
    switch (str[i]) {
      case '(':
      case ')':
      case ' ':
      case '\t':
      case '\n':
      case "'":
      case '"':
        return undefined;
      case '\\':
        i++;
        break;
    }
  }

  return 'url(' + str + ')';
};

exports.parseString = function parseString(val) {
  var type = exports.valueType(val);
  if (type === exports.TYPES.NULL_OR_EMPTY_STR) {
    return val;
  }
  if (type !== exports.TYPES.STRING) {
    return undefined;
  }
  var i;
  for (i = 1; i < val.length - 1; i++) {
    switch (val[i]) {
      case val[0]:
        return undefined;
      case '\\':
        i++;
        while (i < val.length - 1 && /[0-9A-Fa-f]/.test(val[i])) {
          i++;
        }
        break;
    }
  }
  if (i >= val.length) {
    return undefined;
  }
  return val;
};

exports.parseColor = function parseColor(val) {
  var type = exports.valueType(val);
  if (type === exports.TYPES.NULL_OR_EMPTY_STR) {
    return val;
  }
  var red,
    green,
    blue,
    hue,
    saturation,
    lightness,
    alpha = 1;
  var parts;
  var res = colorRegEx1.exec(val);
  // is it #aaa or #ababab
  if (res) {
    var hex = val.substr(1);
    if (hex.length === 3) {
      hex = hex[0] + hex[0] + hex[1] + hex[1] + hex[2] + hex[2];
    }
    red = parseInt(hex.substr(0, 2), 16);
    green = parseInt(hex.substr(2, 2), 16);
    blue = parseInt(hex.substr(4, 2), 16);
    return 'rgb(' + red + ', ' + green + ', ' + blue + ')';
  }

  res = colorRegEx2.exec(val);
  if (res) {
    parts = res[1].split(/\s*,\s*/);
    if (parts.length !== 3) {
      return undefined;
    }
    if (parts.every(percentRegEx.test.bind(percentRegEx))) {
      red = Math.floor((parseFloat(parts[0].slice(0, -1)) * 255) / 100);
      green = Math.floor((parseFloat(parts[1].slice(0, -1)) * 255) / 100);
      blue = Math.floor((parseFloat(parts[2].slice(0, -1)) * 255) / 100);
    } else if (parts.every(integerRegEx.test.bind(integerRegEx))) {
      red = parseInt(parts[0], 10);
      green = parseInt(parts[1], 10);
      blue = parseInt(parts[2], 10);
    } else {
      return undefined;
    }
    red = Math.min(255, Math.max(0, red));
    green = Math.min(255, Math.max(0, green));
    blue = Math.min(255, Math.max(0, blue));
    return 'rgb(' + red + ', ' + green + ', ' + blue + ')';
  }

  res = colorRegEx3.exec(val);
  if (res) {
    parts = res[1].split(/\s*,\s*/);
    if (parts.length !== 4) {
      return undefined;
    }
    if (parts.slice(0, 3).every(percentRegEx.test.bind(percentRegEx))) {
      red = Math.floor((parseFloat(parts[0].slice(0, -1)) * 255) / 100);
      green = Math.floor((parseFloat(parts[1].slice(0, -1)) * 255) / 100);
      blue = Math.floor((parseFloat(parts[2].slice(0, -1)) * 255) / 100);
      alpha = parseFloat(parts[3]);
    } else if (parts.slice(0, 3).every(integerRegEx.test.bind(integerRegEx))) {
      red = parseInt(parts[0], 10);
      green = parseInt(parts[1], 10);
      blue = parseInt(parts[2], 10);
      alpha = parseFloat(parts[3]);
    } else {
      return undefined;
    }
    if (isNaN(alpha)) {
      alpha = 1;
    }
    red = Math.min(255, Math.max(0, red));
    green = Math.min(255, Math.max(0, green));
    blue = Math.min(255, Math.max(0, blue));
    alpha = Math.min(1, Math.max(0, alpha));
    if (alpha === 1) {
      return 'rgb(' + red + ', ' + green + ', ' + blue + ')';
    }
    return 'rgba(' + red + ', ' + green + ', ' + blue + ', ' + alpha + ')';
  }

  res = colorRegEx4.exec(val);
  if (res) {
    const [, _hue, _saturation, _lightness, _alphaString = ''] = res;
    const _alpha = parseFloat(_alphaString.replace(',', '').trim());
    if (!_hue || !_saturation || !_lightness) {
      return undefined;
    }
    hue = parseFloat(_hue);
    saturation = parseInt(_saturation, 10);
    lightness = parseInt(_lightness, 10);
    if (_alpha && numberRegEx.test(_alpha)) {
      alpha = parseFloat(_alpha);
    }
    if (!_alphaString || alpha === 1) {
      return 'hsl(' + hue + ', ' + saturation + '%, ' + lightness + '%)';
    }
    return 'hsla(' + hue + ', ' + saturation + '%, ' + lightness + '%, ' + alpha + ')';
  }

  if (type === exports.TYPES.COLOR) {
    return val;
  }
  return undefined;
};

exports.parseAngle = function parseAngle(val) {
  var type = exports.valueType(val);
  if (type === exports.TYPES.NULL_OR_EMPTY_STR) {
    return val;
  }
  if (type !== exports.TYPES.ANGLE) {
    return undefined;
  }
  var res = angleRegEx.exec(val);
  var flt = parseFloat(res[1]);
  if (res[2] === 'rad') {
    flt *= 180 / Math.PI;
  } else if (res[2] === 'grad') {
    flt *= 360 / 400;
  }

  while (flt < 0) {
    flt += 360;
  }
  while (flt > 360) {
    flt -= 360;
  }
  return flt + 'deg';
};

exports.parseKeyword = function parseKeyword(val, valid_keywords) {
  var type = exports.valueType(val);
  if (type === exports.TYPES.NULL_OR_EMPTY_STR) {
    return val;
  }
  if (type !== exports.TYPES.KEYWORD) {
    return undefined;
  }
  val = val.toString().toLowerCase();
  var i;
  for (i = 0; i < valid_keywords.length; i++) {
    if (valid_keywords[i].toLowerCase() === val) {
      return valid_keywords[i];
    }
  }
  return undefined;
};

// utility to translate from border-width to borderWidth
var dashedToCamelCase = function(dashed) {
  var i;
  var camel = '';
  var nextCap = false;
  for (i = 0; i < dashed.length; i++) {
    if (dashed[i] !== '-') {
      camel += nextCap ? dashed[i].toUpperCase() : dashed[i];
      nextCap = false;
    } else {
      nextCap = true;
    }
  }
  return camel;
};
exports.dashedToCamelCase = dashedToCamelCase;

var is_space = /\s/;
var opening_deliminators = ['"', "'", '('];
var closing_deliminators = ['"', "'", ')'];
// this splits on whitespace, but keeps quoted and parened parts together
var getParts = function(str) {
  var deliminator_stack = [];
  var length = str.length;
  var i;
  var parts = [];
  var current_part = '';
  var opening_index;
  var closing_index;
  for (i = 0; i < length; i++) {
    opening_index = opening_deliminators.indexOf(str[i]);
    closing_index = closing_deliminators.indexOf(str[i]);
    if (is_space.test(str[i])) {
      if (deliminator_stack.length === 0) {
        if (current_part !== '') {
          parts.push(current_part);
        }
        current_part = '';
      } else {
        current_part += str[i];
      }
    } else {
      if (str[i] === '\\') {
        i++;
        current_part += str[i];
      } else {
        current_part += str[i];
        if (
          closing_index !== -1 &&
          closing_index === deliminator_stack[deliminator_stack.length - 1]
        ) {
          deliminator_stack.pop();
        } else if (opening_index !== -1) {
          deliminator_stack.push(opening_index);
        }
      }
    }
  }
  if (current_part !== '') {
    parts.push(current_part);
  }
  return parts;
};

/*
 * this either returns undefined meaning that it isn't valid
 * or returns an object where the keys are dashed short
 * hand properties and the values are the values to set
 * on them
 */
exports.shorthandParser = function parse(v, shorthand_for) {
  var obj = {};
  var type = exports.valueType(v);
  if (type === exports.TYPES.NULL_OR_EMPTY_STR) {
    Object.keys(shorthand_for).forEach(function(property) {
      obj[property] = '';
    });
    return obj;
  }

  if (typeof v === 'number') {
    v = v.toString();
  }

  if (typeof v !== 'string') {
    return undefined;
  }

  if (v.toLowerCase() === 'inherit') {
    return {};
  }
  var parts = getParts(v);
  var valid = true;
  parts.forEach(function(part, i) {
    var part_valid = false;
    Object.keys(shorthand_for).forEach(function(property) {
      if (shorthand_for[property].isValid(part, i)) {
        part_valid = true;
        obj[property] = part;
      }
    });
    valid = valid && part_valid;
  });
  if (!valid) {
    return undefined;
  }
  return obj;
};

exports.shorthandSetter = function(property, shorthand_for) {
  return function(v) {
    var obj = exports.shorthandParser(v, shorthand_for);
    if (obj === undefined) {
      return;
    }
    //console.log('shorthandSetter for:', property, 'obj:', obj);
    Object.keys(obj).forEach(function(subprop) {
      // in case subprop is an implicit property, this will clear
      // *its* subpropertiesX
      var camel = dashedToCamelCase(subprop);
      this[camel] = obj[subprop];
      // in case it gets translated into something else (0 -> 0px)
      obj[subprop] = this[camel];
      this.removeProperty(subprop);
      // don't add in empty properties
      if (obj[subprop] !== '') {
        this._values[subprop] = obj[subprop];
      }
    }, this);
    Object.keys(shorthand_for).forEach(function(subprop) {
      if (!obj.hasOwnProperty(subprop)) {
        this.removeProperty(subprop);
        delete this._values[subprop];
      }
    }, this);
    // in case the value is something like 'none' that removes all values,
    // check that the generated one is not empty, first remove the property
    // if it already exists, then call the shorthandGetter, if it's an empty
    // string, don't set the property
    this.removeProperty(property);
    var calculated = exports.shorthandGetter(property, shorthand_for).call(this);
    if (calculated !== '') {
      this._setProperty(property, calculated);
    }
  };
};

exports.shorthandGetter = function(property, shorthand_for) {
  return function() {
    if (this._values[property] !== undefined) {
      return this.getPropertyValue(property);
    }
    return Object.keys(shorthand_for)
      .map(function(subprop) {
        return this.getPropertyValue(subprop);
      }, this)
      .filter(function(value) {
        return value !== '';
      })
      .join(' ');
  };
};

// isValid(){1,4} | inherit
// if one, it applies to all
// if two, the first applies to the top and bottom, and the second to left and right
// if three, the first applies to the top, the second to left and right, the third bottom
// if four, top, right, bottom, left
exports.implicitSetter = function(property_before, property_after, isValid, parser) {
  property_after = property_after || '';
  if (property_after !== '') {
    property_after = '-' + property_after;
  }
  var part_names = ['top', 'right', 'bottom', 'left'];

  return function(v) {
    if (typeof v === 'number') {
      v = v.toString();
    }
    if (typeof v !== 'string') {
      return undefined;
    }
    var parts;
    if (v.toLowerCase() === 'inherit' || v === '') {
      parts = [v];
    } else {
      parts = getParts(v);
    }
    if (parts.length < 1 || parts.length > 4) {
      return undefined;
    }

    if (!parts.every(isValid)) {
      return undefined;
    }

    parts = parts.map(function(part) {
      return parser(part);
    });
    this._setProperty(property_before + property_after, parts.join(' '));
    if (parts.length === 1) {
      parts[1] = parts[0];
    }
    if (parts.length === 2) {
      parts[2] = parts[0];
    }
    if (parts.length === 3) {
      parts[3] = parts[1];
    }

    for (var i = 0; i < 4; i++) {
      var property = property_before + '-' + part_names[i] + property_after;
      this.removeProperty(property);
      if (parts[i] !== '') {
        this._values[property] = parts[i];
      }
    }
    return v;
  };
};

//
//  Companion to implicitSetter, but for the individual parts.
//  This sets the individual value, and checks to see if all four
//  sub-parts are set.  If so, it sets the shorthand version and removes
//  the individual parts from the cssText.
//
exports.subImplicitSetter = function(prefix, part, isValid, parser) {
  var property = prefix + '-' + part;
  var subparts = [prefix + '-top', prefix + '-right', prefix + '-bottom', prefix + '-left'];

  return function(v) {
    if (typeof v === 'number') {
      v = v.toString();
    }
    if (typeof v !== 'string') {
      return undefined;
    }
    if (!isValid(v)) {
      return undefined;
    }
    v = parser(v);
    this._setProperty(property, v);
    var parts = [];
    for (var i = 0; i < 4; i++) {
      if (this._values[subparts[i]] == null || this._values[subparts[i]] === '') {
        break;
      }
      parts.push(this._values[subparts[i]]);
    }
    if (parts.length === 4) {
      for (i = 0; i < 4; i++) {
        this.removeProperty(subparts[i]);
        this._values[subparts[i]] = parts[i];
      }
      this._setProperty(prefix, parts.join(' '));
    }
    return v;
  };
};

var camel_to_dashed = /[A-Z]/g;
var first_segment = /^\([^-]\)-/;
var vendor_prefixes = ['o', 'moz', 'ms', 'webkit'];
exports.camelToDashed = function(camel_case) {
  var match;
  var dashed = camel_case.replace(camel_to_dashed, '-$&').toLowerCase();
  match = dashed.match(first_segment);
  if (match && vendor_prefixes.indexOf(match[1]) !== -1) {
    dashed = '-' + dashed;
  }
  return dashed;
};

},{"./named_colors.json":159}],161:[function(require,module,exports){
'use strict';

var GetIntrinsic = require('get-intrinsic');

var $gOPD = GetIntrinsic('%Object.getOwnPropertyDescriptor%');
if ($gOPD) {
	try {
		$gOPD([], 'length');
	} catch (e) {
		// IE 8 has a broken gOPD
		$gOPD = null;
	}
}

module.exports = $gOPD;

},{"get-intrinsic":166}],162:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';

var R = typeof Reflect === 'object' ? Reflect : null
var ReflectApply = R && typeof R.apply === 'function'
  ? R.apply
  : function ReflectApply(target, receiver, args) {
    return Function.prototype.apply.call(target, receiver, args);
  }

var ReflectOwnKeys
if (R && typeof R.ownKeys === 'function') {
  ReflectOwnKeys = R.ownKeys
} else if (Object.getOwnPropertySymbols) {
  ReflectOwnKeys = function ReflectOwnKeys(target) {
    return Object.getOwnPropertyNames(target)
      .concat(Object.getOwnPropertySymbols(target));
  };
} else {
  ReflectOwnKeys = function ReflectOwnKeys(target) {
    return Object.getOwnPropertyNames(target);
  };
}

function ProcessEmitWarning(warning) {
  if (console && console.warn) console.warn(warning);
}

var NumberIsNaN = Number.isNaN || function NumberIsNaN(value) {
  return value !== value;
}

function EventEmitter() {
  EventEmitter.init.call(this);
}
module.exports = EventEmitter;
module.exports.once = once;

// Backwards-compat with node 0.10.x
EventEmitter.EventEmitter = EventEmitter;

EventEmitter.prototype._events = undefined;
EventEmitter.prototype._eventsCount = 0;
EventEmitter.prototype._maxListeners = undefined;

// By default EventEmitters will print a warning if more than 10 listeners are
// added to it. This is a useful default which helps finding memory leaks.
var defaultMaxListeners = 10;

function checkListener(listener) {
  if (typeof listener !== 'function') {
    throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof listener);
  }
}

Object.defineProperty(EventEmitter, 'defaultMaxListeners', {
  enumerable: true,
  get: function() {
    return defaultMaxListeners;
  },
  set: function(arg) {
    if (typeof arg !== 'number' || arg < 0 || NumberIsNaN(arg)) {
      throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + arg + '.');
    }
    defaultMaxListeners = arg;
  }
});

EventEmitter.init = function() {

  if (this._events === undefined ||
      this._events === Object.getPrototypeOf(this)._events) {
    this._events = Object.create(null);
    this._eventsCount = 0;
  }

  this._maxListeners = this._maxListeners || undefined;
};

// Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.
EventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {
  if (typeof n !== 'number' || n < 0 || NumberIsNaN(n)) {
    throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + n + '.');
  }
  this._maxListeners = n;
  return this;
};

function _getMaxListeners(that) {
  if (that._maxListeners === undefined)
    return EventEmitter.defaultMaxListeners;
  return that._maxListeners;
}

EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
  return _getMaxListeners(this);
};

EventEmitter.prototype.emit = function emit(type) {
  var args = [];
  for (var i = 1; i < arguments.length; i++) args.push(arguments[i]);
  var doError = (type === 'error');

  var events = this._events;
  if (events !== undefined)
    doError = (doError && events.error === undefined);
  else if (!doError)
    return false;

  // If there is no 'error' event listener then throw.
  if (doError) {
    var er;
    if (args.length > 0)
      er = args[0];
    if (er instanceof Error) {
      // Note: The comments on the `throw` lines are intentional, they show
      // up in Node's output if this results in an unhandled exception.
      throw er; // Unhandled 'error' event
    }
    // At least give some kind of context to the user
    var err = new Error('Unhandled error.' + (er ? ' (' + er.message + ')' : ''));
    err.context = er;
    throw err; // Unhandled 'error' event
  }

  var handler = events[type];

  if (handler === undefined)
    return false;

  if (typeof handler === 'function') {
    ReflectApply(handler, this, args);
  } else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      ReflectApply(listeners[i], this, args);
  }

  return true;
};

function _addListener(target, type, listener, prepend) {
  var m;
  var events;
  var existing;

  checkListener(listener);

  events = target._events;
  if (events === undefined) {
    events = target._events = Object.create(null);
    target._eventsCount = 0;
  } else {
    // To avoid recursion in the case that type === "newListener"! Before
    // adding it to the listeners, first emit "newListener".
    if (events.newListener !== undefined) {
      target.emit('newListener', type,
                  listener.listener ? listener.listener : listener);

      // Re-assign `events` because a newListener handler could have caused the
      // this._events to be assigned to a new object
      events = target._events;
    }
    existing = events[type];
  }

  if (existing === undefined) {
    // Optimize the case of one listener. Don't need the extra array object.
    existing = events[type] = listener;
    ++target._eventsCount;
  } else {
    if (typeof existing === 'function') {
      // Adding the second element, need to change to array.
      existing = events[type] =
        prepend ? [listener, existing] : [existing, listener];
      // If we've already got an array, just append.
    } else if (prepend) {
      existing.unshift(listener);
    } else {
      existing.push(listener);
    }

    // Check for listener leak
    m = _getMaxListeners(target);
    if (m > 0 && existing.length > m && !existing.warned) {
      existing.warned = true;
      // No error code for this since it is a Warning
      // eslint-disable-next-line no-restricted-syntax
      var w = new Error('Possible EventEmitter memory leak detected. ' +
                          existing.length + ' ' + String(type) + ' listeners ' +
                          'added. Use emitter.setMaxListeners() to ' +
                          'increase limit');
      w.name = 'MaxListenersExceededWarning';
      w.emitter = target;
      w.type = type;
      w.count = existing.length;
      ProcessEmitWarning(w);
    }
  }

  return target;
}

EventEmitter.prototype.addListener = function addListener(type, listener) {
  return _addListener(this, type, listener, false);
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener;

EventEmitter.prototype.prependListener =
    function prependListener(type, listener) {
      return _addListener(this, type, listener, true);
    };

function onceWrapper() {
  if (!this.fired) {
    this.target.removeListener(this.type, this.wrapFn);
    this.fired = true;
    if (arguments.length === 0)
      return this.listener.call(this.target);
    return this.listener.apply(this.target, arguments);
  }
}

function _onceWrap(target, type, listener) {
  var state = { fired: false, wrapFn: undefined, target: target, type: type, listener: listener };
  var wrapped = onceWrapper.bind(state);
  wrapped.listener = listener;
  state.wrapFn = wrapped;
  return wrapped;
}

EventEmitter.prototype.once = function once(type, listener) {
  checkListener(listener);
  this.on(type, _onceWrap(this, type, listener));
  return this;
};

EventEmitter.prototype.prependOnceListener =
    function prependOnceListener(type, listener) {
      checkListener(listener);
      this.prependListener(type, _onceWrap(this, type, listener));
      return this;
    };

// Emits a 'removeListener' event if and only if the listener was removed.
EventEmitter.prototype.removeListener =
    function removeListener(type, listener) {
      var list, events, position, i, originalListener;

      checkListener(listener);

      events = this._events;
      if (events === undefined)
        return this;

      list = events[type];
      if (list === undefined)
        return this;

      if (list === listener || list.listener === listener) {
        if (--this._eventsCount === 0)
          this._events = Object.create(null);
        else {
          delete events[type];
          if (events.removeListener)
            this.emit('removeListener', type, list.listener || listener);
        }
      } else if (typeof list !== 'function') {
        position = -1;

        for (i = list.length - 1; i >= 0; i--) {
          if (list[i] === listener || list[i].listener === listener) {
            originalListener = list[i].listener;
            position = i;
            break;
          }
        }

        if (position < 0)
          return this;

        if (position === 0)
          list.shift();
        else {
          spliceOne(list, position);
        }

        if (list.length === 1)
          events[type] = list[0];

        if (events.removeListener !== undefined)
          this.emit('removeListener', type, originalListener || listener);
      }

      return this;
    };

EventEmitter.prototype.off = EventEmitter.prototype.removeListener;

EventEmitter.prototype.removeAllListeners =
    function removeAllListeners(type) {
      var listeners, events, i;

      events = this._events;
      if (events === undefined)
        return this;

      // not listening for removeListener, no need to emit
      if (events.removeListener === undefined) {
        if (arguments.length === 0) {
          this._events = Object.create(null);
          this._eventsCount = 0;
        } else if (events[type] !== undefined) {
          if (--this._eventsCount === 0)
            this._events = Object.create(null);
          else
            delete events[type];
        }
        return this;
      }

      // emit removeListener for all listeners on all events
      if (arguments.length === 0) {
        var keys = Object.keys(events);
        var key;
        for (i = 0; i < keys.length; ++i) {
          key = keys[i];
          if (key === 'removeListener') continue;
          this.removeAllListeners(key);
        }
        this.removeAllListeners('removeListener');
        this._events = Object.create(null);
        this._eventsCount = 0;
        return this;
      }

      listeners = events[type];

      if (typeof listeners === 'function') {
        this.removeListener(type, listeners);
      } else if (listeners !== undefined) {
        // LIFO order
        for (i = listeners.length - 1; i >= 0; i--) {
          this.removeListener(type, listeners[i]);
        }
      }

      return this;
    };

function _listeners(target, type, unwrap) {
  var events = target._events;

  if (events === undefined)
    return [];

  var evlistener = events[type];
  if (evlistener === undefined)
    return [];

  if (typeof evlistener === 'function')
    return unwrap ? [evlistener.listener || evlistener] : [evlistener];

  return unwrap ?
    unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);
}

EventEmitter.prototype.listeners = function listeners(type) {
  return _listeners(this, type, true);
};

EventEmitter.prototype.rawListeners = function rawListeners(type) {
  return _listeners(this, type, false);
};

EventEmitter.listenerCount = function(emitter, type) {
  if (typeof emitter.listenerCount === 'function') {
    return emitter.listenerCount(type);
  } else {
    return listenerCount.call(emitter, type);
  }
};

EventEmitter.prototype.listenerCount = listenerCount;
function listenerCount(type) {
  var events = this._events;

  if (events !== undefined) {
    var evlistener = events[type];

    if (typeof evlistener === 'function') {
      return 1;
    } else if (evlistener !== undefined) {
      return evlistener.length;
    }
  }

  return 0;
}

EventEmitter.prototype.eventNames = function eventNames() {
  return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];
};

function arrayClone(arr, n) {
  var copy = new Array(n);
  for (var i = 0; i < n; ++i)
    copy[i] = arr[i];
  return copy;
}

function spliceOne(list, index) {
  for (; index + 1 < list.length; index++)
    list[index] = list[index + 1];
  list.pop();
}

function unwrapListeners(arr) {
  var ret = new Array(arr.length);
  for (var i = 0; i < ret.length; ++i) {
    ret[i] = arr[i].listener || arr[i];
  }
  return ret;
}

function once(emitter, name) {
  return new Promise(function (resolve, reject) {
    function errorListener(err) {
      emitter.removeListener(name, resolver);
      reject(err);
    }

    function resolver() {
      if (typeof emitter.removeListener === 'function') {
        emitter.removeListener('error', errorListener);
      }
      resolve([].slice.call(arguments));
    };

    eventTargetAgnosticAddListener(emitter, name, resolver, { once: true });
    if (name !== 'error') {
      addErrorHandlerIfEventEmitter(emitter, errorListener, { once: true });
    }
  });
}

function addErrorHandlerIfEventEmitter(emitter, handler, flags) {
  if (typeof emitter.on === 'function') {
    eventTargetAgnosticAddListener(emitter, 'error', handler, flags);
  }
}

function eventTargetAgnosticAddListener(emitter, name, listener, flags) {
  if (typeof emitter.on === 'function') {
    if (flags.once) {
      emitter.once(name, listener);
    } else {
      emitter.on(name, listener);
    }
  } else if (typeof emitter.addEventListener === 'function') {
    // EventTarget does not have `error` event semantics like Node
    // EventEmitters, we do not listen for `error` events here.
    emitter.addEventListener(name, function wrapListener(arg) {
      // IE does not have builtin `{ once: true }` support so we
      // have to do it manually.
      if (flags.once) {
        emitter.removeEventListener(name, wrapListener);
      }
      listener(arg);
    });
  } else {
    throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof emitter);
  }
}

},{}],163:[function(require,module,exports){

var hasOwn = Object.prototype.hasOwnProperty;
var toString = Object.prototype.toString;

module.exports = function forEach (obj, fn, ctx) {
    if (toString.call(fn) !== '[object Function]') {
        throw new TypeError('iterator must be a function');
    }
    var l = obj.length;
    if (l === +l) {
        for (var i = 0; i < l; i++) {
            fn.call(ctx, obj[i], i, obj);
        }
    } else {
        for (var k in obj) {
            if (hasOwn.call(obj, k)) {
                fn.call(ctx, obj[k], k, obj);
            }
        }
    }
};


},{}],164:[function(require,module,exports){
'use strict';

/* eslint no-invalid-this: 1 */

var ERROR_MESSAGE = 'Function.prototype.bind called on incompatible ';
var slice = Array.prototype.slice;
var toStr = Object.prototype.toString;
var funcType = '[object Function]';

module.exports = function bind(that) {
    var target = this;
    if (typeof target !== 'function' || toStr.call(target) !== funcType) {
        throw new TypeError(ERROR_MESSAGE + target);
    }
    var args = slice.call(arguments, 1);

    var bound;
    var binder = function () {
        if (this instanceof bound) {
            var result = target.apply(
                this,
                args.concat(slice.call(arguments))
            );
            if (Object(result) === result) {
                return result;
            }
            return this;
        } else {
            return target.apply(
                that,
                args.concat(slice.call(arguments))
            );
        }
    };

    var boundLength = Math.max(0, target.length - args.length);
    var boundArgs = [];
    for (var i = 0; i < boundLength; i++) {
        boundArgs.push('$' + i);
    }

    bound = Function('binder', 'return function (' + boundArgs.join(',') + '){ return binder.apply(this,arguments); }')(binder);

    if (target.prototype) {
        var Empty = function Empty() {};
        Empty.prototype = target.prototype;
        bound.prototype = new Empty();
        Empty.prototype = null;
    }

    return bound;
};

},{}],165:[function(require,module,exports){
'use strict';

var implementation = require('./implementation');

module.exports = Function.prototype.bind || implementation;

},{"./implementation":164}],166:[function(require,module,exports){
'use strict';

var undefined;

var $SyntaxError = SyntaxError;
var $Function = Function;
var $TypeError = TypeError;

// eslint-disable-next-line consistent-return
var getEvalledConstructor = function (expressionSyntax) {
	try {
		return $Function('"use strict"; return (' + expressionSyntax + ').constructor;')();
	} catch (e) {}
};

var $gOPD = Object.getOwnPropertyDescriptor;
if ($gOPD) {
	try {
		$gOPD({}, '');
	} catch (e) {
		$gOPD = null; // this is IE 8, which has a broken gOPD
	}
}

var throwTypeError = function () {
	throw new $TypeError();
};
var ThrowTypeError = $gOPD
	? (function () {
		try {
			// eslint-disable-next-line no-unused-expressions, no-caller, no-restricted-properties
			arguments.callee; // IE 8 does not throw here
			return throwTypeError;
		} catch (calleeThrows) {
			try {
				// IE 8 throws on Object.getOwnPropertyDescriptor(arguments, '')
				return $gOPD(arguments, 'callee').get;
			} catch (gOPDthrows) {
				return throwTypeError;
			}
		}
	}())
	: throwTypeError;

var hasSymbols = require('has-symbols')();

var getProto = Object.getPrototypeOf || function (x) { return x.__proto__; }; // eslint-disable-line no-proto

var needsEval = {};

var TypedArray = typeof Uint8Array === 'undefined' ? undefined : getProto(Uint8Array);

var INTRINSICS = {
	'%AggregateError%': typeof AggregateError === 'undefined' ? undefined : AggregateError,
	'%Array%': Array,
	'%ArrayBuffer%': typeof ArrayBuffer === 'undefined' ? undefined : ArrayBuffer,
	'%ArrayIteratorPrototype%': hasSymbols ? getProto([][Symbol.iterator]()) : undefined,
	'%AsyncFromSyncIteratorPrototype%': undefined,
	'%AsyncFunction%': needsEval,
	'%AsyncGenerator%': needsEval,
	'%AsyncGeneratorFunction%': needsEval,
	'%AsyncIteratorPrototype%': needsEval,
	'%Atomics%': typeof Atomics === 'undefined' ? undefined : Atomics,
	'%BigInt%': typeof BigInt === 'undefined' ? undefined : BigInt,
	'%Boolean%': Boolean,
	'%DataView%': typeof DataView === 'undefined' ? undefined : DataView,
	'%Date%': Date,
	'%decodeURI%': decodeURI,
	'%decodeURIComponent%': decodeURIComponent,
	'%encodeURI%': encodeURI,
	'%encodeURIComponent%': encodeURIComponent,
	'%Error%': Error,
	'%eval%': eval, // eslint-disable-line no-eval
	'%EvalError%': EvalError,
	'%Float32Array%': typeof Float32Array === 'undefined' ? undefined : Float32Array,
	'%Float64Array%': typeof Float64Array === 'undefined' ? undefined : Float64Array,
	'%FinalizationRegistry%': typeof FinalizationRegistry === 'undefined' ? undefined : FinalizationRegistry,
	'%Function%': $Function,
	'%GeneratorFunction%': needsEval,
	'%Int8Array%': typeof Int8Array === 'undefined' ? undefined : Int8Array,
	'%Int16Array%': typeof Int16Array === 'undefined' ? undefined : Int16Array,
	'%Int32Array%': typeof Int32Array === 'undefined' ? undefined : Int32Array,
	'%isFinite%': isFinite,
	'%isNaN%': isNaN,
	'%IteratorPrototype%': hasSymbols ? getProto(getProto([][Symbol.iterator]())) : undefined,
	'%JSON%': typeof JSON === 'object' ? JSON : undefined,
	'%Map%': typeof Map === 'undefined' ? undefined : Map,
	'%MapIteratorPrototype%': typeof Map === 'undefined' || !hasSymbols ? undefined : getProto(new Map()[Symbol.iterator]()),
	'%Math%': Math,
	'%Number%': Number,
	'%Object%': Object,
	'%parseFloat%': parseFloat,
	'%parseInt%': parseInt,
	'%Promise%': typeof Promise === 'undefined' ? undefined : Promise,
	'%Proxy%': typeof Proxy === 'undefined' ? undefined : Proxy,
	'%RangeError%': RangeError,
	'%ReferenceError%': ReferenceError,
	'%Reflect%': typeof Reflect === 'undefined' ? undefined : Reflect,
	'%RegExp%': RegExp,
	'%Set%': typeof Set === 'undefined' ? undefined : Set,
	'%SetIteratorPrototype%': typeof Set === 'undefined' || !hasSymbols ? undefined : getProto(new Set()[Symbol.iterator]()),
	'%SharedArrayBuffer%': typeof SharedArrayBuffer === 'undefined' ? undefined : SharedArrayBuffer,
	'%String%': String,
	'%StringIteratorPrototype%': hasSymbols ? getProto(''[Symbol.iterator]()) : undefined,
	'%Symbol%': hasSymbols ? Symbol : undefined,
	'%SyntaxError%': $SyntaxError,
	'%ThrowTypeError%': ThrowTypeError,
	'%TypedArray%': TypedArray,
	'%TypeError%': $TypeError,
	'%Uint8Array%': typeof Uint8Array === 'undefined' ? undefined : Uint8Array,
	'%Uint8ClampedArray%': typeof Uint8ClampedArray === 'undefined' ? undefined : Uint8ClampedArray,
	'%Uint16Array%': typeof Uint16Array === 'undefined' ? undefined : Uint16Array,
	'%Uint32Array%': typeof Uint32Array === 'undefined' ? undefined : Uint32Array,
	'%URIError%': URIError,
	'%WeakMap%': typeof WeakMap === 'undefined' ? undefined : WeakMap,
	'%WeakRef%': typeof WeakRef === 'undefined' ? undefined : WeakRef,
	'%WeakSet%': typeof WeakSet === 'undefined' ? undefined : WeakSet
};

var doEval = function doEval(name) {
	var value;
	if (name === '%AsyncFunction%') {
		value = getEvalledConstructor('async function () {}');
	} else if (name === '%GeneratorFunction%') {
		value = getEvalledConstructor('function* () {}');
	} else if (name === '%AsyncGeneratorFunction%') {
		value = getEvalledConstructor('async function* () {}');
	} else if (name === '%AsyncGenerator%') {
		var fn = doEval('%AsyncGeneratorFunction%');
		if (fn) {
			value = fn.prototype;
		}
	} else if (name === '%AsyncIteratorPrototype%') {
		var gen = doEval('%AsyncGenerator%');
		if (gen) {
			value = getProto(gen.prototype);
		}
	}

	INTRINSICS[name] = value;

	return value;
};

var LEGACY_ALIASES = {
	'%ArrayBufferPrototype%': ['ArrayBuffer', 'prototype'],
	'%ArrayPrototype%': ['Array', 'prototype'],
	'%ArrayProto_entries%': ['Array', 'prototype', 'entries'],
	'%ArrayProto_forEach%': ['Array', 'prototype', 'forEach'],
	'%ArrayProto_keys%': ['Array', 'prototype', 'keys'],
	'%ArrayProto_values%': ['Array', 'prototype', 'values'],
	'%AsyncFunctionPrototype%': ['AsyncFunction', 'prototype'],
	'%AsyncGenerator%': ['AsyncGeneratorFunction', 'prototype'],
	'%AsyncGeneratorPrototype%': ['AsyncGeneratorFunction', 'prototype', 'prototype'],
	'%BooleanPrototype%': ['Boolean', 'prototype'],
	'%DataViewPrototype%': ['DataView', 'prototype'],
	'%DatePrototype%': ['Date', 'prototype'],
	'%ErrorPrototype%': ['Error', 'prototype'],
	'%EvalErrorPrototype%': ['EvalError', 'prototype'],
	'%Float32ArrayPrototype%': ['Float32Array', 'prototype'],
	'%Float64ArrayPrototype%': ['Float64Array', 'prototype'],
	'%FunctionPrototype%': ['Function', 'prototype'],
	'%Generator%': ['GeneratorFunction', 'prototype'],
	'%GeneratorPrototype%': ['GeneratorFunction', 'prototype', 'prototype'],
	'%Int8ArrayPrototype%': ['Int8Array', 'prototype'],
	'%Int16ArrayPrototype%': ['Int16Array', 'prototype'],
	'%Int32ArrayPrototype%': ['Int32Array', 'prototype'],
	'%JSONParse%': ['JSON', 'parse'],
	'%JSONStringify%': ['JSON', 'stringify'],
	'%MapPrototype%': ['Map', 'prototype'],
	'%NumberPrototype%': ['Number', 'prototype'],
	'%ObjectPrototype%': ['Object', 'prototype'],
	'%ObjProto_toString%': ['Object', 'prototype', 'toString'],
	'%ObjProto_valueOf%': ['Object', 'prototype', 'valueOf'],
	'%PromisePrototype%': ['Promise', 'prototype'],
	'%PromiseProto_then%': ['Promise', 'prototype', 'then'],
	'%Promise_all%': ['Promise', 'all'],
	'%Promise_reject%': ['Promise', 'reject'],
	'%Promise_resolve%': ['Promise', 'resolve'],
	'%RangeErrorPrototype%': ['RangeError', 'prototype'],
	'%ReferenceErrorPrototype%': ['ReferenceError', 'prototype'],
	'%RegExpPrototype%': ['RegExp', 'prototype'],
	'%SetPrototype%': ['Set', 'prototype'],
	'%SharedArrayBufferPrototype%': ['SharedArrayBuffer', 'prototype'],
	'%StringPrototype%': ['String', 'prototype'],
	'%SymbolPrototype%': ['Symbol', 'prototype'],
	'%SyntaxErrorPrototype%': ['SyntaxError', 'prototype'],
	'%TypedArrayPrototype%': ['TypedArray', 'prototype'],
	'%TypeErrorPrototype%': ['TypeError', 'prototype'],
	'%Uint8ArrayPrototype%': ['Uint8Array', 'prototype'],
	'%Uint8ClampedArrayPrototype%': ['Uint8ClampedArray', 'prototype'],
	'%Uint16ArrayPrototype%': ['Uint16Array', 'prototype'],
	'%Uint32ArrayPrototype%': ['Uint32Array', 'prototype'],
	'%URIErrorPrototype%': ['URIError', 'prototype'],
	'%WeakMapPrototype%': ['WeakMap', 'prototype'],
	'%WeakSetPrototype%': ['WeakSet', 'prototype']
};

var bind = require('function-bind');
var hasOwn = require('has');
var $concat = bind.call(Function.call, Array.prototype.concat);
var $spliceApply = bind.call(Function.apply, Array.prototype.splice);
var $replace = bind.call(Function.call, String.prototype.replace);
var $strSlice = bind.call(Function.call, String.prototype.slice);

/* adapted from https://github.com/lodash/lodash/blob/4.17.15/dist/lodash.js#L6735-L6744 */
var rePropName = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g;
var reEscapeChar = /\\(\\)?/g; /** Used to match backslashes in property paths. */
var stringToPath = function stringToPath(string) {
	var first = $strSlice(string, 0, 1);
	var last = $strSlice(string, -1);
	if (first === '%' && last !== '%') {
		throw new $SyntaxError('invalid intrinsic syntax, expected closing `%`');
	} else if (last === '%' && first !== '%') {
		throw new $SyntaxError('invalid intrinsic syntax, expected opening `%`');
	}
	var result = [];
	$replace(string, rePropName, function (match, number, quote, subString) {
		result[result.length] = quote ? $replace(subString, reEscapeChar, '$1') : number || match;
	});
	return result;
};
/* end adaptation */

var getBaseIntrinsic = function getBaseIntrinsic(name, allowMissing) {
	var intrinsicName = name;
	var alias;
	if (hasOwn(LEGACY_ALIASES, intrinsicName)) {
		alias = LEGACY_ALIASES[intrinsicName];
		intrinsicName = '%' + alias[0] + '%';
	}

	if (hasOwn(INTRINSICS, intrinsicName)) {
		var value = INTRINSICS[intrinsicName];
		if (value === needsEval) {
			value = doEval(intrinsicName);
		}
		if (typeof value === 'undefined' && !allowMissing) {
			throw new $TypeError('intrinsic ' + name + ' exists, but is not available. Please file an issue!');
		}

		return {
			alias: alias,
			name: intrinsicName,
			value: value
		};
	}

	throw new $SyntaxError('intrinsic ' + name + ' does not exist!');
};

module.exports = function GetIntrinsic(name, allowMissing) {
	if (typeof name !== 'string' || name.length === 0) {
		throw new $TypeError('intrinsic name must be a non-empty string');
	}
	if (arguments.length > 1 && typeof allowMissing !== 'boolean') {
		throw new $TypeError('"allowMissing" argument must be a boolean');
	}

	var parts = stringToPath(name);
	var intrinsicBaseName = parts.length > 0 ? parts[0] : '';

	var intrinsic = getBaseIntrinsic('%' + intrinsicBaseName + '%', allowMissing);
	var intrinsicRealName = intrinsic.name;
	var value = intrinsic.value;
	var skipFurtherCaching = false;

	var alias = intrinsic.alias;
	if (alias) {
		intrinsicBaseName = alias[0];
		$spliceApply(parts, $concat([0, 1], alias));
	}

	for (var i = 1, isOwn = true; i < parts.length; i += 1) {
		var part = parts[i];
		var first = $strSlice(part, 0, 1);
		var last = $strSlice(part, -1);
		if (
			(
				(first === '"' || first === "'" || first === '`')
				|| (last === '"' || last === "'" || last === '`')
			)
			&& first !== last
		) {
			throw new $SyntaxError('property names with quotes must have matching quotes');
		}
		if (part === 'constructor' || !isOwn) {
			skipFurtherCaching = true;
		}

		intrinsicBaseName += '.' + part;
		intrinsicRealName = '%' + intrinsicBaseName + '%';

		if (hasOwn(INTRINSICS, intrinsicRealName)) {
			value = INTRINSICS[intrinsicRealName];
		} else if (value != null) {
			if (!(part in value)) {
				if (!allowMissing) {
					throw new $TypeError('base intrinsic for ' + name + ' exists, but the property is not available.');
				}
				return void undefined;
			}
			if ($gOPD && (i + 1) >= parts.length) {
				var desc = $gOPD(value, part);
				isOwn = !!desc;

				// By convention, when a data property is converted to an accessor
				// property to emulate a data property that does not suffer from
				// the override mistake, that accessor's getter is marked with
				// an `originalValue` property. Here, when we detect this, we
				// uphold the illusion by pretending to see that original data
				// property, i.e., returning the value rather than the getter
				// itself.
				if (isOwn && 'get' in desc && !('originalValue' in desc.get)) {
					value = desc.get;
				} else {
					value = value[part];
				}
			} else {
				isOwn = hasOwn(value, part);
				value = value[part];
			}

			if (isOwn && !skipFurtherCaching) {
				INTRINSICS[intrinsicRealName] = value;
			}
		}
	}
	return value;
};

},{"function-bind":165,"has":169,"has-symbols":167}],167:[function(require,module,exports){
'use strict';

var origSymbol = typeof Symbol !== 'undefined' && Symbol;
var hasSymbolSham = require('./shams');

module.exports = function hasNativeSymbols() {
	if (typeof origSymbol !== 'function') { return false; }
	if (typeof Symbol !== 'function') { return false; }
	if (typeof origSymbol('foo') !== 'symbol') { return false; }
	if (typeof Symbol('bar') !== 'symbol') { return false; }

	return hasSymbolSham();
};

},{"./shams":168}],168:[function(require,module,exports){
'use strict';

/* eslint complexity: [2, 18], max-statements: [2, 33] */
module.exports = function hasSymbols() {
	if (typeof Symbol !== 'function' || typeof Object.getOwnPropertySymbols !== 'function') { return false; }
	if (typeof Symbol.iterator === 'symbol') { return true; }

	var obj = {};
	var sym = Symbol('test');
	var symObj = Object(sym);
	if (typeof sym === 'string') { return false; }

	if (Object.prototype.toString.call(sym) !== '[object Symbol]') { return false; }
	if (Object.prototype.toString.call(symObj) !== '[object Symbol]') { return false; }

	// temp disabled per https://github.com/ljharb/object.assign/issues/17
	// if (sym instanceof Symbol) { return false; }
	// temp disabled per https://github.com/WebReflection/get-own-property-symbols/issues/4
	// if (!(symObj instanceof Symbol)) { return false; }

	// if (typeof Symbol.prototype.toString !== 'function') { return false; }
	// if (String(sym) !== Symbol.prototype.toString.call(sym)) { return false; }

	var symVal = 42;
	obj[sym] = symVal;
	for (sym in obj) { return false; } // eslint-disable-line no-restricted-syntax, no-unreachable-loop
	if (typeof Object.keys === 'function' && Object.keys(obj).length !== 0) { return false; }

	if (typeof Object.getOwnPropertyNames === 'function' && Object.getOwnPropertyNames(obj).length !== 0) { return false; }

	var syms = Object.getOwnPropertySymbols(obj);
	if (syms.length !== 1 || syms[0] !== sym) { return false; }

	if (!Object.prototype.propertyIsEnumerable.call(obj, sym)) { return false; }

	if (typeof Object.getOwnPropertyDescriptor === 'function') {
		var descriptor = Object.getOwnPropertyDescriptor(obj, sym);
		if (descriptor.value !== symVal || descriptor.enumerable !== true) { return false; }
	}

	return true;
};

},{}],169:[function(require,module,exports){
'use strict';

var bind = require('function-bind');

module.exports = bind.call(Function.call, Object.prototype.hasOwnProperty);

},{"function-bind":165}],170:[function(require,module,exports){
(function (Buffer){(function (){
var querystring = require( 'querystring' )
var trim = require( './trim' )

/**
 * Link
 * @constructor
 * @return {Link}
 */
function Link( value ) {

  if( !(this instanceof Link) ) {
    return new Link( value )
  }

  /** @type {Array} URI references */
  this.refs = []

}

/**
 * General matching pattern
 * @type {RegExp}
 */
Link.pattern = /(?:\<([^\>]+)\>)((\s*;\s*([a-z\*]+)=(("[^"]+")|('[^']+')|([^\,\;]+)))*)(\s*,\s*|$)/gi

/**
 * Attribute matching pattern
 * @type {RegExp}
 */
Link.attrPattern = /([a-z\*]+)=(?:(?:"([^"]+)")|(?:'([^']+)')|([^\,\;]+))/gi

/**
 * Determines whether an encoding can be
 * natively handled with a `Buffer`
 * @param {String} value
 * @return {Boolean}
 */
Link.isCompatibleEncoding = function( value ) {
  return /^utf-?8|ascii|utf-?16-?le|ucs-?2|base-?64|latin-?1$/i.test( value )
}

/**
 * Format a given extended attribute and it's value
 * @param {String} attr
 * @param {Object} data
 * @return {String}
 */
Link.formatExtendedAttribute = function( attr, data ) {

  var encoding = ( data.encoding || 'utf-8' ).toUpperCase()
  var language = data.language || 'en'

  var encodedValue = ''

  if( Buffer.isBuffer( data.value ) && Link.isCompatibleEncoding( encoding ) ) {
    encodedValue = data.value.toString( encoding )
  } else if( Buffer.isBuffer( data.value ) ) {
    encodedValue = data.value.toString( 'hex' )
      .replace( /[0-9a-f]{2}/gi, '%$1' )
  } else {
    encodedValue = querystring.escape( data.value )
  }

  return attr + '=' + encoding + '\'' +
    language + '\'' + encodedValue

}

/**
 * Format a given attribute and it's value
 * @param {String} attr
 * @param {String|Object} value
 * @return {String}
 */
Link.formatAttribute = function( attr, value ) {

  // NOTE: Properly test this condition
  if( /\*$/.test( attr ) || typeof value !== 'string' )
    return Link.formatExtendedAttribute( attr, value )

  // Strictly, not all values matching this
  // selector would need quotes, but it's better to be safe
  var needsQuotes = /[^a-z]/i.test( value )

  if( needsQuotes ) {
    // We don't need to escape <SP> <,> <;>
    value = querystring.escape( value )
      .replace( /%20/g, ' ' )
      .replace( /%2C/g, ',' )
      .replace( /%3B/g, ';' )

    value = '"' + value + '"'
  }

  return attr + '=' + value

}

/**
 * Parses an extended value and attempts to decode it
 * @internal
 * @param {String} value
 * @return {Object}
 */
Link.parseExtendedValue = function( value ) {
  var parts = /([^']+)?(?:'([^']+)')?(.+)/.exec( value )
  return {
    language: parts[2].toLowerCase(),
    encoding: Link.isCompatibleEncoding( parts[1] ) ?
      null : parts[1].toLowerCase(),
    value: Link.isCompatibleEncoding( parts[1] ) ?
      querystring.unescape( parts[3] ) : parts[3]
  }
}

/**
 * Set an attribute on a link ref
 * @param {Object} link
 * @param {String} attr
 * @param {String} value
 */
Link.setAttr = function( link, attr, value ) {

  // Occurrences after the first "rel" MUST be ignored by parsers
  // @see RFC 5988, Section 5.3: Relation Type
  if( attr === 'rel' && link[ attr ] != null )
    return link

  if( Array.isArray( link[ attr ] ) ) {
    link[ attr ].push( value )
  } else if( link[ attr ] != null ) {
    link[ attr ] = [ link[ attr ], value ]
  } else {
    link[ attr ] = value
  }

  return link

}

/**
 * Parses uri attributes
 */
Link.parseParams = function( link, uri ) {

  var kvs = {}
  var params = /(.+)\?(.+)/gi.exec( uri )

  if( !params ) {
    return link
  }

  params = params[2].split('&')

  for( var i = 0; i < params.length; i++ ) {
    var param = params[i].split('=');
    kvs[ param[0] ] = param[1]
  }

  Link.setAttr( link, 'params', kvs )

  return link

}

/**
 * Parses out URI attributes
 * @internal
 * @param {Object} link
 * @param {String} parts
 * @return {Object} link
 */
Link.parseAttrs = function( link, parts ) {

  var match = null
  var attr = ''
  var value = ''
  var attrs = ''

  var uriAttrs = /<(.*)>;\s*(.*)/gi.exec( parts )
  if( uriAttrs ) {
    attrs = uriAttrs[2]
    link = Link.parseParams( link, uriAttrs[1] )
  }

  while( match = Link.attrPattern.exec( attrs ) ) {
    attr = match[1].toLowerCase()
    value = match[4] || match[3] || match[2]
    if( /\*$/.test( attr ) ) {
      Link.setAttr( link, attr, Link.parseExtendedValue( value ) )
    } else if( /%/.test( value ) ) {
      Link.setAttr( link, attr, querystring.unescape( value ) )
    } else {
      Link.setAttr( link, attr, value )
    }
  }

  return link

}

Link.parse = function( value ) {
  return new Link().parse( value )
}

/**
 * Link prototype
 * @type {Object}
 */
Link.prototype = {

  constructor: Link,

  /**
   * Get refs with given relation type
   * @param {String} value
   * @return {Array<Object>}
   */
  rel: function( value ) {

    var links = []

    for( var i = 0; i < this.refs.length; i++ ) {
      if( this.refs[ i ].rel === value ) {
        links.push( this.refs[ i ] )
      }
    }

    return links

  },

  /**
   * Get refs where given attribute has a given value
   * @param {String} attr
   * @param {String} value
   * @return {Array<Object>}
   */
  get: function( attr, value ) {

    attr = attr.toLowerCase()

    var links = []

    for( var i = 0; i < this.refs.length; i++ ) {
      if( this.refs[ i ][ attr ] === value ) {
        links.push( this.refs[ i ] )
      }
    }

    return links

  },

  set: function( link ) {
    this.refs.push( link )
    return this
  },

  has: function( attr, value ) {
    return this.get( attr, value ) != null
  },

  parse: function( value ) {

    // Unfold folded lines
    value = trim( value )
      .replace( /\r?\n[\x20\x09]+/g, '' )

    var match = null

    while( match = Link.pattern.exec( value ) ) {
      var link = Link.parseAttrs({ uri: match[1] }, match[0] )
      this.refs.push( link )
    }

    return this

  },

  toString: function() {

    var refs = []
    var link = ''
    var ref = null

    for( var i = 0; i < this.refs.length; i++ ) {
      ref = this.refs[i]
      link = Object.keys( this.refs[i] ).reduce( function( link, attr ) {
        if( attr === 'uri' ) return link
        return link + '; ' + Link.formatAttribute( attr, ref[ attr ] )
      }, '<' + ref.uri + '>' )
      refs.push( link )
    }

    return refs.join( ', ' )

  },

}

// Exports
module.exports = Link

}).call(this)}).call(this,{"isBuffer":require("../../is-buffer/index.js")})
},{"../../is-buffer/index.js":182,"./trim":171,"querystring":226}],171:[function(require,module,exports){
module.exports = function trim( value ) {
  return value.replace( /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, '' )
}

},{}],172:[function(require,module,exports){
exports.read = function (buffer, offset, isLE, mLen, nBytes) {
  var e, m
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var nBits = -7
  var i = isLE ? (nBytes - 1) : 0
  var d = isLE ? -1 : 1
  var s = buffer[offset + i]

  i += d

  e = s & ((1 << (-nBits)) - 1)
  s >>= (-nBits)
  nBits += eLen
  for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  m = e & ((1 << (-nBits)) - 1)
  e >>= (-nBits)
  nBits += mLen
  for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  if (e === 0) {
    e = 1 - eBias
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity)
  } else {
    m = m + Math.pow(2, mLen)
    e = e - eBias
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
}

exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)
  var i = isLE ? 0 : (nBytes - 1)
  var d = isLE ? 1 : -1
  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0

  value = Math.abs(value)

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0
    e = eMax
  } else {
    e = Math.floor(Math.log(value) / Math.LN2)
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--
      c *= 2
    }
    if (e + eBias >= 1) {
      value += rt / c
    } else {
      value += rt * Math.pow(2, 1 - eBias)
    }
    if (value * c >= 2) {
      e++
      c /= 2
    }

    if (e + eBias >= eMax) {
      m = 0
      e = eMax
    } else if (e + eBias >= 1) {
      m = ((value * c) - 1) * Math.pow(2, mLen)
      e = e + eBias
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)
      e = 0
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

  e = (e << mLen) | m
  eLen += mLen
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

  buffer[offset + i - d] |= s * 128
}

},{}],173:[function(require,module,exports){
/**
 * @preserve
 * Copyright 2015 Igor Bezkrovny
 * All rights reserved. (MIT Licensed)
 *
 * ssim.ts - part of Image Quantization Library
 */
/**
 * - Original TypeScript implementation:
 *   https://github.com/igor-bezkrovny/image-quantization/blob/9f62764ac047c3e53accdf1d7e4e424b0ef2fb60/src/quality/ssim.ts
 * - Based on Java implementation: https://github.com/rhys-e/structural-similarity
 * - For more information see: http://en.wikipedia.org/wiki/Structural_similarity
 */
var ImageSSIM;
(function (ImageSSIM) {
    'use strict';
    /**
     * Grey = 1, GreyAlpha = 2, RGB = 3, RGBAlpha = 4
     */
    (function (Channels) {
        Channels[Channels["Grey"] = 1] = "Grey";
        Channels[Channels["GreyAlpha"] = 2] = "GreyAlpha";
        Channels[Channels["RGB"] = 3] = "RGB";
        Channels[Channels["RGBAlpha"] = 4] = "RGBAlpha";
    })(ImageSSIM.Channels || (ImageSSIM.Channels = {}));
    var Channels = ImageSSIM.Channels;
    /**
     * Entry point.
     * @throws new Error('Images have different sizes!')
     */
    function compare(image1, image2, windowSize, K1, K2, luminance, bitsPerComponent) {
        if (windowSize === void 0) { windowSize = 8; }
        if (K1 === void 0) { K1 = 0.01; }
        if (K2 === void 0) { K2 = 0.03; }
        if (luminance === void 0) { luminance = true; }
        if (bitsPerComponent === void 0) { bitsPerComponent = 8; }
        if (image1.width !== image2.width || image1.height !== image2.height) {
            throw new Error('Images have different sizes!');
        }
        /* tslint:disable:no-bitwise */
        var L = (1 << bitsPerComponent) - 1;
        /* tslint:enable:no-bitwise */
        var c1 = Math.pow((K1 * L), 2), c2 = Math.pow((K2 * L), 2), numWindows = 0, mssim = 0.0;
        var mcs = 0.0;
        function iteration(lumaValues1, lumaValues2, averageLumaValue1, averageLumaValue2) {
            // calculate variance and covariance
            var sigxy, sigsqx, sigsqy;
            sigxy = sigsqx = sigsqy = 0.0;
            for (var i = 0; i < lumaValues1.length; i++) {
                sigsqx += Math.pow((lumaValues1[i] - averageLumaValue1), 2);
                sigsqy += Math.pow((lumaValues2[i] - averageLumaValue2), 2);
                sigxy += (lumaValues1[i] - averageLumaValue1) * (lumaValues2[i] - averageLumaValue2);
            }
            var numPixelsInWin = lumaValues1.length - 1;
            sigsqx /= numPixelsInWin;
            sigsqy /= numPixelsInWin;
            sigxy /= numPixelsInWin;
            // perform ssim calculation on window
            var numerator = (2 * averageLumaValue1 * averageLumaValue2 + c1) * (2 * sigxy + c2);
            var denominator = (Math.pow(averageLumaValue1, 2) + Math.pow(averageLumaValue2, 2) + c1) * (sigsqx + sigsqy + c2);
            mssim += numerator / denominator;
            mcs += (2 * sigxy + c2) / (sigsqx + sigsqy + c2);
            numWindows++;
        }
        // calculate SSIM for each window
        Internals._iterate(image1, image2, windowSize, luminance, iteration);
        return { ssim: mssim / numWindows, mcs: mcs / numWindows };
    }
    ImageSSIM.compare = compare;
    /**
     * Internal functions.
     */
    var Internals;
    (function (Internals) {
        function _iterate(image1, image2, windowSize, luminance, callback) {
            var width = image1.width, height = image1.height;
            for (var y = 0; y < height; y += windowSize) {
                for (var x = 0; x < width; x += windowSize) {
                    // avoid out-of-width/height
                    var windowWidth = Math.min(windowSize, width - x), windowHeight = Math.min(windowSize, height - y);
                    var lumaValues1 = _lumaValuesForWindow(image1, x, y, windowWidth, windowHeight, luminance), lumaValues2 = _lumaValuesForWindow(image2, x, y, windowWidth, windowHeight, luminance), averageLuma1 = _averageLuma(lumaValues1), averageLuma2 = _averageLuma(lumaValues2);
                    callback(lumaValues1, lumaValues2, averageLuma1, averageLuma2);
                }
            }
        }
        Internals._iterate = _iterate;
        function _lumaValuesForWindow(image, x, y, width, height, luminance) {
            var array = image.data, lumaValues = new Float32Array(new ArrayBuffer(width * height * 4)), counter = 0;
            var maxj = y + height;
            for (var j = y; j < maxj; j++) {
                var offset = j * image.width;
                var i = (offset + x) * image.channels;
                var maxi = (offset + x + width) * image.channels;
                switch (image.channels) {
                    case 1 /* Grey */:
                        while (i < maxi) {
                            // (0.212655 +  0.715158 + 0.072187) === 1
                            lumaValues[counter++] = array[i++];
                        }
                        break;
                    case 2 /* GreyAlpha */:
                        while (i < maxi) {
                            lumaValues[counter++] = array[i++] * (array[i++] / 255);
                        }
                        break;
                    case 3 /* RGB */:
                        if (luminance) {
                            while (i < maxi) {
                                lumaValues[counter++] = (array[i++] * 0.212655 + array[i++] * 0.715158 + array[i++] * 0.072187);
                            }
                        }
                        else {
                            while (i < maxi) {
                                lumaValues[counter++] = (array[i++] + array[i++] + array[i++]);
                            }
                        }
                        break;
                    case 4 /* RGBAlpha */:
                        if (luminance) {
                            while (i < maxi) {
                                lumaValues[counter++] = (array[i++] * 0.212655 + array[i++] * 0.715158 + array[i++] * 0.072187) * (array[i++] / 255);
                            }
                        }
                        else {
                            while (i < maxi) {
                                lumaValues[counter++] = (array[i++] + array[i++] + array[i++]) * (array[i++] / 255);
                            }
                        }
                        break;
                }
            }
            return lumaValues;
        }
        function _averageLuma(lumaValues) {
            var sumLuma = 0.0;
            for (var i = 0; i < lumaValues.length; i++) {
                sumLuma += lumaValues[i];
            }
            return sumLuma / lumaValues.length;
        }
    })(Internals || (Internals = {}));
})(ImageSSIM || (ImageSSIM = {}));
module.exports = ImageSSIM;

},{}],174:[function(require,module,exports){
if (typeof Object.create === 'function') {
  // implementation from standard node.js 'util' module
  module.exports = function inherits(ctor, superCtor) {
    if (superCtor) {
      ctor.super_ = superCtor
      ctor.prototype = Object.create(superCtor.prototype, {
        constructor: {
          value: ctor,
          enumerable: false,
          writable: true,
          configurable: true
        }
      })
    }
  };
} else {
  // old school shim for old browsers
  module.exports = function inherits(ctor, superCtor) {
    if (superCtor) {
      ctor.super_ = superCtor
      var TempCtor = function () {}
      TempCtor.prototype = superCtor.prototype
      ctor.prototype = new TempCtor()
      ctor.prototype.constructor = ctor
    }
  }
}

},{}],175:[function(require,module,exports){
'use strict';

var parser = require('./lib/parser')

module.exports = parser
module.exports['default'] = parser

},{"./lib/parser":176}],176:[function(require,module,exports){
/*
 * Generated by PEG.js 0.10.0.
 *
 * http://pegjs.org/
 */

"use strict";

function peg$subclass(child, parent) {
  function ctor() { this.constructor = child; }
  ctor.prototype = parent.prototype;
  child.prototype = new ctor();
}

function peg$SyntaxError(message, expected, found, location) {
  this.message  = message;
  this.expected = expected;
  this.found    = found;
  this.location = location;
  this.name     = "SyntaxError";

  if (typeof Error.captureStackTrace === "function") {
    Error.captureStackTrace(this, peg$SyntaxError);
  }
}

peg$subclass(peg$SyntaxError, Error);

peg$SyntaxError.buildMessage = function(expected, found) {
  var DESCRIBE_EXPECTATION_FNS = {
        literal: function(expectation) {
          return "\"" + literalEscape(expectation.text) + "\"";
        },

        "class": function(expectation) {
          var escapedParts = "",
              i;

          for (i = 0; i < expectation.parts.length; i++) {
            escapedParts += expectation.parts[i] instanceof Array
              ? classEscape(expectation.parts[i][0]) + "-" + classEscape(expectation.parts[i][1])
              : classEscape(expectation.parts[i]);
          }

          return "[" + (expectation.inverted ? "^" : "") + escapedParts + "]";
        },

        any: function(expectation) {
          return "any character";
        },

        end: function(expectation) {
          return "end of input";
        },

        other: function(expectation) {
          return expectation.description;
        }
      };

  function hex(ch) {
    return ch.charCodeAt(0).toString(16).toUpperCase();
  }

  function literalEscape(s) {
    return s
      .replace(/\\/g, '\\\\')
      .replace(/"/g,  '\\"')
      .replace(/\0/g, '\\0')
      .replace(/\t/g, '\\t')
      .replace(/\n/g, '\\n')
      .replace(/\r/g, '\\r')
      .replace(/[\x00-\x0F]/g,          function(ch) { return '\\x0' + hex(ch); })
      .replace(/[\x10-\x1F\x7F-\x9F]/g, function(ch) { return '\\x'  + hex(ch); });
  }

  function classEscape(s) {
    return s
      .replace(/\\/g, '\\\\')
      .replace(/\]/g, '\\]')
      .replace(/\^/g, '\\^')
      .replace(/-/g,  '\\-')
      .replace(/\0/g, '\\0')
      .replace(/\t/g, '\\t')
      .replace(/\n/g, '\\n')
      .replace(/\r/g, '\\r')
      .replace(/[\x00-\x0F]/g,          function(ch) { return '\\x0' + hex(ch); })
      .replace(/[\x10-\x1F\x7F-\x9F]/g, function(ch) { return '\\x'  + hex(ch); });
  }

  function describeExpectation(expectation) {
    return DESCRIBE_EXPECTATION_FNS[expectation.type](expectation);
  }

  function describeExpected(expected) {
    var descriptions = new Array(expected.length),
        i, j;

    for (i = 0; i < expected.length; i++) {
      descriptions[i] = describeExpectation(expected[i]);
    }

    descriptions.sort();

    if (descriptions.length > 0) {
      for (i = 1, j = 1; i < descriptions.length; i++) {
        if (descriptions[i - 1] !== descriptions[i]) {
          descriptions[j] = descriptions[i];
          j++;
        }
      }
      descriptions.length = j;
    }

    switch (descriptions.length) {
      case 1:
        return descriptions[0];

      case 2:
        return descriptions[0] + " or " + descriptions[1];

      default:
        return descriptions.slice(0, -1).join(", ")
          + ", or "
          + descriptions[descriptions.length - 1];
    }
  }

  function describeFound(found) {
    return found ? "\"" + literalEscape(found) + "\"" : "end of input";
  }

  return "Expected " + describeExpected(expected) + " but " + describeFound(found) + " found.";
};

function peg$parse(input, options) {
  options = options !== void 0 ? options : {};

  var peg$FAILED = {},

      peg$startRuleFunctions = { start: peg$parsestart },
      peg$startRuleFunction  = peg$parsestart,

      peg$c0 = function(elements) {
              return {
                  type    : 'messageFormatPattern',
                  elements: elements,
                  location: location()
              };
          },
      peg$c1 = function(chunks) {
              return chunks.reduce(function (all, chunk) {
                  return all.concat(chunk)
              }, []).join('')
          },
      peg$c2 = function(messageText) {
              return {
                  type : 'messageTextElement',
                  value: messageText,
                  location: location()
              };
          },
      peg$c3 = function(chars) { return chars.join(''); },
      peg$c4 = "{",
      peg$c5 = peg$literalExpectation("{", false),
      peg$c6 = ",",
      peg$c7 = peg$literalExpectation(",", false),
      peg$c8 = "}",
      peg$c9 = peg$literalExpectation("}", false),
      peg$c10 = function(id, format) {
              return {
                  type  : 'argumentElement',
                  id    : id,
                  format: format && format[2],
                  location: location()
              };
          },
      peg$c11 = "number",
      peg$c12 = peg$literalExpectation("number", false),
      peg$c13 = "date",
      peg$c14 = peg$literalExpectation("date", false),
      peg$c15 = "time",
      peg$c16 = peg$literalExpectation("time", false),
      peg$c17 = function(type, style) {
              return {
                  type : type + 'Format',
                  style: style && style[2],
                  location: location()
              };
          },
      peg$c18 = "plural",
      peg$c19 = peg$literalExpectation("plural", false),
      peg$c20 = function(pluralStyle) {
              return {
                  type   : pluralStyle.type,
                  ordinal: false,
                  offset : pluralStyle.offset || 0,
                  options: pluralStyle.options,
                  location: location()
              };
          },
      peg$c21 = "selectordinal",
      peg$c22 = peg$literalExpectation("selectordinal", false),
      peg$c23 = function(pluralStyle) {
              return {
                  type   : pluralStyle.type,
                  ordinal: true,
                  offset : pluralStyle.offset || 0,
                  options: pluralStyle.options,
                  location: location()
              }
          },
      peg$c24 = "select",
      peg$c25 = peg$literalExpectation("select", false),
      peg$c26 = function(options) {
              return {
                  type   : 'selectFormat',
                  options: options,
                  location: location()
              };
          },
      peg$c27 = "=",
      peg$c28 = peg$literalExpectation("=", false),
      peg$c29 = function(selector, pattern) {
              return {
                  type    : 'optionalFormatPattern',
                  selector: selector,
                  value   : pattern,
                  location: location()
              };
          },
      peg$c30 = "offset:",
      peg$c31 = peg$literalExpectation("offset:", false),
      peg$c32 = function(number) {
              return number;
          },
      peg$c33 = function(offset, options) {
              return {
                  type   : 'pluralFormat',
                  offset : offset,
                  options: options,
                  location: location()
              };
          },
      peg$c34 = peg$otherExpectation("whitespace"),
      peg$c35 = /^[ \t\n\r]/,
      peg$c36 = peg$classExpectation([" ", "\t", "\n", "\r"], false, false),
      peg$c37 = peg$otherExpectation("optionalWhitespace"),
      peg$c38 = /^[0-9]/,
      peg$c39 = peg$classExpectation([["0", "9"]], false, false),
      peg$c40 = /^[0-9a-f]/i,
      peg$c41 = peg$classExpectation([["0", "9"], ["a", "f"]], false, true),
      peg$c42 = "0",
      peg$c43 = peg$literalExpectation("0", false),
      peg$c44 = /^[1-9]/,
      peg$c45 = peg$classExpectation([["1", "9"]], false, false),
      peg$c46 = function(digits) {
          return parseInt(digits, 10);
      },
      peg$c47 = "'",
      peg$c48 = peg$literalExpectation("'", false),
      peg$c49 = /^[ \t\n\r,.+={}#]/,
      peg$c50 = peg$classExpectation([" ", "\t", "\n", "\r", ",", ".", "+", "=", "{", "}", "#"], false, false),
      peg$c51 = peg$anyExpectation(),
      peg$c52 = function(char) { return char; },
      peg$c53 = function(sequence) { return sequence; },
      peg$c54 = /^[^{}\\\0-\x1F\x7F \t\n\r]/,
      peg$c55 = peg$classExpectation(["{", "}", "\\", ["\0", "\x1F"], "\x7F", " ", "\t", "\n", "\r"], true, false),
      peg$c56 = "\\\\",
      peg$c57 = peg$literalExpectation("\\\\", false),
      peg$c58 = function() { return '\\'; },
      peg$c59 = "\\#",
      peg$c60 = peg$literalExpectation("\\#", false),
      peg$c61 = function() { return '\\#'; },
      peg$c62 = "\\{",
      peg$c63 = peg$literalExpectation("\\{", false),
      peg$c64 = function() { return '\u007B'; },
      peg$c65 = "\\}",
      peg$c66 = peg$literalExpectation("\\}", false),
      peg$c67 = function() { return '\u007D'; },
      peg$c68 = "\\u",
      peg$c69 = peg$literalExpectation("\\u", false),
      peg$c70 = function(digits) {
              return String.fromCharCode(parseInt(digits, 16));
          },

      peg$currPos          = 0,
      peg$savedPos         = 0,
      peg$posDetailsCache  = [{ line: 1, column: 1 }],
      peg$maxFailPos       = 0,
      peg$maxFailExpected  = [],
      peg$silentFails      = 0,

      peg$result;

  if ("startRule" in options) {
    if (!(options.startRule in peg$startRuleFunctions)) {
      throw new Error("Can't start parsing from rule \"" + options.startRule + "\".");
    }

    peg$startRuleFunction = peg$startRuleFunctions[options.startRule];
  }

  function text() {
    return input.substring(peg$savedPos, peg$currPos);
  }

  function location() {
    return peg$computeLocation(peg$savedPos, peg$currPos);
  }

  function expected(description, location) {
    location = location !== void 0 ? location : peg$computeLocation(peg$savedPos, peg$currPos)

    throw peg$buildStructuredError(
      [peg$otherExpectation(description)],
      input.substring(peg$savedPos, peg$currPos),
      location
    );
  }

  function error(message, location) {
    location = location !== void 0 ? location : peg$computeLocation(peg$savedPos, peg$currPos)

    throw peg$buildSimpleError(message, location);
  }

  function peg$literalExpectation(text, ignoreCase) {
    return { type: "literal", text: text, ignoreCase: ignoreCase };
  }

  function peg$classExpectation(parts, inverted, ignoreCase) {
    return { type: "class", parts: parts, inverted: inverted, ignoreCase: ignoreCase };
  }

  function peg$anyExpectation() {
    return { type: "any" };
  }

  function peg$endExpectation() {
    return { type: "end" };
  }

  function peg$otherExpectation(description) {
    return { type: "other", description: description };
  }

  function peg$computePosDetails(pos) {
    var details = peg$posDetailsCache[pos], p;

    if (details) {
      return details;
    } else {
      p = pos - 1;
      while (!peg$posDetailsCache[p]) {
        p--;
      }

      details = peg$posDetailsCache[p];
      details = {
        line:   details.line,
        column: details.column
      };

      while (p < pos) {
        if (input.charCodeAt(p) === 10) {
          details.line++;
          details.column = 1;
        } else {
          details.column++;
        }

        p++;
      }

      peg$posDetailsCache[pos] = details;
      return details;
    }
  }

  function peg$computeLocation(startPos, endPos) {
    var startPosDetails = peg$computePosDetails(startPos),
        endPosDetails   = peg$computePosDetails(endPos);

    return {
      start: {
        offset: startPos,
        line:   startPosDetails.line,
        column: startPosDetails.column
      },
      end: {
        offset: endPos,
        line:   endPosDetails.line,
        column: endPosDetails.column
      }
    };
  }

  function peg$fail(expected) {
    if (peg$currPos < peg$maxFailPos) { return; }

    if (peg$currPos > peg$maxFailPos) {
      peg$maxFailPos = peg$currPos;
      peg$maxFailExpected = [];
    }

    peg$maxFailExpected.push(expected);
  }

  function peg$buildSimpleError(message, location) {
    return new peg$SyntaxError(message, null, null, location);
  }

  function peg$buildStructuredError(expected, found, location) {
    return new peg$SyntaxError(
      peg$SyntaxError.buildMessage(expected, found),
      expected,
      found,
      location
    );
  }

  function peg$parsestart() {
    var s0;

    s0 = peg$parsemessageFormatPattern();

    return s0;
  }

  function peg$parsemessageFormatPattern() {
    var s0, s1, s2;

    s0 = peg$currPos;
    s1 = [];
    s2 = peg$parsemessageFormatElement();
    while (s2 !== peg$FAILED) {
      s1.push(s2);
      s2 = peg$parsemessageFormatElement();
    }
    if (s1 !== peg$FAILED) {
      peg$savedPos = s0;
      s1 = peg$c0(s1);
    }
    s0 = s1;

    return s0;
  }

  function peg$parsemessageFormatElement() {
    var s0;

    s0 = peg$parsemessageTextElement();
    if (s0 === peg$FAILED) {
      s0 = peg$parseargumentElement();
    }

    return s0;
  }

  function peg$parsemessageText() {
    var s0, s1, s2, s3, s4, s5;

    s0 = peg$currPos;
    s1 = [];
    s2 = peg$currPos;
    s3 = peg$parse_();
    if (s3 !== peg$FAILED) {
      s4 = peg$parsechars();
      if (s4 !== peg$FAILED) {
        s5 = peg$parse_();
        if (s5 !== peg$FAILED) {
          s3 = [s3, s4, s5];
          s2 = s3;
        } else {
          peg$currPos = s2;
          s2 = peg$FAILED;
        }
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
    } else {
      peg$currPos = s2;
      s2 = peg$FAILED;
    }
    if (s2 !== peg$FAILED) {
      while (s2 !== peg$FAILED) {
        s1.push(s2);
        s2 = peg$currPos;
        s3 = peg$parse_();
        if (s3 !== peg$FAILED) {
          s4 = peg$parsechars();
          if (s4 !== peg$FAILED) {
            s5 = peg$parse_();
            if (s5 !== peg$FAILED) {
              s3 = [s3, s4, s5];
              s2 = s3;
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
          } else {
            peg$currPos = s2;
            s2 = peg$FAILED;
          }
        } else {
          peg$currPos = s2;
          s2 = peg$FAILED;
        }
      }
    } else {
      s1 = peg$FAILED;
    }
    if (s1 !== peg$FAILED) {
      peg$savedPos = s0;
      s1 = peg$c1(s1);
    }
    s0 = s1;
    if (s0 === peg$FAILED) {
      s0 = peg$currPos;
      s1 = peg$parsews();
      if (s1 !== peg$FAILED) {
        s0 = input.substring(s0, peg$currPos);
      } else {
        s0 = s1;
      }
    }

    return s0;
  }

  function peg$parsemessageTextElement() {
    var s0, s1;

    s0 = peg$currPos;
    s1 = peg$parsemessageText();
    if (s1 !== peg$FAILED) {
      peg$savedPos = s0;
      s1 = peg$c2(s1);
    }
    s0 = s1;

    return s0;
  }

  function peg$parseargument() {
    var s0, s1, s2;

    s0 = peg$parsenumber();
    if (s0 === peg$FAILED) {
      s0 = peg$currPos;
      s1 = [];
      s2 = peg$parsequoteEscapedChar();
      while (s2 !== peg$FAILED) {
        s1.push(s2);
        s2 = peg$parsequoteEscapedChar();
      }
      if (s1 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c3(s1);
      }
      s0 = s1;
    }

    return s0;
  }

  function peg$parseargumentElement() {
    var s0, s1, s2, s3, s4, s5, s6, s7, s8;

    s0 = peg$currPos;
    if (input.charCodeAt(peg$currPos) === 123) {
      s1 = peg$c4;
      peg$currPos++;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c5); }
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$parse_();
      if (s2 !== peg$FAILED) {
        s3 = peg$parseargument();
        if (s3 !== peg$FAILED) {
          s4 = peg$parse_();
          if (s4 !== peg$FAILED) {
            s5 = peg$currPos;
            if (input.charCodeAt(peg$currPos) === 44) {
              s6 = peg$c6;
              peg$currPos++;
            } else {
              s6 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c7); }
            }
            if (s6 !== peg$FAILED) {
              s7 = peg$parse_();
              if (s7 !== peg$FAILED) {
                s8 = peg$parseelementFormat();
                if (s8 !== peg$FAILED) {
                  s6 = [s6, s7, s8];
                  s5 = s6;
                } else {
                  peg$currPos = s5;
                  s5 = peg$FAILED;
                }
              } else {
                peg$currPos = s5;
                s5 = peg$FAILED;
              }
            } else {
              peg$currPos = s5;
              s5 = peg$FAILED;
            }
            if (s5 === peg$FAILED) {
              s5 = null;
            }
            if (s5 !== peg$FAILED) {
              s6 = peg$parse_();
              if (s6 !== peg$FAILED) {
                if (input.charCodeAt(peg$currPos) === 125) {
                  s7 = peg$c8;
                  peg$currPos++;
                } else {
                  s7 = peg$FAILED;
                  if (peg$silentFails === 0) { peg$fail(peg$c9); }
                }
                if (s7 !== peg$FAILED) {
                  peg$savedPos = s0;
                  s1 = peg$c10(s3, s5);
                  s0 = s1;
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parseelementFormat() {
    var s0;

    s0 = peg$parsesimpleFormat();
    if (s0 === peg$FAILED) {
      s0 = peg$parsepluralFormat();
      if (s0 === peg$FAILED) {
        s0 = peg$parseselectOrdinalFormat();
        if (s0 === peg$FAILED) {
          s0 = peg$parseselectFormat();
        }
      }
    }

    return s0;
  }

  function peg$parsesimpleFormat() {
    var s0, s1, s2, s3, s4, s5, s6;

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 6) === peg$c11) {
      s1 = peg$c11;
      peg$currPos += 6;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c12); }
    }
    if (s1 === peg$FAILED) {
      if (input.substr(peg$currPos, 4) === peg$c13) {
        s1 = peg$c13;
        peg$currPos += 4;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c14); }
      }
      if (s1 === peg$FAILED) {
        if (input.substr(peg$currPos, 4) === peg$c15) {
          s1 = peg$c15;
          peg$currPos += 4;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c16); }
        }
      }
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$parse_();
      if (s2 !== peg$FAILED) {
        s3 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 44) {
          s4 = peg$c6;
          peg$currPos++;
        } else {
          s4 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c7); }
        }
        if (s4 !== peg$FAILED) {
          s5 = peg$parse_();
          if (s5 !== peg$FAILED) {
            s6 = peg$parsechars();
            if (s6 !== peg$FAILED) {
              s4 = [s4, s5, s6];
              s3 = s4;
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
        } else {
          peg$currPos = s3;
          s3 = peg$FAILED;
        }
        if (s3 === peg$FAILED) {
          s3 = null;
        }
        if (s3 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c17(s1, s3);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parsepluralFormat() {
    var s0, s1, s2, s3, s4, s5;

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 6) === peg$c18) {
      s1 = peg$c18;
      peg$currPos += 6;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c19); }
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$parse_();
      if (s2 !== peg$FAILED) {
        if (input.charCodeAt(peg$currPos) === 44) {
          s3 = peg$c6;
          peg$currPos++;
        } else {
          s3 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c7); }
        }
        if (s3 !== peg$FAILED) {
          s4 = peg$parse_();
          if (s4 !== peg$FAILED) {
            s5 = peg$parsepluralStyle();
            if (s5 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c20(s5);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parseselectOrdinalFormat() {
    var s0, s1, s2, s3, s4, s5;

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 13) === peg$c21) {
      s1 = peg$c21;
      peg$currPos += 13;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c22); }
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$parse_();
      if (s2 !== peg$FAILED) {
        if (input.charCodeAt(peg$currPos) === 44) {
          s3 = peg$c6;
          peg$currPos++;
        } else {
          s3 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c7); }
        }
        if (s3 !== peg$FAILED) {
          s4 = peg$parse_();
          if (s4 !== peg$FAILED) {
            s5 = peg$parsepluralStyle();
            if (s5 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c23(s5);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parseselectFormat() {
    var s0, s1, s2, s3, s4, s5, s6;

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 6) === peg$c24) {
      s1 = peg$c24;
      peg$currPos += 6;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c25); }
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$parse_();
      if (s2 !== peg$FAILED) {
        if (input.charCodeAt(peg$currPos) === 44) {
          s3 = peg$c6;
          peg$currPos++;
        } else {
          s3 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c7); }
        }
        if (s3 !== peg$FAILED) {
          s4 = peg$parse_();
          if (s4 !== peg$FAILED) {
            s5 = [];
            s6 = peg$parseoptionalFormatPattern();
            if (s6 !== peg$FAILED) {
              while (s6 !== peg$FAILED) {
                s5.push(s6);
                s6 = peg$parseoptionalFormatPattern();
              }
            } else {
              s5 = peg$FAILED;
            }
            if (s5 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c26(s5);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parseselector() {
    var s0, s1, s2, s3;

    s0 = peg$currPos;
    s1 = peg$currPos;
    if (input.charCodeAt(peg$currPos) === 61) {
      s2 = peg$c27;
      peg$currPos++;
    } else {
      s2 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c28); }
    }
    if (s2 !== peg$FAILED) {
      s3 = peg$parsenumber();
      if (s3 !== peg$FAILED) {
        s2 = [s2, s3];
        s1 = s2;
      } else {
        peg$currPos = s1;
        s1 = peg$FAILED;
      }
    } else {
      peg$currPos = s1;
      s1 = peg$FAILED;
    }
    if (s1 !== peg$FAILED) {
      s0 = input.substring(s0, peg$currPos);
    } else {
      s0 = s1;
    }
    if (s0 === peg$FAILED) {
      s0 = peg$parsechars();
    }

    return s0;
  }

  function peg$parseoptionalFormatPattern() {
    var s0, s1, s2, s3, s4, s5, s6;

    s0 = peg$currPos;
    s1 = peg$parse_();
    if (s1 !== peg$FAILED) {
      s2 = peg$parseselector();
      if (s2 !== peg$FAILED) {
        s3 = peg$parse_();
        if (s3 !== peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 123) {
            s4 = peg$c4;
            peg$currPos++;
          } else {
            s4 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c5); }
          }
          if (s4 !== peg$FAILED) {
            s5 = peg$parsemessageFormatPattern();
            if (s5 !== peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 125) {
                s6 = peg$c8;
                peg$currPos++;
              } else {
                s6 = peg$FAILED;
                if (peg$silentFails === 0) { peg$fail(peg$c9); }
              }
              if (s6 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c29(s2, s5);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parseoffset() {
    var s0, s1, s2, s3;

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 7) === peg$c30) {
      s1 = peg$c30;
      peg$currPos += 7;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c31); }
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$parse_();
      if (s2 !== peg$FAILED) {
        s3 = peg$parsenumber();
        if (s3 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c32(s3);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parsepluralStyle() {
    var s0, s1, s2, s3, s4;

    s0 = peg$currPos;
    s1 = peg$parseoffset();
    if (s1 === peg$FAILED) {
      s1 = null;
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$parse_();
      if (s2 !== peg$FAILED) {
        s3 = [];
        s4 = peg$parseoptionalFormatPattern();
        if (s4 !== peg$FAILED) {
          while (s4 !== peg$FAILED) {
            s3.push(s4);
            s4 = peg$parseoptionalFormatPattern();
          }
        } else {
          s3 = peg$FAILED;
        }
        if (s3 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c33(s1, s3);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parsews() {
    var s0, s1;

    peg$silentFails++;
    s0 = [];
    if (peg$c35.test(input.charAt(peg$currPos))) {
      s1 = input.charAt(peg$currPos);
      peg$currPos++;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c36); }
    }
    if (s1 !== peg$FAILED) {
      while (s1 !== peg$FAILED) {
        s0.push(s1);
        if (peg$c35.test(input.charAt(peg$currPos))) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c36); }
        }
      }
    } else {
      s0 = peg$FAILED;
    }
    peg$silentFails--;
    if (s0 === peg$FAILED) {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c34); }
    }

    return s0;
  }

  function peg$parse_() {
    var s0, s1, s2;

    peg$silentFails++;
    s0 = peg$currPos;
    s1 = [];
    s2 = peg$parsews();
    while (s2 !== peg$FAILED) {
      s1.push(s2);
      s2 = peg$parsews();
    }
    if (s1 !== peg$FAILED) {
      s0 = input.substring(s0, peg$currPos);
    } else {
      s0 = s1;
    }
    peg$silentFails--;
    if (s0 === peg$FAILED) {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c37); }
    }

    return s0;
  }

  function peg$parsedigit() {
    var s0;

    if (peg$c38.test(input.charAt(peg$currPos))) {
      s0 = input.charAt(peg$currPos);
      peg$currPos++;
    } else {
      s0 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c39); }
    }

    return s0;
  }

  function peg$parsehexDigit() {
    var s0;

    if (peg$c40.test(input.charAt(peg$currPos))) {
      s0 = input.charAt(peg$currPos);
      peg$currPos++;
    } else {
      s0 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c41); }
    }

    return s0;
  }

  function peg$parsenumber() {
    var s0, s1, s2, s3, s4, s5;

    s0 = peg$currPos;
    if (input.charCodeAt(peg$currPos) === 48) {
      s1 = peg$c42;
      peg$currPos++;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c43); }
    }
    if (s1 === peg$FAILED) {
      s1 = peg$currPos;
      s2 = peg$currPos;
      if (peg$c44.test(input.charAt(peg$currPos))) {
        s3 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s3 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c45); }
      }
      if (s3 !== peg$FAILED) {
        s4 = [];
        s5 = peg$parsedigit();
        while (s5 !== peg$FAILED) {
          s4.push(s5);
          s5 = peg$parsedigit();
        }
        if (s4 !== peg$FAILED) {
          s3 = [s3, s4];
          s2 = s3;
        } else {
          peg$currPos = s2;
          s2 = peg$FAILED;
        }
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 !== peg$FAILED) {
        s1 = input.substring(s1, peg$currPos);
      } else {
        s1 = s2;
      }
    }
    if (s1 !== peg$FAILED) {
      peg$savedPos = s0;
      s1 = peg$c46(s1);
    }
    s0 = s1;

    return s0;
  }

  function peg$parsequoteEscapedChar() {
    var s0, s1, s2;

    s0 = peg$currPos;
    s1 = peg$currPos;
    peg$silentFails++;
    if (input.charCodeAt(peg$currPos) === 39) {
      s2 = peg$c47;
      peg$currPos++;
    } else {
      s2 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c48); }
    }
    if (s2 === peg$FAILED) {
      if (peg$c49.test(input.charAt(peg$currPos))) {
        s2 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s2 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c50); }
      }
    }
    peg$silentFails--;
    if (s2 === peg$FAILED) {
      s1 = void 0;
    } else {
      peg$currPos = s1;
      s1 = peg$FAILED;
    }
    if (s1 !== peg$FAILED) {
      if (input.length > peg$currPos) {
        s2 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s2 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c51); }
      }
      if (s2 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c52(s2);
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    if (s0 === peg$FAILED) {
      s0 = peg$currPos;
      if (input.charCodeAt(peg$currPos) === 39) {
        s1 = peg$c47;
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c48); }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parseescape();
        if (s2 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c53(s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    }

    return s0;
  }

  function peg$parseapostrophe() {
    var s0;

    if (input.charCodeAt(peg$currPos) === 39) {
      s0 = peg$c47;
      peg$currPos++;
    } else {
      s0 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c48); }
    }

    return s0;
  }

  function peg$parseescape() {
    var s0;

    if (peg$c49.test(input.charAt(peg$currPos))) {
      s0 = input.charAt(peg$currPos);
      peg$currPos++;
    } else {
      s0 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c50); }
    }
    if (s0 === peg$FAILED) {
      s0 = peg$parseapostrophe();
    }

    return s0;
  }

  function peg$parsechar() {
    var s0, s1, s2, s3, s4, s5, s6, s7;

    s0 = peg$currPos;
    if (input.charCodeAt(peg$currPos) === 39) {
      s1 = peg$c47;
      peg$currPos++;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c48); }
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$parseapostrophe();
      if (s2 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c53(s2);
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    if (s0 === peg$FAILED) {
      if (peg$c54.test(input.charAt(peg$currPos))) {
        s0 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s0 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c55); }
      }
      if (s0 === peg$FAILED) {
        s0 = peg$currPos;
        if (input.substr(peg$currPos, 2) === peg$c56) {
          s1 = peg$c56;
          peg$currPos += 2;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c57); }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c58();
        }
        s0 = s1;
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 2) === peg$c59) {
            s1 = peg$c59;
            peg$currPos += 2;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c60); }
          }
          if (s1 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c61();
          }
          s0 = s1;
          if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            if (input.substr(peg$currPos, 2) === peg$c62) {
              s1 = peg$c62;
              peg$currPos += 2;
            } else {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c63); }
            }
            if (s1 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c64();
            }
            s0 = s1;
            if (s0 === peg$FAILED) {
              s0 = peg$currPos;
              if (input.substr(peg$currPos, 2) === peg$c65) {
                s1 = peg$c65;
                peg$currPos += 2;
              } else {
                s1 = peg$FAILED;
                if (peg$silentFails === 0) { peg$fail(peg$c66); }
              }
              if (s1 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c67();
              }
              s0 = s1;
              if (s0 === peg$FAILED) {
                s0 = peg$currPos;
                if (input.substr(peg$currPos, 2) === peg$c68) {
                  s1 = peg$c68;
                  peg$currPos += 2;
                } else {
                  s1 = peg$FAILED;
                  if (peg$silentFails === 0) { peg$fail(peg$c69); }
                }
                if (s1 !== peg$FAILED) {
                  s2 = peg$currPos;
                  s3 = peg$currPos;
                  s4 = peg$parsehexDigit();
                  if (s4 !== peg$FAILED) {
                    s5 = peg$parsehexDigit();
                    if (s5 !== peg$FAILED) {
                      s6 = peg$parsehexDigit();
                      if (s6 !== peg$FAILED) {
                        s7 = peg$parsehexDigit();
                        if (s7 !== peg$FAILED) {
                          s4 = [s4, s5, s6, s7];
                          s3 = s4;
                        } else {
                          peg$currPos = s3;
                          s3 = peg$FAILED;
                        }
                      } else {
                        peg$currPos = s3;
                        s3 = peg$FAILED;
                      }
                    } else {
                      peg$currPos = s3;
                      s3 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s3;
                    s3 = peg$FAILED;
                  }
                  if (s3 !== peg$FAILED) {
                    s2 = input.substring(s2, peg$currPos);
                  } else {
                    s2 = s3;
                  }
                  if (s2 !== peg$FAILED) {
                    peg$savedPos = s0;
                    s1 = peg$c70(s2);
                    s0 = s1;
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              }
            }
          }
        }
      }
    }

    return s0;
  }

  function peg$parsechars() {
    var s0, s1, s2;

    s0 = peg$currPos;
    s1 = [];
    s2 = peg$parsechar();
    if (s2 !== peg$FAILED) {
      while (s2 !== peg$FAILED) {
        s1.push(s2);
        s2 = peg$parsechar();
      }
    } else {
      s1 = peg$FAILED;
    }
    if (s1 !== peg$FAILED) {
      peg$savedPos = s0;
      s1 = peg$c3(s1);
    }
    s0 = s1;

    return s0;
  }

  peg$result = peg$startRuleFunction();

  if (peg$result !== peg$FAILED && peg$currPos === input.length) {
    return peg$result;
  } else {
    if (peg$result !== peg$FAILED && peg$currPos < input.length) {
      peg$fail(peg$endExpectation());
    }

    throw peg$buildStructuredError(
      peg$maxFailExpected,
      peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null,
      peg$maxFailPos < input.length
        ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1)
        : peg$computeLocation(peg$maxFailPos, peg$maxFailPos)
    );
  }
}

module.exports = {
  SyntaxError: peg$SyntaxError,
  parse:       peg$parse
};

},{}],177:[function(require,module,exports){
"use strict";
/*
Copyright (c) 2014, Yahoo! Inc. All rights reserved.
Copyrights licensed under the New BSD License.
See the accompanying LICENSE file for terms.
*/
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var Compiler = /** @class */ (function () {
    function Compiler(locales, formats, formatters) {
        this.locales = [];
        this.formats = {
            number: {},
            date: {},
            time: {}
        };
        this.pluralNumberFormat = null;
        this.currentPlural = null;
        this.pluralStack = [];
        this.locales = locales;
        this.formats = formats;
        this.formatters = formatters;
    }
    Compiler.prototype.compile = function (ast) {
        this.pluralStack = [];
        this.currentPlural = null;
        this.pluralNumberFormat = null;
        return this.compileMessage(ast);
    };
    Compiler.prototype.compileMessage = function (ast) {
        var _this = this;
        if (!(ast && ast.type === 'messageFormatPattern')) {
            throw new Error('Message AST is not of type: "messageFormatPattern"');
        }
        var elements = ast.elements;
        var pattern = elements
            .filter(function (el) {
            return el.type === 'messageTextElement' || el.type === 'argumentElement';
        })
            .map(function (el) {
            return el.type === 'messageTextElement'
                ? _this.compileMessageText(el)
                : _this.compileArgument(el);
        });
        if (pattern.length !== elements.length) {
            throw new Error('Message element does not have a valid type');
        }
        return pattern;
    };
    Compiler.prototype.compileMessageText = function (element) {
        // When this `element` is part of plural sub-pattern and its value contains
        // an unescaped '#', use a `PluralOffsetString` helper to properly output
        // the number with the correct offset in the string.
        if (this.currentPlural && /(^|[^\\])#/g.test(element.value)) {
            // Create a cache a NumberFormat instance that can be reused for any
            // PluralOffsetString instance in this message.
            if (!this.pluralNumberFormat) {
                this.pluralNumberFormat = new Intl.NumberFormat(this.locales);
            }
            return new PluralOffsetString(this.currentPlural.id, this.currentPlural.format.offset, this.pluralNumberFormat, element.value);
        }
        // Unescape the escaped '#'s in the message text.
        return element.value.replace(/\\#/g, '#');
    };
    Compiler.prototype.compileArgument = function (element) {
        var format = element.format, id = element.id;
        var formatters = this.formatters;
        if (!format) {
            return new StringFormat(id);
        }
        var _a = this, formats = _a.formats, locales = _a.locales;
        switch (format.type) {
            case 'numberFormat':
                return {
                    id: id,
                    format: formatters.getNumberFormat(locales, formats.number[format.style]).format
                };
            case 'dateFormat':
                return {
                    id: id,
                    format: formatters.getDateTimeFormat(locales, formats.date[format.style]).format
                };
            case 'timeFormat':
                return {
                    id: id,
                    format: formatters.getDateTimeFormat(locales, formats.time[format.style]).format
                };
            case 'pluralFormat':
                return new PluralFormat(id, format.offset, this.compileOptions(element), formatters.getPluralRules(locales, {
                    type: format.ordinal ? 'ordinal' : 'cardinal'
                }));
            case 'selectFormat':
                return new SelectFormat(id, this.compileOptions(element));
            default:
                throw new Error('Message element does not have a valid format type');
        }
    };
    Compiler.prototype.compileOptions = function (element) {
        var _this = this;
        var format = element.format;
        var options = format.options;
        // Save the current plural element, if any, then set it to a new value when
        // compiling the options sub-patterns. This conforms the spec's algorithm
        // for handling `"#"` syntax in message text.
        this.pluralStack.push(this.currentPlural);
        this.currentPlural = format.type === 'pluralFormat' ? element : null;
        var optionsHash = options.reduce(function (all, option) {
            // Compile the sub-pattern and save it under the options's selector.
            all[option.selector] = _this.compileMessage(option.value);
            return all;
        }, {});
        // Pop the plural stack to put back the original current plural value.
        this.currentPlural = this.pluralStack.pop();
        return optionsHash;
    };
    return Compiler;
}());
exports.default = Compiler;
// -- Compiler Helper Classes --------------------------------------------------
var Formatter = /** @class */ (function () {
    function Formatter(id) {
        this.id = id;
    }
    return Formatter;
}());
var StringFormat = /** @class */ (function (_super) {
    __extends(StringFormat, _super);
    function StringFormat() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    StringFormat.prototype.format = function (value) {
        if (!value && typeof value !== 'number') {
            return '';
        }
        return typeof value === 'string' ? value : String(value);
    };
    return StringFormat;
}(Formatter));
var PluralFormat = /** @class */ (function () {
    function PluralFormat(id, offset, options, pluralRules) {
        this.id = id;
        this.offset = offset;
        this.options = options;
        this.pluralRules = pluralRules;
    }
    PluralFormat.prototype.getOption = function (value) {
        var options = this.options;
        var option = options['=' + value] ||
            options[this.pluralRules.select(value - this.offset)];
        return option || options.other;
    };
    return PluralFormat;
}());
var PluralOffsetString = /** @class */ (function (_super) {
    __extends(PluralOffsetString, _super);
    function PluralOffsetString(id, offset, numberFormat, string) {
        var _this = _super.call(this, id) || this;
        _this.offset = offset;
        _this.numberFormat = numberFormat;
        _this.string = string;
        return _this;
    }
    PluralOffsetString.prototype.format = function (value) {
        var number = this.numberFormat.format(value - this.offset);
        return this.string
            .replace(/(^|[^\\])#/g, '$1' + number)
            .replace(/\\#/g, '#');
    };
    return PluralOffsetString;
}(Formatter));
exports.PluralOffsetString = PluralOffsetString;
var SelectFormat = /** @class */ (function () {
    function SelectFormat(id, options) {
        this.id = id;
        this.options = options;
    }
    SelectFormat.prototype.getOption = function (value) {
        var options = this.options;
        return options[value] || options.other;
    };
    return SelectFormat;
}());
exports.SelectFormat = SelectFormat;
function isSelectOrPluralFormat(f) {
    return !!f.options;
}
exports.isSelectOrPluralFormat = isSelectOrPluralFormat;

},{}],178:[function(require,module,exports){
"use strict";
/*
Copyright (c) 2014, Yahoo! Inc. All rights reserved.
Copyrights licensed under the New BSD License.
See the accompanying LICENSE file for terms.
*/
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
Object.defineProperty(exports, "__esModule", { value: true });
/* jslint esnext: true */
var compiler_1 = require("./compiler");
// -- MessageFormat --------------------------------------------------------
function resolveLocale(locales) {
    if (typeof locales === 'string') {
        locales = [locales];
    }
    try {
        return Intl.NumberFormat.supportedLocalesOf(locales, {
            // IE11 localeMatcher `lookup` seems to convert `en` -> `en-US`
            // but not other browsers,
            localeMatcher: 'best fit'
        })[0];
    }
    catch (e) {
        return IntlMessageFormat.defaultLocale;
    }
}
function formatPatterns(pattern, values) {
    var result = '';
    for (var _i = 0, pattern_1 = pattern; _i < pattern_1.length; _i++) {
        var part = pattern_1[_i];
        // Exist early for string parts.
        if (typeof part === 'string') {
            result += part;
            continue;
        }
        var id = part.id;
        // Enforce that all required values are provided by the caller.
        if (!(values && id in values)) {
            throw new FormatError("A value must be provided for: " + id, id);
        }
        var value = values[id];
        // Recursively format plural and select parts' option — which can be a
        // nested pattern structure. The choosing of the option to use is
        // abstracted-by and delegated-to the part helper object.
        if (compiler_1.isSelectOrPluralFormat(part)) {
            result += formatPatterns(part.getOption(value), values);
        }
        else {
            result += part.format(value);
        }
    }
    return result;
}
function mergeConfig(c1, c2) {
    if (!c2) {
        return c1;
    }
    return __assign({}, (c1 || {}), (c2 || {}), Object.keys(c1).reduce(function (all, k) {
        all[k] = __assign({}, c1[k], (c2[k] || {}));
        return all;
    }, {}));
}
function mergeConfigs(defaultConfig, configs) {
    if (!configs) {
        return defaultConfig;
    }
    return Object.keys(defaultConfig).reduce(function (all, k) {
        all[k] = mergeConfig(defaultConfig[k], configs[k]);
        return all;
    }, __assign({}, defaultConfig));
}
var FormatError = /** @class */ (function (_super) {
    __extends(FormatError, _super);
    function FormatError(msg, variableId) {
        var _this = _super.call(this, msg) || this;
        _this.variableId = variableId;
        return _this;
    }
    return FormatError;
}(Error));
function createDefaultFormatters() {
    return {
        getNumberFormat: function () {
            var _a;
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            return new ((_a = Intl.NumberFormat).bind.apply(_a, [void 0].concat(args)))();
        },
        getDateTimeFormat: function () {
            var _a;
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            return new ((_a = Intl.DateTimeFormat).bind.apply(_a, [void 0].concat(args)))();
        },
        getPluralRules: function () {
            var _a;
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            return new ((_a = Intl.PluralRules).bind.apply(_a, [void 0].concat(args)))();
        }
    };
}
exports.createDefaultFormatters = createDefaultFormatters;
var IntlMessageFormat = /** @class */ (function () {
    function IntlMessageFormat(message, locales, overrideFormats, opts) {
        var _this = this;
        if (locales === void 0) { locales = IntlMessageFormat.defaultLocale; }
        this.format = function (values) {
            try {
                return formatPatterns(_this.pattern, values);
            }
            catch (e) {
                if (e.variableId) {
                    throw new Error("The intl string context variable '" + e.variableId + "' was not provided to the string '" + _this.message + "'");
                }
                else {
                    throw e;
                }
            }
        };
        if (typeof message === 'string') {
            if (!IntlMessageFormat.__parse) {
                throw new TypeError('IntlMessageFormat.__parse must be set to process `message` of type `string`');
            }
            // Parse string messages into an AST.
            this.ast = IntlMessageFormat.__parse(message);
        }
        else {
            this.ast = message;
        }
        this.message = message;
        if (!(this.ast && this.ast.type === 'messageFormatPattern')) {
            throw new TypeError('A message must be provided as a String or AST.');
        }
        // Creates a new object with the specified `formats` merged with the default
        // formats.
        var formats = mergeConfigs(IntlMessageFormat.formats, overrideFormats);
        // Defined first because it's used to build the format pattern.
        this.locale = resolveLocale(locales || []);
        var formatters = (opts && opts.formatters) || createDefaultFormatters();
        // Compile the `ast` to a pattern that is highly optimized for repeated
        // `format()` invocations. **Note:** This passes the `locales` set provided
        // to the constructor instead of just the resolved locale.
        this.pattern = new compiler_1.default(locales, formats, formatters).compile(this.ast);
        // "Bind" `format()` method to `this` so it can be passed by reference like
        // the other `Intl` APIs.
    }
    IntlMessageFormat.prototype.resolvedOptions = function () {
        return { locale: this.locale };
    };
    IntlMessageFormat.prototype.getAst = function () {
        return this.ast;
    };
    IntlMessageFormat.defaultLocale = 'en';
    IntlMessageFormat.__parse = undefined;
    // Default format options used as the prototype of the `formats` provided to the
    // constructor. These are used when constructing the internal Intl.NumberFormat
    // and Intl.DateTimeFormat instances.
    IntlMessageFormat.formats = {
        number: {
            currency: {
                style: 'currency'
            },
            percent: {
                style: 'percent'
            }
        },
        date: {
            short: {
                month: 'numeric',
                day: 'numeric',
                year: '2-digit'
            },
            medium: {
                month: 'short',
                day: 'numeric',
                year: 'numeric'
            },
            long: {
                month: 'long',
                day: 'numeric',
                year: 'numeric'
            },
            full: {
                weekday: 'long',
                month: 'long',
                day: 'numeric',
                year: 'numeric'
            }
        },
        time: {
            short: {
                hour: 'numeric',
                minute: 'numeric'
            },
            medium: {
                hour: 'numeric',
                minute: 'numeric',
                second: 'numeric'
            },
            long: {
                hour: 'numeric',
                minute: 'numeric',
                second: 'numeric',
                timeZoneName: 'short'
            },
            full: {
                hour: 'numeric',
                minute: 'numeric',
                second: 'numeric',
                timeZoneName: 'short'
            }
        }
    };
    return IntlMessageFormat;
}());
exports.IntlMessageFormat = IntlMessageFormat;
exports.default = IntlMessageFormat;

},{"./compiler":177}],179:[function(require,module,exports){
"use strict";
/*
Copyright (c) 2014, Yahoo! Inc. All rights reserved.
Copyrights licensed under the New BSD License.
See the accompanying LICENSE file for terms.
*/
function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
var intl_messageformat_parser_1 = require("intl-messageformat-parser");
var core_1 = require("./core");
core_1.default.__parse = intl_messageformat_parser_1.default.parse;
__export(require("./core"));
exports.default = core_1.default;

},{"./core":178,"intl-messageformat-parser":175}],180:[function(require,module,exports){
'use strict';
var IntlMessageFormat = require('./dist').default;

// Re-export `IntlMessageFormat` as the CommonJS default exports with all the
// locale data registered, and with English set as the default locale. Define
// the `default` prop for use with other compiled ES6 Modules.
exports = module.exports = IntlMessageFormat;
exports['default'] = exports;

},{"./dist":179}],181:[function(require,module,exports){
'use strict';

var hasToStringTag = typeof Symbol === 'function' && typeof Symbol.toStringTag === 'symbol';
var callBound = require('call-bind/callBound');

var $toString = callBound('Object.prototype.toString');

var isStandardArguments = function isArguments(value) {
	if (hasToStringTag && value && typeof value === 'object' && Symbol.toStringTag in value) {
		return false;
	}
	return $toString(value) === '[object Arguments]';
};

var isLegacyArguments = function isArguments(value) {
	if (isStandardArguments(value)) {
		return true;
	}
	return value !== null &&
		typeof value === 'object' &&
		typeof value.length === 'number' &&
		value.length >= 0 &&
		$toString(value) !== '[object Array]' &&
		$toString(value.callee) === '[object Function]';
};

var supportsStandardArguments = (function () {
	return isStandardArguments(arguments);
}());

isStandardArguments.isLegacyArguments = isLegacyArguments; // for tests

module.exports = supportsStandardArguments ? isStandardArguments : isLegacyArguments;

},{"call-bind/callBound":146}],182:[function(require,module,exports){
/*!
 * Determine if an object is a Buffer
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */

// The _isBuffer check is for Safari 5-7 support, because it's missing
// Object.prototype.constructor. Remove this eventually
module.exports = function (obj) {
  return obj != null && (isBuffer(obj) || isSlowBuffer(obj) || !!obj._isBuffer)
}

function isBuffer (obj) {
  return !!obj.constructor && typeof obj.constructor.isBuffer === 'function' && obj.constructor.isBuffer(obj)
}

// For Node v0.10 support. Remove this eventually.
function isSlowBuffer (obj) {
  return typeof obj.readFloatLE === 'function' && typeof obj.slice === 'function' && isBuffer(obj.slice(0, 0))
}

},{}],183:[function(require,module,exports){
'use strict';

var toStr = Object.prototype.toString;
var fnToStr = Function.prototype.toString;
var isFnRegex = /^\s*(?:function)?\*/;
var hasToStringTag = typeof Symbol === 'function' && typeof Symbol.toStringTag === 'symbol';
var getProto = Object.getPrototypeOf;
var getGeneratorFunc = function () { // eslint-disable-line consistent-return
	if (!hasToStringTag) {
		return false;
	}
	try {
		return Function('return function*() {}')();
	} catch (e) {
	}
};
var generatorFunc = getGeneratorFunc();
var GeneratorFunction = getProto && generatorFunc ? getProto(generatorFunc) : false;

module.exports = function isGeneratorFunction(fn) {
	if (typeof fn !== 'function') {
		return false;
	}
	if (isFnRegex.test(fnToStr.call(fn))) {
		return true;
	}
	if (!hasToStringTag) {
		var str = toStr.call(fn);
		return str === '[object GeneratorFunction]';
	}
	return getProto && getProto(fn) === GeneratorFunction;
};

},{}],184:[function(require,module,exports){
(function (global){(function (){
'use strict';

var forEach = require('foreach');
var availableTypedArrays = require('available-typed-arrays');
var callBound = require('call-bind/callBound');

var $toString = callBound('Object.prototype.toString');
var hasSymbols = require('has-symbols')();
var hasToStringTag = hasSymbols && typeof Symbol.toStringTag === 'symbol';

var typedArrays = availableTypedArrays();

var $indexOf = callBound('Array.prototype.indexOf', true) || function indexOf(array, value) {
	for (var i = 0; i < array.length; i += 1) {
		if (array[i] === value) {
			return i;
		}
	}
	return -1;
};
var $slice = callBound('String.prototype.slice');
var toStrTags = {};
var gOPD = require('es-abstract/helpers/getOwnPropertyDescriptor');
var getPrototypeOf = Object.getPrototypeOf; // require('getprototypeof');
if (hasToStringTag && gOPD && getPrototypeOf) {
	forEach(typedArrays, function (typedArray) {
		var arr = new global[typedArray]();
		if (!(Symbol.toStringTag in arr)) {
			throw new EvalError('this engine has support for Symbol.toStringTag, but ' + typedArray + ' does not have the property! Please report this.');
		}
		var proto = getPrototypeOf(arr);
		var descriptor = gOPD(proto, Symbol.toStringTag);
		if (!descriptor) {
			var superProto = getPrototypeOf(proto);
			descriptor = gOPD(superProto, Symbol.toStringTag);
		}
		toStrTags[typedArray] = descriptor.get;
	});
}

var tryTypedArrays = function tryAllTypedArrays(value) {
	var anyTrue = false;
	forEach(toStrTags, function (getter, typedArray) {
		if (!anyTrue) {
			try {
				anyTrue = getter.call(value) === typedArray;
			} catch (e) { /**/ }
		}
	});
	return anyTrue;
};

module.exports = function isTypedArray(value) {
	if (!value || typeof value !== 'object') { return false; }
	if (!hasToStringTag) {
		var tag = $slice($toString(value), 8, -1);
		return $indexOf(typedArrays, tag) > -1;
	}
	if (!gOPD) { return false; }
	return tryTypedArrays(value);
};

}).call(this)}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"available-typed-arrays":131,"call-bind/callBound":146,"es-abstract/helpers/getOwnPropertyDescriptor":161,"foreach":163,"has-symbols":167}],185:[function(require,module,exports){
var encode = require('./lib/encoder'),
    decode = require('./lib/decoder');

module.exports = {
  encode: encode,
  decode: decode
};

},{"./lib/decoder":186,"./lib/encoder":187}],186:[function(require,module,exports){
(function (Buffer){(function (){
/* -*- tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- /
/* vim: set shiftwidth=2 tabstop=2 autoindent cindent expandtab: */
/*
   Copyright 2011 notmasteryet

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.
*/

// - The JPEG specification can be found in the ITU CCITT Recommendation T.81
//   (www.w3.org/Graphics/JPEG/itu-t81.pdf)
// - The JFIF specification can be found in the JPEG File Interchange Format
//   (www.w3.org/Graphics/JPEG/jfif3.pdf)
// - The Adobe Application-Specific JPEG markers in the Supporting the DCT Filters
//   in PostScript Level 2, Technical Note #5116
//   (partners.adobe.com/public/developer/en/ps/sdk/5116.DCT_Filter.pdf)

var JpegImage = (function jpegImage() {
  "use strict";
  var dctZigZag = new Int32Array([
     0,
     1,  8,
    16,  9,  2,
     3, 10, 17, 24,
    32, 25, 18, 11, 4,
     5, 12, 19, 26, 33, 40,
    48, 41, 34, 27, 20, 13,  6,
     7, 14, 21, 28, 35, 42, 49, 56,
    57, 50, 43, 36, 29, 22, 15,
    23, 30, 37, 44, 51, 58,
    59, 52, 45, 38, 31,
    39, 46, 53, 60,
    61, 54, 47,
    55, 62,
    63
  ]);

  var dctCos1  =  4017   // cos(pi/16)
  var dctSin1  =   799   // sin(pi/16)
  var dctCos3  =  3406   // cos(3*pi/16)
  var dctSin3  =  2276   // sin(3*pi/16)
  var dctCos6  =  1567   // cos(6*pi/16)
  var dctSin6  =  3784   // sin(6*pi/16)
  var dctSqrt2 =  5793   // sqrt(2)
  var dctSqrt1d2 = 2896  // sqrt(2) / 2

  function constructor() {
  }

  function buildHuffmanTable(codeLengths, values) {
    var k = 0, code = [], i, j, length = 16;
    while (length > 0 && !codeLengths[length - 1])
      length--;
    code.push({children: [], index: 0});
    var p = code[0], q;
    for (i = 0; i < length; i++) {
      for (j = 0; j < codeLengths[i]; j++) {
        p = code.pop();
        p.children[p.index] = values[k];
        while (p.index > 0) {
          if (code.length === 0)
            throw new Error('Could not recreate Huffman Table');
          p = code.pop();
        }
        p.index++;
        code.push(p);
        while (code.length <= i) {
          code.push(q = {children: [], index: 0});
          p.children[p.index] = q.children;
          p = q;
        }
        k++;
      }
      if (i + 1 < length) {
        // p here points to last code
        code.push(q = {children: [], index: 0});
        p.children[p.index] = q.children;
        p = q;
      }
    }
    return code[0].children;
  }

  function decodeScan(data, offset,
                      frame, components, resetInterval,
                      spectralStart, spectralEnd,
                      successivePrev, successive, opts) {
    var precision = frame.precision;
    var samplesPerLine = frame.samplesPerLine;
    var scanLines = frame.scanLines;
    var mcusPerLine = frame.mcusPerLine;
    var progressive = frame.progressive;
    var maxH = frame.maxH, maxV = frame.maxV;

    var startOffset = offset, bitsData = 0, bitsCount = 0;
    function readBit() {
      if (bitsCount > 0) {
        bitsCount--;
        return (bitsData >> bitsCount) & 1;
      }
      bitsData = data[offset++];
      if (bitsData == 0xFF) {
        var nextByte = data[offset++];
        if (nextByte) {
          throw new Error("unexpected marker: " + ((bitsData << 8) | nextByte).toString(16));
        }
        // unstuff 0
      }
      bitsCount = 7;
      return bitsData >>> 7;
    }
    function decodeHuffman(tree) {
      var node = tree, bit;
      while ((bit = readBit()) !== null) {
        node = node[bit];
        if (typeof node === 'number')
          return node;
        if (typeof node !== 'object')
          throw new Error("invalid huffman sequence");
      }
      return null;
    }
    function receive(length) {
      var n = 0;
      while (length > 0) {
        var bit = readBit();
        if (bit === null) return;
        n = (n << 1) | bit;
        length--;
      }
      return n;
    }
    function receiveAndExtend(length) {
      var n = receive(length);
      if (n >= 1 << (length - 1))
        return n;
      return n + (-1 << length) + 1;
    }
    function decodeBaseline(component, zz) {
      var t = decodeHuffman(component.huffmanTableDC);
      var diff = t === 0 ? 0 : receiveAndExtend(t);
      zz[0]= (component.pred += diff);
      var k = 1;
      while (k < 64) {
        var rs = decodeHuffman(component.huffmanTableAC);
        var s = rs & 15, r = rs >> 4;
        if (s === 0) {
          if (r < 15)
            break;
          k += 16;
          continue;
        }
        k += r;
        var z = dctZigZag[k];
        zz[z] = receiveAndExtend(s);
        k++;
      }
    }
    function decodeDCFirst(component, zz) {
      var t = decodeHuffman(component.huffmanTableDC);
      var diff = t === 0 ? 0 : (receiveAndExtend(t) << successive);
      zz[0] = (component.pred += diff);
    }
    function decodeDCSuccessive(component, zz) {
      zz[0] |= readBit() << successive;
    }
    var eobrun = 0;
    function decodeACFirst(component, zz) {
      if (eobrun > 0) {
        eobrun--;
        return;
      }
      var k = spectralStart, e = spectralEnd;
      while (k <= e) {
        var rs = decodeHuffman(component.huffmanTableAC);
        var s = rs & 15, r = rs >> 4;
        if (s === 0) {
          if (r < 15) {
            eobrun = receive(r) + (1 << r) - 1;
            break;
          }
          k += 16;
          continue;
        }
        k += r;
        var z = dctZigZag[k];
        zz[z] = receiveAndExtend(s) * (1 << successive);
        k++;
      }
    }
    var successiveACState = 0, successiveACNextValue;
    function decodeACSuccessive(component, zz) {
      var k = spectralStart, e = spectralEnd, r = 0;
      while (k <= e) {
        var z = dctZigZag[k];
        var direction = zz[z] < 0 ? -1 : 1;
        switch (successiveACState) {
        case 0: // initial state
          var rs = decodeHuffman(component.huffmanTableAC);
          var s = rs & 15, r = rs >> 4;
          if (s === 0) {
            if (r < 15) {
              eobrun = receive(r) + (1 << r);
              successiveACState = 4;
            } else {
              r = 16;
              successiveACState = 1;
            }
          } else {
            if (s !== 1)
              throw new Error("invalid ACn encoding");
            successiveACNextValue = receiveAndExtend(s);
            successiveACState = r ? 2 : 3;
          }
          continue;
        case 1: // skipping r zero items
        case 2:
          if (zz[z])
            zz[z] += (readBit() << successive) * direction;
          else {
            r--;
            if (r === 0)
              successiveACState = successiveACState == 2 ? 3 : 0;
          }
          break;
        case 3: // set value for a zero item
          if (zz[z])
            zz[z] += (readBit() << successive) * direction;
          else {
            zz[z] = successiveACNextValue << successive;
            successiveACState = 0;
          }
          break;
        case 4: // eob
          if (zz[z])
            zz[z] += (readBit() << successive) * direction;
          break;
        }
        k++;
      }
      if (successiveACState === 4) {
        eobrun--;
        if (eobrun === 0)
          successiveACState = 0;
      }
    }
    function decodeMcu(component, decode, mcu, row, col) {
      var mcuRow = (mcu / mcusPerLine) | 0;
      var mcuCol = mcu % mcusPerLine;
      var blockRow = mcuRow * component.v + row;
      var blockCol = mcuCol * component.h + col;
      // If the block is missing and we're in tolerant mode, just skip it.
      if (component.blocks[blockRow] === undefined && opts.tolerantDecoding)
        return;
      decode(component, component.blocks[blockRow][blockCol]);
    }
    function decodeBlock(component, decode, mcu) {
      var blockRow = (mcu / component.blocksPerLine) | 0;
      var blockCol = mcu % component.blocksPerLine;
      // If the block is missing and we're in tolerant mode, just skip it.
      if (component.blocks[blockRow] === undefined && opts.tolerantDecoding)
        return;
      decode(component, component.blocks[blockRow][blockCol]);
    }

    var componentsLength = components.length;
    var component, i, j, k, n;
    var decodeFn;
    if (progressive) {
      if (spectralStart === 0)
        decodeFn = successivePrev === 0 ? decodeDCFirst : decodeDCSuccessive;
      else
        decodeFn = successivePrev === 0 ? decodeACFirst : decodeACSuccessive;
    } else {
      decodeFn = decodeBaseline;
    }

    var mcu = 0, marker;
    var mcuExpected;
    if (componentsLength == 1) {
      mcuExpected = components[0].blocksPerLine * components[0].blocksPerColumn;
    } else {
      mcuExpected = mcusPerLine * frame.mcusPerColumn;
    }
    if (!resetInterval) resetInterval = mcuExpected;

    var h, v;
    while (mcu < mcuExpected) {
      // reset interval stuff
      for (i = 0; i < componentsLength; i++)
        components[i].pred = 0;
      eobrun = 0;

      if (componentsLength == 1) {
        component = components[0];
        for (n = 0; n < resetInterval; n++) {
          decodeBlock(component, decodeFn, mcu);
          mcu++;
        }
      } else {
        for (n = 0; n < resetInterval; n++) {
          for (i = 0; i < componentsLength; i++) {
            component = components[i];
            h = component.h;
            v = component.v;
            for (j = 0; j < v; j++) {
              for (k = 0; k < h; k++) {
                decodeMcu(component, decodeFn, mcu, j, k);
              }
            }
          }
          mcu++;

          // If we've reached our expected MCU's, stop decoding
          if (mcu === mcuExpected) break;
        }
      }

      if (mcu === mcuExpected) {
        // Skip trailing bytes at the end of the scan - until we reach the next marker
        do {
          if (data[offset] === 0xFF) {
            if (data[offset + 1] !== 0x00) {
              break;
            }
          }
          offset += 1;
        } while (offset < data.length - 2);
      }

      // find marker
      bitsCount = 0;
      marker = (data[offset] << 8) | data[offset + 1];
      if (marker < 0xFF00) {
        throw new Error("marker was not found");
      }

      if (marker >= 0xFFD0 && marker <= 0xFFD7) { // RSTx
        offset += 2;
      }
      else
        break;
    }

    return offset - startOffset;
  }

  function buildComponentData(frame, component) {
    var lines = [];
    var blocksPerLine = component.blocksPerLine;
    var blocksPerColumn = component.blocksPerColumn;
    var samplesPerLine = blocksPerLine << 3;
    // Only 1 used per invocation of this function and garbage collected after invocation, so no need to account for its memory footprint.
    var R = new Int32Array(64), r = new Uint8Array(64);

    // A port of poppler's IDCT method which in turn is taken from:
    //   Christoph Loeffler, Adriaan Ligtenberg, George S. Moschytz,
    //   "Practical Fast 1-D DCT Algorithms with 11 Multiplications",
    //   IEEE Intl. Conf. on Acoustics, Speech & Signal Processing, 1989,
    //   988-991.
    function quantizeAndInverse(zz, dataOut, dataIn) {
      var qt = component.quantizationTable;
      var v0, v1, v2, v3, v4, v5, v6, v7, t;
      var p = dataIn;
      var i;

      // dequant
      for (i = 0; i < 64; i++)
        p[i] = zz[i] * qt[i];

      // inverse DCT on rows
      for (i = 0; i < 8; ++i) {
        var row = 8 * i;

        // check for all-zero AC coefficients
        if (p[1 + row] == 0 && p[2 + row] == 0 && p[3 + row] == 0 &&
            p[4 + row] == 0 && p[5 + row] == 0 && p[6 + row] == 0 &&
            p[7 + row] == 0) {
          t = (dctSqrt2 * p[0 + row] + 512) >> 10;
          p[0 + row] = t;
          p[1 + row] = t;
          p[2 + row] = t;
          p[3 + row] = t;
          p[4 + row] = t;
          p[5 + row] = t;
          p[6 + row] = t;
          p[7 + row] = t;
          continue;
        }

        // stage 4
        v0 = (dctSqrt2 * p[0 + row] + 128) >> 8;
        v1 = (dctSqrt2 * p[4 + row] + 128) >> 8;
        v2 = p[2 + row];
        v3 = p[6 + row];
        v4 = (dctSqrt1d2 * (p[1 + row] - p[7 + row]) + 128) >> 8;
        v7 = (dctSqrt1d2 * (p[1 + row] + p[7 + row]) + 128) >> 8;
        v5 = p[3 + row] << 4;
        v6 = p[5 + row] << 4;

        // stage 3
        t = (v0 - v1+ 1) >> 1;
        v0 = (v0 + v1 + 1) >> 1;
        v1 = t;
        t = (v2 * dctSin6 + v3 * dctCos6 + 128) >> 8;
        v2 = (v2 * dctCos6 - v3 * dctSin6 + 128) >> 8;
        v3 = t;
        t = (v4 - v6 + 1) >> 1;
        v4 = (v4 + v6 + 1) >> 1;
        v6 = t;
        t = (v7 + v5 + 1) >> 1;
        v5 = (v7 - v5 + 1) >> 1;
        v7 = t;

        // stage 2
        t = (v0 - v3 + 1) >> 1;
        v0 = (v0 + v3 + 1) >> 1;
        v3 = t;
        t = (v1 - v2 + 1) >> 1;
        v1 = (v1 + v2 + 1) >> 1;
        v2 = t;
        t = (v4 * dctSin3 + v7 * dctCos3 + 2048) >> 12;
        v4 = (v4 * dctCos3 - v7 * dctSin3 + 2048) >> 12;
        v7 = t;
        t = (v5 * dctSin1 + v6 * dctCos1 + 2048) >> 12;
        v5 = (v5 * dctCos1 - v6 * dctSin1 + 2048) >> 12;
        v6 = t;

        // stage 1
        p[0 + row] = v0 + v7;
        p[7 + row] = v0 - v7;
        p[1 + row] = v1 + v6;
        p[6 + row] = v1 - v6;
        p[2 + row] = v2 + v5;
        p[5 + row] = v2 - v5;
        p[3 + row] = v3 + v4;
        p[4 + row] = v3 - v4;
      }

      // inverse DCT on columns
      for (i = 0; i < 8; ++i) {
        var col = i;

        // check for all-zero AC coefficients
        if (p[1*8 + col] == 0 && p[2*8 + col] == 0 && p[3*8 + col] == 0 &&
            p[4*8 + col] == 0 && p[5*8 + col] == 0 && p[6*8 + col] == 0 &&
            p[7*8 + col] == 0) {
          t = (dctSqrt2 * dataIn[i+0] + 8192) >> 14;
          p[0*8 + col] = t;
          p[1*8 + col] = t;
          p[2*8 + col] = t;
          p[3*8 + col] = t;
          p[4*8 + col] = t;
          p[5*8 + col] = t;
          p[6*8 + col] = t;
          p[7*8 + col] = t;
          continue;
        }

        // stage 4
        v0 = (dctSqrt2 * p[0*8 + col] + 2048) >> 12;
        v1 = (dctSqrt2 * p[4*8 + col] + 2048) >> 12;
        v2 = p[2*8 + col];
        v3 = p[6*8 + col];
        v4 = (dctSqrt1d2 * (p[1*8 + col] - p[7*8 + col]) + 2048) >> 12;
        v7 = (dctSqrt1d2 * (p[1*8 + col] + p[7*8 + col]) + 2048) >> 12;
        v5 = p[3*8 + col];
        v6 = p[5*8 + col];

        // stage 3
        t = (v0 - v1 + 1) >> 1;
        v0 = (v0 + v1 + 1) >> 1;
        v1 = t;
        t = (v2 * dctSin6 + v3 * dctCos6 + 2048) >> 12;
        v2 = (v2 * dctCos6 - v3 * dctSin6 + 2048) >> 12;
        v3 = t;
        t = (v4 - v6 + 1) >> 1;
        v4 = (v4 + v6 + 1) >> 1;
        v6 = t;
        t = (v7 + v5 + 1) >> 1;
        v5 = (v7 - v5 + 1) >> 1;
        v7 = t;

        // stage 2
        t = (v0 - v3 + 1) >> 1;
        v0 = (v0 + v3 + 1) >> 1;
        v3 = t;
        t = (v1 - v2 + 1) >> 1;
        v1 = (v1 + v2 + 1) >> 1;
        v2 = t;
        t = (v4 * dctSin3 + v7 * dctCos3 + 2048) >> 12;
        v4 = (v4 * dctCos3 - v7 * dctSin3 + 2048) >> 12;
        v7 = t;
        t = (v5 * dctSin1 + v6 * dctCos1 + 2048) >> 12;
        v5 = (v5 * dctCos1 - v6 * dctSin1 + 2048) >> 12;
        v6 = t;

        // stage 1
        p[0*8 + col] = v0 + v7;
        p[7*8 + col] = v0 - v7;
        p[1*8 + col] = v1 + v6;
        p[6*8 + col] = v1 - v6;
        p[2*8 + col] = v2 + v5;
        p[5*8 + col] = v2 - v5;
        p[3*8 + col] = v3 + v4;
        p[4*8 + col] = v3 - v4;
      }

      // convert to 8-bit integers
      for (i = 0; i < 64; ++i) {
        var sample = 128 + ((p[i] + 8) >> 4);
        dataOut[i] = sample < 0 ? 0 : sample > 0xFF ? 0xFF : sample;
      }
    }

    requestMemoryAllocation(samplesPerLine * blocksPerColumn * 8);

    var i, j;
    for (var blockRow = 0; blockRow < blocksPerColumn; blockRow++) {
      var scanLine = blockRow << 3;
      for (i = 0; i < 8; i++)
        lines.push(new Uint8Array(samplesPerLine));
      for (var blockCol = 0; blockCol < blocksPerLine; blockCol++) {
        quantizeAndInverse(component.blocks[blockRow][blockCol], r, R);

        var offset = 0, sample = blockCol << 3;
        for (j = 0; j < 8; j++) {
          var line = lines[scanLine + j];
          for (i = 0; i < 8; i++)
            line[sample + i] = r[offset++];
        }
      }
    }
    return lines;
  }

  function clampTo8bit(a) {
    return a < 0 ? 0 : a > 255 ? 255 : a;
  }

  constructor.prototype = {
    load: function load(path) {
      var xhr = new XMLHttpRequest();
      xhr.open("GET", path, true);
      xhr.responseType = "arraybuffer";
      xhr.onload = (function() {
        // TODO catch parse error
        var data = new Uint8Array(xhr.response || xhr.mozResponseArrayBuffer);
        this.parse(data);
        if (this.onload)
          this.onload();
      }).bind(this);
      xhr.send(null);
    },
    parse: function parse(data) {
      var maxResolutionInPixels = this.opts.maxResolutionInMP * 1000 * 1000;
      var offset = 0, length = data.length;
      function readUint16() {
        var value = (data[offset] << 8) | data[offset + 1];
        offset += 2;
        return value;
      }
      function readDataBlock() {
        var length = readUint16();
        var array = data.subarray(offset, offset + length - 2);
        offset += array.length;
        return array;
      }
      function prepareComponents(frame) {
        var maxH = 0, maxV = 0;
        var component, componentId;
        for (componentId in frame.components) {
          if (frame.components.hasOwnProperty(componentId)) {
            component = frame.components[componentId];
            if (maxH < component.h) maxH = component.h;
            if (maxV < component.v) maxV = component.v;
          }
        }
        var mcusPerLine = Math.ceil(frame.samplesPerLine / 8 / maxH);
        var mcusPerColumn = Math.ceil(frame.scanLines / 8 / maxV);
        for (componentId in frame.components) {
          if (frame.components.hasOwnProperty(componentId)) {
            component = frame.components[componentId];
            var blocksPerLine = Math.ceil(Math.ceil(frame.samplesPerLine / 8) * component.h / maxH);
            var blocksPerColumn = Math.ceil(Math.ceil(frame.scanLines  / 8) * component.v / maxV);
            var blocksPerLineForMcu = mcusPerLine * component.h;
            var blocksPerColumnForMcu = mcusPerColumn * component.v;
            var blocksToAllocate = blocksPerColumnForMcu * blocksPerLineForMcu;
            var blocks = [];

            // Each block is a Int32Array of length 64 (4 x 64 = 256 bytes)
            requestMemoryAllocation(blocksToAllocate * 256);

            for (var i = 0; i < blocksPerColumnForMcu; i++) {
              var row = [];
              for (var j = 0; j < blocksPerLineForMcu; j++)
                row.push(new Int32Array(64));
              blocks.push(row);
            }
            component.blocksPerLine = blocksPerLine;
            component.blocksPerColumn = blocksPerColumn;
            component.blocks = blocks;
          }
        }
        frame.maxH = maxH;
        frame.maxV = maxV;
        frame.mcusPerLine = mcusPerLine;
        frame.mcusPerColumn = mcusPerColumn;
      }
      var jfif = null;
      var adobe = null;
      var pixels = null;
      var frame, resetInterval;
      var quantizationTables = [], frames = [];
      var huffmanTablesAC = [], huffmanTablesDC = [];
      var fileMarker = readUint16();
      this.comments = [];
      if (fileMarker != 0xFFD8) { // SOI (Start of Image)
        throw new Error("SOI not found");
      }

      fileMarker = readUint16();
      while (fileMarker != 0xFFD9) { // EOI (End of image)
        var i, j, l;
        switch(fileMarker) {
          case 0xFF00: break;
          case 0xFFE0: // APP0 (Application Specific)
          case 0xFFE1: // APP1
          case 0xFFE2: // APP2
          case 0xFFE3: // APP3
          case 0xFFE4: // APP4
          case 0xFFE5: // APP5
          case 0xFFE6: // APP6
          case 0xFFE7: // APP7
          case 0xFFE8: // APP8
          case 0xFFE9: // APP9
          case 0xFFEA: // APP10
          case 0xFFEB: // APP11
          case 0xFFEC: // APP12
          case 0xFFED: // APP13
          case 0xFFEE: // APP14
          case 0xFFEF: // APP15
          case 0xFFFE: // COM (Comment)
            var appData = readDataBlock();

            if (fileMarker === 0xFFFE) {
              var comment = String.fromCharCode.apply(null, appData);
              this.comments.push(comment);
            }

            if (fileMarker === 0xFFE0) {
              if (appData[0] === 0x4A && appData[1] === 0x46 && appData[2] === 0x49 &&
                appData[3] === 0x46 && appData[4] === 0) { // 'JFIF\x00'
                jfif = {
                  version: { major: appData[5], minor: appData[6] },
                  densityUnits: appData[7],
                  xDensity: (appData[8] << 8) | appData[9],
                  yDensity: (appData[10] << 8) | appData[11],
                  thumbWidth: appData[12],
                  thumbHeight: appData[13],
                  thumbData: appData.subarray(14, 14 + 3 * appData[12] * appData[13])
                };
              }
            }
            // TODO APP1 - Exif
            if (fileMarker === 0xFFE1) {
              if (appData[0] === 0x45 &&
                appData[1] === 0x78 &&
                appData[2] === 0x69 &&
                appData[3] === 0x66 &&
                appData[4] === 0) { // 'EXIF\x00'
                this.exifBuffer = appData.subarray(5, appData.length);
              }
            }

            if (fileMarker === 0xFFEE) {
              if (appData[0] === 0x41 && appData[1] === 0x64 && appData[2] === 0x6F &&
                appData[3] === 0x62 && appData[4] === 0x65 && appData[5] === 0) { // 'Adobe\x00'
                adobe = {
                  version: appData[6],
                  flags0: (appData[7] << 8) | appData[8],
                  flags1: (appData[9] << 8) | appData[10],
                  transformCode: appData[11]
                };
              }
            }
            break;

          case 0xFFDB: // DQT (Define Quantization Tables)
            var quantizationTablesLength = readUint16();
            var quantizationTablesEnd = quantizationTablesLength + offset - 2;
            while (offset < quantizationTablesEnd) {
              var quantizationTableSpec = data[offset++];
              requestMemoryAllocation(64 * 4);
              var tableData = new Int32Array(64);
              if ((quantizationTableSpec >> 4) === 0) { // 8 bit values
                for (j = 0; j < 64; j++) {
                  var z = dctZigZag[j];
                  tableData[z] = data[offset++];
                }
              } else if ((quantizationTableSpec >> 4) === 1) { //16 bit
                for (j = 0; j < 64; j++) {
                  var z = dctZigZag[j];
                  tableData[z] = readUint16();
                }
              } else
                throw new Error("DQT: invalid table spec");
              quantizationTables[quantizationTableSpec & 15] = tableData;
            }
            break;

          case 0xFFC0: // SOF0 (Start of Frame, Baseline DCT)
          case 0xFFC1: // SOF1 (Start of Frame, Extended DCT)
          case 0xFFC2: // SOF2 (Start of Frame, Progressive DCT)
            readUint16(); // skip data length
            frame = {};
            frame.extended = (fileMarker === 0xFFC1);
            frame.progressive = (fileMarker === 0xFFC2);
            frame.precision = data[offset++];
            frame.scanLines = readUint16();
            frame.samplesPerLine = readUint16();
            frame.components = {};
            frame.componentsOrder = [];

            var pixelsInFrame = frame.scanLines * frame.samplesPerLine;
            if (pixelsInFrame > maxResolutionInPixels) {
              var exceededAmount = Math.ceil((pixelsInFrame - maxResolutionInPixels) / 1e6);
              throw new Error(`maxResolutionInMP limit exceeded by ${exceededAmount}MP`);
            }

            var componentsCount = data[offset++], componentId;
            var maxH = 0, maxV = 0;
            for (i = 0; i < componentsCount; i++) {
              componentId = data[offset];
              var h = data[offset + 1] >> 4;
              var v = data[offset + 1] & 15;
              var qId = data[offset + 2];
              frame.componentsOrder.push(componentId);
              frame.components[componentId] = {
                h: h,
                v: v,
                quantizationIdx: qId
              };
              offset += 3;
            }
            prepareComponents(frame);
            frames.push(frame);
            break;

          case 0xFFC4: // DHT (Define Huffman Tables)
            var huffmanLength = readUint16();
            for (i = 2; i < huffmanLength;) {
              var huffmanTableSpec = data[offset++];
              var codeLengths = new Uint8Array(16);
              var codeLengthSum = 0;
              for (j = 0; j < 16; j++, offset++) {
                codeLengthSum += (codeLengths[j] = data[offset]);
              }
              requestMemoryAllocation(16 + codeLengthSum);
              var huffmanValues = new Uint8Array(codeLengthSum);
              for (j = 0; j < codeLengthSum; j++, offset++)
                huffmanValues[j] = data[offset];
              i += 17 + codeLengthSum;

              ((huffmanTableSpec >> 4) === 0 ?
                huffmanTablesDC : huffmanTablesAC)[huffmanTableSpec & 15] =
                buildHuffmanTable(codeLengths, huffmanValues);
            }
            break;

          case 0xFFDD: // DRI (Define Restart Interval)
            readUint16(); // skip data length
            resetInterval = readUint16();
            break;

          case 0xFFDA: // SOS (Start of Scan)
            var scanLength = readUint16();
            var selectorsCount = data[offset++];
            var components = [], component;
            for (i = 0; i < selectorsCount; i++) {
              component = frame.components[data[offset++]];
              var tableSpec = data[offset++];
              component.huffmanTableDC = huffmanTablesDC[tableSpec >> 4];
              component.huffmanTableAC = huffmanTablesAC[tableSpec & 15];
              components.push(component);
            }
            var spectralStart = data[offset++];
            var spectralEnd = data[offset++];
            var successiveApproximation = data[offset++];
            var processed = decodeScan(data, offset,
              frame, components, resetInterval,
              spectralStart, spectralEnd,
              successiveApproximation >> 4, successiveApproximation & 15, this.opts);
            offset += processed;
            break;

          case 0xFFFF: // Fill bytes
            if (data[offset] !== 0xFF) { // Avoid skipping a valid marker.
              offset--;
            }
            break;

          default:
            if (data[offset - 3] == 0xFF &&
                data[offset - 2] >= 0xC0 && data[offset - 2] <= 0xFE) {
              // could be incorrect encoding -- last 0xFF byte of the previous
              // block was eaten by the encoder
              offset -= 3;
              break;
            }
            throw new Error("unknown JPEG marker " + fileMarker.toString(16));
        }
        fileMarker = readUint16();
      }
      if (frames.length != 1)
        throw new Error("only single frame JPEGs supported");

      // set each frame's components quantization table
      for (var i = 0; i < frames.length; i++) {
        var cp = frames[i].components;
        for (var j in cp) {
          cp[j].quantizationTable = quantizationTables[cp[j].quantizationIdx];
          delete cp[j].quantizationIdx;
        }
      }

      this.width = frame.samplesPerLine;
      this.height = frame.scanLines;
      this.jfif = jfif;
      this.adobe = adobe;
      this.components = [];
      for (var i = 0; i < frame.componentsOrder.length; i++) {
        var component = frame.components[frame.componentsOrder[i]];
        this.components.push({
          lines: buildComponentData(frame, component),
          scaleX: component.h / frame.maxH,
          scaleY: component.v / frame.maxV
        });
      }
    },
    getData: function getData(width, height) {
      var scaleX = this.width / width, scaleY = this.height / height;

      var component1, component2, component3, component4;
      var component1Line, component2Line, component3Line, component4Line;
      var x, y;
      var offset = 0;
      var Y, Cb, Cr, K, C, M, Ye, R, G, B;
      var colorTransform;
      var dataLength = width * height * this.components.length;
      requestMemoryAllocation(dataLength);
      var data = new Uint8Array(dataLength);
      switch (this.components.length) {
        case 1:
          component1 = this.components[0];
          for (y = 0; y < height; y++) {
            component1Line = component1.lines[0 | (y * component1.scaleY * scaleY)];
            for (x = 0; x < width; x++) {
              Y = component1Line[0 | (x * component1.scaleX * scaleX)];

              data[offset++] = Y;
            }
          }
          break;
        case 2:
          // PDF might compress two component data in custom colorspace
          component1 = this.components[0];
          component2 = this.components[1];
          for (y = 0; y < height; y++) {
            component1Line = component1.lines[0 | (y * component1.scaleY * scaleY)];
            component2Line = component2.lines[0 | (y * component2.scaleY * scaleY)];
            for (x = 0; x < width; x++) {
              Y = component1Line[0 | (x * component1.scaleX * scaleX)];
              data[offset++] = Y;
              Y = component2Line[0 | (x * component2.scaleX * scaleX)];
              data[offset++] = Y;
            }
          }
          break;
        case 3:
          // The default transform for three components is true
          colorTransform = true;
          // The adobe transform marker overrides any previous setting
          if (this.adobe && this.adobe.transformCode)
            colorTransform = true;
          else if (typeof this.opts.colorTransform !== 'undefined')
            colorTransform = !!this.opts.colorTransform;

          component1 = this.components[0];
          component2 = this.components[1];
          component3 = this.components[2];
          for (y = 0; y < height; y++) {
            component1Line = component1.lines[0 | (y * component1.scaleY * scaleY)];
            component2Line = component2.lines[0 | (y * component2.scaleY * scaleY)];
            component3Line = component3.lines[0 | (y * component3.scaleY * scaleY)];
            for (x = 0; x < width; x++) {
              if (!colorTransform) {
                R = component1Line[0 | (x * component1.scaleX * scaleX)];
                G = component2Line[0 | (x * component2.scaleX * scaleX)];
                B = component3Line[0 | (x * component3.scaleX * scaleX)];
              } else {
                Y = component1Line[0 | (x * component1.scaleX * scaleX)];
                Cb = component2Line[0 | (x * component2.scaleX * scaleX)];
                Cr = component3Line[0 | (x * component3.scaleX * scaleX)];

                R = clampTo8bit(Y + 1.402 * (Cr - 128));
                G = clampTo8bit(Y - 0.3441363 * (Cb - 128) - 0.71413636 * (Cr - 128));
                B = clampTo8bit(Y + 1.772 * (Cb - 128));
              }

              data[offset++] = R;
              data[offset++] = G;
              data[offset++] = B;
            }
          }
          break;
        case 4:
          if (!this.adobe)
            throw new Error('Unsupported color mode (4 components)');
          // The default transform for four components is false
          colorTransform = false;
          // The adobe transform marker overrides any previous setting
          if (this.adobe && this.adobe.transformCode)
            colorTransform = true;
          else if (typeof this.opts.colorTransform !== 'undefined')
            colorTransform = !!this.opts.colorTransform;

          component1 = this.components[0];
          component2 = this.components[1];
          component3 = this.components[2];
          component4 = this.components[3];
          for (y = 0; y < height; y++) {
            component1Line = component1.lines[0 | (y * component1.scaleY * scaleY)];
            component2Line = component2.lines[0 | (y * component2.scaleY * scaleY)];
            component3Line = component3.lines[0 | (y * component3.scaleY * scaleY)];
            component4Line = component4.lines[0 | (y * component4.scaleY * scaleY)];
            for (x = 0; x < width; x++) {
              if (!colorTransform) {
                C = component1Line[0 | (x * component1.scaleX * scaleX)];
                M = component2Line[0 | (x * component2.scaleX * scaleX)];
                Ye = component3Line[0 | (x * component3.scaleX * scaleX)];
                K = component4Line[0 | (x * component4.scaleX * scaleX)];
              } else {
                Y = component1Line[0 | (x * component1.scaleX * scaleX)];
                Cb = component2Line[0 | (x * component2.scaleX * scaleX)];
                Cr = component3Line[0 | (x * component3.scaleX * scaleX)];
                K = component4Line[0 | (x * component4.scaleX * scaleX)];

                C = 255 - clampTo8bit(Y + 1.402 * (Cr - 128));
                M = 255 - clampTo8bit(Y - 0.3441363 * (Cb - 128) - 0.71413636 * (Cr - 128));
                Ye = 255 - clampTo8bit(Y + 1.772 * (Cb - 128));
              }
              data[offset++] = 255-C;
              data[offset++] = 255-M;
              data[offset++] = 255-Ye;
              data[offset++] = 255-K;
            }
          }
          break;
        default:
          throw new Error('Unsupported color mode');
      }
      return data;
    },
    copyToImageData: function copyToImageData(imageData, formatAsRGBA) {
      var width = imageData.width, height = imageData.height;
      var imageDataArray = imageData.data;
      var data = this.getData(width, height);
      var i = 0, j = 0, x, y;
      var Y, K, C, M, R, G, B;
      switch (this.components.length) {
        case 1:
          for (y = 0; y < height; y++) {
            for (x = 0; x < width; x++) {
              Y = data[i++];

              imageDataArray[j++] = Y;
              imageDataArray[j++] = Y;
              imageDataArray[j++] = Y;
              if (formatAsRGBA) {
                imageDataArray[j++] = 255;
              }
            }
          }
          break;
        case 3:
          for (y = 0; y < height; y++) {
            for (x = 0; x < width; x++) {
              R = data[i++];
              G = data[i++];
              B = data[i++];

              imageDataArray[j++] = R;
              imageDataArray[j++] = G;
              imageDataArray[j++] = B;
              if (formatAsRGBA) {
                imageDataArray[j++] = 255;
              }
            }
          }
          break;
        case 4:
          for (y = 0; y < height; y++) {
            for (x = 0; x < width; x++) {
              C = data[i++];
              M = data[i++];
              Y = data[i++];
              K = data[i++];

              R = 255 - clampTo8bit(C * (1 - K / 255) + K);
              G = 255 - clampTo8bit(M * (1 - K / 255) + K);
              B = 255 - clampTo8bit(Y * (1 - K / 255) + K);

              imageDataArray[j++] = R;
              imageDataArray[j++] = G;
              imageDataArray[j++] = B;
              if (formatAsRGBA) {
                imageDataArray[j++] = 255;
              }
            }
          }
          break;
        default:
          throw new Error('Unsupported color mode');
      }
    }
  };


  // We cap the amount of memory used by jpeg-js to avoid unexpected OOMs from untrusted content.
  var totalBytesAllocated = 0;
  var maxMemoryUsageBytes = 0;
  function requestMemoryAllocation(increaseAmount = 0) {
    var totalMemoryImpactBytes = totalBytesAllocated + increaseAmount;
    if (totalMemoryImpactBytes > maxMemoryUsageBytes) {
      var exceededAmount = Math.ceil((totalMemoryImpactBytes - maxMemoryUsageBytes) / 1024 / 1024);
      throw new Error(`maxMemoryUsageInMB limit exceeded by at least ${exceededAmount}MB`);
    }

    totalBytesAllocated = totalMemoryImpactBytes;
  }

  constructor.resetMaxMemoryUsage = function (maxMemoryUsageBytes_) {
    totalBytesAllocated = 0;
    maxMemoryUsageBytes = maxMemoryUsageBytes_;
  };

  constructor.getBytesAllocated = function () {
    return totalBytesAllocated;
  };

  constructor.requestMemoryAllocation = requestMemoryAllocation;

  return constructor;
})();

if (typeof module !== 'undefined') {
	module.exports = decode;
} else if (typeof window !== 'undefined') {
	window['jpeg-js'] = window['jpeg-js'] || {};
	window['jpeg-js'].decode = decode;
}

function decode(jpegData, userOpts = {}) {
  var defaultOpts = {
    // "undefined" means "Choose whether to transform colors based on the image’s color model."
    colorTransform: undefined,
    useTArray: false,
    formatAsRGBA: true,
    tolerantDecoding: true,
    maxResolutionInMP: 100, // Don't decode more than 100 megapixels
    maxMemoryUsageInMB: 512, // Don't decode if memory footprint is more than 512MB
  };

  var opts = {...defaultOpts, ...userOpts};
  var arr = new Uint8Array(jpegData);
  var decoder = new JpegImage();
  decoder.opts = opts;
  // If this constructor ever supports async decoding this will need to be done differently.
  // Until then, treating as singleton limit is fine.
  JpegImage.resetMaxMemoryUsage(opts.maxMemoryUsageInMB * 1024 * 1024);
  decoder.parse(arr);

  var channels = (opts.formatAsRGBA) ? 4 : 3;
  var bytesNeeded = decoder.width * decoder.height * channels;
  try {
    JpegImage.requestMemoryAllocation(bytesNeeded);
    var image = {
      width: decoder.width,
      height: decoder.height,
      exifBuffer: decoder.exifBuffer,
      data: opts.useTArray ?
        new Uint8Array(bytesNeeded) :
        new Buffer(bytesNeeded)
    };
    if(decoder.comments.length > 0) {
      image["comments"] = decoder.comments;
    }
  } catch (err){
    if (err instanceof RangeError){
      throw new Error("Could not allocate enough memory for the image. " +
                      "Required: " + bytesNeeded);
    } else {
      throw err;
    }
  }

  decoder.copyToImageData(image, opts.formatAsRGBA);

  return image;
}

}).call(this)}).call(this,require("buffer").Buffer)
},{"buffer":145}],187:[function(require,module,exports){
(function (Buffer){(function (){
/*
  Copyright (c) 2008, Adobe Systems Incorporated
  All rights reserved.

  Redistribution and use in source and binary forms, with or without 
  modification, are permitted provided that the following conditions are
  met:

  * Redistributions of source code must retain the above copyright notice, 
    this list of conditions and the following disclaimer.
  
  * Redistributions in binary form must reproduce the above copyright
    notice, this list of conditions and the following disclaimer in the 
    documentation and/or other materials provided with the distribution.
  
  * Neither the name of Adobe Systems Incorporated nor the names of its 
    contributors may be used to endorse or promote products derived from 
    this software without specific prior written permission.

  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
  IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
  THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
  PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR 
  CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
  EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
  PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/
/*
JPEG encoder ported to JavaScript and optimized by Andreas Ritter, www.bytestrom.eu, 11/2009

Basic GUI blocking jpeg encoder
*/

var btoa = btoa || function(buf) {
  return new Buffer(buf).toString('base64');
};

function JPEGEncoder(quality) {
  var self = this;
	var fround = Math.round;
	var ffloor = Math.floor;
	var YTable = new Array(64);
	var UVTable = new Array(64);
	var fdtbl_Y = new Array(64);
	var fdtbl_UV = new Array(64);
	var YDC_HT;
	var UVDC_HT;
	var YAC_HT;
	var UVAC_HT;
	
	var bitcode = new Array(65535);
	var category = new Array(65535);
	var outputfDCTQuant = new Array(64);
	var DU = new Array(64);
	var byteout = [];
	var bytenew = 0;
	var bytepos = 7;
	
	var YDU = new Array(64);
	var UDU = new Array(64);
	var VDU = new Array(64);
	var clt = new Array(256);
	var RGB_YUV_TABLE = new Array(2048);
	var currentQuality;
	
	var ZigZag = [
			 0, 1, 5, 6,14,15,27,28,
			 2, 4, 7,13,16,26,29,42,
			 3, 8,12,17,25,30,41,43,
			 9,11,18,24,31,40,44,53,
			10,19,23,32,39,45,52,54,
			20,22,33,38,46,51,55,60,
			21,34,37,47,50,56,59,61,
			35,36,48,49,57,58,62,63
		];
	
	var std_dc_luminance_nrcodes = [0,0,1,5,1,1,1,1,1,1,0,0,0,0,0,0,0];
	var std_dc_luminance_values = [0,1,2,3,4,5,6,7,8,9,10,11];
	var std_ac_luminance_nrcodes = [0,0,2,1,3,3,2,4,3,5,5,4,4,0,0,1,0x7d];
	var std_ac_luminance_values = [
			0x01,0x02,0x03,0x00,0x04,0x11,0x05,0x12,
			0x21,0x31,0x41,0x06,0x13,0x51,0x61,0x07,
			0x22,0x71,0x14,0x32,0x81,0x91,0xa1,0x08,
			0x23,0x42,0xb1,0xc1,0x15,0x52,0xd1,0xf0,
			0x24,0x33,0x62,0x72,0x82,0x09,0x0a,0x16,
			0x17,0x18,0x19,0x1a,0x25,0x26,0x27,0x28,
			0x29,0x2a,0x34,0x35,0x36,0x37,0x38,0x39,
			0x3a,0x43,0x44,0x45,0x46,0x47,0x48,0x49,
			0x4a,0x53,0x54,0x55,0x56,0x57,0x58,0x59,
			0x5a,0x63,0x64,0x65,0x66,0x67,0x68,0x69,
			0x6a,0x73,0x74,0x75,0x76,0x77,0x78,0x79,
			0x7a,0x83,0x84,0x85,0x86,0x87,0x88,0x89,
			0x8a,0x92,0x93,0x94,0x95,0x96,0x97,0x98,
			0x99,0x9a,0xa2,0xa3,0xa4,0xa5,0xa6,0xa7,
			0xa8,0xa9,0xaa,0xb2,0xb3,0xb4,0xb5,0xb6,
			0xb7,0xb8,0xb9,0xba,0xc2,0xc3,0xc4,0xc5,
			0xc6,0xc7,0xc8,0xc9,0xca,0xd2,0xd3,0xd4,
			0xd5,0xd6,0xd7,0xd8,0xd9,0xda,0xe1,0xe2,
			0xe3,0xe4,0xe5,0xe6,0xe7,0xe8,0xe9,0xea,
			0xf1,0xf2,0xf3,0xf4,0xf5,0xf6,0xf7,0xf8,
			0xf9,0xfa
		];
	
	var std_dc_chrominance_nrcodes = [0,0,3,1,1,1,1,1,1,1,1,1,0,0,0,0,0];
	var std_dc_chrominance_values = [0,1,2,3,4,5,6,7,8,9,10,11];
	var std_ac_chrominance_nrcodes = [0,0,2,1,2,4,4,3,4,7,5,4,4,0,1,2,0x77];
	var std_ac_chrominance_values = [
			0x00,0x01,0x02,0x03,0x11,0x04,0x05,0x21,
			0x31,0x06,0x12,0x41,0x51,0x07,0x61,0x71,
			0x13,0x22,0x32,0x81,0x08,0x14,0x42,0x91,
			0xa1,0xb1,0xc1,0x09,0x23,0x33,0x52,0xf0,
			0x15,0x62,0x72,0xd1,0x0a,0x16,0x24,0x34,
			0xe1,0x25,0xf1,0x17,0x18,0x19,0x1a,0x26,
			0x27,0x28,0x29,0x2a,0x35,0x36,0x37,0x38,
			0x39,0x3a,0x43,0x44,0x45,0x46,0x47,0x48,
			0x49,0x4a,0x53,0x54,0x55,0x56,0x57,0x58,
			0x59,0x5a,0x63,0x64,0x65,0x66,0x67,0x68,
			0x69,0x6a,0x73,0x74,0x75,0x76,0x77,0x78,
			0x79,0x7a,0x82,0x83,0x84,0x85,0x86,0x87,
			0x88,0x89,0x8a,0x92,0x93,0x94,0x95,0x96,
			0x97,0x98,0x99,0x9a,0xa2,0xa3,0xa4,0xa5,
			0xa6,0xa7,0xa8,0xa9,0xaa,0xb2,0xb3,0xb4,
			0xb5,0xb6,0xb7,0xb8,0xb9,0xba,0xc2,0xc3,
			0xc4,0xc5,0xc6,0xc7,0xc8,0xc9,0xca,0xd2,
			0xd3,0xd4,0xd5,0xd6,0xd7,0xd8,0xd9,0xda,
			0xe2,0xe3,0xe4,0xe5,0xe6,0xe7,0xe8,0xe9,
			0xea,0xf2,0xf3,0xf4,0xf5,0xf6,0xf7,0xf8,
			0xf9,0xfa
		];
	
	function initQuantTables(sf){
			var YQT = [
				16, 11, 10, 16, 24, 40, 51, 61,
				12, 12, 14, 19, 26, 58, 60, 55,
				14, 13, 16, 24, 40, 57, 69, 56,
				14, 17, 22, 29, 51, 87, 80, 62,
				18, 22, 37, 56, 68,109,103, 77,
				24, 35, 55, 64, 81,104,113, 92,
				49, 64, 78, 87,103,121,120,101,
				72, 92, 95, 98,112,100,103, 99
			];
			
			for (var i = 0; i < 64; i++) {
				var t = ffloor((YQT[i]*sf+50)/100);
				if (t < 1) {
					t = 1;
				} else if (t > 255) {
					t = 255;
				}
				YTable[ZigZag[i]] = t;
			}
			var UVQT = [
				17, 18, 24, 47, 99, 99, 99, 99,
				18, 21, 26, 66, 99, 99, 99, 99,
				24, 26, 56, 99, 99, 99, 99, 99,
				47, 66, 99, 99, 99, 99, 99, 99,
				99, 99, 99, 99, 99, 99, 99, 99,
				99, 99, 99, 99, 99, 99, 99, 99,
				99, 99, 99, 99, 99, 99, 99, 99,
				99, 99, 99, 99, 99, 99, 99, 99
			];
			for (var j = 0; j < 64; j++) {
				var u = ffloor((UVQT[j]*sf+50)/100);
				if (u < 1) {
					u = 1;
				} else if (u > 255) {
					u = 255;
				}
				UVTable[ZigZag[j]] = u;
			}
			var aasf = [
				1.0, 1.387039845, 1.306562965, 1.175875602,
				1.0, 0.785694958, 0.541196100, 0.275899379
			];
			var k = 0;
			for (var row = 0; row < 8; row++)
			{
				for (var col = 0; col < 8; col++)
				{
					fdtbl_Y[k]  = (1.0 / (YTable [ZigZag[k]] * aasf[row] * aasf[col] * 8.0));
					fdtbl_UV[k] = (1.0 / (UVTable[ZigZag[k]] * aasf[row] * aasf[col] * 8.0));
					k++;
				}
			}
		}
		
		function computeHuffmanTbl(nrcodes, std_table){
			var codevalue = 0;
			var pos_in_table = 0;
			var HT = new Array();
			for (var k = 1; k <= 16; k++) {
				for (var j = 1; j <= nrcodes[k]; j++) {
					HT[std_table[pos_in_table]] = [];
					HT[std_table[pos_in_table]][0] = codevalue;
					HT[std_table[pos_in_table]][1] = k;
					pos_in_table++;
					codevalue++;
				}
				codevalue*=2;
			}
			return HT;
		}
		
		function initHuffmanTbl()
		{
			YDC_HT = computeHuffmanTbl(std_dc_luminance_nrcodes,std_dc_luminance_values);
			UVDC_HT = computeHuffmanTbl(std_dc_chrominance_nrcodes,std_dc_chrominance_values);
			YAC_HT = computeHuffmanTbl(std_ac_luminance_nrcodes,std_ac_luminance_values);
			UVAC_HT = computeHuffmanTbl(std_ac_chrominance_nrcodes,std_ac_chrominance_values);
		}
	
		function initCategoryNumber()
		{
			var nrlower = 1;
			var nrupper = 2;
			for (var cat = 1; cat <= 15; cat++) {
				//Positive numbers
				for (var nr = nrlower; nr<nrupper; nr++) {
					category[32767+nr] = cat;
					bitcode[32767+nr] = [];
					bitcode[32767+nr][1] = cat;
					bitcode[32767+nr][0] = nr;
				}
				//Negative numbers
				for (var nrneg =-(nrupper-1); nrneg<=-nrlower; nrneg++) {
					category[32767+nrneg] = cat;
					bitcode[32767+nrneg] = [];
					bitcode[32767+nrneg][1] = cat;
					bitcode[32767+nrneg][0] = nrupper-1+nrneg;
				}
				nrlower <<= 1;
				nrupper <<= 1;
			}
		}
		
		function initRGBYUVTable() {
			for(var i = 0; i < 256;i++) {
				RGB_YUV_TABLE[i]      		=  19595 * i;
				RGB_YUV_TABLE[(i+ 256)>>0] 	=  38470 * i;
				RGB_YUV_TABLE[(i+ 512)>>0] 	=   7471 * i + 0x8000;
				RGB_YUV_TABLE[(i+ 768)>>0] 	= -11059 * i;
				RGB_YUV_TABLE[(i+1024)>>0] 	= -21709 * i;
				RGB_YUV_TABLE[(i+1280)>>0] 	=  32768 * i + 0x807FFF;
				RGB_YUV_TABLE[(i+1536)>>0] 	= -27439 * i;
				RGB_YUV_TABLE[(i+1792)>>0] 	= - 5329 * i;
			}
		}
		
		// IO functions
		function writeBits(bs)
		{
			var value = bs[0];
			var posval = bs[1]-1;
			while ( posval >= 0 ) {
				if (value & (1 << posval) ) {
					bytenew |= (1 << bytepos);
				}
				posval--;
				bytepos--;
				if (bytepos < 0) {
					if (bytenew == 0xFF) {
						writeByte(0xFF);
						writeByte(0);
					}
					else {
						writeByte(bytenew);
					}
					bytepos=7;
					bytenew=0;
				}
			}
		}
	
		function writeByte(value)
		{
			//byteout.push(clt[value]); // write char directly instead of converting later
      byteout.push(value);
		}
	
		function writeWord(value)
		{
			writeByte((value>>8)&0xFF);
			writeByte((value   )&0xFF);
		}
		
		// DCT & quantization core
		function fDCTQuant(data, fdtbl)
		{
			var d0, d1, d2, d3, d4, d5, d6, d7;
			/* Pass 1: process rows. */
			var dataOff=0;
			var i;
			var I8 = 8;
			var I64 = 64;
			for (i=0; i<I8; ++i)
			{
				d0 = data[dataOff];
				d1 = data[dataOff+1];
				d2 = data[dataOff+2];
				d3 = data[dataOff+3];
				d4 = data[dataOff+4];
				d5 = data[dataOff+5];
				d6 = data[dataOff+6];
				d7 = data[dataOff+7];
				
				var tmp0 = d0 + d7;
				var tmp7 = d0 - d7;
				var tmp1 = d1 + d6;
				var tmp6 = d1 - d6;
				var tmp2 = d2 + d5;
				var tmp5 = d2 - d5;
				var tmp3 = d3 + d4;
				var tmp4 = d3 - d4;
	
				/* Even part */
				var tmp10 = tmp0 + tmp3;	/* phase 2 */
				var tmp13 = tmp0 - tmp3;
				var tmp11 = tmp1 + tmp2;
				var tmp12 = tmp1 - tmp2;
	
				data[dataOff] = tmp10 + tmp11; /* phase 3 */
				data[dataOff+4] = tmp10 - tmp11;
	
				var z1 = (tmp12 + tmp13) * 0.707106781; /* c4 */
				data[dataOff+2] = tmp13 + z1; /* phase 5 */
				data[dataOff+6] = tmp13 - z1;
	
				/* Odd part */
				tmp10 = tmp4 + tmp5; /* phase 2 */
				tmp11 = tmp5 + tmp6;
				tmp12 = tmp6 + tmp7;
	
				/* The rotator is modified from fig 4-8 to avoid extra negations. */
				var z5 = (tmp10 - tmp12) * 0.382683433; /* c6 */
				var z2 = 0.541196100 * tmp10 + z5; /* c2-c6 */
				var z4 = 1.306562965 * tmp12 + z5; /* c2+c6 */
				var z3 = tmp11 * 0.707106781; /* c4 */
	
				var z11 = tmp7 + z3;	/* phase 5 */
				var z13 = tmp7 - z3;
	
				data[dataOff+5] = z13 + z2;	/* phase 6 */
				data[dataOff+3] = z13 - z2;
				data[dataOff+1] = z11 + z4;
				data[dataOff+7] = z11 - z4;
	
				dataOff += 8; /* advance pointer to next row */
			}
	
			/* Pass 2: process columns. */
			dataOff = 0;
			for (i=0; i<I8; ++i)
			{
				d0 = data[dataOff];
				d1 = data[dataOff + 8];
				d2 = data[dataOff + 16];
				d3 = data[dataOff + 24];
				d4 = data[dataOff + 32];
				d5 = data[dataOff + 40];
				d6 = data[dataOff + 48];
				d7 = data[dataOff + 56];
				
				var tmp0p2 = d0 + d7;
				var tmp7p2 = d0 - d7;
				var tmp1p2 = d1 + d6;
				var tmp6p2 = d1 - d6;
				var tmp2p2 = d2 + d5;
				var tmp5p2 = d2 - d5;
				var tmp3p2 = d3 + d4;
				var tmp4p2 = d3 - d4;
	
				/* Even part */
				var tmp10p2 = tmp0p2 + tmp3p2;	/* phase 2 */
				var tmp13p2 = tmp0p2 - tmp3p2;
				var tmp11p2 = tmp1p2 + tmp2p2;
				var tmp12p2 = tmp1p2 - tmp2p2;
	
				data[dataOff] = tmp10p2 + tmp11p2; /* phase 3 */
				data[dataOff+32] = tmp10p2 - tmp11p2;
	
				var z1p2 = (tmp12p2 + tmp13p2) * 0.707106781; /* c4 */
				data[dataOff+16] = tmp13p2 + z1p2; /* phase 5 */
				data[dataOff+48] = tmp13p2 - z1p2;
	
				/* Odd part */
				tmp10p2 = tmp4p2 + tmp5p2; /* phase 2 */
				tmp11p2 = tmp5p2 + tmp6p2;
				tmp12p2 = tmp6p2 + tmp7p2;
	
				/* The rotator is modified from fig 4-8 to avoid extra negations. */
				var z5p2 = (tmp10p2 - tmp12p2) * 0.382683433; /* c6 */
				var z2p2 = 0.541196100 * tmp10p2 + z5p2; /* c2-c6 */
				var z4p2 = 1.306562965 * tmp12p2 + z5p2; /* c2+c6 */
				var z3p2 = tmp11p2 * 0.707106781; /* c4 */
	
				var z11p2 = tmp7p2 + z3p2;	/* phase 5 */
				var z13p2 = tmp7p2 - z3p2;
	
				data[dataOff+40] = z13p2 + z2p2; /* phase 6 */
				data[dataOff+24] = z13p2 - z2p2;
				data[dataOff+ 8] = z11p2 + z4p2;
				data[dataOff+56] = z11p2 - z4p2;
	
				dataOff++; /* advance pointer to next column */
			}
	
			// Quantize/descale the coefficients
			var fDCTQuant;
			for (i=0; i<I64; ++i)
			{
				// Apply the quantization and scaling factor & Round to nearest integer
				fDCTQuant = data[i]*fdtbl[i];
				outputfDCTQuant[i] = (fDCTQuant > 0.0) ? ((fDCTQuant + 0.5)|0) : ((fDCTQuant - 0.5)|0);
				//outputfDCTQuant[i] = fround(fDCTQuant);

			}
			return outputfDCTQuant;
		}
		
		function writeAPP0()
		{
			writeWord(0xFFE0); // marker
			writeWord(16); // length
			writeByte(0x4A); // J
			writeByte(0x46); // F
			writeByte(0x49); // I
			writeByte(0x46); // F
			writeByte(0); // = "JFIF",'\0'
			writeByte(1); // versionhi
			writeByte(1); // versionlo
			writeByte(0); // xyunits
			writeWord(1); // xdensity
			writeWord(1); // ydensity
			writeByte(0); // thumbnwidth
			writeByte(0); // thumbnheight
		}

		function writeAPP1(exifBuffer) {
			if (!exifBuffer) return;

			writeWord(0xFFE1); // APP1 marker

			if (exifBuffer[0] === 0x45 &&
					exifBuffer[1] === 0x78 &&
					exifBuffer[2] === 0x69 &&
					exifBuffer[3] === 0x66) {
				// Buffer already starts with EXIF, just use it directly
				writeWord(exifBuffer.length + 2); // length is buffer + length itself!
			} else {
				// Buffer doesn't start with EXIF, write it for them
				writeWord(exifBuffer.length + 5 + 2); // length is buffer + EXIF\0 + length itself!
				writeByte(0x45); // E
				writeByte(0x78); // X
				writeByte(0x69); // I
				writeByte(0x66); // F
				writeByte(0); // = "EXIF",'\0'
			}

			for (var i = 0; i < exifBuffer.length; i++) {
				writeByte(exifBuffer[i]);
			}
		}

		function writeSOF0(width, height)
		{
			writeWord(0xFFC0); // marker
			writeWord(17);   // length, truecolor YUV JPG
			writeByte(8);    // precision
			writeWord(height);
			writeWord(width);
			writeByte(3);    // nrofcomponents
			writeByte(1);    // IdY
			writeByte(0x11); // HVY
			writeByte(0);    // QTY
			writeByte(2);    // IdU
			writeByte(0x11); // HVU
			writeByte(1);    // QTU
			writeByte(3);    // IdV
			writeByte(0x11); // HVV
			writeByte(1);    // QTV
		}
	
		function writeDQT()
		{
			writeWord(0xFFDB); // marker
			writeWord(132);	   // length
			writeByte(0);
			for (var i=0; i<64; i++) {
				writeByte(YTable[i]);
			}
			writeByte(1);
			for (var j=0; j<64; j++) {
				writeByte(UVTable[j]);
			}
		}
	
		function writeDHT()
		{
			writeWord(0xFFC4); // marker
			writeWord(0x01A2); // length
	
			writeByte(0); // HTYDCinfo
			for (var i=0; i<16; i++) {
				writeByte(std_dc_luminance_nrcodes[i+1]);
			}
			for (var j=0; j<=11; j++) {
				writeByte(std_dc_luminance_values[j]);
			}
	
			writeByte(0x10); // HTYACinfo
			for (var k=0; k<16; k++) {
				writeByte(std_ac_luminance_nrcodes[k+1]);
			}
			for (var l=0; l<=161; l++) {
				writeByte(std_ac_luminance_values[l]);
			}
	
			writeByte(1); // HTUDCinfo
			for (var m=0; m<16; m++) {
				writeByte(std_dc_chrominance_nrcodes[m+1]);
			}
			for (var n=0; n<=11; n++) {
				writeByte(std_dc_chrominance_values[n]);
			}
	
			writeByte(0x11); // HTUACinfo
			for (var o=0; o<16; o++) {
				writeByte(std_ac_chrominance_nrcodes[o+1]);
			}
			for (var p=0; p<=161; p++) {
				writeByte(std_ac_chrominance_values[p]);
			}
		}
	
		function writeSOS()
		{
			writeWord(0xFFDA); // marker
			writeWord(12); // length
			writeByte(3); // nrofcomponents
			writeByte(1); // IdY
			writeByte(0); // HTY
			writeByte(2); // IdU
			writeByte(0x11); // HTU
			writeByte(3); // IdV
			writeByte(0x11); // HTV
			writeByte(0); // Ss
			writeByte(0x3f); // Se
			writeByte(0); // Bf
		}
		
		function processDU(CDU, fdtbl, DC, HTDC, HTAC){
			var EOB = HTAC[0x00];
			var M16zeroes = HTAC[0xF0];
			var pos;
			var I16 = 16;
			var I63 = 63;
			var I64 = 64;
			var DU_DCT = fDCTQuant(CDU, fdtbl);
			//ZigZag reorder
			for (var j=0;j<I64;++j) {
				DU[ZigZag[j]]=DU_DCT[j];
			}
			var Diff = DU[0] - DC; DC = DU[0];
			//Encode DC
			if (Diff==0) {
				writeBits(HTDC[0]); // Diff might be 0
			} else {
				pos = 32767+Diff;
				writeBits(HTDC[category[pos]]);
				writeBits(bitcode[pos]);
			}
			//Encode ACs
			var end0pos = 63; // was const... which is crazy
			for (; (end0pos>0)&&(DU[end0pos]==0); end0pos--) {};
			//end0pos = first element in reverse order !=0
			if ( end0pos == 0) {
				writeBits(EOB);
				return DC;
			}
			var i = 1;
			var lng;
			while ( i <= end0pos ) {
				var startpos = i;
				for (; (DU[i]==0) && (i<=end0pos); ++i) {}
				var nrzeroes = i-startpos;
				if ( nrzeroes >= I16 ) {
					lng = nrzeroes>>4;
					for (var nrmarker=1; nrmarker <= lng; ++nrmarker)
						writeBits(M16zeroes);
					nrzeroes = nrzeroes&0xF;
				}
				pos = 32767+DU[i];
				writeBits(HTAC[(nrzeroes<<4)+category[pos]]);
				writeBits(bitcode[pos]);
				i++;
			}
			if ( end0pos != I63 ) {
				writeBits(EOB);
			}
			return DC;
		}

		function initCharLookupTable(){
			var sfcc = String.fromCharCode;
			for(var i=0; i < 256; i++){ ///// ACHTUNG // 255
				clt[i] = sfcc(i);
			}
		}
		
		this.encode = function(image,quality) // image data object
		{
			var time_start = new Date().getTime();
			
			if(quality) setQuality(quality);
			
			// Initialize bit writer
			byteout = new Array();
			bytenew=0;
			bytepos=7;
	
			// Add JPEG headers
			writeWord(0xFFD8); // SOI
			writeAPP0();
			writeAPP1(image.exifBuffer);
			writeDQT();
			writeSOF0(image.width,image.height);
			writeDHT();
			writeSOS();

	
			// Encode 8x8 macroblocks
			var DCY=0;
			var DCU=0;
			var DCV=0;
			
			bytenew=0;
			bytepos=7;
			
			
			this.encode.displayName = "_encode_";

			var imageData = image.data;
			var width = image.width;
			var height = image.height;

			var quadWidth = width*4;
			var tripleWidth = width*3;
			
			var x, y = 0;
			var r, g, b;
			var start,p, col,row,pos;
			while(y < height){
				x = 0;
				while(x < quadWidth){
				start = quadWidth * y + x;
				p = start;
				col = -1;
				row = 0;
				
				for(pos=0; pos < 64; pos++){
					row = pos >> 3;// /8
					col = ( pos & 7 ) * 4; // %8
					p = start + ( row * quadWidth ) + col;		
					
					if(y+row >= height){ // padding bottom
						p-= (quadWidth*(y+1+row-height));
					}

					if(x+col >= quadWidth){ // padding right	
						p-= ((x+col) - quadWidth +4)
					}
					
					r = imageData[ p++ ];
					g = imageData[ p++ ];
					b = imageData[ p++ ];
					
					
					/* // calculate YUV values dynamically
					YDU[pos]=((( 0.29900)*r+( 0.58700)*g+( 0.11400)*b))-128; //-0x80
					UDU[pos]=(((-0.16874)*r+(-0.33126)*g+( 0.50000)*b));
					VDU[pos]=((( 0.50000)*r+(-0.41869)*g+(-0.08131)*b));
					*/
					
					// use lookup table (slightly faster)
					YDU[pos] = ((RGB_YUV_TABLE[r]             + RGB_YUV_TABLE[(g +  256)>>0] + RGB_YUV_TABLE[(b +  512)>>0]) >> 16)-128;
					UDU[pos] = ((RGB_YUV_TABLE[(r +  768)>>0] + RGB_YUV_TABLE[(g + 1024)>>0] + RGB_YUV_TABLE[(b + 1280)>>0]) >> 16)-128;
					VDU[pos] = ((RGB_YUV_TABLE[(r + 1280)>>0] + RGB_YUV_TABLE[(g + 1536)>>0] + RGB_YUV_TABLE[(b + 1792)>>0]) >> 16)-128;

				}
				
				DCY = processDU(YDU, fdtbl_Y, DCY, YDC_HT, YAC_HT);
				DCU = processDU(UDU, fdtbl_UV, DCU, UVDC_HT, UVAC_HT);
				DCV = processDU(VDU, fdtbl_UV, DCV, UVDC_HT, UVAC_HT);
				x+=32;
				}
				y+=8;
			}
			
			
			////////////////////////////////////////////////////////////////
	
			// Do the bit alignment of the EOI marker
			if ( bytepos >= 0 ) {
				var fillbits = [];
				fillbits[1] = bytepos+1;
				fillbits[0] = (1<<(bytepos+1))-1;
				writeBits(fillbits);
			}
	
			writeWord(0xFFD9); //EOI

			if (typeof module === 'undefined') return new Uint8Array(byteout);
      return new Buffer(byteout);

			var jpegDataUri = 'data:image/jpeg;base64,' + btoa(byteout.join(''));
			
			byteout = [];
			
			// benchmarking
			var duration = new Date().getTime() - time_start;
    		//console.log('Encoding time: '+ duration + 'ms');
    		//
			
			return jpegDataUri			
	}
	
	function setQuality(quality){
		if (quality <= 0) {
			quality = 1;
		}
		if (quality > 100) {
			quality = 100;
		}
		
		if(currentQuality == quality) return // don't recalc if unchanged
		
		var sf = 0;
		if (quality < 50) {
			sf = Math.floor(5000 / quality);
		} else {
			sf = Math.floor(200 - quality*2);
		}
		
		initQuantTables(sf);
		currentQuality = quality;
		//console.log('Quality set to: '+quality +'%');
	}
	
	function init(){
		var time_start = new Date().getTime();
		if(!quality) quality = 50;
		// Create tables
		initCharLookupTable()
		initHuffmanTbl();
		initCategoryNumber();
		initRGBYUVTable();
		
		setQuality(quality);
		var duration = new Date().getTime() - time_start;
    	//console.log('Initialization '+ duration + 'ms');
	}
	
	init();
	
};

if (typeof module !== 'undefined') {
	module.exports = encode;
} else if (typeof window !== 'undefined') {
	window['jpeg-js'] = window['jpeg-js'] || {};
	window['jpeg-js'].encode = encode;
}

function encode(imgData, qu) {
  if (typeof qu === 'undefined') qu = 50;
  var encoder = new JPEGEncoder(qu);
	var data = encoder.encode(imgData, qu);
  return {
    data: data,
    width: imgData.width,
    height: imgData.height
  };
}

// helper function to get the imageData of an existing image on the current page.
function getImageDataFromImage(idOrElement){
	var theImg = (typeof(idOrElement)=='string')? document.getElementById(idOrElement):idOrElement;
	var cvs = document.createElement('canvas');
	cvs.width = theImg.width;
	cvs.height = theImg.height;
	var ctx = cvs.getContext("2d");
	ctx.drawImage(theImg,0,0);
	
	return (ctx.getImageData(0, 0, cvs.width, cvs.height));
}

}).call(this)}).call(this,require("buffer").Buffer)
},{"buffer":145}],188:[function(require,module,exports){
(function (process){(function (){
/**
 * @license Copyright 2016 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.
 */
'use strict';

const debug = require('debug');
const marky = require('marky');

const EventEmitter = require('events').EventEmitter;
const isWindows = process.platform === 'win32';

// process.browser is set when browserify'd via the `process` npm module
const isBrowser = process.browser;

const colors = {
  red: isBrowser ? 'crimson' : 1,
  yellow: isBrowser ? 'gold' : 3,
  cyan: isBrowser ? 'darkturquoise' : 6,
  green: isBrowser ? 'forestgreen' : 2,
  blue: isBrowser ? 'steelblue' : 4,
  magenta: isBrowser ? 'palevioletred' : 5,
};

// whitelist non-red/yellow colors for debug()
debug.colors = [colors.cyan, colors.green, colors.blue, colors.magenta];

class Emitter extends EventEmitter {
  /**
   * Fires off all status updates. Listen with
   * `require('lib/log').events.addListener('status', callback)`
   * @param {string} title
   * @param {!Array<*>} argsArray
   */
  issueStatus(title, argsArray) {
    if (title === 'status' || title === 'statusEnd') {
      this.emit(title, [title, ...argsArray]);
    }
  }

  /**
   * Fires off all warnings. Listen with
   * `require('lib/log').events.addListener('warning', callback)`
   * @param {string} title
   * @param {!Array<*>} argsArray
   */
  issueWarning(title, argsArray) {
    this.emit('warning', [title, ...argsArray]);
  }
}

const loggersByTitle = {};
const loggingBufferColumns = 25;
let level_;

class Log {
  static _logToStdErr(title, argsArray) {
    const log = Log.loggerfn(title);
    log(...argsArray);
  }

  static loggerfn(title) {
    let log = loggersByTitle[title];
    if (!log) {
      log = debug(title);
      loggersByTitle[title] = log;
      // errors with red, warnings with yellow.
      if (title.endsWith('error')) {
        log.color = colors.red;
      } else if (title.endsWith('warn')) {
        log.color = colors.yellow;
      }
    }
    return log;
  }

  /**
   * @param {string} level
   */
  static setLevel(level) {
    level_ = level;
    switch (level) {
      case 'silent':
        debug.enable('-*');
        break;
      case 'verbose':
        debug.enable('*');
        break;
      case 'error':
        debug.enable('-*, *:error');
        break;
      default:
        debug.enable('*, -*:verbose');
    }
  }

  /**
   * A simple formatting utility for event logging.
   * @param {string} prefix
   * @param {!Object} data A JSON-serializable object of event data to log.
   * @param {string=} level Optional logging level. Defaults to 'log'.
   */
  static formatProtocol(prefix, data, level) {
    const columns = (!process || process.browser) ? Infinity : process.stdout.columns;
    const method = data.method || '?????';
    const maxLength = columns - method.length - prefix.length - loggingBufferColumns;
    // IO.read blacklisted here to avoid logging megabytes of trace data
    const snippet = (data.params && method !== 'IO.read') ?
      JSON.stringify(data.params).substr(0, maxLength) : '';
    Log._logToStdErr(`${prefix}:${level || ''}`, [method, snippet]);
  }

  /**
   * @return {boolean}
   */
  static isVerbose() {
    return level_ === 'verbose';
  }

  static time({msg, id, args = []}, level = 'log') {
    marky.mark(id);
    Log[level]('status', msg, ...args);
  }

  static timeEnd({msg, id, args = []}, level = 'verbose') {
    Log[level]('statusEnd', msg, ...args);
    marky.stop(id);
  }

  static log(title, ...args) {
    Log.events.issueStatus(title, args);
    return Log._logToStdErr(title, args);
  }

  static warn(title, ...args) {
    Log.events.issueWarning(title, args);
    return Log._logToStdErr(`${title}:warn`, args);
  }

  static error(title, ...args) {
    return Log._logToStdErr(`${title}:error`, args);
  }

  static verbose(title, ...args) {
    Log.events.issueStatus(title, args);
    return Log._logToStdErr(`${title}:verbose`, args);
  }

  /**
   * Add surrounding escape sequences to turn a string green when logged.
   * @param {string} str
   * @return {string}
   */
  static greenify(str) {
    return `${Log.green}${str}${Log.reset}`;
  }

  /**
   * Add surrounding escape sequences to turn a string red when logged.
   * @param {string} str
   * @return {string}
   */
  static redify(str) {
    return `${Log.red}${str}${Log.reset}`;
  }

  static get green() {
    return '\x1B[32m';
  }

  static get red() {
    return '\x1B[31m';
  }

  static get yellow() {
    return '\x1b[33m';
  }

  static get purple() {
    return '\x1b[95m';
  }

  static get reset() {
    return '\x1B[0m';
  }

  static get bold() {
    return '\x1b[1m';
  }

  static get dim() {
    return '\x1b[2m';
  }

  static get tick() {
    return isWindows ? '\u221A' : '✓';
  }

  static get cross() {
    return isWindows ? '\u00D7' : '✘';
  }

  static get whiteSmallSquare() {
    return isWindows ? '\u0387' : '▫';
  }

  static get heavyHorizontal() {
    return isWindows ? '\u2500' : '━';
  }

  static get heavyVertical() {
    return isWindows ? '\u2502 ' : '┃ ';
  }

  static get heavyUpAndRight() {
    return isWindows ? '\u2514' : '┗';
  }

  static get heavyVerticalAndRight() {
    return isWindows ? '\u251C' : '┣';
  }

  static get heavyDownAndHorizontal() {
    return isWindows ? '\u252C' : '┳';
  }

  static get doubleLightHorizontal() {
    return '──';
  }
}

Log.events = new Emitter();
Log.takeTimeEntries = () => {
  const entries = marky.getEntries();
  marky.clear();
  return entries;
};
Log.getTimeEntries = () => marky.getEntries();

module.exports = Log;

}).call(this)}).call(this,require('_process'))
},{"_process":223,"debug":189,"events":162,"marky":219}],189:[function(require,module,exports){
(function (process){(function (){
/**
 * This is the web browser implementation of `debug()`.
 *
 * Expose `debug()` as the module.
 */

exports = module.exports = require('./debug');
exports.log = log;
exports.formatArgs = formatArgs;
exports.save = save;
exports.load = load;
exports.useColors = useColors;
exports.storage = 'undefined' != typeof chrome
               && 'undefined' != typeof chrome.storage
                  ? chrome.storage.local
                  : localstorage();

/**
 * Colors.
 */

exports.colors = [
  'lightseagreen',
  'forestgreen',
  'goldenrod',
  'dodgerblue',
  'darkorchid',
  'crimson'
];

/**
 * Currently only WebKit-based Web Inspectors, Firefox >= v31,
 * and the Firebug extension (any Firefox version) are known
 * to support "%c" CSS customizations.
 *
 * TODO: add a `localStorage` variable to explicitly enable/disable colors
 */

function useColors() {
  // NB: In an Electron preload script, document will be defined but not fully
  // initialized. Since we know we're in Chrome, we'll just detect this case
  // explicitly
  if (typeof window !== 'undefined' && window.process && window.process.type === 'renderer') {
    return true;
  }

  // is webkit? http://stackoverflow.com/a/16459606/376773
  // document is undefined in react-native: https://github.com/facebook/react-native/pull/1632
  return (typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance) ||
    // is firebug? http://stackoverflow.com/a/398120/376773
    (typeof window !== 'undefined' && window.console && (window.console.firebug || (window.console.exception && window.console.table))) ||
    // is firefox >= v31?
    // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
    (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31) ||
    // double check webkit in userAgent just in case we are in a worker
    (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/));
}

/**
 * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
 */

exports.formatters.j = function(v) {
  try {
    return JSON.stringify(v);
  } catch (err) {
    return '[UnexpectedJSONParseError]: ' + err.message;
  }
};


/**
 * Colorize log arguments if enabled.
 *
 * @api public
 */

function formatArgs(args) {
  var useColors = this.useColors;

  args[0] = (useColors ? '%c' : '')
    + this.namespace
    + (useColors ? ' %c' : ' ')
    + args[0]
    + (useColors ? '%c ' : ' ')
    + '+' + exports.humanize(this.diff);

  if (!useColors) return;

  var c = 'color: ' + this.color;
  args.splice(1, 0, c, 'color: inherit')

  // the final "%c" is somewhat tricky, because there could be other
  // arguments passed either before or after the %c, so we need to
  // figure out the correct index to insert the CSS into
  var index = 0;
  var lastC = 0;
  args[0].replace(/%[a-zA-Z%]/g, function(match) {
    if ('%%' === match) return;
    index++;
    if ('%c' === match) {
      // we only are interested in the *last* %c
      // (the user may have provided their own)
      lastC = index;
    }
  });

  args.splice(lastC, 0, c);
}

/**
 * Invokes `console.log()` when available.
 * No-op when `console.log` is not a "function".
 *
 * @api public
 */

function log() {
  // this hackery is required for IE8/9, where
  // the `console.log` function doesn't have 'apply'
  return 'object' === typeof console
    && console.log
    && Function.prototype.apply.call(console.log, console, arguments);
}

/**
 * Save `namespaces`.
 *
 * @param {String} namespaces
 * @api private
 */

function save(namespaces) {
  try {
    if (null == namespaces) {
      exports.storage.removeItem('debug');
    } else {
      exports.storage.debug = namespaces;
    }
  } catch(e) {}
}

/**
 * Load `namespaces`.
 *
 * @return {String} returns the previously persisted debug modes
 * @api private
 */

function load() {
  var r;
  try {
    r = exports.storage.debug;
  } catch(e) {}

  // If debug isn't set in LS, and we're in Electron, try to load $DEBUG
  if (!r && typeof process !== 'undefined' && 'env' in process) {
    r = process.env.DEBUG;
  }

  return r;
}

/**
 * Enable namespaces listed in `localStorage.debug` initially.
 */

exports.enable(load());

/**
 * Localstorage attempts to return the localstorage.
 *
 * This is necessary because safari throws
 * when a user disables cookies/localstorage
 * and you attempt to access it.
 *
 * @return {LocalStorage}
 * @api private
 */

function localstorage() {
  try {
    return window.localStorage;
  } catch (e) {}
}

}).call(this)}).call(this,require('_process'))
},{"./debug":190,"_process":223}],190:[function(require,module,exports){

/**
 * This is the common logic for both the Node.js and web browser
 * implementations of `debug()`.
 *
 * Expose `debug()` as the module.
 */

exports = module.exports = createDebug.debug = createDebug['default'] = createDebug;
exports.coerce = coerce;
exports.disable = disable;
exports.enable = enable;
exports.enabled = enabled;
exports.humanize = require('ms');

/**
 * The currently active debug mode names, and names to skip.
 */

exports.names = [];
exports.skips = [];

/**
 * Map of special "%n" handling functions, for the debug "format" argument.
 *
 * Valid key names are a single, lower or upper-case letter, i.e. "n" and "N".
 */

exports.formatters = {};

/**
 * Previous log timestamp.
 */

var prevTime;

/**
 * Select a color.
 * @param {String} namespace
 * @return {Number}
 * @api private
 */

function selectColor(namespace) {
  var hash = 0, i;

  for (i in namespace) {
    hash  = ((hash << 5) - hash) + namespace.charCodeAt(i);
    hash |= 0; // Convert to 32bit integer
  }

  return exports.colors[Math.abs(hash) % exports.colors.length];
}

/**
 * Create a debugger with the given `namespace`.
 *
 * @param {String} namespace
 * @return {Function}
 * @api public
 */

function createDebug(namespace) {

  function debug() {
    // disabled?
    if (!debug.enabled) return;

    var self = debug;

    // set `diff` timestamp
    var curr = +new Date();
    var ms = curr - (prevTime || curr);
    self.diff = ms;
    self.prev = prevTime;
    self.curr = curr;
    prevTime = curr;

    // turn the `arguments` into a proper Array
    var args = new Array(arguments.length);
    for (var i = 0; i < args.length; i++) {
      args[i] = arguments[i];
    }

    args[0] = exports.coerce(args[0]);

    if ('string' !== typeof args[0]) {
      // anything else let's inspect with %O
      args.unshift('%O');
    }

    // apply any `formatters` transformations
    var index = 0;
    args[0] = args[0].replace(/%([a-zA-Z%])/g, function(match, format) {
      // if we encounter an escaped % then don't increase the array index
      if (match === '%%') return match;
      index++;
      var formatter = exports.formatters[format];
      if ('function' === typeof formatter) {
        var val = args[index];
        match = formatter.call(self, val);

        // now we need to remove `args[index]` since it's inlined in the `format`
        args.splice(index, 1);
        index--;
      }
      return match;
    });

    // apply env-specific formatting (colors, etc.)
    exports.formatArgs.call(self, args);

    var logFn = debug.log || exports.log || console.log.bind(console);
    logFn.apply(self, args);
  }

  debug.namespace = namespace;
  debug.enabled = exports.enabled(namespace);
  debug.useColors = exports.useColors();
  debug.color = selectColor(namespace);

  // env-specific initialization logic for debug instances
  if ('function' === typeof exports.init) {
    exports.init(debug);
  }

  return debug;
}

/**
 * Enables a debug mode by namespaces. This can include modes
 * separated by a colon and wildcards.
 *
 * @param {String} namespaces
 * @api public
 */

function enable(namespaces) {
  exports.save(namespaces);

  exports.names = [];
  exports.skips = [];

  var split = (typeof namespaces === 'string' ? namespaces : '').split(/[\s,]+/);
  var len = split.length;

  for (var i = 0; i < len; i++) {
    if (!split[i]) continue; // ignore empty strings
    namespaces = split[i].replace(/\*/g, '.*?');
    if (namespaces[0] === '-') {
      exports.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));
    } else {
      exports.names.push(new RegExp('^' + namespaces + '$'));
    }
  }
}

/**
 * Disable debug output.
 *
 * @api public
 */

function disable() {
  exports.enable('');
}

/**
 * Returns true if the given mode name is enabled, false otherwise.
 *
 * @param {String} name
 * @return {Boolean}
 * @api public
 */

function enabled(name) {
  var i, len;
  for (i = 0, len = exports.skips.length; i < len; i++) {
    if (exports.skips[i].test(name)) {
      return false;
    }
  }
  for (i = 0, len = exports.names.length; i < len; i++) {
    if (exports.names[i].test(name)) {
      return true;
    }
  }
  return false;
}

/**
 * Coerce `val`.
 *
 * @param {Mixed} val
 * @return {Mixed}
 * @api private
 */

function coerce(val) {
  if (val instanceof Error) return val.stack || val.message;
  return val;
}

},{"ms":191}],191:[function(require,module,exports){
/**
 * Helpers.
 */

var s = 1000;
var m = s * 60;
var h = m * 60;
var d = h * 24;
var y = d * 365.25;

/**
 * Parse or format the given `val`.
 *
 * Options:
 *
 *  - `long` verbose formatting [false]
 *
 * @param {String|Number} val
 * @param {Object} [options]
 * @throws {Error} throw an error if val is not a non-empty string or a number
 * @return {String|Number}
 * @api public
 */

module.exports = function(val, options) {
  options = options || {};
  var type = typeof val;
  if (type === 'string' && val.length > 0) {
    return parse(val);
  } else if (type === 'number' && isNaN(val) === false) {
    return options.long ? fmtLong(val) : fmtShort(val);
  }
  throw new Error(
    'val is not a non-empty string or a valid number. val=' +
      JSON.stringify(val)
  );
};

/**
 * Parse the given `str` and return milliseconds.
 *
 * @param {String} str
 * @return {Number}
 * @api private
 */

function parse(str) {
  str = String(str);
  if (str.length > 100) {
    return;
  }
  var match = /^((?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(
    str
  );
  if (!match) {
    return;
  }
  var n = parseFloat(match[1]);
  var type = (match[2] || 'ms').toLowerCase();
  switch (type) {
    case 'years':
    case 'year':
    case 'yrs':
    case 'yr':
    case 'y':
      return n * y;
    case 'days':
    case 'day':
    case 'd':
      return n * d;
    case 'hours':
    case 'hour':
    case 'hrs':
    case 'hr':
    case 'h':
      return n * h;
    case 'minutes':
    case 'minute':
    case 'mins':
    case 'min':
    case 'm':
      return n * m;
    case 'seconds':
    case 'second':
    case 'secs':
    case 'sec':
    case 's':
      return n * s;
    case 'milliseconds':
    case 'millisecond':
    case 'msecs':
    case 'msec':
    case 'ms':
      return n;
    default:
      return undefined;
  }
}

/**
 * Short format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function fmtShort(ms) {
  if (ms >= d) {
    return Math.round(ms / d) + 'd';
  }
  if (ms >= h) {
    return Math.round(ms / h) + 'h';
  }
  if (ms >= m) {
    return Math.round(ms / m) + 'm';
  }
  if (ms >= s) {
    return Math.round(ms / s) + 's';
  }
  return ms + 'ms';
}

/**
 * Long format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function fmtLong(ms) {
  return plural(ms, d, 'day') ||
    plural(ms, h, 'hour') ||
    plural(ms, m, 'minute') ||
    plural(ms, s, 'second') ||
    ms + ' ms';
}

/**
 * Pluralization helper.
 */

function plural(ms, n, name) {
  if (ms < n) {
    return;
  }
  if (ms < n * 1.5) {
    return Math.floor(ms / n) + ' ' + name;
  }
  return Math.ceil(ms / n) + ' ' + name + 's';
}

},{}],192:[function(require,module,exports){
// Copyright 2019 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

const BaseNode = require('lighthouse/lighthouse-core/lib/dependency-graph/base-node.js');
// eslint-disable-next-line no-unused-vars
const CpuNode = require('lighthouse/lighthouse-core/lib/dependency-graph/cpu-node.js');
// @ts-ignore Remove request() below after importing the type.
const LanternMetric = require('lighthouse/lighthouse-core/computed/metrics/lantern-metric');
// eslint-disable-next-line no-unused-vars
const NetworkNode = require('lighthouse/lighthouse-core/lib/dependency-graph/network-node.js');
const {isBidRelatedRequest, isImpressionPing, isGoogleAds, isGptAdRequest, isGptTag, isGptImplTag, toURL} = require('../utils/resource-classification');

/** @typedef {LH.Gatherer.Simulation.GraphNode} GraphNode */
/** @typedef {LH.Gatherer.Simulation.NodeTiming} NodeTiming */

/**
 * Returns the frame ID of the given event, if present.
 * @param {LH.TraceEvent} event
 * @return {?string}
 */
function getFrame(event) {
  // @ts-ignore
  return event.args.frame || event.args.data && event.args.data.frame || null;
}

/**
 * Returns a list of URLs associated with this CPU node.
 * @param {CpuNode} cpuNode
 * @return {string[]}
 */
function getCpuNodeUrls(cpuNode) {
  /** @type {Set<string>} */ const results = new Set();
  for (const {args} of cpuNode.childEvents) {
    if (args.data && args.data.url) {
      results.add(args.data.url);
    }
  }
  return Array.from(results);
}

/**
 * Checks if the given CPU node is related to bidding.
 * @param {CpuNode} cpuNode
 * @return {boolean}
 */
function isAdTask(cpuNode) {
  return !!getCpuNodeUrls(cpuNode).find(
    (url) => isBidRelatedRequest(url) || isGoogleAds(toURL(url)));
}

/**
 * Checks if the given CPU node is a long task.
 * @param {CpuNode} cpuNode
 * @return {boolean}
 */
function isLongTask(cpuNode) {
  // TODO(warrengm): Consider scaling 50 ms based on current processor speed
  // so that we include tasks that will be long on slower processors.
  return cpuNode.event.dur > 50 * 1000;
}

/**
 * Adds a dependency edge between a nd b, where a came before b.
 * @param {CpuNode|NetworkNode} a
 * @param {CpuNode|NetworkNode} b
 */
function addEdge(a, b) {
  if (a === b || a.endTime > b.startTime) return;
  a.addDependent(b);
}

/**
 * Inserts edges between bid requests and ad requests.
 * @param {BaseNode} graph
 */
function addEdges(graph) {
  /** @type {NetworkNode[]} */ const adRequestNodes = [];
  /** @type {NetworkNode[]} */ const gptJsNodes = [];
  graph.traverse((node) => {
    if (node.type !== BaseNode.TYPES.NETWORK) {
      return;
    }
    if (isGptTag(node.record.url) && node.record.resourceType === 'Script') {
      gptJsNodes.push(node);
    } else if (isGptAdRequest(node.record)) {
      adRequestNodes.push(node);
    }
  });
  graph.traverse((node) => {
    if (node.type !== BaseNode.TYPES.NETWORK) {
      return;
    }
    if (isGptImplTag(node.record.url)) {
      const gptImplNode = node;
      for (const gptJsNode of gptJsNodes) {
        addEdge(gptJsNode, gptImplNode);
      }
    }
    if (isBidRelatedRequest(node.record)) {
      const bidNode = node;
      for (const adNode of adRequestNodes) {
        addEdge(bidNode, adNode);
      }
    }
    if (isImpressionPing(node.record.url)) {
      const impressionNode = node;
      for (const adNode of adRequestNodes) {
        addEdge(adNode, impressionNode);
        for (const dependent of adNode.getDependents()) {
          addEdge(dependent, impressionNode);
        }
      }
    }
  });
}

/** An abstract class for ad lantern metrics. */
class AdLanternMetric extends LanternMetric {
  /**
   * @return {LH.Gatherer.Simulation.MetricCoefficients}
   * @override
   */
  static get COEFFICIENTS() {
    return {
      intercept: 0,
      // We only have one graph so put all the weight on it.
      optimistic: 1,
      pessimistic: 0,
    };
  }

  /**
   * @param {BaseNode} graph Root of the dependency graph, i.e. the
   *     document node.
   * @return {BaseNode}
   * @override
   */
  static getPessimisticGraph(graph) {
    // The pessimistic graph is the whole graph.
    const pessimisticGraph = graph.cloneWithRelationships((_) => true);
    addEdges(pessimisticGraph);
    return pessimisticGraph;
  }

  /**
   * @param {BaseNode} graph Root of the dependency graph, i.e. the
   *     document node.
   * @return {BaseNode}
   * @override
   */
  static getOptimisticGraph(graph) {
    // @ts-ignore
    const mainFrame = graph.record.frameId;
    const pessimisticGraph = AdLanternMetric.getPessimisticGraph(graph);
    // Filter the pessimistic graph.
    const optimisticGraph = pessimisticGraph.cloneWithRelationships((node) => {
      if (node.type === BaseNode.TYPES.CPU) {
        return (
          isLongTask(node) ||
          isAdTask(node) ||
          !!getFrame(node.event) && getFrame(node.event) !== mainFrame);
      }
      if (node.hasRenderBlockingPriority()) {
        return true;
      }
      const /** string */ url = node.record.url;
      return isBidRelatedRequest(url) || isGoogleAds(toURL(url));
    });
    addEdges(pessimisticGraph);
    return optimisticGraph;
  }

  /**
   * @param {LH.Gatherer.Simulation.Result} simulationResult
   * @param {Object} extras
   * @return {LH.Gatherer.Simulation.Result}
   * @override
   */
  static getEstimateFromSimulation(simulationResult, extras) {
    throw new Error(
      'getEstimateFromSimulation not implemented by ' + this.name);
  }

  /**
   * @param {Map<GraphNode, NodeTiming>} nodeTimings
   * @param {function(GraphNode, NodeTiming): boolean} isTargetNode
   * @return {NodeTiming}
   */
  static findTiming(nodeTimings, isTargetNode) {
    let leastTiming = {startTime: Infinity, endTime: -Infinity, duration: 0};
    for (const [node, timing] of nodeTimings.entries()) {
      if (isTargetNode(node, timing) &&
          leastTiming.startTime > timing.startTime) {
        leastTiming = timing;
      }
    }
    return leastTiming;
  }

  /**
   * @param {Map<GraphNode, NodeTiming>} nodeTimings
   * @param {function(LH.Artifacts.NetworkRequest): boolean} isTargetRequest
   * @return {NodeTiming}
   */
  static findNetworkTiming(nodeTimings, isTargetRequest) {
    return this.findTiming(
      nodeTimings,
      (node) =>
        node.type === BaseNode.TYPES.NETWORK && isTargetRequest(node.record));
  }
}

module.exports = AdLanternMetric;

},{"../utils/resource-classification":206,"lighthouse/lighthouse-core/computed/metrics/lantern-metric":27,"lighthouse/lighthouse-core/lib/dependency-graph/base-node.js":86,"lighthouse/lighthouse-core/lib/dependency-graph/cpu-node.js":87,"lighthouse/lighthouse-core/lib/dependency-graph/network-node.js":88}],193:[function(require,module,exports){
// Copyright 2019 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

const AdLanternMetric = require('./ad-lantern-metric');
// @ts-ignore
const ComputedMetric = require('lighthouse/lighthouse-core/computed/metrics/metric');
// @ts-ignore
const makeComputedArtifact = require('lighthouse/lighthouse-core/computed/computed-artifact');
const {getPageStartTime, getImpressionStartTime} = require('../utils/network-timing');
const {isImpressionPing} = require('../utils/resource-classification');

// @ts-ignore
// eslint-disable-next-line max-len
/** @typedef {import('lighthouse/lighthouse-core/lib/dependency-graph/base-node.js').Node} Node */

/** Computes simulated first ad render time using Lantern. */
class LanternAdRenderTime extends AdLanternMetric {
  /**
   * @param {LH.Gatherer.Simulation.Result} simulationResult
   * @param {Object} extras
   * @return {LH.Gatherer.Simulation.Result}
   * @override
   */
  static getEstimateFromSimulation(simulationResult, extras) {
    const {nodeTimings} = simulationResult;
    const timeInMs = AdLanternMetric.findNetworkTiming(
      nodeTimings,
      (req) => !!req.url && isImpressionPing(new URL(req.url))).startTime;
    return {timeInMs, nodeTimings};
  }
}

// Decorate the class.
// @ts-ignore Allow reassignment for decoration.
// eslint-disable-next-line no-class-assign
LanternAdRenderTime = makeComputedArtifact(LanternAdRenderTime);

/** Computes the first ad render time metric. */
class AdRenderTime extends ComputedMetric {
  /**
   * @param {LH.Artifacts.MetricComputationData} data
   * @param {LH.Audit.Context} context
   * @return {Promise<LH.Artifacts.LanternMetric>}
   * @override
   */
  static async computeSimulatedMetric(data, context) {
    // @ts-ignore request does not exist on LanternAdRenderTime
    return LanternAdRenderTime.request(data, context);
  }

  /**
   * @param {LH.Artifacts.MetricComputationData} data
   * @param {LH.Audit.Context} context
   * @return {Promise<LH.Artifacts.Metric>}
   * @override
   */
  static async computeObservedMetric(data, context) {
    const {networkRecords} = data;
    const pageStartTime = getPageStartTime(networkRecords);
    const impressionStartTime = getImpressionStartTime(networkRecords);
    const firstPaintMs = (impressionStartTime - pageStartTime) * 1000;
    return Promise.resolve({timing: firstPaintMs});
  }

  /**
   * @param {unknown} artifacts
   * @param {LH.Audit.Context} context
   * @return {Promise<LH.Artifacts.Metric>}
   */
  static async request(artifacts, context) {
    // Implement request() to make the compiler happy. It will be implemented
    // below with decoration. Long term we should find a good way to have the
    // compiler infer this.
    throw Error('Not implemented -- class not decorated');
  }
}

// Decorate the class.
// @ts-ignore Allow reassignment for decoration.
// eslint-disable-next-line no-class-assign
AdRenderTime = makeComputedArtifact(AdRenderTime);

module.exports = AdRenderTime;


},{"../utils/network-timing":204,"../utils/resource-classification":206,"./ad-lantern-metric":192,"lighthouse/lighthouse-core/computed/computed-artifact":9,"lighthouse/lighthouse-core/computed/metrics/metric":33}],194:[function(require,module,exports){
// Copyright 2019 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

const AdLanternMetric = require('./ad-lantern-metric');
// @ts-ignore
const ComputedMetric = require('lighthouse/lighthouse-core/computed/metrics/metric');
// @ts-ignore
const makeComputedArtifact = require('lighthouse/lighthouse-core/computed/computed-artifact');
const {getAdStartTime, getPageStartTime} = require('../utils/network-timing');
const {isAdRequest} = require('../utils/resource-classification');

// @ts-ignore
// eslint-disable-next-line max-len
/** @typedef {import('lighthouse/lighthouse-core/lib/dependency-graph/base-node.js').Node} Node */

/** Computes simulated first ad request time using Lantern. */
class LanternAdRequestTime extends AdLanternMetric {
  /**
   * @param {LH.Gatherer.Simulation.Result} simulationResult
   * @param {Object} extras
   * @return {LH.Gatherer.Simulation.Result}
   * @override
   */
  static getEstimateFromSimulation(simulationResult, extras) {
    const {nodeTimings} = simulationResult;
    const timeInMs = AdLanternMetric.findNetworkTiming(
      nodeTimings, isAdRequest).startTime;
    return {timeInMs, nodeTimings};
  }
}

// Decorate the class.
// @ts-ignore Allow reassignment for decoration.
// eslint-disable-next-line no-class-assign
LanternAdRequestTime = makeComputedArtifact(LanternAdRequestTime);

/** Computes time to the first ad request. */
class AdRequestTime extends ComputedMetric {
  /**
   * @param {LH.Artifacts.MetricComputationData} data
   * @param {LH.Audit.Context} context
   * @return {Promise<LH.Artifacts.LanternMetric>}
   * @override
   */
  static async computeSimulatedMetric(data, context) {
    // @ts-ignore request does not exist on LanternAdRequestTime
    return LanternAdRequestTime.request(data, context);
  }

  /**
   * @param {LH.Artifacts.MetricComputationData} data
   * @return {Promise<LH.Artifacts.Metric>}
   * @override
   */
  static async computeObservedMetric(data) {
    const {networkRecords} = data;
    const pageStartTime = getPageStartTime(networkRecords);
    const adStartTime = getAdStartTime(networkRecords);
    const adRequestTimeMs = (adStartTime - pageStartTime) * 1000;
    return Promise.resolve({timing: adRequestTimeMs});
  }

  /**
   * @param {unknown} artifacts
   * @param {LH.Audit.Context} context
   * @return {Promise<LH.Artifacts.Metric>}
   */
  static async request(artifacts, context) {
    // Implement request() to make the compiler happy. It will be implemented
    // below with decoration. Long term we should find a good way to have the
    // compiler infer this.
    throw Error('Not implemented -- class not decorated');
  }
}

// Decorate the class.
// @ts-ignore Allow reassignment for decoration.
// eslint-disable-next-line no-class-assign
AdRequestTime = makeComputedArtifact(AdRequestTime);

module.exports = AdRequestTime;

},{"../utils/network-timing":204,"../utils/resource-classification":206,"./ad-lantern-metric":192,"lighthouse/lighthouse-core/computed/computed-artifact":9,"lighthouse/lighthouse-core/computed/metrics/metric":33}],195:[function(require,module,exports){
// Copyright 2019 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

const AdLanternMetric = require('./ad-lantern-metric');
// @ts-ignore
const ComputedMetric = require('lighthouse/lighthouse-core/computed/metrics/metric');
// @ts-ignore
const makeComputedArtifact = require('lighthouse/lighthouse-core/computed/computed-artifact');
const {getAdStartTime, getBidStartTime, getPageStartTime} = require('../utils/network-timing');
const {isAdRequest, isBidRequest} = require('../utils/resource-classification');

// @ts-ignore
// eslint-disable-next-line max-len
/** @typedef {import('lighthouse/lighthouse-core/lib/dependency-graph/base-node.js').Node} Node */

/** Computes simulated first ad request time using Lantern. */
class LanternBidRequestTime extends AdLanternMetric {
  /**
   * @param {LH.Gatherer.Simulation.Result} simulationResult
   * @param {Object} extras
   * @return {LH.Gatherer.Simulation.Result}
   * @override
   */
  static getEstimateFromSimulation(simulationResult, extras) {
    const {nodeTimings} = simulationResult;
    const bidTimeInMs = AdLanternMetric.findNetworkTiming(
      nodeTimings, isBidRequest).startTime;
    const adRequestTimeMs = AdLanternMetric.findNetworkTiming(
      nodeTimings, isAdRequest).startTime;
    if (bidTimeInMs > adRequestTimeMs) {
      return {timeInMs: -1, nodeTimings};
    }
    return {timeInMs: bidTimeInMs, nodeTimings};
  }
}

// Decorate the class.
// @ts-ignore Allow reassignment for decoration.
// eslint-disable-next-line no-class-assign
LanternBidRequestTime = makeComputedArtifact(LanternBidRequestTime);

/** Computes time to the first ad request. */
class BidRequestTime extends ComputedMetric {
  /**
   * @param {LH.Artifacts.MetricComputationData} data
   * @param {LH.Audit.Context} context
   * @return {Promise<LH.Artifacts.LanternMetric>}
   * @override
   */
  static async computeSimulatedMetric(data, context) {
    // @ts-ignore request does not exist on LanternBidRequestTime
    return LanternBidRequestTime.request(data, context);
  }

  /**
   * @param {LH.Artifacts.MetricComputationData} data
   * @return {Promise<LH.Artifacts.Metric>}
   * @override
   */
  static async computeObservedMetric(data) {
    const {networkRecords} = data;
    const pageStartTime = getPageStartTime(networkRecords);
    const bidStartTime = getBidStartTime(networkRecords);
    const adStartTime = getAdStartTime(networkRecords);
    if (adStartTime < bidStartTime) {
      return {timing: -1};
    }
    const bidRequestTimeMs = (bidStartTime - pageStartTime) * 1000;
    return {timing: bidRequestTimeMs};
  }

  /**
   * @param {unknown} artifacts
   * @param {LH.Audit.Context} context
   * @return {Promise<LH.Artifacts.Metric>}
   */
  static async request(artifacts, context) {
    // Implement request() to make the compiler happy. It will be implemented
    // below with decoration. Long term we should find a good way to have the
    // compiler infer this.
    throw Error('Not implemented -- class not decorated');
  }
}

// Decorate the class.
// @ts-ignore Allow reassignment for decoration.
// eslint-disable-next-line no-class-assign
BidRequestTime = makeComputedArtifact(BidRequestTime);

module.exports = BidRequestTime;

},{"../utils/network-timing":204,"../utils/resource-classification":206,"./ad-lantern-metric":192,"lighthouse/lighthouse-core/computed/computed-artifact":9,"lighthouse/lighthouse-core/computed/metrics/metric":33}],196:[function(require,module,exports){
// Copyright 2019 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

const AdLanternMetric = require('../computed/ad-lantern-metric');
const BaseNode = require('lighthouse/lighthouse-core/lib/dependency-graph/base-node.js');
// @ts-ignore
const ComputedMetric = require('lighthouse/lighthouse-core/computed/metrics/metric');
// eslint-disable-next-line no-unused-vars
const CpuNode = require('lighthouse/lighthouse-core/lib/dependency-graph/cpu-node.js');
const {getAttributableUrl} = require('../utils/tasks');
// @ts-ignore
const LoadSimulator = require('lighthouse/lighthouse-core/computed/load-simulator');
const MainThreadTasks = require('lighthouse/lighthouse-core/computed/main-thread-tasks');
// @ts-ignore
const makeComputedArtifact = require('lighthouse/lighthouse-core/computed/computed-artifact');
// eslint-disable-next-line no-unused-vars
const NetworkNode = require('lighthouse/lighthouse-core/lib/dependency-graph/network-node.js');
const NetworkRecords = require('lighthouse/lighthouse-core/computed/network-records');
const PageDependencyGraph = require('lighthouse/lighthouse-core/computed/page-dependency-graph');

const PROVIDED_LONG_TASK_THRESHOLD_MS = 50;
const SIMULATED_LONG_TASK_THRESHOLD_MS = 100;

/**
 * @param {LH.Artifacts.TaskNode} task
 * @param {Set<string>} knownScripts
 * @return {boolean}
 */
function isLong(task, knownScripts) {
  if (task.duration < PROVIDED_LONG_TASK_THRESHOLD_MS) {
    return false; // Short task
  }
  const script = getAttributableUrl(task, knownScripts);
  if (!script) {
    return false;
  }
  if (task.parent) {
    // Only show this long task if doing so adds more information for debugging.
    // So we hide it if it's attributed to the same script as the parent task.
    const parentScript = getAttributableUrl(task.parent, knownScripts);
    return script != parentScript;
  }
  return true;
}

/** Finds long tasks, with support for simulation. */
class LongTasks extends ComputedMetric {
  /**
   * @param {LH.Trace} trace
   * @param {LH.DevtoolsLog} devtoolsLog
   * @param {LH.Audit.Context} context
   * @return {Promise<BaseNode>} networkRecords
   */
  static async getSimulationGraph(trace, devtoolsLog, context) {
    /** @type {NetworkNode} */
    const documentNode =
      // @ts-ignore Property 'request' does not appear on PageDependencyGraph
      await PageDependencyGraph.request({trace, devtoolsLog}, context);
    return AdLanternMetric.getOptimisticGraph(documentNode);
  }

  /**
   * @param {LH.Trace} trace
   * @param {LH.DevtoolsLog} devtoolsLog
   * @param {LH.Audit.Context} context
   * @return {Promise<LH.Artifacts.TaskNode[]>} networkRecords
   */
  static async computeSimulatedResult(trace, devtoolsLog, context) {
    const graph = await this.getSimulationGraph(trace, devtoolsLog, context);
    const simulator = await LoadSimulator.request(
      {devtoolsLog, settings: context.settings}, context);
    const {nodeTimings} = simulator.simulate(graph, {});

    /** @type {LH.Artifacts.TaskNode[]} */ const tasks = [];
    for (const [node, timing] of nodeTimings.entries()) {
      if (node.type !== BaseNode.TYPES.CPU ||
          timing.duration < SIMULATED_LONG_TASK_THRESHOLD_MS) {
        continue; // Not a long task
      }
      tasks.push({
        event: node.event,
        startTime: timing.startTime,
        endTime: timing.endTime,
        duration: timing.duration,
        selfTime: timing.duration, // TODO: subtract child time
        attributableURLs: Array.from(node.getEvaluateScriptURLs()),
        children: [],
        parent: node.parent,
        unbounded: node.unbounded,
        group: node.group,
      });
    }
    return tasks;
  }

  /**
   * @param {LH.Trace} trace
   * @param {LH.DevtoolsLog} devtoolsLog
   * @param {LH.Audit.Context} context
   * @return {Promise<LH.Artifacts.TaskNode[]>}
   */
  static async computeObservedResult(trace, devtoolsLog, context) {
    const tasks = await MainThreadTasks.request(trace, context);
    const networkRecords = await NetworkRecords.request(devtoolsLog, context);

    /** @type {Set<string>} */ const knownScripts = new Set(networkRecords
        .filter((record) => record.resourceType === 'Script')
        .map((record) => record.url));
    return tasks.filter((t) => isLong(t, knownScripts));
  }

  /**
   * @param {{devtoolsLog: LH.DevtoolsLog, trace: LH.Trace}} data
   * @param {LH.Audit.Context} context
   * @return {Promise<LH.Artifacts.TaskNode[]>}
   */
  static async compute_({trace, devtoolsLog}, context) {
    return context.settings.throttlingMethod == 'simulate' ?
      this.computeSimulatedResult(trace, devtoolsLog, context) :
      this.computeObservedResult(trace, devtoolsLog, context);
  }

  /**
   * @param {unknown} artifacts
   * @param {LH.Audit.Context} context
   * @return {Promise<LH.Artifacts.TaskNode[]>}
   */
  static async request(artifacts, context) {
    // Implement request() to make the compiler happy. It will be implemented
    // below with decoration. Long term we should find a good way to have the
    // compiler infer this.
    throw Error('Not implemented -- class not decorated');
  }
}

// Decorate the class.
// @ts-ignore Allow reassignment for decoration.
// eslint-disable-next-line no-class-assign
LongTasks = makeComputedArtifact(LongTasks);

module.exports = LongTasks;

},{"../computed/ad-lantern-metric":192,"../utils/tasks":207,"lighthouse/lighthouse-core/computed/computed-artifact":9,"lighthouse/lighthouse-core/computed/load-simulator":13,"lighthouse/lighthouse-core/computed/main-thread-tasks":15,"lighthouse/lighthouse-core/computed/metrics/metric":33,"lighthouse/lighthouse-core/computed/network-records":40,"lighthouse/lighthouse-core/computed/page-dependency-graph":41,"lighthouse/lighthouse-core/lib/dependency-graph/base-node.js":86,"lighthouse/lighthouse-core/lib/dependency-graph/cpu-node.js":87,"lighthouse/lighthouse-core/lib/dependency-graph/network-node.js":88}],197:[function(require,module,exports){
// Copyright 2019 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

const AdLanternMetric = require('./ad-lantern-metric');
// @ts-ignore
const ComputedMetric = require('lighthouse/lighthouse-core/computed/metrics/metric');
// @ts-ignore
const makeComputedArtifact = require('lighthouse/lighthouse-core/computed/computed-artifact');
const {getPageStartTime, getTagEndTime} = require('../utils/network-timing');
const {isImplTag} = require('../utils/resource-classification');
const {URL} = require('url');

// @ts-ignore
// eslint-disable-next-line max-len
/** @typedef {import('lighthouse/lighthouse-core/lib/dependency-graph/base-node.js').Node} Node */

/** Computes simulated tag load time using Lantern. */
class LanternTagLoadTime extends AdLanternMetric {
  /**
   * @param {LH.Gatherer.Simulation.Result} simulationResult
   * @param {Object} extras
   * @return {LH.Gatherer.Simulation.Result}
   * @override
   */
  static getEstimateFromSimulation(simulationResult, extras) {
    const {nodeTimings} = simulationResult;
    const timeInMs = AdLanternMetric.findNetworkTiming(
      nodeTimings, (req) => !!req.url && isImplTag(new URL(req.url))).endTime;
    return {timeInMs, nodeTimings};
  }
}

// Decorate the class.
// @ts-ignore Allow reassignment for decoration.
// eslint-disable-next-line no-class-assign
LanternTagLoadTime = makeComputedArtifact(LanternTagLoadTime);

/** Computes the tag load time metric. */
class TagLoadTime extends ComputedMetric {
  /**
   * @param {LH.Artifacts.MetricComputationData} data
   * @param {LH.Audit.Context} context
   * @return {Promise<LH.Artifacts.LanternMetric>}
   * @override
   */
  static async computeSimulatedMetric(data, context) {
    // @ts-ignore request does not exist on LanternTagLoadTime
    return LanternTagLoadTime.request(data, context);
  }

  /**
   * @param {LH.Artifacts.MetricComputationData} data
   * @param {LH.Audit.Context} context
   * @return {Promise<LH.Artifacts.Metric>}
   * @override
   */
  static async computeObservedMetric(data, context) {
    const {networkRecords} = data;
    const pageStartTime = getPageStartTime(networkRecords);
    const tagEndTime = getTagEndTime(networkRecords);
    const tagLoadMs = (tagEndTime - pageStartTime) * 1000;
    return Promise.resolve({timing: tagLoadMs});
  }

  /**
   * @param {unknown} artifacts
   * @param {LH.Audit.Context} context
   * @return {Promise<LH.Artifacts.Metric>}
   */
  static async request(artifacts, context) {
    // Implement request() to make the compiler happy. It will be implemented
    // below with decoration. Long term we should find a good way to have the
    // compiler infer this.
    throw Error('Not implemented -- class not decorated');
  }
}

// Decorate the class.
// @ts-ignore Allow reassignment for decoration.
// eslint-disable-next-line no-class-assign
TagLoadTime = makeComputedArtifact(TagLoadTime);

module.exports = TagLoadTime;


},{"../utils/network-timing":204,"../utils/resource-classification":206,"./ad-lantern-metric":192,"lighthouse/lighthouse-core/computed/computed-artifact":9,"lighthouse/lighthouse-core/computed/metrics/metric":33,"url":"url"}],198:[function(require,module,exports){
(function (__filename){(function (){
// Copyright 2018 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

const UIStrings = {
  GROUPS__METRICS: 'Metrics',
  GROUPS__ADS_PERFORMANCE: 'Ad Speed',
  GROUPS__ADS_BEST_PRACTICES: 'Tag Best Practices',

  NOT_APPLICABLE__DEFAULT: 'Audit not applicable',
  NOT_APPLICABLE__INVALID_TIMING: 'Invalid timing task data',
  NOT_APPLICABLE__NO_AD_RELATED_REQ: 'No ad-related requests',
  NOT_APPLICABLE__NO_AD_RENDERED: 'No ads rendered',
  NOT_APPLICABLE__NO_ADS_VIEWPORT: 'No ads in viewport',
  NOT_APPLICABLE__NO_ADS: 'No ads requested',
  NOT_APPLICABLE__NO_BIDS: 'No bids detected',
  NOT_APPLICABLE__NO_EVENT_MATCHING_REQ: 'No event matches network records',
  NOT_APPLICABLE__NO_GPT: 'GPT not requested',
  NOT_APPLICABLE__NO_RECORDS: 'No successful network records',
  NOT_APPLICABLE__NO_VISIBLE_SLOTS: 'No visible slots',
  NOT_APPLICABLE__NO_TAG: 'No tag requested',
  NOT_APPLICABLE__NO_TAGS: 'No tags requested',
  NOT_APPLICABLE__NO_TASKS: 'No tasks to compare',
  NOT_APPLICABLE__NO_VALID_AD_WIDTHS: 'No requested ads contain ads of valid width',
  NOT_APPLICABLE__NO_LAYOUT_SHIFTS: 'No layout shift events found',

  ERRORS__AREA_LARGER_THAN_VIEWPORT: 'Calculated ad area is larger than viewport',
  ERRORS__VIEWPORT_AREA_ZERO: 'Viewport area is zero',

  WARNINGS__NO_ADS: 'No ads were requested when fetching this page.',
  WARNINGS__NO_AD_RENDERED: 'No ads were rendered when rendering this page.',
  WARNINGS__NO_TAG: 'The GPT tag was not requested.',
};
const i18n = require('lighthouse/lighthouse-core/lib/i18n/i18n');

const str_ = i18n.createMessageInstanceIdFn(__filename, UIStrings);

/**
 * Returns object for a notApplicable audit given a message string
 * @param {string} message
 * @return {LH.Audit.Product}
 */
const notApplicableObj = (message) => ({
  notApplicable: true,
  score: 1,
  displayValue: str_(message),
});

/**
 * Returns notApplicable object for a given property.
 * @return {LH.Audit.Product}
 */
const auditNotApplicable = {
  Default: notApplicableObj(UIStrings.NOT_APPLICABLE__DEFAULT),
  InvalidTiming: notApplicableObj(UIStrings.NOT_APPLICABLE__INVALID_TIMING),
  NoAdRelatedReq: notApplicableObj(UIStrings.NOT_APPLICABLE__NO_AD_RELATED_REQ),
  NoAdRendered: notApplicableObj(UIStrings.NOT_APPLICABLE__NO_AD_RENDERED),
  NoAdsViewport: notApplicableObj(UIStrings.NOT_APPLICABLE__NO_ADS_VIEWPORT),
  NoAds: notApplicableObj(UIStrings.NOT_APPLICABLE__NO_ADS),
  NoBids: notApplicableObj(UIStrings.NOT_APPLICABLE__NO_BIDS),
  NoEventMatchingReq: notApplicableObj(
    UIStrings.NOT_APPLICABLE__NO_EVENT_MATCHING_REQ),
  NoGpt: notApplicableObj(UIStrings.NOT_APPLICABLE__NO_GPT),
  NoLayoutShifts: notApplicableObj(UIStrings.NOT_APPLICABLE__NO_LAYOUT_SHIFTS),
  NoRecords: notApplicableObj(UIStrings.NOT_APPLICABLE__NO_RECORDS),
  NoVisibleSlots: notApplicableObj(UIStrings.NOT_APPLICABLE__NO_VISIBLE_SLOTS),
  NoTag: notApplicableObj(UIStrings.NOT_APPLICABLE__NO_TAG),
  NoTags: notApplicableObj(UIStrings.NOT_APPLICABLE__NO_TAGS),
  NoTasks: notApplicableObj(UIStrings.NOT_APPLICABLE__NO_TASKS),
  NoValidAdWidths: notApplicableObj(
    UIStrings.NOT_APPLICABLE__NO_VALID_AD_WIDTHS),
};

const runWarning = {
  NoAds: str_(UIStrings.WARNINGS__NO_ADS),
  NoAdRendered: str_(UIStrings.WARNINGS__NO_AD_RENDERED),
  NoTag: str_(UIStrings.WARNINGS__NO_TAG),
};

const auditError = {
  ViewportAreaZero: str_(UIStrings.ERRORS__VIEWPORT_AREA_ZERO),
};

const group = {
  Metrics: str_(UIStrings.GROUPS__METRICS),
  AdsPerformance: str_(UIStrings.GROUPS__ADS_PERFORMANCE),
  AdsBestPractices: str_(UIStrings.GROUPS__ADS_BEST_PRACTICES),
};

module.exports = {auditNotApplicable, runWarning, auditError, group};
module.exports.UIStrings = UIStrings;

}).call(this)}).call(this,"/node_modules/lighthouse-plugin-publisher-ads/messages/common-strings.js")
},{"lighthouse/lighthouse-core/lib/i18n/i18n":96}],199:[function(require,module,exports){
// Copyright 2019 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * Counts how many elements of the array match the given predicate.
 * @param {Array<T>} arr
 * @param {function(T): boolean} pred
 * @return {number}
 * @template T
 */
function count(arr, pred) {
  let num = 0;
  for (const el of arr) {
    if (pred(el)) {
      num++;
    }
  }
  return num;
}

/**
 * Sorts an array into buckets depending on a splitting function.
 * We use the type 'any' because the bucket function works on any type, and
 * returns an object of arrays of any type. The type is not specified.
 * @param {V[]} array
 * @param {function(V): B} splitter
 * @return {Map<!B, V[]>}
 * @template V, B
 */
function bucket(array, splitter) {
  /** @type {Map<!B, V[]>} */
  const buckets = new Map();
  for (const element of array) {
    const result = splitter(element);
    if (result != null) {
      // The result is not undefined, so either push the result to the right
      // bucket, or create it if necessary.
      const bucket = buckets.get(result) || [];
      bucket.push(element);
      buckets.set(result, bucket);
    }
  }
  return buckets;
}

/**
 * Flattens a 2-d array to a 1-d array.
 * @param {T[][]} arrs
 * @return {T[]}
 * @template T
 */
function flatten(arrs) {
  const result = [];
  for (const arr of arrs) {
    result.push(...arr);
  }
  return result;
}

module.exports = {
  count, bucket, flatten,
};

},{}],200:[function(require,module,exports){
// Copyright 2019 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @param {?X|undefined} x
 * @return {!X}
 * @template X
 */
function assert(x) {
  if (x == null) throw new Error('Expected not to be null');
  return x;
}

module.exports = {
  assert,
};

},{}],201:[function(require,module,exports){
// Copyright 2018 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

module.exports = [
  {
    label: 'Prebid JS',
    patterns: [
      `^https?://([^.]*.)?prebid[.]org/.*`,
      '^https?://acdn[.]adnxs[.]com/prebid/.*',
    ],
  },
  {
    label: '33Across',
    patterns: [
      '^https?://ssc[.]33across.com/api/.*',
    ],
  },
  {
    label: 'AppNexus',
    patterns: [
      '^https?://ib[.]adnxs[.]com/.*',
    ],
  },
  {
    label: 'Amazon Ads',
    patterns: [
      '^https?://[a-z-_.]*[.]amazon-adsystem[.]com/.*bid.*',
    ],
  },
  {
    label: 'AdTechus (AOL)',
    patterns: [
      '^https?://([^.]*.)?adserver[.]adtechus[.]com/.*',
    ],
  },
  {
    label: 'Aardvark',
    patterns: [
      '^https?://thor[.]rtk[.]io/.*',
    ],
  },
  {
    label: 'AdBlade',
    patterns: [
      '^https?://rtb[.]adblade[.]com/prebidjs/bid.*',
    ],
  },
  {
    label: 'AdBund',
    patterns: [
      '^https?://us-east-engine[.]adbund[.]xyz/prebid/ad/get.*',
      '^https?://us-west-engine[.]adbund[.]xyz/prebid/ad/get.*',
    ],
  },
  {
    label: 'AdButler',
    patterns: [
      '^https?://servedbyadbutler[.]com/adserve.*',
    ],
  },
  {
    label: 'Adequant',
    patterns: [
      '^https?://rex[.]adequant[.]com/rex/c2s_prebid.*',
    ],
  },
  {
    label: 'AdForm',
    patterns: [
      '^https?://adx[.]adform[.]net/adx.*',
    ],
  },
  {
    label: 'AdMedia',
    patterns: [
      '^https?://b[.]admedia[.]com/banner/prebid/bidder.*',
    ],
  },
  {
    label: 'AdMixer',
    patterns: [
      '^https?://inv-nets[.]admixer[.]net/prebid[.]aspx.*',
      '^https?://inv-nets[.]admixer[.]net/videoprebid[.]aspx.*',
    ],
  },
  {
    label: 'AOL',
    patterns: [
      '^https?://adserver-us[.]adtech[.]advertising[.]com.*',
      '^https?://adserver-eu[.]adtech[.]advertising[.]com.*',
      '^https?://adserver-as[.]adtech[.]advertising[.]com.*',
      '^https?://adserver[.]adtech[.]de/pubapi/.*',
    ],
  },
  {
    label: 'Beachfront',
    patterns: [
      '^https?://reachms[.]bfmio[.]com/bid[.]json?exchange_id=.*',
    ],
  },
  {
    label: 'Bidfluence',
    patterns: [
      '^https?://cdn[.]bidfluence[.]com/forge[.]js.*',
    ],
  },
  {
    label: 'Brightcom',
    patterns: [
      '^https?://hb[.]iselephant[.]com/auc/ortb.*',
    ],
  },
  {
    label: 'C1x',
    patterns: [
      '^https?://ht-integration[.]c1exchange[.]com:9000/ht.*',
    ],
  },
  {
    label: 'CentroBid',
    patterns: [
      '^https?://t[.]brand-server[.]com/hb.*',
    ],
  },
  {
    label: 'Conversant',
    patterns: [
      '^https?://media[.]msg[.]dotomi[.]com/s2s/.*',
    ],
  },
  {
    label: 'Criteo',
    patterns: [
      '^https?://static[.]criteo[.]net/js/ld/publishertag[.]js.*',
      '^https?://([^.]*.)?bidder[.]criteo[.]com/cdb.*',
      '^https?://([^.]*.)?rtax[.]criteo[.]com/delivery/rta.*',
      '^https?://([^.]*.)?rtax[.]eu[.]criteo[.]com/delivery/rta.*',
    ],
  },
  {
    label: 'Datablocks',
    patterns: [
      '^https?://[a-z0-9_.-]*[.]dblks[.]net/.*',
    ],
  },
  {
    label: 'Districtm',
    patterns: [
      '^https?://prebid[.]districtm[.]ca/lib[.]js.*',
    ],
  },
  {
    label: 'E-Planning',
    patterns: [
      '^https?://ads[.]us[.]e-planning[.]net.*',
    ],
  },
  {
    label: 'Essens',
    patterns: [
      '^https?://bid[.]essrtb[.]com/bid/prebid_call.*',
    ],
  },
  {
    label: 'Facebook',
    patterns: [
      '^https?://an[.]facebook[.]com/v2/placementbid[.]json.*',
    ],
  },
  {
    label: 'FeatureForward',
    patterns: [
      '^https?://prmbdr[.]featureforward[.]com/newbidder/.*',
    ],
  },
  {
    label: 'Fidelity',
    patterns: [
      '^https?://x[.]fidelity-media[.]com.*',
    ],
  },
  {
    label: 'GetIntent',
    patterns: [
      '^https?://px[.]adhigh[.]net/rtb/direct_banner.*',
      '^https?://px[.]adhigh[.]net/rtb/direct_vast.*',
    ],
  },
  {
    label: 'GumGum',
    patterns: [
      '^https?://g2[.]gumgum[.]com/hbid/imp.*',
    ],
  },
  {
    label: 'Hiromedia',
    patterns: [
      '^https?://hb-rtb[.]ktdpublishers[.]com/bid/get.*',
    ],
  },
  {
    label: 'Imonomy',
    patterns: [
      '^https?://b[.]imonomy[.]com/openrtb/hb/.*',
    ],
  },
  {
    label: 'ImproveDigital',
    patterns: [
      '^https?://ad[.]360yield[.]com/hb.*',
    ],
  },
  {
    label: 'IndexExchange',
    patterns: [
      '^https?://as(-sec)?[.]casalemedia[.]com/(cygnus|headertag).*',
      '^https?://js(-sec)?[.]indexww[.]com/ht/.*',
    ],
  },
  {
    label: 'InnerActive',
    patterns: [
      '^https?://ad-tag[.]inner-active[.]mobi/simpleM2M/requestJsonAd.*',
    ],
  },
  {
    label: 'Innity',
    patterns: [
      '^https?://as[.]innity[.]com/synd/.*',
    ],
  },
  {
    label: 'JCM',
    patterns: [
      '^https?://media[.]adfrontiers[.]com/pq.*',
    ],
  },
  {
    label: 'JustPremium',
    patterns: [
      '^https?://pre[.]ads[.]justpremium[.]com/v/.*',
    ],
  },
  {
    label: 'Kargo',
    patterns: [
      '^https?://krk[.]kargo[.]com/api/v1/bid.*',
    ],
  },
  {
    label: 'Komoona',
    patterns: [
      '^https?://bidder[.]komoona[.]com/v1/GetSBids.*',
    ],
  },
  {
    label: 'KruxLink',
    patterns: [
      '^https?://link[.]krxd[.]net/hb.*',
    ],
  },
  {
    label: 'Kumma',
    patterns: [
      '^https?://cdn[.]kumma[.]com/pb_ortb[.]js.*',
    ],
  },
  {
    label: 'Mantis',
    patterns: [
      '^https?://mantodea[.]mantisadnetwork[.]com/website/prebid.*',
    ],
  },
  {
    label: 'MarsMedia',
    patterns: [
      '^https?://bid306[.]rtbsrv[.]com:9306/bidder.*',
    ],
  },
  {
    label: 'Media.net',
    patterns: [
      '^https?://contextual[.]media[.]net/bidexchange.*',
    ],
  },
  {
    label: 'MemeGlobal',
    patterns: [
      '^https?://stinger[.]memeglobal[.]com/api/v1/services/prebid.*',
    ],
  },
  {
    label: 'MobFox',
    patterns: [
      '^https?://my[.]mobfox[.]com/request[.]php.*',
    ],
  },
  {
    label: 'NanoInteractive',
    patterns: [
      '^https?://tmp[.]audiencemanager[.]de/hb.*',
    ],
  },
  {
    label: 'OpenX',
    patterns: [
      '^https?://([^.]*.)?d[.]openx[.]net/w/1[.]0/arj.*',
      '^https?://([^.]*.)?servedbyopenx[.]com/.*',
    ],
  },
  {
    label: 'Piximedia',
    patterns: [
      '^https?://static[.]adserver[.]pm/prebid.*',
    ],
  },
  {
    label: 'Platformio',
    patterns: [
      '^https?://piohbdisp[.]hb[.]adx1[.]com.*',
    ],
  },
  {
    label: 'Pollux',
    patterns: [
      '^https?://adn[.]plxnt[.]com/prebid.*',
    ],
  },
  {
    label: 'PubGears',
    patterns: [
      '^https?://c[.]pubgears[.]com/tags.*',
    ],
  },
  {
    label: 'Pubmatic',
    patterns: [
      '^https?://ads[.]pubmatic[.]com/AdServer/js/gshowad[.]js.*',
      '^https?://([^.]*.)?gads.pubmatic[.]com/.*',
      '^https?://hbopenbid.pubmatic[.]com/.*',
    ],
  },
  {
    label: 'Pulsepoint',
    patterns: [
      '^https?://bid[.]contextweb[.]com/header/tag.*',
    ],
  },
  {
    label: 'Quantcast',
    patterns: [
      '^https?://global[.]qc[.]rtb[.]quantserve[.]com:8080/qchb.*',
    ],
  },
  {
    label: 'Rhythmone',
    patterns: [
      '^https?://tag[.]1rx[.]io/rmp/.*',
    ],
  },
  {
    label: 'Roxot',
    patterns: [
      '^https?://r[.]rxthdr[.]com.*',
    ],
  },
  {
    label: 'Rubicon',
    patterns: [
      '^https?://([^.]*.)?(fastlane|optimized-by|anvil)[.]rubiconproject[.]com/a/api.*',
      '^https?://fastlane-adv[.]rubiconproject[.]com/v1/auction/video.*',
    ],
  },
  {
    label: 'Sekindo',
    patterns: [
      '^https?://hb[.]sekindo[.]com/live/liveView[.]php.*',
    ],
  },
  {
    label: 'ShareThrough',
    patterns: [
      '^https?://btlr[.]sharethrough[.]com/header-bid/.*',
    ],
  },
  {
    label: 'Smart AdServer',
    patterns: [
      '^https?://prg[.]smartadserver[.]com/prebid.*',
    ],
  },
  {
    label: 'Sonobi',
    patterns: [
      '^https?://apex[.]go[.]sonobi[.]com/trinity[.]js.*',
    ],
  },
  {
    label: 'Sovrn',
    patterns: [
      '^https?://ap[.]lijit[.]com/rtb/bid.*',
    ],
  },
  {
    label: 'SpringServe',
    patterns: [
      '^https?://bidder[.]springserve[.]com/display/hbid.*',
    ],
  },
  {
    label: 'StickyAds',
    patterns: [
      '^https?://cdn[.]stickyadstv[.]com/mustang/mustang[.]min[.]js.*',
      '^https?://cdn[.]stickyadstv[.]com/prime-time/.*',
    ],
  },
  {
    label: 'TapSense3',
    patterns: [
      '^https?://ads04[.]tapsense[.]com/ads/headerad.*',
    ],
  },
  {
    label: 'ThoughtLeadr',
    patterns: [
      '^https?://a[.]thoughtleadr[.]com/v4/.*',
    ],
  },
  {
    label: 'TremorBid',
    patterns: [
      '^https?://([^.]*.)?ads[.]tremorhub[.]com/ad/tag.*',
    ],
  },
  {
    label: 'Trion',
    patterns: [
      '^https?://in-appadvertising[.]com/api/bidRequest.*',
    ],
  },
  {
    label: 'TripleLift',
    patterns: [
      '^https?://tlx[.]3lift[.]com/header/auction.*',
    ],
  },
  {
    label: 'TrustX',
    patterns: [
      '^https?://sofia[.]trustx[.]org/hb.*',
    ],
  },
  {
    label: 'UCFunnel',
    patterns: [
      '^https?://agent[.]aralego[.]com/header.*',
    ],
  },
  {
    label: 'Underdog Media',
    patterns: [
      '^https?://udmserve[.]net/udm/img[.]fetch.*',
    ],
  },
  {
    label: 'UnRuly',
    patterns: [
      '^https?://targeting[.]unrulymedia[.]com/prebid.*',
    ],
  },
  {
    label: 'VertaMedia',
    patterns: [
      '^https?://rtb[.]vertamedia[.]com/hb/.*',
    ],
  },
  {
    label: 'Vertoz',
    patterns: [
      '^https?://hb[.]vrtzads[.]com/vzhbidder/bid.*',
    ],
  },
  {
    label: 'WideOrbig',
    patterns: [
      '^https?://([^.]*.)?atemda[.]com/JSAdservingMP[.]ashx.*',
    ],
  },
  {
    label: 'WideSpace',
    patterns: [
      '^https?://engine[.]widespace[.]com/map/engine/hb/.*',
    ],
  },
  {
    label: 'YieldBot',
    patterns: [
      '^https?://cdn[.]yldbt[.]com/js/yieldbot[.]intent[.]js.*',
    ],
  },
  {
    label: 'YieldMo',
    patterns: [
      '^https?://ads[.]yieldmo[.]com/exchange/prebid.*',
    ],
  },
];

},{}],202:[function(require,module,exports){
// Copyright 2018 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @param {ClientRect} clientRect
 * @param {LH.Artifacts.ViewportDimensions} viewport
 * @return {boolean}
 */
function isBoxInViewport(clientRect, viewport) {
  const {innerWidth, innerHeight} = viewport;
  const {left, top, right, bottom} = clientRect;

  return left < right && top < bottom && // Non-zero area
    left < innerWidth && top < innerHeight && 0 < right && 0 < bottom;
}

/**
 * @param {ClientRect} clientRect
 * @param {LH.Artifacts.ViewportDimensions} viewport
 * @return {number}
 */
function boxViewableArea(clientRect, viewport) {
  if (!isBoxInViewport(clientRect, viewport)) return 0;

  const {innerWidth, innerHeight} = viewport;
  const {left, top, right, bottom} = clientRect;

  return (Math.min(right, innerWidth) - Math.max(left, 0)) *
    (Math.min(bottom, innerHeight) - Math.max(top, 0));
}

/**
 * Converts points (from a TraceEvent) to a ClientRect.
 * @param {number[]} points
 * @return {ClientRect}
 */
function toClientRect([left, top, width, height]) {
  return {
    left,
    top,
    width,
    height,
    right: left + width,
    bottom: top + height,
  };
}

/**
 * Checks ClientRect a overlaps ClientRect b. Note that this returns true for
 * overlapping perimeters.
 * @param {ClientRect} a
 * @param {ClientRect} b
 * @return {boolean}
 */
function overlaps(a, b) {
  const overlapX = !(a.right < b.left || b.right < a.left);
  const overlapY = !(a.bottom < b.top || b.bottom < a.top);
  return overlapX && overlapY;
}

module.exports = {
  boxViewableArea,
  isBoxInViewport,
  overlaps,
  toClientRect,
};


},{}],203:[function(require,module,exports){
// Copyright 2019 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

const BaseNode = require('lighthouse/lighthouse-core/lib/dependency-graph/base-node');
// eslint-disable-next-line no-unused-vars
const CpuNode = require('lighthouse/lighthouse-core/lib/dependency-graph/cpu-node.js');
// eslint-disable-next-line no-unused-vars
const NetworkNode = require('lighthouse/lighthouse-core/lib/dependency-graph/network-node.js');
const NetworkRecords = require('lighthouse/lighthouse-core/computed/network-records');
const {assert} = require('./asserts');
const {getNameOrTld, trimUrl} = require('../utils/resource-classification');
const {getNetworkInitiators} = require('lighthouse/lighthouse-core/computed/page-dependency-graph');
const {getTimingsByRecord} = require('../utils/network-timing');
const {isAdRequest, isAdSense, isGpt, getHeaderBidder} = require('./resource-classification');

/** @typedef {LH.Gatherer.Simulation.NodeTiming} NodeTiming */
/** @typedef {LH.TraceEvent} TraceEvent */
/** @typedef {LH.Artifacts.NetworkRequest} NetworkRequest */

/**
 * @typedef {Object} NetworkSummary
 * @property {Map<string, NetworkRequest>} requestsByUrl
 * @property {Map<string, Set<string>>} xhrEdges
 * @property {NetworkRequest[]} allRecords
 */

/**
 * @param {BaseNode.Node} root The root node of the DAG.
 * @param {(req: NetworkRequest) => boolean} isTargetRequest
 * @return {?NetworkNode}
 */
function findTargetRequest(root, isTargetRequest) {
  /** @type {?NetworkNode} */
  let firstTarget = null;
  root.traverse((node) => {
    if (node.type === BaseNode.TYPES.CPU || !isTargetRequest(node.record)) {
      return;
    }
    if (firstTarget && firstTarget.startTime < node.startTime) {
      return;
    }
    firstTarget = node;
  });
  return firstTarget;
}

/**
 * Returns all requests and CPU tasks in the loading graph of the target
 * requests.
 * @param {BaseNode.Node} root The root node of the DAG.
 * @param {(req: NetworkRequest) => boolean} isTargetRequest
 * @return {{requests: NetworkRequest[], traceEvents: TraceEvent[]}}
 */
function getTransitiveClosure(root, isTargetRequest) {
  /** @type {Set<BaseNode.Node>} */
  const closure = new Set();
  /** @type {?NetworkNode} */
  const firstTarget = findTargetRequest(root, isTargetRequest);

  /** @type {NetworkRequest[]} */
  const requests = [];
  /** @type {TraceEvent[]} */
  const traceEvents = [];

  if (firstTarget == null) {
    return {requests, traceEvents};
  }

  /** @type {BaseNode.Node[]} */ const stack = [firstTarget];

  // Search target -> root
  while (stack.length) {
    const node = stack.pop();
    if (!node || closure.has(node)) {
      continue;
    }
    closure.add(node);
    stack.push(...node.getDependencies());
  }

  // Search root -> target
  const visited = new Set();
  stack.push(...root.getDependents());
  while (stack.length) {
    const node = stack.pop();
    if (!node || visited.has(node)) {
      continue;
    }
    visited.add(node);
    if (closure.has(node)) {
      for (const n of stack) {
        closure.add(n);
      }
    }
    stack.push(...node.getDependents());
  }


  for (const node of closure) {
    if (node.type === BaseNode.TYPES.NETWORK) {
      if (node.endTime < assert(firstTarget).startTime) {
        requests.push(node.record);
      }
    } else if (node.type === BaseNode.TYPES.CPU) {
      if (node.event.ts < assert(firstTarget).startTime * 1e6) {
        traceEvents.push(node.event, ...node.childEvents);
      }
    }
  }
  return {requests, traceEvents};
}

/**
 * Checks if the given XHR request is critical.
 * @param {NetworkRequest} xhrReq
 * @param {NetworkSummary} networkSummary
 * @param {Set<NetworkRequest>} criticalRequests Known critical requests.
 * @return {boolean}
 */
function isXhrCritical(xhrReq, networkSummary, criticalRequests) {
  const edges = networkSummary.xhrEdges.get(xhrReq.url);
  if (!edges) {
    return false;
  }
  for (const {url} of criticalRequests) {
    if (edges.has(url)) {
      return true;
    }
  }
  return false;
}

/**
 * Adds all XHRs and JSONPs initiated by the given script if they are critical.
 * @param {NetworkRequest} scriptReq
 * @param {NetworkRequest} parentReq
 * @param {NetworkSummary} networkSummary
 * @param {Set<NetworkRequest>} criticalRequests Known critical requests. This
 *     method may mutate this set to add new requests.
 */
function addInitiatedRequests(
  scriptReq, parentReq, networkSummary, criticalRequests) {
  const initiatedRequests = networkSummary.allRecords
      .filter((r) => r.resourceType != undefined)
      .filter((r) => ['Script', 'XHR'].includes(r.resourceType || '') &&
          r.endTime < parentReq.startTime)
      .filter((r) => r.initiatorRequest == scriptReq ||
        getNetworkInitiators(r).includes(scriptReq.url));

  for (const initiatedReq of initiatedRequests) {
    // TODO(warrengm): Check for JSONP and Fetch requests.
    const blocking =
      initiatedReq.resourceType == 'XHR' &&
      isXhrCritical(initiatedReq, networkSummary, criticalRequests);
    if (blocking) {
      linkGraph(networkSummary, initiatedReq, criticalRequests);
    }
  }
}

/**
 * Returns the set of requests in the critical path of the target request.
 * @param {NetworkRequest[]} networkRecords
 * @param {TraceEvent[]} traceEvents
 * @param {NetworkRequest} targetRequest
 * @return {Set<NetworkRequest>}
 */
function getCriticalGraph(networkRecords, traceEvents, targetRequest) {
  const summary = buildNetworkSummary(networkRecords, traceEvents);
  const criticalRequests = new Set();
  linkGraph(summary, targetRequest, criticalRequests);
  return criticalRequests;
}

/**
 * Returns the set of requests in the critical path of the target request.
 * @param {NetworkSummary} networkSummary
 * @param {?NetworkRequest} targetRequest
 * @param {Set<NetworkRequest>=} criticalRequests
 * @return {Set<NetworkRequest>}
 */
function linkGraph(
  networkSummary, targetRequest, criticalRequests = new Set()) {
  if (!targetRequest || criticalRequests.has(targetRequest)) {
    return criticalRequests;
  }
  criticalRequests.add(targetRequest);
  const seen = new Set();
  for (let stack = targetRequest.initiator.stack; stack; stack = stack.parent) {
    for (const {url} of stack.callFrames) {
      if (seen.has(url)) continue;
      seen.add(url);

      const request = networkSummary.requestsByUrl.get(url);
      if (!request) continue;

      linkGraph(networkSummary, request, criticalRequests);

      if (request.resourceType == 'Script') {
        const scriptUrl = stack.callFrames[0].url;
        const scriptReq = networkSummary.requestsByUrl.get(scriptUrl);
        if (scriptReq) {
          addInitiatedRequests(
            scriptReq,
            targetRequest,
            networkSummary,
            criticalRequests);
        }
      }
    }
  }
  // Check the initiator request just to be sure.
  linkGraph(
    networkSummary, targetRequest.initiatorRequest || null, criticalRequests);
  return criticalRequests;
}

/**
 * @param {NetworkRequest[]} networkRecords
 * @param {TraceEvent[]} traceEvents
 * @return {NetworkSummary}
 */
function buildNetworkSummary(networkRecords, traceEvents) {
  const requestsByUrl = new Map();
  for (const req of networkRecords) {
    requestsByUrl.set(req.url, req);
  }

  const xhrEvents = traceEvents
      .filter((t) => t.name.startsWith('XHR'))
      .filter((t) => !!(t.args.data || {}).url);
  const xhrEdges = new Map();
  for (const e of xhrEvents) {
    const data = e.args.data || {};
    const edges = xhrEdges.get(data.url) || new Set();
    for (const {url} of data.stackTrace || []) {
      edges.add(url);
    }
    xhrEdges.set(data.url, edges);
  }
  return {requestsByUrl, xhrEdges, allRecords: networkRecords};
}

/**
 * @typedef {Object} SimpleRequest
 * @property {string} url
 * @property {string} nameOrTld
 * @property {string} type
 * @property {number} startTime
 * @property {number} endTime
 * @property {number} duration
 * @property {number} selfTime
 * @property {NetworkRequest} [record]
 */

/**
 * Checks if two requests are similar enough to be merged.
 * @param {SimpleRequest} r1
 * @param {SimpleRequest} r2
 * @return {boolean}
 */
function areSimilarRequests(r1, r2) {
  if (Math.max(r1.startTime, r2.startTime) > Math.min(r1.endTime, r2.endTime)) {
    return false;
  }
  if (r1.type && r2.type && r1.type != r2.type) {
    return false;
  }
  if (r1.type == 'Script') {
    return false; // Don't merge script records.
  }
  return r1.nameOrTld == r2.nameOrTld;
}

/**
 * Summarizes the given array of requests by merging overlapping requests with
 * the same url. The resulting array will be ordered by start time.
 * @param {SimpleRequest[]} requests
 * @return {SimpleRequest[]}
 */
function computeSummaries(requests) {
  // Sort requests by URL first since we will merge overlapping records with
  // the same URL below, using a similar algorithm to std::unique.
  // Within a url, we sort by time to make overlap checks easier.
  requests.sort((a, b) => {
    if (a.nameOrTld != b.nameOrTld) {
      return a.nameOrTld < b.nameOrTld ? -1 : 1;
    }
    if (a.type != b.type) {
      return a.type < b.type ? -1 : 1;
    }
    if (a.startTime != b.startTime) {
      return a.startTime < b.startTime ? -1 : 1;
    }
    return a.endTime - b.endTime;
  });
  const result = [];
  for (let i = 0; i < requests.length; i++) {
    const current = requests[i];
    let next;
    while (i < requests.length) {
      next = requests[i + 1];
      if (!next || !areSimilarRequests(next, current)) {
        break;
      }
      current.endTime = Math.max(current.endTime, next.endTime);
      current.duration = current.endTime - current.startTime;
      i++;
    }
    result.push(current);
  }
  result.sort((a, b) => a.startTime - b.startTime);
  return result;
}

/**
 * @param {SimpleRequest[]} requests A pre-sorted list of requests by start
 *   time.
 */
function computeSelfTimes(requests) {
  if (!requests.length) {
    return [];
  }
  /** @type {SimpleRequest} */
  let bottlneckRequest = assert(requests[0]);
  bottlneckRequest.selfTime = bottlneckRequest.duration;

  let scanEnd = bottlneckRequest.startTime;

  for (const current of requests) {
    if (current.endTime < scanEnd || current == bottlneckRequest) {
      // Overlaps with previous requests, skip to avoid double counting.
      continue;
    }
    const left = Math.max(scanEnd, current.startTime);
    const right = Math.min(bottlneckRequest.endTime, current.endTime);
    if (left < right) {
      // @ts-ignore selfTime is initialized elsewhere, so it won't be undefined.
      bottlneckRequest.selfTime -= (right - left);
    }
    scanEnd = Math.max(scanEnd, right);
    if (current.endTime > bottlneckRequest.endTime) {
      current.selfTime = current.endTime - left;
      bottlneckRequest = current;
    }
  }
}

// TODO(warrengm): Memoize this function?
/**
 * Returns all requests in the loading graph of ads. This will return the empty
 * set if no ad requests are present.
 * @param {LH.Trace} trace
 * @param {LH.DevtoolsLog} devtoolsLog
 * @param {LH.Audit.Context} context
 * @return {Promise<SimpleRequest[]>}
 */
async function computeAdRequestWaterfall(trace, devtoolsLog, context) {
  const networkRecords = await NetworkRecords.request(devtoolsLog, context);

  const maybeFirstAdRequest = networkRecords.find(isAdRequest);
  if (maybeFirstAdRequest == null) {
    return Promise.resolve([]);
  }
  const criticalRequests = new Set();
  const firstAdRequest = assert(maybeFirstAdRequest);
  const tagRequests = networkRecords.filter((r) =>
    isGpt(r.url) || isAdSense(r.url));
  const bidRequests = networkRecords.filter((r) =>
    !!getHeaderBidder(r.url) && r.endTime <= firstAdRequest.startTime);
  const summary = buildNetworkSummary(networkRecords, trace.traceEvents);
  for (const req of [firstAdRequest, ...bidRequests, ...tagRequests]) {
    linkGraph(summary, req, criticalRequests);
  }

  const REQUEST_TYPES = new Set([
    'Script', 'XHR', 'Fetch', 'EventStream', 'Document', undefined]);
  const waterfall = Array.from(criticalRequests)
      .filter((r) => r.endTime < firstAdRequest.startTime)
      .filter((r) => REQUEST_TYPES.has(r.resourceType))
      .filter((r) => r.mimeType != 'text/css');

  /** @type {Map<NetworkRequest, NodeTiming>} */
  const timingsByRecord =
      await getTimingsByRecord(trace, devtoolsLog, context);
  const timedWaterfall = waterfall.map((req) => {
    const {startTime, endTime} = timingsByRecord.get(req) || req;
    return {
      startTime,
      endTime,
      duration: endTime - startTime,
      selfTime: 0, // Computed below.
      url: trimUrl(req.url),
      nameOrTld: getNameOrTld(req.url),
      type: req.resourceType,
      record: req,
    };
  });
  const result = computeSummaries(timedWaterfall);
  computeSelfTimes(result);
  return result;
}

module.exports = {
  getTransitiveClosure,
  getCriticalGraph,
  computeAdRequestWaterfall,
};

},{"../utils/network-timing":204,"../utils/resource-classification":206,"./asserts":200,"./resource-classification":206,"lighthouse/lighthouse-core/computed/network-records":40,"lighthouse/lighthouse-core/computed/page-dependency-graph":41,"lighthouse/lighthouse-core/lib/dependency-graph/base-node":86,"lighthouse/lighthouse-core/lib/dependency-graph/cpu-node.js":87,"lighthouse/lighthouse-core/lib/dependency-graph/network-node.js":88}],204:[function(require,module,exports){
// Copyright 2018 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

const AdLanternMetric = require('../computed/ad-lantern-metric');
// @ts-ignore
const LoadSimulator = require('lighthouse/lighthouse-core/computed/load-simulator');
const NetworkRecords = require('lighthouse/lighthouse-core/computed/network-records');
const PageDependencyGraph = require('lighthouse/lighthouse-core/computed/page-dependency-graph');
const {isAdRequest, isBidRequest, isImplTag, isImpressionPing} = require('./resource-classification');
const {URL} = require('url');

/** @typedef {LH.Artifacts.NetworkRequest} NetworkRequest */
/** @typedef {LH.Gatherer.Simulation.NodeTiming} NodeTiming */

/* eslint-disable max-len */
/** @typedef {import('lighthouse/lighthouse-core/lib/dependency-graph/base-node.js').Node} Node */
/** @typedef {import('lighthouse/lighthouse-core/lib/dependency-graph/network-node.js')} NetworkNode */
/* eslint-enable max-len */

/**
 * Returns end time of tag load (s) relative to system boot.
 * @param {LH.Artifacts.NetworkRequest[]} networkRecords
 * @return {number}
 */
function getTagEndTime(networkRecords) {
  const tagRecord = networkRecords.find(
    (record) => isImplTag(new URL(record.url)));
  return tagRecord ? tagRecord.endTime : -1;
}

/**
 * Returns start time of first ad request (s) relative to system boot.
 * @param {LH.Artifacts.NetworkRequest[]} networkRecords
 * @return {number}
 */
function getAdStartTime(networkRecords) {
  const firstAdRecord = networkRecords.find(isAdRequest);
  return firstAdRecord ? firstAdRecord.startTime : -1;
}

/**
 * Returns start time of first bid request (s) relative to system boot.
 * @param {LH.Artifacts.NetworkRequest[]} networkRecords
 * @return {number}
 */
function getBidStartTime(networkRecords) {
  const firstBidRecord = networkRecords.find(isBidRequest);
  return firstBidRecord ? firstBidRecord.startTime : -1;
}

/**
 * Returns start time of first ad impression relative to system boot.
 * @param {LH.Artifacts.NetworkRequest[]} networkRecords
 * @return {number}
 */
function getImpressionStartTime(networkRecords) {
  const firstImpressionRecord = networkRecords.find(
    (record) => isImpressionPing(record.url));
  return firstImpressionRecord ? firstImpressionRecord.startTime : -1;
}

/**
 * Returns start time of page request (s) relative to system boot.
 * @param {LH.Artifacts.NetworkRequest[]} networkRecords
 * @param {number=} defaultValue
 * @return {number}
 */
function getPageStartTime(networkRecords, defaultValue = -1) {
  const firstSuccessRecord = networkRecords.find(
    (record) => record.statusCode == 200);
  return firstSuccessRecord ? firstSuccessRecord.startTime : defaultValue;
}

/**
 * Returns start time of page response (s) relative to system boot.
 * @param {LH.Artifacts.NetworkRequest[]} networkRecords
 * @param {number=} defaultValue
 * @return {number}
 */
function getPageResponseTime(networkRecords, defaultValue = -1) {
  const firstSuccessRecord = networkRecords.find(
    (record) => record.statusCode == 200);
  return firstSuccessRecord ?
    firstSuccessRecord.responseReceivedTime : defaultValue;
}

/**
 * @param {LH.Trace} trace
 * @param {LH.DevtoolsLog} devtoolsLog
 * @param {LH.Audit.Context} context
 * @return {Promise<Map<NetworkRequest, NodeTiming>>}
 */
async function getTimingsByRecord(trace, devtoolsLog, context) {
  /** @type {Map<NetworkRequest, NodeTiming>} */
  const timingsByRecord = new Map();
  const networkRecords = await NetworkRecords.request(devtoolsLog, context);
  if (context.settings.throttlingMethod == 'simulate') {
    /** @type {NetworkNode} */
    const documentNode =
      // @ts-ignore Property 'request' does not appear on PageDependencyGraph
      await PageDependencyGraph.request({trace, devtoolsLog}, context);
    const releventGraph = AdLanternMetric.getOptimisticGraph(documentNode);
    const simulator = await LoadSimulator.request(
      {devtoolsLog, settings: context.settings}, context);
    const {nodeTimings} = simulator.simulate(releventGraph, {});
    for (const [{record}, timing] of nodeTimings.entries()) {
      if (!record) continue;
      timingsByRecord.set(record, timing);
    }
  } else {
    const pageStartTime = getPageStartTime(networkRecords);
    for (const record of networkRecords) {
      timingsByRecord.set(record, {
        startTime: (record.startTime - pageStartTime) * 1000,
        endTime: (record.endTime - pageStartTime) * 1000,
        duration: (record.endTime - record.startTime) * 1000,
      });
    }
  }
  return timingsByRecord;
}

/**
 * @param {LH.TraceEvent} e A trace event.
 * @return {string|undefined} A script URL, if applicable.
 */
function getScriptUrl(e) {
  if (!e.args.data) {
    return undefined;
  }
  if (!['EvaluateScript', 'FunctionCall'].includes(e.name)) {
    return undefined;
  }
  if (e.args.data.url) {
    return e.args.data.url;
  }
  if (e.args.data.stackTrace) {
    return e.args.data.stackTrace[0].url;
  }
  return undefined;
}

/**
 * Returns the load time for each script based on when the script executed. This
 * is particularly important when network timing does not reflect execution
 * time (for example if the script was preloaded).
 * @param {LH.Trace} trace
 * @param {LH.DevtoolsLog} devtoolsLog
 * @param {LH.Audit.Context} context
 * @return {Promise<Map<string, number>>} A map from script URL to evaluation
 *   time.
 */
async function getScriptEvaluationTimes(trace, devtoolsLog, context) {
  const networkRecords = await NetworkRecords.request(devtoolsLog, context);
  const pageStartTime = getPageStartTime(networkRecords) * 1000;
  /** @type {Map<string, number>} */
  const rawTimes = new Map();
  for (const e of trace.traceEvents) {
    const script = getScriptUrl(e);
    if (!script) {
      continue;
    }
    const time = (e.ts / 1000) - pageStartTime;
    // @ts-ignore The get() call won't return undefined.
    if (!rawTimes.has(script) || rawTimes.get(script) > time) {
      rawTimes.set(script, time);
    }
  }
  if (context.settings.throttlingMethod !== 'simulate') {
    return rawTimes;
  }
  // Offset each timing by network timings to account for simulation.
  const timingsByRecord = await getTimingsByRecord(trace, devtoolsLog, context);
  /** @type {Map<string, number>} */
  const simulatedTimes = new Map();
  for (const [req, timing] of timingsByRecord.entries()) {
    const scriptEvalTime = rawTimes.get(req.url);
    if (!scriptEvalTime) {
      continue;
    }
    if (simulatedTimes.has(req.url)) {
      continue;
    }
    const unsimulatedNetworkTime = req.startTime * 1000 - pageStartTime;
    const simulatedNetworkTime = timing.endTime;

    const cpuFactor = context.settings.throttling.cpuSlowdownMultiplier;
    // Any time between script eval and network response is due to cpu.
    const unsimulatedCpuTime = scriptEvalTime - unsimulatedNetworkTime;
    const simulatedCpuTime = cpuFactor * unsimulatedCpuTime;
    // Update results.
    simulatedTimes.set(req.url, simulatedNetworkTime + simulatedCpuTime);
  }
  return simulatedTimes;
}

module.exports = {
  getTagEndTime,
  getImpressionStartTime,
  getAdStartTime,
  getBidStartTime,
  getPageStartTime,
  getPageResponseTime,
  getScriptUrl,
  getTimingsByRecord,
  getScriptEvaluationTimes,
};

},{"../computed/ad-lantern-metric":192,"./resource-classification":206,"lighthouse/lighthouse-core/computed/load-simulator":13,"lighthouse/lighthouse-core/computed/network-records":40,"lighthouse/lighthouse-core/computed/page-dependency-graph":41,"url":"url"}],205:[function(require,module,exports){
// Copyright 2019 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// @ts-ignore
const CacheHeaders = require('lighthouse/lighthouse-core/audits/byte-efficiency/uses-long-cache-ttl');
// @ts-ignore
const {parse: parseCacheControl} = require('@tusbar/cache-control');

/**
 * @param {LH.Artifacts.NetworkRequest} req
 * @param {string} header
 * @return {{name: string, value: string}|undefined}
 */
function getHeader(req, header) {
  const lowerHeader = header.toLowerCase();
  return (req.responseHeaders || []).find(
    (h) => h.name.toLowerCase() === lowerHeader);
}

/**
 * Checks if a record is cacheable by clients.
 * @param {LH.Artifacts.NetworkRequest} req
 * @return {boolean}
 */
function isCacheable(req) {
  // Check resource type before headers.
  if (!CacheHeaders.isCacheableAsset(req)) {
    return false;
  }
  const cacheControlHeader = getHeader(req, 'cache-control');
  if (cacheControlHeader) {
    try {
      const cacheControl = parseCacheControl(cacheControlHeader.value);
      if (cacheControl.noStore || cacheControl.noCache ||
          cacheControl.maxAge === 0) {
        return false;
      }
    } catch (e) {/* Ignore parsing errors or missing headers. */}
    return true;
  }
  // Check for other cacheable headers.
  return !!getHeader(req, 'expires') || !!getHeader(req, 'last-modified');
}

module.exports = {
  isCacheable,
};

},{"@tusbar/cache-control":125,"lighthouse/lighthouse-core/audits/byte-efficiency/uses-long-cache-ttl":"../audits/byte-efficiency/uses-long-cache-ttl"}],206:[function(require,module,exports){
// Copyright 2018 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

const bidderPatterns = require('./bidder-patterns');
const thirdPartyWeb = require('lighthouse/lighthouse-core/lib/third-party-web');
const {isCacheable} = require('../utils/network');
const {URL} = require('url');

/**
 * Converts the given url to a URL, if it's not already a URL. Otherwise returns
 * the same URL object (not a copy).
 * This function is guaranteed not to throw. Be sure to validate URL format
 * before calling this method if needed.
 * @param {URL|string} urlOrStr
 * @return {URL}
 */
function toURL(urlOrStr) {
  let url;
  try {
    url = (typeof urlOrStr === 'string') ? new URL(urlOrStr) : urlOrStr;
  } catch (e) {
    url = new URL('http://_'); // error
  }
  return url;
}

/**
 * Checks if the url is from a Google ads host.
 * @param {URL|string} url
 * @return {boolean}
 */
function isGoogleAds(url) {
  url = toURL(url);
  return /(^|\.)(doubleclick.net|google(syndication|tagservices).com)$/
      .test(url.hostname);
}

/**
 * Checks if the url is loading an AdSense script.
 * @param {URL|string} url
 * @return {boolean}
 */
function isAdSenseTag(url) {
  url = toURL(url);
  const matchesHost = url.host === 'pagead2.googlesyndication.com';
  const matchesPath =
      [
        '/pagead/js/adsbygoogle.js',
        '/pagead/show_ads.js',
      ].includes(url.pathname);
  return matchesHost && matchesPath;
}

/**
 * Checks if the url is loading an AdSense script.
 * @param {URL|string} url
 * @return {boolean}
 */
function isAdSenseImplTag(url) {
  url = toURL(url);
  const matchesHost = url.host === 'pagead2.googlesyndication.com';
  const matchesPath =
      /(^\/pagead\/js\/.*\/show_ads_impl.*?\.js)/.test(url.pathname);
  return matchesHost && matchesPath;
}

/**
 * Checks if the url is loading an AdSense loader or impl script.
 * @param {URL|string} url
 * @return {boolean}
 */
function isAdSense(url) {
  url = toURL(url);
  return isAdSenseTag(url) || isAdSenseImplTag(url);
}

/**
 * Checks if a network request is an AdSense ad request.
 * @param {LH.Artifacts.NetworkRequest} request
 * @return {boolean}
 */
function isAdSenseAdRequest(request) {
  if (!request) return false;
  const url = new URL(request.url);
  return (
    url.pathname === '/pagead/ads' &&
    url.host === 'googleads.g.doubleclick.net'
  );
}

/**
 * @param {Artifacts['IFrameElement']} iframe
 * @return {boolean}
 */
function isAdSenseIframe(iframe) {
  return /(^aswift_\d+)/.test(iframe.id); // (^google_ads_frame) is cross-domain
}

/**
 * Checks if the url is an impression ping.
 * @param {URL|string} url
 * @return {boolean}
 */
function isImpressionPing(url) {
  const {host, pathname} = toURL(url);
  return (
    [
      'securepubads.g.doubleclick.net',
      'googleads4.g.doubleclick.net',
    ].includes(host) &&
    ['/pcs/view', '/pagead/adview'].includes(pathname)
  );
}

/**
 * Checks if the url is loading a gpt.js script.
 * @param {URL|string} url
 * @return {boolean}
 */
function isGptTag(url) {
  const {host, pathname} = toURL(url);
  const matchesHost = [
    'www.googletagservices.com',
    'pagead2.googlesyndication.com',
    'securepubads.g.doubleclick.net'].includes(host);
  const matchesPath =
    ['/tag/js/gpt.js', '/tag/js/gpt_mobile.js'].includes(pathname);
  return ( matchesHost && matchesPath );
}

/**
 * Checks if the url is loading an amp-ad-{version}.js script.
 * @param {URL|string} url
 * @return {boolean}
 */
function isAMPTag(url) {
  const {host, pathname} = toURL(url);
  const matchesHost = ['cdn.ampproject.org'].includes(host);
  const matchesPath =
    ['/v0/amp-ad-0.1.js'].includes(pathname);

  return matchesHost && matchesPath;
}

/**
 * Checks if the url is for pubads implementation tag.
 * @param {URL|string} url
 * @return {boolean}
 */
function isGptImplTag(url) {
  return isGoogleAds(url) &&
    /(^\/gpt\/pubads_impl([a-z_]*)((?<!rendering)_)\d+\.js)/
        .test(toURL(url).pathname);
}

/**
 * Checks if the url is for AMP implementation tag.
 * @param {URL|string} url
 * @return {boolean}
 */
function isAMPImplTag(url) {
  return (
    /^\/[a-z_]*\/\d+\/v0\/amp-ad-network-doubleclick-impl-0.1.js/
        .test(toURL(url).pathname)
  );
}

/**
 * Checks if the url is loading a gpt.js or pubads_impl_*.js script.
 * @param {URL|string} url
 * @return {boolean}
 */
function isGpt(url) {
  url = toURL(url);
  return isGptTag(url) || isGptImplTag(url);
}

/**
 * Checks if the url is loading amp-ad script.
 * @param {URL} url
 * @return {boolean}
 */
function isAMP(url) {
  return isAMPTag(url) || isAMPImplTag(url);
}

/**
 * Checks if a network request is a GPT ad request.
 * @param {LH.Artifacts.NetworkRequest} request
 * @return {boolean}
 */
function isGptAdRequest(request) {
  if (!request) return false;
  const url = new URL(request.url);
  return (
    url.pathname === '/gampad/ads' &&
    request.resourceType === 'XHR' &&
    isGoogleAds(request.url)
  );
}


/**
 * Checks if a network request is an AMP ad request.
 * @param {LH.Artifacts.NetworkRequest} request
 * @return {boolean}
 */
function isAMPAdRequest(request) {
  if (!request) return false;
  const url = new URL(request.url);
  return (
    url.pathname === '/gampad/ads' &&
    url.host === 'securepubads.g.doubleclick.net' &&
    ( request.resourceType === 'Fetch' )
  );
}

/**
 * @param {Artifacts['IFrameElement']} iframe
 * @return {boolean}
 */
function isGptIframe(iframe) {
  return /(^google_ads_iframe_)/.test(iframe.id);
}

/**
 * Checks if the url is loading an AdSense or GPT loader script.
 * @param {URL} url
 * @return {boolean}
 */
function isAdTag(url) {
  return isAdSenseTag(url) || isGptTag(url) || isAMPTag(url);
}

/**
 * Checks if the url is loading an AdSense or GPT loader or impl script.
 * @param {URL} url
 * @return {boolean}
 */
function isAdScript(url) {
  return isAdSense(url) || isGpt(url) || isAMP(url);
}

/**
 * Checks if a network request is an AdSense or GPT ad request.
 * @param {LH.Artifacts.NetworkRequest} request
 * @return {boolean}
 */
function isAdRequest(request) {
  return isAdSenseAdRequest(request) ||
    isGptAdRequest(request) ||
    isAMPAdRequest(request);
}

/**
 * Checks if an iframe is an AdSense or GPT iframe.
 * @param {Artifacts['IFrameElement']} iframe
 * @return {boolean}
 */
function isAdIframe(iframe) {
  return isAdSenseIframe(iframe) || isGptIframe(iframe);
}

/**
 * Checks if the url is loading either the AdSense or GPT impl script.
 * @param {URL|string} url
 * @return {boolean}
 */
function isImplTag(url) {
  return isAdSenseTag(url) || isGptImplTag(url) || isAMPImplTag(url);
}

/**
 * Checks if str contains at least one provided substring.
 * @param {string} str
 * @param {Array<string>} substrings
 * @return {boolean}
 */
function containsAnySubstring(str, substrings) {
  return substrings.some((substring) => str.includes(substring));
}

/**
 * Checks if the url has an impression path.
 * @param {URL} url
 * @return {boolean}
 */
function hasImpressionPath(url) {
  return url.pathname === '/pcs/view' ||
      url.pathname === '/pagead/adview';
}

/**
 * Returns header bidder or undefined if not a bid.
 * @param {string} url
 * @return {string|undefined}
 */
function getHeaderBidder(url) {
  for (const def of bidderPatterns) {
    for (const pattern of def.patterns) {
      if (new RegExp(pattern).test(url)) {
        return def.label;
      }
    }
  }
  return undefined;
}

/**
 * Checks whether the given request is a bid request or related to bidding (e.g.
 * a bidding script).
 * @param {LH.Artifacts.NetworkRequest|string} requestOrUrl
 * @return {boolean}
 */
function isBidRelatedRequest(requestOrUrl) {
  return !!getHeaderBidder(
    typeof requestOrUrl == 'string' ? requestOrUrl : requestOrUrl.url);
}

/**
 * Checks the request to see if it meets requirements for bid requests.
 * @param {LH.Artifacts.NetworkRequest} req
 * @return {boolean}
 */
function isPossibleBidRequest(req) {
  return (req.resourceSize == null || req.resourceSize > 0) &&
      (req.resourceType != 'Image') &&
      !isCacheable(req);
}

/**
 * Checks the request to see if it's a bid request.
 * @param {LH.Artifacts.NetworkRequest} req
 * @return {boolean}
 */
function isBidRequest(req) {
  return isBidRelatedRequest(req) && isPossibleBidRequest(req);
}

/**
 * @param {LH.Artifacts.NetworkRequest} request
 * @return {boolean}
 */
function isStaticRequest(request) {
  // Use initiator type to determine if tag was loaded statically.
  return ['parser', 'preload', 'other'].includes(request.initiator.type);
}

/**
 * Removes the query string from the URL.
 * @param {string} url
 * @return {string}
 */
function trimUrl(url) {
  const u = new URL(url);
  const PATH_MAX = 60;
  const path = u.pathname.length > PATH_MAX ?
    u.pathname.substr(0, PATH_MAX) + '...' : u.pathname;
  return u.origin + path;
}

/**
 * @param {string} url
 * @return {string}
 */
function getNameOrTld(url) {
  const bidderLabel = getHeaderBidder(url);
  if (bidderLabel) {
    return bidderLabel;
  }
  if (isGpt(url)) {
    return 'GPT';
  }
  if (isAdSense(url)) {
    return 'AdSense';
  }
  if (isAMPTag(url)) {
    return 'AMP tag';
  }
  const thirdPartyEntity = thirdPartyWeb.getEntity(url);
  if (thirdPartyEntity) {
    return thirdPartyEntity.name;
  }
  const {host} = new URL(url);
  const [tld = ''] = host.match(/([^.]*(\.[a-z]{2,3}){1,2})$/) || [];
  return tld || host;
}

module.exports = {
  isGoogleAds,
  isGptAdRequest,
  isImpressionPing,
  isGpt,
  isAdSense,
  isAdSenseTag,
  isAdSenseImplTag,
  isAdSenseAdRequest,
  isAdSenseIframe,
  isGptTag,
  isGptImplTag,
  isGptIframe,
  isAdTag,
  isAdScript,
  isAdRequest,
  isAdIframe,
  isImplTag,
  containsAnySubstring,
  hasImpressionPath,
  getHeaderBidder,
  isBidRelatedRequest,
  isBidRequest,
  isStaticRequest,
  toURL,
  trimUrl,
  getNameOrTld,
  isAMPTag,
  isAMPAdRequest,
};

},{"../utils/network":205,"./bidder-patterns":201,"lighthouse/lighthouse-core/lib/third-party-web":116,"url":"url"}],207:[function(require,module,exports){
// Copyright 2019 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.


/**
 * Returns the attributable script for this long task.
 * @param {LH.Artifacts.TaskNode} longTask
 * @param {Set<string>=} knownScripts
 * @return {string}
 */
function getAttributableUrl(longTask, knownScripts = new Set()) {
  const scriptUrl = longTask.attributableURLs.find(
    /** @param {string} url */ (url) => knownScripts.has(url));
  const fallbackUrl = longTask.attributableURLs[0];
  const attributableUrl = scriptUrl || fallbackUrl;

  if (attributableUrl) {
    return attributableUrl;
  }
  let maxChildDuration = 50; // Filter children with duration < 50ms.
  let childUrl = '';
  for (const child of longTask.children) {
    const url = getAttributableUrl(child, knownScripts);
    if (url && child.duration > maxChildDuration) {
      childUrl = url;
      maxChildDuration = child.duration;
    }
  }
  return childUrl;
}

module.exports = {getAttributableUrl};

},{}],208:[function(require,module,exports){
const stackPacks = [
  require('./packs/wordpress.js'),
  require('./packs/drupal.js'),
  require('./packs/react.js'),
  require('./packs/angular.js'),
  require('./packs/amp.js'),
  require('./packs/magento.js'),
  require('./packs/joomla.js'),
  require('./packs/octobercms.js'),
];

module.exports = stackPacks;

},{"./packs/amp.js":209,"./packs/angular.js":210,"./packs/drupal.js":211,"./packs/joomla.js":212,"./packs/magento.js":213,"./packs/octobercms.js":214,"./packs/react.js":215,"./packs/wordpress.js":216}],209:[function(require,module,exports){

const icon = `data:image/svg+xml,%3Csvg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 256 256"%3E%3Cpath d="M171.887 116.28l-53.696 89.36h-9.728l9.617-58.227-30.2.047a4.852 4.852 0 01-4.855-4.855c0-1.152 1.07-3.102 1.07-3.102l53.52-89.254 9.9.043-9.86 58.317 30.413-.043a4.852 4.852 0 014.855 4.855c0 1.088-.427 2.044-1.033 2.854l.004.004zM128 0C57.306 0 0 57.3 0 128s57.306 128 128 128 128-57.306 128-128S198.7 0 128 0z" fill="%230379c4" fill-rule="evenodd"/%3E%3C/svg%3E`;

const UIStrings = {
  /** Additional description of a Lighthouse audit that tells the user how they can improve image loading by using WebP in the context of AMP. This is displayed after a user expands the section to see more. No character length limits. Links in (parenthesis) become link texts to additional documentation. */
  'modern-image-formats': 'Consider displaying all [`amp-img`](https://amp.dev/documentation/components/amp-img/?format=websites) components in WebP formats while specifying an appropriate fallback for other browsers. [Learn more](https://amp.dev/documentation/components/amp-img/#example:-specifying-a-fallback-image).',
  /** Additional description of a Lighthouse audit that tells the user how images are automatically lazy loaded for the AMP framewok. This is displayed after a user expands the section to see more. No character length limits. Links in (parenthesis) become link texts to additional documentation. */
  'offscreen-images': 'Ensure that you are using [`amp-img`](https://amp.dev/documentation/components/amp-img/?format=websites) for images to automatically lazy-load. [Learn more](https://amp.dev/documentation/guides-and-tutorials/develop/media_iframes_3p/?format=websites#images).',
  /** Additional description of a Lighthouse audit that tells the user how they can improve performance by reducing the amount of render blocking resources present on their page in the context of the AMP framework. This is displayed after a user expands the section to see more. No character length limits. Links in (parenthesis) become link texts to additional documentation. */
  'render-blocking-resources': 'Use tools such as [AMP Optimizer](https://github.com/ampproject/amp-toolbox/tree/master/packages/optimizer) to [server-side render AMP layouts](https://amp.dev/documentation/guides-and-tutorials/optimize-and-measure/server-side-rendering/).',
  /** Additional description of a Lighthouse audit that tells the user how they can improve performance by ensuring all the CSS written is supported by the AMP framework. This is displayed after a user expands the section to see more. No character length limits. Links in (parenthesis) become link texts to additional documentation. */
  'unminified-css': 'Refer to the [AMP documentation](https://amp.dev/documentation/guides-and-tutorials/develop/style_and_layout/style_pages/) to ensure all styles are supported.',
  /** Additional description of a Lighthouse audit that tells the user how they can improve performance by using a runtime-managed animated image in the context of the AMP framework. This is displayed after a user expands the section to see more. No character length limits. Links in (parenthesis) become link texts to additional documentation. */
  'efficient-animated-content': 'For animated content, use [`amp-anim`](https://amp.dev/documentation/components/amp-anim/) to minimize CPU usage when the content is offscreen.',
  /** Additional description of a Lighthouse audit that tells the user how they can improve performance by using responsive images in the context of the AMP framework. This is displayed after a user expands the section to see more. No character length limits. Links in (parenthesis) become link texts to additional documentation. */
  'uses-responsive-images': 'The [`amp-img`](https://amp.dev/documentation/components/amp-img/?format=websites) component supports the [`srcset`](https://web.dev/use-srcset-to-automatically-choose-the-right-image/) attribute to specify which image assets to use based on the screen size. [Learn more](https://amp.dev/documentation/guides-and-tutorials/develop/style_and_layout/art_direction/).',
};

module.exports = {
  id: 'amp',
  title: 'AMP',
  icon,
  UIStrings,
};

},{}],210:[function(require,module,exports){

const icon = `data:image/svg+xml,%3Csvg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 250 250"%3E%3Cpath fill="%23dd0031" d="M125 30L31.9 63.2l14.2 123.1L125 230l78.9-43.7 14.2-123.1z"/%3E%3Cpath fill="%23c3002f" d="M125 30v22.2-.1V230l78.9-43.7 14.2-123.1L125 30z"/%3E%3Cpath d="M125 52.1L66.8 182.6h21.7l11.7-29.2h49.4l11.7 29.2H183L125 52.1zm17 83.3h-34l17-40.9 17 40.9z" fill="%23fff"/%3E%3C/svg%3E`;

const UIStrings = {
  /** Additional description of a Lighthouse audit that tells the user how they can improve site loading performance by reducing the total bytes delivered by their page in the context of the Angular framework. This is displayed after a user expands the section to see more. No character length limits. Links in (parenthesis) become link texts to additional documentation. */
  'total-byte-weight': 'Apply [route-level code splitting](https://web.dev/route-level-code-splitting-in-angular/) to minimize the size of your JavaScript bundles. Also, consider precaching assets with the [Angular service worker](https://web.dev/precaching-with-the-angular-service-worker/).',
  /** Additional description of a Lighthouse audit that tells the user how they can improve performance by minifying their CSS and JS files in the context of the Angular framework. This is displayed after a user expands the section to see more. No character length limits. Links in (parenthesis) become link texts to additional documentation. */
  'unminified-warning': 'If you are using Angular CLI, ensure that builds are generated in production mode. [Learn more](https://angular.io/guide/deployment#enable-runtime-production-mode).',
  /** Additional description of a Lighthouse audit that tells the user how they can improve performance by removing unused Javascript files in the context of the Angular framework. This is displayed after a user expands the section to see more. No character length limits. Links in (parenthesis) become link texts to additional documentation. */
  'unused-javascript': 'If you are using Angular CLI, include source maps in your production build to inspect your bundles. [Learn more](https://angular.io/guide/deployment#inspect-the-bundles).',
  /** Additional description of a Lighthouse audit that tells the user how they can use responsive images in the context of the Angular framework. This is displayed after a user expands the section to see more. No character length limits. Links in (parenthesis) become link texts to additional documentation. */
  'uses-responsive-images': 'Consider using the `BreakpointObserver` utility in the Component Dev Kit (CDK) to manage image breakpoints. [Learn more](https://material.angular.io/cdk/layout/overview).',
  /** Additional description of a Lighthouse audit that tells the user how they can use preload to improve performance in the context of the Angular framework. This is displayed after a user expands the section to see more. No character length limits. Links in (parenthesis) become link texts to additional documentation. */
  'uses-rel-preload': 'Preload routes ahead of time to speed up navigation. [Learn more](https://web.dev/route-preloading-in-angular/).',
  /** Additional description of a Lighthouse audit that tells the user and *how* they should reduce the size of the web page's DOM in the context of the Angular framework. Links in (parenthesis) become link texts to additional documentation. */
  'dom-size': 'Consider virtual scrolling with the Component Dev Kit (CDK) if very large lists are being rendered. [Learn more](https://web.dev/virtualize-lists-with-angular-cdk/).',
};

module.exports = {
  id: 'angular',
  title: 'Angular',
  icon,
  UIStrings,
}

},{}],211:[function(require,module,exports){

const icon = `data:image/svg+xml,%3Csvg viewBox="0 0 681.167 778.583" xmlns="http://www.w3.org/2000/svg"%3E%3Cpath style="fill:%2300598E" d="M510.167 144.833c-39.75-24.75-77.25-34.5-114.75-59.25c-23.25-15.75-55.5-53.25-82.5-85.5c-5.25 51.75-21 72.75-39 87.75c-38.25 30-62.25 39-95.25 57c-27.75 14.25-178.5 104.25-178.5 297.75s162.75 336 343.5 336s337.5-131.25 337.5-330S534.167 159.833 510.167 144.833z" /%3E%3Cpath style="fill:%23FFF" d="M449.25 610.5c12 0 24.75 0.75 33.75 6.75s14.25 19.5 17.25 27s0 12-6 15c-5.25 3-6 1.5-11.25-8.25s-9.75-19.5-36-19.5s-34.5 9-47.25 19.5s-17.25 14.25-21.75 8.25s-3-12 5.25-19.5s21.75-19.5 34.5-24.75S437.25 610.5 449.25 610.5L449.25 610.5z" /%3E%3Cpath style="fill:%23FFF" d="M324.75 696c15 12 37.5 21.75 85.5 21.75S492 704.25 507 693c6.75-5.25 9.75-0.75 10.5 2.25s2.25 7.5-3 12.75c-3.75 3.75-38.25 27.75-78.75 31.5s-95.25 6-128.25-24c-5.25-5.25-3.75-12.75 0-15.75s6.75-5.25 11.25-5.25S322.5 694.5 324.75 696L324.75 696z" /%3E%3Cpath style="fill:%230073BA" d="M141 639c57-0.75 67.5-10.5 117.75-33c271.5-121.5 321.75-232.5 331.5-258s24-66.75 9-112.5c-2.896-8.832-5.006-15.924-6.53-21.63c-36.079-40.343-71.898-62.357-82.72-69.12c-39-24.75-77.25-34.5-114.75-59.25c-23.25-15-55.5-53.25-82.5-85.5c-5.25 51.75-20.25 73.5-39 87.75c-38.25 30-62.25 39-95.25 57C150.75 159.75 0 249 0 442.5c0 61.78 16.593 118.361 45.063 166.766L52.5 609C68.25 623.25 93 639.75 141 639z" /%3E%3Cpath style="fill:%23004975" d="M510 144.75c-39-24.75-77.25-34.5-114.75-59.25c-23.25-15-55.5-53.25-82.5-85.5c-5.25 51.75-20.25 73.5-39 87.75c-38.25 30-62.25 39-95.25 57C150.75 159.75 0 249 0 442.5c0 61.78 16.593 118.361 45.063 166.766C105.763 712.467 220.46 778.5 343.5 778.5c180.75 0 337.5-131.25 337.5-330c0-109.146-44.332-185.488-88.28-234.63C556.641 173.527 520.82 151.513 510 144.75z M601.164 232.547c49.242 61.564 74.211 134.221 74.211 215.953c0 47.428-9.033 92.23-26.849 133.165c-16.9 38.831-41.236 73.233-72.333 102.254c-61.47 57.364-144.107 88.956-232.693 88.956c-43.826 0-86.832-8.371-127.824-24.882c-40.263-16.217-76.547-39.438-107.843-69.02C41.923 616.678 5.625 532.696 5.625 442.5c0-80.336 26.076-151.72 77.503-212.167c39.289-46.18 81.655-71.774 98.047-80.634c7.958-4.341 15.423-8.172 22.643-11.877c22.63-11.615 44.005-22.586 73.404-45.645c15.677-11.914 32.377-30.785 39.489-78.702c24.774 29.466 53.522 62.579 75.49 76.752c19.5 12.87 39.501 21.888 58.844 30.61c18.298 8.25 37.219 16.781 55.942 28.663c0.031 0.021 0.702 0.438 0.702 0.438C562.421 184.11 591.581 220.566 601.164 232.547z" /%3E%3Cpath style="fill:%2393C5E4" d="M316.5 15c10.5 30.75 9 46.5 9 53.25S321.75 93 309.75 102c-5.25 3.75-6.75 6.75-6.75 7.5c0 3 6.75 5.25 6.75 12c0 8.25-3.75 24.75-43.5 64.5s-96.75 75-141 96.75S60 303 54 292.5s2.25-33.75 30-64.5s115.5-75 115.5-75L309 76.5l6-29.25" /%3E%3Cpath style="fill:%23FFF" d="M316.5 14.25c-6.75 49.5-21.75 64.5-42 80.25c-33.75 25.5-66.75 41.25-74.25 45c-19.5 9.75-90 48.75-126.75 105c-11.25 17.25 0 24 2.25 25.5s27.75 4.5 82.5-28.5S237 189 267.75 156.75c16.5-17.25 18.75-27 18.75-31.5c0-5.25-3.75-7.5-9.75-9c-3-0.75-3.75-2.25 0-4.5S296.25 102 300 99s21.75-15 22.5-34.5S321.75 31.5 316.5 14.25L316.5 14.25z" /%3E%3Cpath style="fill:%23FFF" d="M147.75 559.5c0.75-58.5 55.5-113.25 124.5-114c87.75-0.75 148.5 87 192.75 86.25c37.5-0.75 109.5-74.25 144.75-74.25c37.5 0 48 39 48 62.25s-7.5 65.25-25.5 91.5s-29.25 36-50.25 34.5c-27-2.25-81-86.25-115.5-87.75c-43.5-1.5-138 90.75-212.25 90.75c-45 0-58.5-6.75-73.5-16.5C158.25 616.5 147 592.5 147.75 559.5L147.75 559.5z" /%3E%3Cpath style="fill:none" d="M599.25 235.5c15 45.75 0.75 87-9 112.5s-60 136.5-331.5 258C208.5 628.5 198 638.25 141 639c-48 0.75-72.75-15.75-88.5-30l-7.437 0.266C105.763 712.467 220.46 778.5 343.5 778.5c180.75 0 337.5-131.25 337.5-330c0-109.146-44.332-185.488-88.28-234.63C594.244 219.576 596.354 226.668 599.25 235.5z" /%3E%3C/svg%3E`;

const UIStrings = {
  /** Additional description of a Lighthouse audit that tells the user how they can improve performance by removing unused CSS, in the context of the Drupal CMS platform. This is displayed after a user expands the section to see more. No character length limits. Links in (parenthesis) become link texts to additional documentation. */
  'unused-css-rules': 'Consider removing unused CSS rules and only attach the needed Drupal libraries to the relevant page or component in a page. See the [Drupal documentation link](https://www.drupal.org/docs/8/creating-custom-modules/adding-stylesheets-css-and-javascript-js-to-a-drupal-8-module#library) for details. To identify attached libraries that are adding extraneous CSS, try running [code coverage](https://developers.google.com/web/updates/2017/04/devtools-release-notes#coverage) in Chrome DevTools. You can identify the theme/module responsible from the URL of the stylesheet when CSS aggregation is disabled in your Drupal site. Look out for themes/modules that have many stylesheets in the list which have a lot of red in code coverage. A theme/module should only enqueue a stylesheet if it is actually used on the page.',
  /** Additional description of a Lighthouse audit that tells the user how they can improve performance by removing unused Javascript files in the context of the Drupal CMS platform. This is displayed after a user expands the section to see more. No character length limits. Links in (parenthesis) become link texts to additional documentation. */
  'unused-javascript': 'Consider removing unused JavaScript assets and only attach the needed Drupal libraries to the relevant page or component in a page. See the [Drupal documentation link](https://www.drupal.org/docs/8/creating-custom-modules/adding-stylesheets-css-and-javascript-js-to-a-drupal-8-module#library) for details. To identify attached libraries that are adding extraneous JavaScript, try running [code coverage](https://developers.google.com/web/updates/2017/04/devtools-release-notes#coverage) in Chrome DevTools. You can identify the theme/module responsible from the URL of the script when JavaScript aggregation is disabled in your Drupal site. Look out for themes/modules that have many scripts in the list which have a lot of red in code coverage. A theme/module should only enqueue a script if it is actually used on the page.',
  /** Additional description of a Lighthouse audit that tells the user how they can improve image loading by using webp in the context of the Drupal CMS platform. This is displayed after a user expands the section to see more. No character length limits. Links in (parenthesis) become link texts to additional documentation. */
  'modern-image-formats': 'Consider installing and configuring [a module to leverage WebP image formats](https://www.drupal.org/project/project_module?f%5B0%5D=&f%5B1%5D=&f%5B2%5D=&f%5B3%5D=&f%5B4%5D=sm_field_project_type%3Afull&f%5B5%5D=&f%5B6%5D=&text=webp&solrsort=iss_project_release_usage+desc&op=Search) in your site. Such modules automatically generate a WebP version of your uploaded images to optimize loading times.',
  /** Additional description of a Lighthouse audit that tells the user how they can improve performance by lazy loading images that are initially offscreen in the context of the Drupal CMS platform. This is displayed after a user expands the section to see more. No character length limits. Links in (parenthesis) become link texts to additional documentation. */
  'offscreen-images': 'Install [a Drupal module](https://www.drupal.org/project/project_module?f%5B0%5D=&f%5B1%5D=&f%5B2%5D=im_vid_3%3A67&f%5B3%5D=&f%5B4%5D=sm_field_project_type%3Afull&f%5B5%5D=&f%5B6%5D=&text=%22lazy+load%22&solrsort=iss_project_release_usage+desc&op=Search) that can lazy load images. Such modules provide the ability to defer any offscreen images to improve performance.',
  /** Additional description of a Lighthouse audit that tells the user how they can improve site loading performance by reducing the total bytes delivered by their page in the context of the Drupal CMS platform. This is displayed after a user expands the section to see more. No character length limits. Links in (parenthesis) become link texts to additional documentation. */
  'total-byte-weight': 'Consider using [Responsive Image Styles](https://www.drupal.org/docs/8/mobile-guide/responsive-images-in-drupal-8) to reduce the size of images loaded on your page. If you are using Views to show multiple content items on a page, consider implementing pagination to limit the number of content items shown on a given page.',
  /** Additional description of a Lighthouse audit that tells the user how they can improve performance by reducing the amount of render blocking resources present on their page, in the context of the Drupal CMS platform. This is displayed after a user expands the section to see more. No character length limits. Links in (parenthesis) become link texts to additional documentation. */
  'render-blocking-resources': 'Consider using a module to inline critical CSS and JavaScript, or potentially load assets asynchronously via JavaScript such as the [Advanced CSS/JS Aggregation](https://www.drupal.org/project/advagg) module. Beware that optimizations provided by this module may break your site, so you will likely need to make code changes.',
  /** Additional description of a Lighthouse audit that tells the user how they can improve performance by minifying their CSS files in the context of the Drupal CMS platform. This is displayed after a user expands the section to see more. No character length limits. Links in (parenthesis) become link texts to additional documentation. */
  'unminified-css': 'Ensure you have enabled "Aggregate CSS files" in the "Administration » Configuration » Development" page. You can also configure more advanced aggregation options through [additional modules](https://www.drupal.org/project/project_module?f%5B0%5D=&f%5B1%5D=&f%5B2%5D=im_vid_3%3A123&f%5B3%5D=&f%5B4%5D=sm_field_project_type%3Afull&f%5B5%5D=&f%5B6%5D=&text=css+aggregation&solrsort=iss_project_release_usage+desc&op=Search) to speed up your site by concatenating, minifying, and compressing your CSS styles.',
  /** Additional description of a Lighthouse audit that tells the user how they can improve performance by minifying their Javascript files in the context of the Drupal CMS platform. This is displayed after a user expands the section to see more. No character length limits. Links in (parenthesis) become link texts to additional documentation. */
  'unminified-javascript': 'Ensure you have enabled "Aggregate JavaScript files" in the "Administration » Configuration » Development" page. You can also configure more advanced aggregation options through [additional modules](https://www.drupal.org/project/project_module?f%5B0%5D=&f%5B1%5D=&f%5B2%5D=im_vid_3%3A123&f%5B3%5D=&f%5B4%5D=sm_field_project_type%3Afull&f%5B5%5D=&f%5B6%5D=&text=javascript+aggregation&solrsort=iss_project_release_usage+desc&op=Search) to speed up your site by concatenating, minifying, and compressing your JavaScript assets.',
  /** Additional description of a Lighthouse audit that tells the user how they can improve performance by encoding animated images as video, in the context of the Drupal CMS platform. This is displayed after a user expands the section to see more. No character length limits. Links in (parenthesis) become link texts to additional documentation. */
  'efficient-animated-content': 'Consider uploading your GIF to a service which will make it available to embed as an HTML5 video.',
  /** Additional description of a Lighthouse audit that tells the user how they can improve their site by enabling long caching in the context of the Drupal CMS platform. This is displayed after a user expands the section to see more. No character length limits. Links in (parenthesis) become link texts to additional documentation. */
  'uses-long-cache-ttl': 'Set the "Browser and proxy cache maximum age" in the "Administration » Configuration » Development" page. Read about [Drupal cache and optimizing for performance](https://www.drupal.org/docs/7/managing-site-performance-and-scalability/caching-to-improve-performance/caching-overview#s-drupal-performance-resources).',
  /** Additional description of a Lighthouse audit that tells the user how they can improve site performance by optimizing images, in the context of the Drupal CMS platform. This is displayed after a user expands the section to see more. No character length limits. Links in (parenthesis) become link texts to additional documentation. */
  'uses-optimized-images': 'Consider using [a module](https://www.drupal.org/project/project_module?f%5B0%5D=&f%5B1%5D=&f%5B2%5D=im_vid_3%3A123&f%5B3%5D=&f%5B4%5D=sm_field_project_type%3Afull&f%5B5%5D=&f%5B6%5D=&text=optimize+images&solrsort=iss_project_release_usage+desc&op=Search) that automatically optimizes and reduces the size of images uploaded through the site while retaining quality. Also, ensure you are using the native [Responsive Image Styles](https://www.drupal.org/docs/8/mobile-guide/responsive-images-in-drupal-8) provided from Drupal (available in Drupal 8 and above) for all images rendered on the site.',
  /** Additional description of a Lighthouse audit that tells the user how they can improve performance by using responsive images in the context of the Drupal CMS platform. This is displayed after a user expands the section to see more. No character length limits. Links in (parenthesis) become link texts to additional documentation. */
  'uses-responsive-images': 'Ensure that you are using the native [Responsive Image Styles](https://www.drupal.org/docs/8/mobile-guide/responsive-images-in-drupal-8) provided from Drupal (available in Drupal 8 and above). Use the Responsive Image Styles when rendering image fields through view modes, views, or images uploaded through the WYSIWYG editor.',
  /** Additional description of a Lighthouse audit that tells the user how they can improve the time to first byte speed metric, in the context of the Drupal CMS platform. This is displayed after a user expands the section to see more. No character length limits. Links in (parenthesis) become link texts to additional documentation. */
  'server-response-time': 'Themes, modules, and server specifications all contribute to server response time. Consider finding a more optimized theme, carefully selecting an optimization module, and/or upgrading your server. Your hosting servers should make use of PHP opcode caching, memory-caching to reduce database query times such as Redis or Memcached, as well as optimized application logic to prepare pages faster.',
  /** Additional description of a Lighthouse audit that tells the user how they can add preconnect or dns-prefetch resource hints, in the context of the Drupal CMS platform. This is displayed after a user expands the section to see more. No character length limits. Links in (parenthesis) become link texts to additional documentation. */
  'uses-rel-preconnect': 'Preconnect or dns-prefetch resource hints can be added by installing and configuring [a module](https://www.drupal.org/project/project_module?f%5B0%5D=&f%5B1%5D=&f%5B2%5D=&f%5B3%5D=&f%5B4%5D=sm_field_project_type%3Afull&f%5B5%5D=&f%5B6%5D=&text=dns-prefetch&solrsort=iss_project_release_usage+desc&op=Search) that provides facilities for user agent resource hints.',
  /** Additional description of a Lighthouse audit that tells the user how they can specify font-display, in the context of the Drupal CMS platform. This is displayed after a user expands the section to see more. No character length limits. Links in (parenthesis) become link texts to additional documentation. */
  'font-display': 'Specify `@font-display` when defining custom fonts in your theme.',
};

module.exports = {
  id: 'drupal',
  title: 'Drupal',
  icon,
  UIStrings,
}

},{}],212:[function(require,module,exports){
/**
 * @license Copyright 2020 The Lighthouse Authors. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the 'License'); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an 'AS IS' BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.
 */
/* eslint-disable max-len */

'use strict';

const icon = `data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' preserveAspectRatio='xMidYMid' viewBox='0 0 256 258'%3E%3Cpath d='M255.7 35.6a33.7 33.7 0 00-67-4.8l-.4-.2c-27.6-12.4-50.8 9.6-50.8 9.6l-61.4 61.7 24.3 23.4 49.4-48.6c23-23 35.6-7.4 35.6-7.4 17.4 14.6.6 32 .6 32l24.9 24c20.3-22 21.5-41.1 15.3-56.3a33.7 33.7 0 0029.5-33.4' fill='%23F9AE41'/%3E%3Cpath d='M226.5 190.5l.2-.3c12.4-27.6-9.6-50.8-9.6-50.8L155.4 78l-23.3 24.3 48.5 49.4c23 23 7.5 35.6 7.5 35.6-14.7 17.4-32 .6-32 .6l-24 24.9c21.9 20.3 41 21.5 56.2 15.3a33.7 33.7 0 1038.2-37.6' fill='%23EE4035'/%3E%3Cpath d='M156 133l-49.5 48.6c-23 23-35.6 7.4-35.6 7.4-17.4-14.6-.6-32-.6-32l-24.9-24c-20.3 22-21.4 41.1-15.3 56.3a33.7 33.7 0 1037.6 38.2l.3.2c27.6 12.4 50.8-9.6 50.8-9.6l61.4-61.7-24.3-23.4' fill='%234F91CD'/%3E%3Cpath d='M75.7 106.6c-23-23-7.4-35.6-7.4-35.6 14.6-17.4 32-.6 32-.6l24-24.9c-22-20.3-41-21.5-56.3-15.3a33.7 33.7 0 10-38.2 37.6l-.2.3C17.2 95.7 39.2 119 39.2 119l61.7 61.4 23.4-24.3-48.6-49.4' fill='%237AC043'/%3E%3C/svg%3E`;

const UIStrings = {
  /** Additional description of a Lighthouse audit that tells the user how they can improve performance by removing unused CSS, in the context of the Joomla CMS platform. This is displayed after a user expands the section to see more. No character length limits. Links in (parenthesis) become link texts to additional documentation. */
  'unused-css-rules': 'Consider reducing, or switching, the number of [Joomla extensions](https://extensions.joomla.org/) loading unused CSS in your page. To identify extensions that are adding extraneous CSS, try running [code coverage](https://developers.google.com/web/updates/2017/04/devtools-release-notes#coverage) in Chrome DevTools. You can identify the theme/plugin responsible from the URL of the stylesheet. Look out for plugins that have many stylesheets in the list which have a lot of red in code coverage. A plugin should only enqueue a stylesheet if it is actually used on the page.',
  /** Additional description of a Lighthouse audit that tells the user how they can improve image loading by using webp in the context of the Joomla CMS platform. This is displayed after a user expands the section to see more. No character length limits. Links in (parenthesis) become link texts to additional documentation. */
  'modern-image-formats': 'Consider using a [plugin](https://extensions.joomla.org/instant-search/?jed_live%5Bquery%5D=webp) or service that will automatically convert your uploaded images to the optimal formats.',
  /** Additional description of a Lighthouse audit that tells the user how they can improve performance by lazy loading images that are initially offscreen in the context of the Joomla CMS platform. This is displayed after a user expands the section to see more. No character length limits. Links in (parenthesis) become link texts to additional documentation. */
  'offscreen-images': 'Install a [lazy-load Joomla plugin](https://extensions.joomla.org/instant-search/?jed_live%5Bquery%5D=lazy%20loading) that provides the ability to defer any offscreen images, or switch to a template that provides that functionality. Starting with Joomla 4.0, all new images will [automatically](https://github.com/joomla/joomla-cms/pull/30748) get the `loading` attribute from the core.',
  /** Additional description of a Lighthouse audit that tells the user how they can improve site loading performance by reducing the total bytes delivered by their page in the context of the Joomla CMS platform. This is displayed after a user expands the section to see more. No character length limits. Links in (parenthesis) become link texts to additional documentation. */
  'total-byte-weight': 'Consider showing excerpts in your article categories (e.g. via the read more link), reducing the number of articles shown on a given page, breaking your long posts into multiple pages, or using a plugin to lazy-load comments.',
  /** Additional description of a Lighthouse audit that tells the user how they can improve performance by reducing the amount of render blocking resources present on their page, in the context of the Joomla CMS platform. This is displayed after a user expands the section to see more. No character length limits. Links in (parenthesis) become link texts to additional documentation. */
  'render-blocking-resources': 'There are a number of Joomla plugins that can help you [inline critical assets](https://extensions.joomla.org/instant-search/?jed_live%5Bquery%5D=performance) or [defer less important resources](https://extensions.joomla.org/instant-search/?jed_live%5Bquery%5D=performance). Beware that optimizations provided by these plugins may break features of your templates or plugins, so you will need to test these thoroughly.',
  /** Additional description of a Lighthouse audit that tells the user how they can improve performance by minifying their CSS files in the context of the Joomla CMS platform. This is displayed after a user expands the section to see more. No character length limits. Links in (parenthesis) become link texts to additional documentation. */
  'unminified-css': 'A number of [Joomla extensions](https://extensions.joomla.org/instant-search/?jed_live%5Bquery%5D=performance) can speed up your site by concatenating, minifying, and compressing your css styles. There are also templates that provide this functionality.',
  /** Additional description of a Lighthouse audit that tells the user how they can improve performance by minifying their Javascript files in the context of the Joomla CMS platform. This is displayed after a user expands the section to see more. No character length limits. Links in (parenthesis) become link texts to additional documentation. */
  'unminified-javascript': 'A number of [Joomla extensions](https://extensions.joomla.org/instant-search/?jed_live%5Bquery%5D=performance) can speed up your site by concatenating, minifying, and compressing your scripts. There are also templates that provide this functionality.',
  /** Additional description of a Lighthouse audit that tells the user how they can improve performance by encoding animated images as video, in the context of the Joomla CMS platform. This is displayed after a user expands the section to see more. No character length limits. Links in (parenthesis) become link texts to additional documentation. */
  'efficient-animated-content': 'Consider uploading your GIF to a service which will make it available to embed as an HTML5 video.',
  /** Additional description of a Lighthouse audit that tells the user how they can improve performance by removing unused Javascript files in the context of the Joomla CMS platform. This is displayed after a user expands the section to see more. No character length limits. Links in (parenthesis) become link texts to additional documentation. */
  'unused-javascript': 'Consider reducing, or switching, the number of [Joomla extensions](https://extensions.joomla.org/) loading unused JavaScript in your page. To identify plugins that are adding extraneous JS, try running [code coverage](https://developers.google.com/web/updates/2017/04/devtools-release-notes#coverage) in Chrome DevTools. You can identify the extension responsible from the URL of the script. Look out for extensions that have many scripts in the list which have a lot of red in code coverage. An extension should only enqueue a script if it is actually used on the page.',
  /** Additional description of a Lighthouse audit that tells the user how they can improve their site by enabling long caching in the context of the Joomla CMS platform. This is displayed after a user expands the section to see more. No character length limits. Links in (parenthesis) become link texts to additional documentation. */
  'uses-long-cache-ttl': 'Read about [Browser Caching in Joomla](https://docs.joomla.org/Cache).',
  /** Additional description of a Lighthouse audit that tells the user how they can improve site performance by optimizing images, in the context of the Joomla CMS platform. This is displayed after a user expands the section to see more. No character length limits. Links in (parenthesis) become link texts to additional documentation. */
  'uses-optimized-images': 'Consider using an [image optimization plugin](https://extensions.joomla.org/instant-search/?jed_live%5Bquery%5D=performance) that compresses your images while retaining quality.',
  /** Additional description of a Lighthouse audit that tells the user how they can improve performance via enabling text compression in the context of the Joomla CMS platform. This is displayed after a user expands the section to see more. No character length limits. Links in (parenthesis) become link texts to additional documentation. */
  'uses-text-compression': 'You can enable text compression by enabling Gzip Page Compression in Joomla (System > Global configuration > Server).',
  /** Additional description of a Lighthouse audit that tells the user how they can improve performance by using responsive images in the context of the Joomla CMS platform. This is displayed after a user expands the section to see more. No character length limits. Links in (parenthesis) become link texts to additional documentation. */
  'uses-responsive-images': 'Consider using a [responsive images plugin](https://extensions.joomla.org/instant-search/?jed_live%5Bquery%5D=responsive%20images) to use responsive images in your content.',
  /** Additional description of a Lighthouse audit that tells the user how they can improve the server-response-time speed metric, in the context of the Joomla CMS platform. This is displayed after a user expands the section to see more. No character length limits. Links in (parenthesis) become link texts to additional documentation. */
  'server-response-time': 'Templates, extensions, and server specifications all contribute to server response time. Consider finding a more optimized template, carefully selecting an optimization extension, and/or upgrading your server.',
};

module.exports = {
  id: 'joomla',
  title: 'Joomla',
  icon,
  UIStrings,
};

},{}],213:[function(require,module,exports){
const icon = `data:image/svg+xml,%3Csvg xmlns="http://www.w3.org/2000/svg" fill="%23f26322" viewBox="0 0 1000 1000"%3E%3Cpath d="M916.9 267.4v465.3l-111.3 67.4V331.4l-1.5-.9-303.9-189-304.6 189.2-1.2.8V799L83.1 732.6V267.4l.7-.4L500.3 10l416 257 .6.4zM560.7 468.5v383.3L500.3 890l-61-38.2V306.7l-136 84.3v476.6l197 122.5 196.4-122.5V391l-136-84.3v161.8z"/%3E%3C/svg%3E`;

const UIStrings = {
  /** Additional description of a Lighthouse audit that tells the user how they can improve image loading by using webp in the context of the Magento platform. This is displayed after a user expands the section to see more. No character length limits. Links in (parenthesis) become link texts to additional documentation. */
  'modern-image-formats': "Consider searching the [Magento Marketplace](https://marketplace.magento.com/catalogsearch/result/?q=webp) for a variety of third-party extensions to leverage newer image formats.",
  /** Additional description of a Lighthouse audit that tells the user how they can improve performance by lazy loading images that are initially offscreen in the context of the Magento platform. This is displayed after a user expands the section to see more. No character length limits. Links in (parenthesis) become link texts to additional documentation. */
  'offscreen-images': "Consider modifying your product and catalog templates to make use of the web platform's [lazy loading](https://web.dev/native-lazy-loading) feature.",
  /** Additional description of a Lighthouse audit that tells the user how they can improve site loading performance by disabling JS bundling in the context of the Magento platform. This is displayed after a user expands the section to see more. No character length limits. Links in (parenthesis) become link texts to additional documentation. */
  'disable-bundling': "Disable Magento's built-in [JavaScript bundling and minification](https://devdocs.magento.com/guides/v2.3/frontend-dev-guide/themes/js-bundling.html), and consider using [baler](https://github.com/magento/baler/) instead.",
  /** Additional description of a Lighthouse audit that tells the user how they can improve performance by minifying their CSS files in the context of the Magento platform. This is displayed after a user expands the section to see more. No character length limits. Links in (parenthesis) become link texts to additional documentation. */
  'unminified-css': "Enable the \"Minify CSS Files\" option in your store's Developer settings. [Learn more](https://devdocs.magento.com/guides/v2.3/performance-best-practices/configuration.html?itm_source=devdocs&itm_medium=search_page&itm_campaign=federated_search&itm_term=minify%20css%20files).",
  /** Additional description of a Lighthouse audit that tells the user how they can improve performance by minifying their Javascript files in the context of the Magento platform. This is displayed after a user expands the section to see more. No character length limits. Links in (parenthesis) become link texts to additional documentation. */
  'unminified-javascript': "Use [Terser](https://www.npmjs.com/package/terser) to minify all JavaScript assets from static content deployment, and disable the built-in minification feature.",
  /** Additional description of a Lighthouse audit that tells the user how they can improve performance by removing unused Javascript files in the context of the Magento platform. This is displayed after a user expands the section to see more. No character length limits. Links in (parenthesis) become link texts to additional documentation. */
  'unused-javascript': "Disable Magento's built-in [JavaScript bundling](https://devdocs.magento.com/guides/v2.3/frontend-dev-guide/themes/js-bundling.html).",
  /** Additional description of a Lighthouse audit that tells the user how they can improve site performance by optimizing images, in the context of the Magento platform. This is displayed after a user expands the section to see more. No character length limits. Links in (parenthesis) become link texts to additional documentation. */
  'uses-optimized-images': "Consider searching the [Magento Marketplace](https://marketplace.magento.com/catalogsearch/result/?q=optimize%20image) for a variety of third party extensions to optimize images.",
  /** Additional description of a Lighthouse audit that tells the user how they can improve the time to first byte speed metric, in the context of the Magento platform. This is displayed after a user expands the section to see more. No character length limits. Links in (parenthesis) become link texts to additional documentation. */
  'server-response-time': "Use Magento's [Varnish integration](https://devdocs.magento.com/guides/v2.3/config-guide/varnish/config-varnish.html).",
  /** Additional description of a Lighthouse audit that tells the user how they can add preconnect or dns-prefetch resource hints, in the context of the Magento platform. This is displayed after a user expands the section to see more. No character length limits. Links in (parenthesis) become link texts to additional documentation. */
  'uses-rel-preconnect': "Preconnect or dns-prefetch resource hints can be added by [modifying a themes's layout](https://devdocs.magento.com/guides/v2.3/frontend-dev-guide/layouts/xml-manage.html).",
  /** Additional description of a Lighthouse audit that tells the user how they can add preload tags, in the context of the Magento platform. This is displayed after a user expands the section to see more. No character length limits. Links in (parenthesis) become link texts to additional documentation. */
  'uses-rel-preload': "`<link rel=preload>` tags can be added by [modifying a themes's layout](https://devdocs.magento.com/guides/v2.3/frontend-dev-guide/layouts/xml-manage.html).",
  /** Additional description of a Lighthouse audit that tells the user how they can minimize critical request chains, in the context of the Magento platform. This is displayed after a user expands the section to see more. No character length limits. Links in (parenthesis) become link texts to additional documentation. */
  'critical-request-chains': "If you are not bundling your JavaScript assets, consider using [baler](https://github.com/magento/baler).",
  /** Additional description of a Lighthouse audit that tells the user how they can specify font-display, in the context of the Magento platform. This is displayed after a user expands the section to see more. No character length limits. Links in (parenthesis) become link texts to additional documentation. */
  'font-display': "Specify `@font-display` when [defining custom fonts](https://devdocs.magento.com/guides/v2.3/frontend-dev-guide/css-topics/using-fonts.html)."
};

module.exports = {
  id: 'magento',
  title: 'Magento',
  icon,
  UIStrings,
};

},{}],214:[function(require,module,exports){
const icon = `data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 310 310"><path fill="none" d="M-1-1h802v602H-1z"/><g><path fill="%23de6c26" d="M135 6.9c-14.2 4.4-34.9 21.8-49.9 42C55.8 88.5 39.6 135.8 41.4 177c.8 20.2 4.9 35.5 14.4 54.5 13.6 27.4 40.8 55.1 65.5 66.9 14.1 6.7 13.4 6.9 14.1-2.8.3-4.4 1-32.4 1.6-62.1 2.7-137.3 4.4-176 8.2-191.3.6-2.3 1.4-4.2 1.9-4.2 1.2 0 3.6 9.1 4.9 18.3.5 4.3 1 17.7 1 29.8 0 12 .3 21.9.7 21.9.3 0 5.7-5 11.9-11 6.9-6.8 12-11 13.3-11 1.8 0 1.9.3 1 2.7-1.2 3.1-7.9 13.2-19.1 28.5L153 128l.1 31.2c.1 17.2.4 37.4.8 44.9l.6 13.7 11-12.6c14-16 35.1-37.1 39.5-39.6l3.3-1.9-.6 3.2c-2 9.8-9.5 20.7-37.4 54.3L154 240.8v31.1c0 18.3.4 31.1.9 31.1 2.8 0 19.3-6.4 26.8-10.5 13.8-7.3 23.8-15 38.3-29.5 15.7-15.7 24.4-27.4 33.4-45.2 20.5-40 21-80.3 1.6-119-17.8-35.6-54.6-72.1-87.8-86.9-11.7-5.3-24.6-7.3-32.2-5z"/></g></svg>`;

const UIStrings = {
  /** Additional description of a Lighthouse audit that tells the user how they can improve performance by removing unused CSS, in the context of the October CMS platform. This is displayed after a user expands the section to see more. No character length limits. Links in (parenthesis) become link texts to additional documentation. */
  'unused-css-rules': "Consider reviewing the [plugins](https://octobercms.com/plugins) loading unused CSS on the website. To identify plugins that add unnecessary CSS, run [code coverage](https://developers.google.com/web/updates/2017/04/devtools-release-notes#coverage) in Chrome DevTools. Identify the theme/plugin responsible from the stylesheet URL. Look for plugins with many stylesheets with lots of red in code coverage. A plugin should only add a stylesheet if it is actually used on the web page.",
  /** Additional description of a Lighthouse audit that tells the user how they can improve image loading by using webp in the context of the October CMS platform. This is displayed after a user expands the section to see more. No character length limits. Links in (parenthesis) become link texts to additional documentation. */
  'modern-image-formats': "Consider using a [plugin](https://octobercms.com/plugins?search=image) or service that will automatically convert the uploaded images to the optimal formats. [WebP lossless images](https://developers.google.com/speed/webp) are 26% smaller in size compared to PNGs and 25-34% smaller than comparable JPEG images at the equivalent SSIM quality index. Another next-gen image format to consider is [AVIF](https://jakearchibald.com/2020/avif-has-landed/).",
  /** Additional description of a Lighthouse audit that tells the user how they can improve performance by lazy loading images that are initially offscreen in the context of the October CMS platform. This is displayed after a user expands the section to see more. No character length limits. Links in (parenthesis) become link texts to additional documentation. */
  'offscreen-images': "Consider installing an [image lazy loading plugin](https://octobercms.com/plugins?search=lazy) that provides the ability to defer any offscreen images, or switch to a theme that provides that functionality. Also consider using [the AMP plugin](https://octobercms.com/plugins?search=Accelerated+Mobile+Pages).",
  /** Additional description of a Lighthouse audit that tells the user how they can improve site loading performance by reducing the total bytes delivered by their page in the context of the October CMS platform. This is displayed after a user expands the section to see more. No character length limits. Links in (parenthesis) become link texts to additional documentation. */
  'total-byte-weight': "Consider showing excerpts in the post lists (e.g. using a `show more` button), reducing the number of posts shown on a given web page, breaking long posts into multiple web pages, or using a plugin to lazy-load comments.",
  /** Additional description of a Lighthouse audit that tells the user how they can improve performance by reducing the amount of render blocking resources present on their page, in the context of the October CMS platform. This is displayed after a user expands the section to see more. No character length limits. Links in (parenthesis) become link texts to additional documentation. */
  'render-blocking-resources': "There are many plugins that help [inline critical assets](https://octobercms.com/plugins?search=css). These plugins may break other plugins, so you should test thoroughly.",
  /** Additional description of a Lighthouse audit that tells the user how they can improve performance by minifying their CSS files in the context of the October CMS platform. This is displayed after a user expands the section to see more. No character length limits. Links in (parenthesis) become link texts to additional documentation. */
  'unminified-css': "There are many [plugins](https://octobercms.com/plugins?search=css) that can speed up a website by concatenating, minifying and compressing the styles. Using a build process to do this minification up-front can speed up development.",
  /** Additional description of a Lighthouse audit that tells the user how they can improve performance by minifying their Javascript files in the context of the October CMS platform. This is displayed after a user expands the section to see more. No character length limits. Links in (parenthesis) become link texts to additional documentation. */
  'unminified-javascript': "There are many [plugins](https://octobercms.com/plugins?search=javascript) that can speed up a website by concatenating, minifying and compressing the scripts. Using a build process to do this minification up-front can speed up development.",
  /** Additional description of a Lighthouse audit that tells the user how they can improve performance by encoding animated images as video, in the context of the October CMS platform. This is displayed after a user expands the section to see more. No character length limits. Links in (parenthesis) become link texts to additional documentation. */
  'efficient-animated-content': "[Replace animated GIFs with video](https://web.dev/replace-gifs-with-videos/) for faster web page loads and consider using modern file formats such as [WebM](https://web.dev/replace-gifs-with-videos/#create-webm-videos) or [AV1](https://developers.google.com/web/updates/2018/09/chrome-70-media-updates#av1-decoder) to improve compression efficiency by greater than 30% over the current state-of-the-art video codec, VP9.",
  /** Additional description of a Lighthouse audit that tells the user how they can improve performance by removing unused Javascript files in the context of the October CMS platform. This is displayed after a user expands the section to see more. No character length limits. Links in (parenthesis) become link texts to additional documentation. */
  'unused-javascript': "Consider reviewing the [plugins](https://octobercms.com/plugins?search=javascript) that load unused JavaScript in the web page. To identify plugins that add unnecessary JavaScript, run [code coverage](https://developers.google.com/web/updates/2017/04/devtools-release-notes#coverage) in Chrome DevTools. Identify the theme/plugin responsible from the URL of the script. Look for plugins with many scripts with lots of red in code coverage. A plugin should only add a script if it is actually used on the web page.",
  /** Additional description of a Lighthouse audit that tells the user how they can improve their site by enabling long caching in the context of the October CMS platform. This is displayed after a user expands the section to see more. No character length limits. Links in (parenthesis) become link texts to additional documentation. */
  'uses-long-cache-ttl': "Read about [preventing unnecessary network requests with the HTTP Cache](https://web.dev/http-cache/#caching-checklist). There are many [plugins](https://octobercms.com/plugins?search=Caching) that can be used to speed up caching.",
  /** Additional description of a Lighthouse audit that tells the user how they can improve site performance by optimizing images, in the context of the October CMS platform. This is displayed after a user expands the section to see more. No character length limits. Links in (parenthesis) become link texts to additional documentation. */
  'uses-optimized-images': "Consider using an [image optimization plugin](https://octobercms.com/plugins?search=image) to compresses images while retaining the quality.",
  /** Additional description of a Lighthouse audit that tells the user how they can improve performance via enabling text compression in the context of the October CMS platform. This is displayed after a user expands the section to see more. No character length limits. Links in (parenthesis) become link texts to additional documentation. */
  'uses-text-compression': "Enable text compression in the web server configuration.",
  /** Additional description of a Lighthouse audit that tells the user how they can improve performance by using responsive images in the context of the October CMS platform. This is displayed after a user expands the section to see more. No character length limits. Links in (parenthesis) become link texts to additional documentation. */
  'uses-responsive-images': "Upload images directly in the media manager to ensure the required image sizes are available. Consider using the [resize filter](https://octobercms.com/docs/markup/filter-resize) or an [image resizing plugin](https://octobercms.com/plugins?search=image) to ensure the optimal image sizes are used.",
  /** Additional description of a Lighthouse audit that tells the user how they can improve the time to first byte speed metric, in the context of the October CMS platform. This is displayed after a user expands the section to see more. No character length limits. Links in (parenthesis) become link texts to additional documentation. */
  'server-response-time': "Themes, plugins and server specifications all contribute to the server response time. Consider finding a more optimized theme, carefully selecting an optimization plugin and/or upgrade the server. October CMS also allows developers to use [`Queues`](https://octobercms.com/docs/services/queues) to defer the processing of a time consuming task, such as sending an e-mail. This drastically speeds up web requests.",
};

module.exports = {
  id: 'octobercms',
  title: 'October CMS',
  icon,
  UIStrings,
}

},{}],215:[function(require,module,exports){

const icon = `data:image/svg+xml,%3Csvg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 841.9 595.3"%3E %3Cg fill="%2361DAFB"%3E%3Cpath d="M666.3 296.5c0-32.5-40.7-63.3-103.1-82.4 14.4-63.6 8-114.2-20.2-130.4-6.5-3.8-14.1-5.6-22.4-5.6v22.3c4.6 0 8.3.9 11.4 2.6 13.6 7.8 19.5 37.5 14.9 75.7-1.1 9.4-2.9 19.3-5.1 29.4-19.6-4.8-41-8.5-63.5-10.9-13.5-18.5-27.5-35.3-41.6-50 32.6-30.3 63.2-46.9 84-46.9V78c-27.5 0-63.5 19.6-99.9 53.6-36.4-33.8-72.4-53.2-99.9-53.2v22.3c20.7 0 51.4 16.5 84 46.6-14 14.7-28 31.4-41.3 49.9-22.6 2.4-44 6.1-63.6 11-2.3-10-4-19.7-5.2-29-4.7-38.2 1.1-67.9 14.6-75.8 3-1.8 6.9-2.6 11.5-2.6V78.5c-8.4 0-16 1.8-22.6 5.6-28.1 16.2-34.4 66.7-19.9 130.1-62.2 19.2-102.7 49.9-102.7 82.3 0 32.5 40.7 63.3 103.1 82.4-14.4 63.6-8 114.2 20.2 130.4 6.5 3.8 14.1 5.6 22.5 5.6 27.5 0 63.5-19.6 99.9-53.6 36.4 33.8 72.4 53.2 99.9 53.2 8.4 0 16-1.8 22.6-5.6 28.1-16.2 34.4-66.7 19.9-130.1 62-19.1 102.5-49.9 102.5-82.3zm-130.2-66.7c-3.7 12.9-8.3 26.2-13.5 39.5-4.1-8-8.4-16-13.1-24-4.6-8-9.5-15.8-14.4-23.4 14.2 2.1 27.9 4.7 41 7.9zm-45.8 106.5c-7.8 13.5-15.8 26.3-24.1 38.2-14.9 1.3-30 2-45.2 2-15.1 0-30.2-.7-45-1.9-8.3-11.9-16.4-24.6-24.2-38-7.6-13.1-14.5-26.4-20.8-39.8 6.2-13.4 13.2-26.8 20.7-39.9 7.8-13.5 15.8-26.3 24.1-38.2 14.9-1.3 30-2 45.2-2 15.1 0 30.2.7 45 1.9 8.3 11.9 16.4 24.6 24.2 38 7.6 13.1 14.5 26.4 20.8 39.8-6.3 13.4-13.2 26.8-20.7 39.9zm32.3-13c5.4 13.4 10 26.8 13.8 39.8-13.1 3.2-26.9 5.9-41.2 8 4.9-7.7 9.8-15.6 14.4-23.7 4.6-8 8.9-16.1 13-24.1zM421.2 430c-9.3-9.6-18.6-20.3-27.8-32 9 .4 18.2.7 27.5.7 9.4 0 18.7-.2 27.8-.7-9 11.7-18.3 22.4-27.5 32zm-74.4-58.9c-14.2-2.1-27.9-4.7-41-7.9 3.7-12.9 8.3-26.2 13.5-39.5 4.1 8 8.4 16 13.1 24 4.7 8 9.5 15.8 14.4 23.4zM420.7 163c9.3 9.6 18.6 20.3 27.8 32-9-.4-18.2-.7-27.5-.7-9.4 0-18.7.2-27.8.7 9-11.7 18.3-22.4 27.5-32zm-74 58.9c-4.9 7.7-9.8 15.6-14.4 23.7-4.6 8-8.9 16-13 24-5.4-13.4-10-26.8-13.8-39.8 13.1-3.1 26.9-5.8 41.2-7.9zm-90.5 125.2c-35.4-15.1-58.3-34.9-58.3-50.6 0-15.7 22.9-35.6 58.3-50.6 8.6-3.7 18-7 27.7-10.1 5.7 19.6 13.2 40 22.5 60.9-9.2 20.8-16.6 41.1-22.2 60.6-9.9-3.1-19.3-6.5-28-10.2zM310 490c-13.6-7.8-19.5-37.5-14.9-75.7 1.1-9.4 2.9-19.3 5.1-29.4 19.6 4.8 41 8.5 63.5 10.9 13.5 18.5 27.5 35.3 41.6 50-32.6 30.3-63.2 46.9-84 46.9-4.5-.1-8.3-1-11.3-2.7zm237.2-76.2c4.7 38.2-1.1 67.9-14.6 75.8-3 1.8-6.9 2.6-11.5 2.6-20.7 0-51.4-16.5-84-46.6 14-14.7 28-31.4 41.3-49.9 22.6-2.4 44-6.1 63.6-11 2.3 10.1 4.1 19.8 5.2 29.1zm38.5-66.7c-8.6 3.7-18 7-27.7 10.1-5.7-19.6-13.2-40-22.5-60.9 9.2-20.8 16.6-41.1 22.2-60.6 9.9 3.1 19.3 6.5 28.1 10.2 35.4 15.1 58.3 34.9 58.3 50.6-.1 15.7-23 35.6-58.4 50.6zM320.8 78.4z"/%3E %3Ccircle cx="420.9" cy="296.5" r="45.7"/%3E %3Cpath d="M520.5 78.1z"/%3E%3C/g%3E%3C/svg%3E`;

const UIStrings = {
  /** Additional description of a Lighthouse audit that tells the user how they can improve performance by minifying their CSS files in the context of the React library. This is displayed after a user expands the section to see more. No character length limits. Links in (parenthesis) become link texts to additional documentation. */
  'unminified-css': "If your build system minifies CSS files automatically, ensure that you are deploying the production build of your application. You can check this with the React Developer Tools extension. [Learn more](https://reactjs.org/docs/optimizing-performance.html#use-the-production-build).",
  /** Additional description of a Lighthouse audit that tells the user how they can improve performance by minifying their Javascript files in the context of the React library. This is displayed after a user expands the section to see more. No character length limits. Links in (parenthesis) become link texts to additional documentation. */
  'unminified-javascript': "If your build system minifies JS files automatically, ensure that you are deploying the production build of your application. You can check this with the React Developer Tools extension. [Learn more](https://reactjs.org/docs/optimizing-performance.html#use-the-production-build).",
  /** Additional description of a Lighthouse audit that tells the user how they can improve performance by removing unused Javascript files in the context of the React library. This is displayed after a user expands the section to see more. No character length limits. Links in (parenthesis) become link texts to additional documentation. */
  'unused-javascript': "If you are not server-side rendering, [split your JavaScript bundles](https://web.dev/code-splitting-suspense/) with `React.lazy()`. Otherwise, code-split using a third-party library such as [loadable-components](https://www.smooth-code.com/open-source/loadable-components/docs/getting-started/).",
  /** Additional description of a Lighthouse audit that tells the user how they can improve the time to first byte speed metric, in the context of the React library. This is displayed after a user expands the section to see more. No character length limits. Links in (parenthesis) become link texts to additional documentation. */
  'server-response-time': "If you are server-side rendering any React components, consider using `renderToNodeStream()` or `renderToStaticNodeStream()` to allow the client to receive and hydrate different parts of the markup instead of all at once. [Learn more](https://reactjs.org/docs/react-dom-server.html#rendertonodestream).",
  /** Additional description of a Lighthouse audit that tells the user how they can minimize redirects, in the context of the React library. This is displayed after a user expands the section to see more. No character length limits. Links in (parenthesis) become link texts to additional documentation. */
  'redirects': "If you are using React Router, minimize usage of the `<Redirect>` component for [route navigations](https://reacttraining.com/react-router/web/api/Redirect).",
  /** Additional description of a Lighthouse audit that tells the user how they can use the Profiler to help measure performance. This is displayed after a user expands the section to see more. No character length limits. Links in (parenthesis) become link texts to additional documentation. */
  'user-timings': "Use the React DevTools Profiler, which makes use of the Profiler API, to measure the rendering performance of your components. [Learn more.](https://reactjs.org/blog/2018/09/10/introducing-the-react-profiler.html)",
  /** Additional description of a Lighthouse audit that tells the user *why* and *how* they should reduce the size of the web page"s DOM, in the context of the React library, as well as how to maximize component performance when many DOM nodes are present. Links in (parenthesis) become link texts to additional documentation. */
  'dom-size': "Consider using a \"windowing\" library like `react-window` to minimize the number of DOM nodes created if you are rendering many repeated elements on the page. [Learn more](https://web.dev/virtualize-long-lists-react-window/). Also, minimize unnecessary re-renders using [`shouldComponentUpdate`](https://reactjs.org/docs/optimizing-performance.html#shouldcomponentupdate-in-action), [`PureComponent`](https://reactjs.org/docs/react-api.html#reactpurecomponent), or [`React.memo`](https://reactjs.org/docs/react-api.html#reactmemo) and [skip effects](https://reactjs.org/docs/hooks-effect.html#tip-optimizing-performance-by-skipping-effects) only until certain dependencies have changed if you are using the `Effect` hook to improve runtime performance.",
};

module.exports = {
  id: 'react',
  title: 'React',
  icon,
  UIStrings,
}

},{}],216:[function(require,module,exports){

const icon = `data:image/svg+xml,%3Csvg viewBox="0 0 122.5 122.5" xmlns="http://www.w3.org/2000/svg"%3E%3Cg fill="%232f3439"%3E%3Cpath d="M8.7 61.3c0 20.8 12.1 38.7 29.6 47.3l-25-68.7c-3 6.5-4.6 13.7-4.6 21.4zM96.7 58.6c0-6.5-2.3-11-4.3-14.5-2.7-4.3-5.2-8-5.2-12.3 0-4.8 3.7-9.3 8.9-9.3h.7a52.4 52.4 0 0 0-79.4 9.9h3.3c5.5 0 14-.6 14-.6 2.9-.2 3.2 4 .4 4.3 0 0-2.9.4-6 .5l19.1 57L59.7 59l-8.2-22.5c-2.8-.1-5.5-.5-5.5-.5-2.8-.1-2.5-4.5.3-4.3 0 0 8.7.7 13.9.7 5.5 0 14-.7 14-.7 2.8-.2 3.2 4 .3 4.3 0 0-2.8.4-6 .5l19 56.5 5.2-17.5c2.3-7.3 4-12.5 4-17z"/%3E%3Cpath d="M62.2 65.9l-15.8 45.8a52.6 52.6 0 0 0 32.3-.9l-.4-.7zM107.4 36a49.6 49.6 0 0 1-3.6 24.2l-16.1 46.5A52.5 52.5 0 0 0 107.4 36z"/%3E%3Cpath d="M61.3 0a61.3 61.3 0 1 0 .1 122.7A61.3 61.3 0 0 0 61.3 0zm0 119.7a58.5 58.5 0 1 1 .1-117 58.5 58.5 0 0 1-.1 117z"/%3E%3C/g%3E%3C/svg%3E`;

const UIStrings = {
  /** Additional description of a Lighthouse audit that tells the user how they can improve performance by removing unused CSS, in the context of the Wordpress CMS platform. This is displayed after a user expands the section to see more. No character length limits. Links in (parenthesis) become link texts to additional documentation. */
  'unused-css-rules': "Consider reducing, or switching, the number of [WordPress plugins](https://wordpress.org/plugins/) loading unused CSS in your page. To identify plugins that are adding extraneous CSS, try running [code coverage](https://developers.google.com/web/updates/2017/04/devtools-release-notes#coverage) in Chrome DevTools. You can identify the theme/plugin responsible from the URL of the stylesheet. Look out for plugins that have many stylesheets in the list which have a lot of red in code coverage. A plugin should only enqueue a stylesheet if it is actually used on the page.",
  /** Additional description of a Lighthouse audit that tells the user how they can improve image loading by using webp in the context of the Wordpress CMS platform. This is displayed after a user expands the section to see more. No character length limits. Links in (parenthesis) become link texts to additional documentation. */
  'modern-image-formats': "Consider using a [plugin](https://wordpress.org/plugins/search/convert+webp/) or service that will automatically convert your uploaded images to the optimal formats.",
  /** Additional description of a Lighthouse audit that tells the user how they can improve performance by lazy loading images that are initially offscreen in the context of the Wordpress CMS platform. This is displayed after a user expands the section to see more. No character length limits. Links in (parenthesis) become link texts to additional documentation. */
  'offscreen-images': "Install a [lazy-load WordPress plugin](https://wordpress.org/plugins/search/lazy+load/) that provides the ability to defer any offscreen images, or switch to a theme that provides that functionality. Also consider using [the AMP plugin](https://wordpress.org/plugins/amp/).",
  /** Additional description of a Lighthouse audit that tells the user how they can improve site loading performance by reducing the total bytes delivered by their page in the context of the Wordpress CMS platform. This is displayed after a user expands the section to see more. No character length limits. Links in (parenthesis) become link texts to additional documentation. */
  'total-byte-weight': "Consider showing excerpts in your post lists (e.g. via the more tag), reducing the number of posts shown on a given page, breaking your long posts into multiple pages, or using a plugin to lazy-load comments.",
  /** Additional description of a Lighthouse audit that tells the user how they can improve performance by reducing the amount of render blocking resources present on their page, in the context of the Wordpress CMS platform. This is displayed after a user expands the section to see more. No character length limits. Links in (parenthesis) become link texts to additional documentation. */
  'render-blocking-resources': "There are a number of WordPress plugins that can help you [inline critical assets](https://wordpress.org/plugins/search/critical+css/) or [defer less important resources](https://wordpress.org/plugins/search/defer+css+javascript/). Beware that optimizations provided by these plugins may break features of your theme or plugins, so you will likely need to make code changes.",
  /** Additional description of a Lighthouse audit that tells the user how they can improve performance by minifying their CSS files in the context of the Wordpress CMS platform. This is displayed after a user expands the section to see more. No character length limits. Links in (parenthesis) become link texts to additional documentation. */
  'unminified-css': "A number of [WordPress plugins](https://wordpress.org/plugins/search/minify+css/) can speed up your site by concatenating, minifying, and compressing your styles. You may also want to use a build process to do this minification up-front if possible.",
  /** Additional description of a Lighthouse audit that tells the user how they can improve performance by minifying their Javascript files in the context of the Wordpress CMS platform. This is displayed after a user expands the section to see more. No character length limits. Links in (parenthesis) become link texts to additional documentation. */
  'unminified-javascript': "A number of [WordPress plugins](https://wordpress.org/plugins/search/minify+javascript/) can speed up your site by concatenating, minifying, and compressing your scripts. You may also want to use a build process to do this minification up front if possible.",
  /** Additional description of a Lighthouse audit that tells the user how they can improve performance by encoding animated images as video, in the context of the Wordpress CMS platform. This is displayed after a user expands the section to see more. No character length limits. Links in (parenthesis) become link texts to additional documentation. */
  'efficient-animated-content': "Consider uploading your GIF to a service which will make it available to embed as an HTML5 video.",
  /** Additional description of a Lighthouse audit that tells the user how they can improve performance by removing unused Javascript files in the context of the Wordpress CMS platform. This is displayed after a user expands the section to see more. No character length limits. Links in (parenthesis) become link texts to additional documentation. */
  'unused-javascript': "Consider reducing, or switching, the number of [WordPress plugins](https://wordpress.org/plugins/) loading unused JavaScript in your page. To identify plugins that are adding extraneous JS, try running [code coverage](https://developers.google.com/web/updates/2017/04/devtools-release-notes#coverage) in Chrome DevTools. You can identify the theme/plugin responsible from the URL of the script. Look out for plugins that have many scripts in the list which have a lot of red in code coverage. A plugin should only enqueue a script if it is actually used on the page.",
  /** Additional description of a Lighthouse audit that tells the user how they can improve their site by enabling long caching in the context of the Wordpress CMS platform. This is displayed after a user expands the section to see more. No character length limits. Links in (parenthesis) become link texts to additional documentation. */
  'uses-long-cache-ttl': "Read about [Browser Caching in WordPress](https://wordpress.org/support/article/optimization/#browser-caching).",
  /** Additional description of a Lighthouse audit that tells the user how they can improve site performance by optimizing images, in the context of the Wordpress CMS platform. This is displayed after a user expands the section to see more. No character length limits. Links in (parenthesis) become link texts to additional documentation. */
  'uses-optimized-images': "Consider using an [image optimization WordPress plugin](https://wordpress.org/plugins/search/optimize+images/) that compresses your images while retaining quality.",
  /** Additional description of a Lighthouse audit that tells the user how they can improve performance via enabling text compression in the context of the Wordpress CMS platform. This is displayed after a user expands the section to see more. No character length limits. Links in (parenthesis) become link texts to additional documentation. */
  'uses-text-compression': "You can enable text compression in your web server configuration.",
  /** Additional description of a Lighthouse audit that tells the user how they can improve performance by using responsive images in the context of the Wordpress CMS platform. This is displayed after a user expands the section to see more. No character length limits. Links in (parenthesis) become link texts to additional documentation. */
  'uses-responsive-images': "Upload images directly through the [media library](https://wordpress.org/support/article/media-library-screen/) to ensure that the required image sizes are available, and then insert them from the media library or use the image widget to ensure the optimal image sizes are used (including those for the responsive breakpoints). Avoid using `Full Size` images unless the dimensions are adequate for their usage. [Learn More](https://wordpress.org/support/article/inserting-images-into-posts-and-pages/).",
  /** Additional description of a Lighthouse audit that tells the user how they can improve the time to first byte speed metric, in the context of the Wordpress CMS platform. This is displayed after a user expands the section to see more. No character length limits. Links in (parenthesis) become link texts to additional documentation. */
  'server-response-time': "Themes, plugins, and server specifications all contribute to server response time. Consider finding a more optimized theme, carefully selecting an optimization plugin, and/or upgrading your server.",
};

module.exports = {
  id: 'wordpress',
  title: 'WordPress',
  icon,
  UIStrings,
}

},{}],217:[function(require,module,exports){
(function (global){(function (){
/**
 * Lodash (Custom Build) <https://lodash.com/>
 * Build: `lodash modularize exports="npm" -o ./`
 * Copyright JS Foundation and other contributors <https://js.foundation/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */

/** Used as the size to enable large array optimizations. */
var LARGE_ARRAY_SIZE = 200;

/** Used to stand-in for `undefined` hash values. */
var HASH_UNDEFINED = '__lodash_hash_undefined__';

/** Used to compose bitmasks for value comparisons. */
var COMPARE_PARTIAL_FLAG = 1,
    COMPARE_UNORDERED_FLAG = 2;

/** Used as references for various `Number` constants. */
var MAX_SAFE_INTEGER = 9007199254740991;

/** `Object#toString` result references. */
var argsTag = '[object Arguments]',
    arrayTag = '[object Array]',
    asyncTag = '[object AsyncFunction]',
    boolTag = '[object Boolean]',
    dateTag = '[object Date]',
    errorTag = '[object Error]',
    funcTag = '[object Function]',
    genTag = '[object GeneratorFunction]',
    mapTag = '[object Map]',
    numberTag = '[object Number]',
    nullTag = '[object Null]',
    objectTag = '[object Object]',
    promiseTag = '[object Promise]',
    proxyTag = '[object Proxy]',
    regexpTag = '[object RegExp]',
    setTag = '[object Set]',
    stringTag = '[object String]',
    symbolTag = '[object Symbol]',
    undefinedTag = '[object Undefined]',
    weakMapTag = '[object WeakMap]';

var arrayBufferTag = '[object ArrayBuffer]',
    dataViewTag = '[object DataView]',
    float32Tag = '[object Float32Array]',
    float64Tag = '[object Float64Array]',
    int8Tag = '[object Int8Array]',
    int16Tag = '[object Int16Array]',
    int32Tag = '[object Int32Array]',
    uint8Tag = '[object Uint8Array]',
    uint8ClampedTag = '[object Uint8ClampedArray]',
    uint16Tag = '[object Uint16Array]',
    uint32Tag = '[object Uint32Array]';

/**
 * Used to match `RegExp`
 * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
 */
var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;

/** Used to detect host constructors (Safari). */
var reIsHostCtor = /^\[object .+?Constructor\]$/;

/** Used to detect unsigned integer values. */
var reIsUint = /^(?:0|[1-9]\d*)$/;

/** Used to identify `toStringTag` values of typed arrays. */
var typedArrayTags = {};
typedArrayTags[float32Tag] = typedArrayTags[float64Tag] =
typedArrayTags[int8Tag] = typedArrayTags[int16Tag] =
typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =
typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =
typedArrayTags[uint32Tag] = true;
typedArrayTags[argsTag] = typedArrayTags[arrayTag] =
typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =
typedArrayTags[dataViewTag] = typedArrayTags[dateTag] =
typedArrayTags[errorTag] = typedArrayTags[funcTag] =
typedArrayTags[mapTag] = typedArrayTags[numberTag] =
typedArrayTags[objectTag] = typedArrayTags[regexpTag] =
typedArrayTags[setTag] = typedArrayTags[stringTag] =
typedArrayTags[weakMapTag] = false;

/** Detect free variable `global` from Node.js. */
var freeGlobal = typeof global == 'object' && global && global.Object === Object && global;

/** Detect free variable `self`. */
var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

/** Used as a reference to the global object. */
var root = freeGlobal || freeSelf || Function('return this')();

/** Detect free variable `exports`. */
var freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;

/** Detect free variable `module`. */
var freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;

/** Detect the popular CommonJS extension `module.exports`. */
var moduleExports = freeModule && freeModule.exports === freeExports;

/** Detect free variable `process` from Node.js. */
var freeProcess = moduleExports && freeGlobal.process;

/** Used to access faster Node.js helpers. */
var nodeUtil = (function() {
  try {
    return freeProcess && freeProcess.binding && freeProcess.binding('util');
  } catch (e) {}
}());

/* Node.js helper references. */
var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;

/**
 * A specialized version of `_.filter` for arrays without support for
 * iteratee shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} predicate The function invoked per iteration.
 * @returns {Array} Returns the new filtered array.
 */
function arrayFilter(array, predicate) {
  var index = -1,
      length = array == null ? 0 : array.length,
      resIndex = 0,
      result = [];

  while (++index < length) {
    var value = array[index];
    if (predicate(value, index, array)) {
      result[resIndex++] = value;
    }
  }
  return result;
}

/**
 * Appends the elements of `values` to `array`.
 *
 * @private
 * @param {Array} array The array to modify.
 * @param {Array} values The values to append.
 * @returns {Array} Returns `array`.
 */
function arrayPush(array, values) {
  var index = -1,
      length = values.length,
      offset = array.length;

  while (++index < length) {
    array[offset + index] = values[index];
  }
  return array;
}

/**
 * A specialized version of `_.some` for arrays without support for iteratee
 * shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} predicate The function invoked per iteration.
 * @returns {boolean} Returns `true` if any element passes the predicate check,
 *  else `false`.
 */
function arraySome(array, predicate) {
  var index = -1,
      length = array == null ? 0 : array.length;

  while (++index < length) {
    if (predicate(array[index], index, array)) {
      return true;
    }
  }
  return false;
}

/**
 * The base implementation of `_.times` without support for iteratee shorthands
 * or max array length checks.
 *
 * @private
 * @param {number} n The number of times to invoke `iteratee`.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the array of results.
 */
function baseTimes(n, iteratee) {
  var index = -1,
      result = Array(n);

  while (++index < n) {
    result[index] = iteratee(index);
  }
  return result;
}

/**
 * The base implementation of `_.unary` without support for storing metadata.
 *
 * @private
 * @param {Function} func The function to cap arguments for.
 * @returns {Function} Returns the new capped function.
 */
function baseUnary(func) {
  return function(value) {
    return func(value);
  };
}

/**
 * Checks if a `cache` value for `key` exists.
 *
 * @private
 * @param {Object} cache The cache to query.
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function cacheHas(cache, key) {
  return cache.has(key);
}

/**
 * Gets the value at `key` of `object`.
 *
 * @private
 * @param {Object} [object] The object to query.
 * @param {string} key The key of the property to get.
 * @returns {*} Returns the property value.
 */
function getValue(object, key) {
  return object == null ? undefined : object[key];
}

/**
 * Converts `map` to its key-value pairs.
 *
 * @private
 * @param {Object} map The map to convert.
 * @returns {Array} Returns the key-value pairs.
 */
function mapToArray(map) {
  var index = -1,
      result = Array(map.size);

  map.forEach(function(value, key) {
    result[++index] = [key, value];
  });
  return result;
}

/**
 * Creates a unary function that invokes `func` with its argument transformed.
 *
 * @private
 * @param {Function} func The function to wrap.
 * @param {Function} transform The argument transform.
 * @returns {Function} Returns the new function.
 */
function overArg(func, transform) {
  return function(arg) {
    return func(transform(arg));
  };
}

/**
 * Converts `set` to an array of its values.
 *
 * @private
 * @param {Object} set The set to convert.
 * @returns {Array} Returns the values.
 */
function setToArray(set) {
  var index = -1,
      result = Array(set.size);

  set.forEach(function(value) {
    result[++index] = value;
  });
  return result;
}

/** Used for built-in method references. */
var arrayProto = Array.prototype,
    funcProto = Function.prototype,
    objectProto = Object.prototype;

/** Used to detect overreaching core-js shims. */
var coreJsData = root['__core-js_shared__'];

/** Used to resolve the decompiled source of functions. */
var funcToString = funcProto.toString;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/** Used to detect methods masquerading as native. */
var maskSrcKey = (function() {
  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');
  return uid ? ('Symbol(src)_1.' + uid) : '';
}());

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var nativeObjectToString = objectProto.toString;

/** Used to detect if a method is native. */
var reIsNative = RegExp('^' +
  funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\$&')
  .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
);

/** Built-in value references. */
var Buffer = moduleExports ? root.Buffer : undefined,
    Symbol = root.Symbol,
    Uint8Array = root.Uint8Array,
    propertyIsEnumerable = objectProto.propertyIsEnumerable,
    splice = arrayProto.splice,
    symToStringTag = Symbol ? Symbol.toStringTag : undefined;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeGetSymbols = Object.getOwnPropertySymbols,
    nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined,
    nativeKeys = overArg(Object.keys, Object);

/* Built-in method references that are verified to be native. */
var DataView = getNative(root, 'DataView'),
    Map = getNative(root, 'Map'),
    Promise = getNative(root, 'Promise'),
    Set = getNative(root, 'Set'),
    WeakMap = getNative(root, 'WeakMap'),
    nativeCreate = getNative(Object, 'create');

/** Used to detect maps, sets, and weakmaps. */
var dataViewCtorString = toSource(DataView),
    mapCtorString = toSource(Map),
    promiseCtorString = toSource(Promise),
    setCtorString = toSource(Set),
    weakMapCtorString = toSource(WeakMap);

/** Used to convert symbols to primitives and strings. */
var symbolProto = Symbol ? Symbol.prototype : undefined,
    symbolValueOf = symbolProto ? symbolProto.valueOf : undefined;

/**
 * Creates a hash object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function Hash(entries) {
  var index = -1,
      length = entries == null ? 0 : entries.length;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

/**
 * Removes all key-value entries from the hash.
 *
 * @private
 * @name clear
 * @memberOf Hash
 */
function hashClear() {
  this.__data__ = nativeCreate ? nativeCreate(null) : {};
  this.size = 0;
}

/**
 * Removes `key` and its value from the hash.
 *
 * @private
 * @name delete
 * @memberOf Hash
 * @param {Object} hash The hash to modify.
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function hashDelete(key) {
  var result = this.has(key) && delete this.__data__[key];
  this.size -= result ? 1 : 0;
  return result;
}

/**
 * Gets the hash value for `key`.
 *
 * @private
 * @name get
 * @memberOf Hash
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function hashGet(key) {
  var data = this.__data__;
  if (nativeCreate) {
    var result = data[key];
    return result === HASH_UNDEFINED ? undefined : result;
  }
  return hasOwnProperty.call(data, key) ? data[key] : undefined;
}

/**
 * Checks if a hash value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Hash
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function hashHas(key) {
  var data = this.__data__;
  return nativeCreate ? (data[key] !== undefined) : hasOwnProperty.call(data, key);
}

/**
 * Sets the hash `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Hash
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the hash instance.
 */
function hashSet(key, value) {
  var data = this.__data__;
  this.size += this.has(key) ? 0 : 1;
  data[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED : value;
  return this;
}

// Add methods to `Hash`.
Hash.prototype.clear = hashClear;
Hash.prototype['delete'] = hashDelete;
Hash.prototype.get = hashGet;
Hash.prototype.has = hashHas;
Hash.prototype.set = hashSet;

/**
 * Creates an list cache object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function ListCache(entries) {
  var index = -1,
      length = entries == null ? 0 : entries.length;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

/**
 * Removes all key-value entries from the list cache.
 *
 * @private
 * @name clear
 * @memberOf ListCache
 */
function listCacheClear() {
  this.__data__ = [];
  this.size = 0;
}

/**
 * Removes `key` and its value from the list cache.
 *
 * @private
 * @name delete
 * @memberOf ListCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function listCacheDelete(key) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  if (index < 0) {
    return false;
  }
  var lastIndex = data.length - 1;
  if (index == lastIndex) {
    data.pop();
  } else {
    splice.call(data, index, 1);
  }
  --this.size;
  return true;
}

/**
 * Gets the list cache value for `key`.
 *
 * @private
 * @name get
 * @memberOf ListCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function listCacheGet(key) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  return index < 0 ? undefined : data[index][1];
}

/**
 * Checks if a list cache value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf ListCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function listCacheHas(key) {
  return assocIndexOf(this.__data__, key) > -1;
}

/**
 * Sets the list cache `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf ListCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the list cache instance.
 */
function listCacheSet(key, value) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  if (index < 0) {
    ++this.size;
    data.push([key, value]);
  } else {
    data[index][1] = value;
  }
  return this;
}

// Add methods to `ListCache`.
ListCache.prototype.clear = listCacheClear;
ListCache.prototype['delete'] = listCacheDelete;
ListCache.prototype.get = listCacheGet;
ListCache.prototype.has = listCacheHas;
ListCache.prototype.set = listCacheSet;

/**
 * Creates a map cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function MapCache(entries) {
  var index = -1,
      length = entries == null ? 0 : entries.length;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

/**
 * Removes all key-value entries from the map.
 *
 * @private
 * @name clear
 * @memberOf MapCache
 */
function mapCacheClear() {
  this.size = 0;
  this.__data__ = {
    'hash': new Hash,
    'map': new (Map || ListCache),
    'string': new Hash
  };
}

/**
 * Removes `key` and its value from the map.
 *
 * @private
 * @name delete
 * @memberOf MapCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function mapCacheDelete(key) {
  var result = getMapData(this, key)['delete'](key);
  this.size -= result ? 1 : 0;
  return result;
}

/**
 * Gets the map value for `key`.
 *
 * @private
 * @name get
 * @memberOf MapCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function mapCacheGet(key) {
  return getMapData(this, key).get(key);
}

/**
 * Checks if a map value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf MapCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function mapCacheHas(key) {
  return getMapData(this, key).has(key);
}

/**
 * Sets the map `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf MapCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the map cache instance.
 */
function mapCacheSet(key, value) {
  var data = getMapData(this, key),
      size = data.size;

  data.set(key, value);
  this.size += data.size == size ? 0 : 1;
  return this;
}

// Add methods to `MapCache`.
MapCache.prototype.clear = mapCacheClear;
MapCache.prototype['delete'] = mapCacheDelete;
MapCache.prototype.get = mapCacheGet;
MapCache.prototype.has = mapCacheHas;
MapCache.prototype.set = mapCacheSet;

/**
 *
 * Creates an array cache object to store unique values.
 *
 * @private
 * @constructor
 * @param {Array} [values] The values to cache.
 */
function SetCache(values) {
  var index = -1,
      length = values == null ? 0 : values.length;

  this.__data__ = new MapCache;
  while (++index < length) {
    this.add(values[index]);
  }
}

/**
 * Adds `value` to the array cache.
 *
 * @private
 * @name add
 * @memberOf SetCache
 * @alias push
 * @param {*} value The value to cache.
 * @returns {Object} Returns the cache instance.
 */
function setCacheAdd(value) {
  this.__data__.set(value, HASH_UNDEFINED);
  return this;
}

/**
 * Checks if `value` is in the array cache.
 *
 * @private
 * @name has
 * @memberOf SetCache
 * @param {*} value The value to search for.
 * @returns {number} Returns `true` if `value` is found, else `false`.
 */
function setCacheHas(value) {
  return this.__data__.has(value);
}

// Add methods to `SetCache`.
SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
SetCache.prototype.has = setCacheHas;

/**
 * Creates a stack cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function Stack(entries) {
  var data = this.__data__ = new ListCache(entries);
  this.size = data.size;
}

/**
 * Removes all key-value entries from the stack.
 *
 * @private
 * @name clear
 * @memberOf Stack
 */
function stackClear() {
  this.__data__ = new ListCache;
  this.size = 0;
}

/**
 * Removes `key` and its value from the stack.
 *
 * @private
 * @name delete
 * @memberOf Stack
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function stackDelete(key) {
  var data = this.__data__,
      result = data['delete'](key);

  this.size = data.size;
  return result;
}

/**
 * Gets the stack value for `key`.
 *
 * @private
 * @name get
 * @memberOf Stack
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function stackGet(key) {
  return this.__data__.get(key);
}

/**
 * Checks if a stack value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Stack
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function stackHas(key) {
  return this.__data__.has(key);
}

/**
 * Sets the stack `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Stack
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the stack cache instance.
 */
function stackSet(key, value) {
  var data = this.__data__;
  if (data instanceof ListCache) {
    var pairs = data.__data__;
    if (!Map || (pairs.length < LARGE_ARRAY_SIZE - 1)) {
      pairs.push([key, value]);
      this.size = ++data.size;
      return this;
    }
    data = this.__data__ = new MapCache(pairs);
  }
  data.set(key, value);
  this.size = data.size;
  return this;
}

// Add methods to `Stack`.
Stack.prototype.clear = stackClear;
Stack.prototype['delete'] = stackDelete;
Stack.prototype.get = stackGet;
Stack.prototype.has = stackHas;
Stack.prototype.set = stackSet;

/**
 * Creates an array of the enumerable property names of the array-like `value`.
 *
 * @private
 * @param {*} value The value to query.
 * @param {boolean} inherited Specify returning inherited property names.
 * @returns {Array} Returns the array of property names.
 */
function arrayLikeKeys(value, inherited) {
  var isArr = isArray(value),
      isArg = !isArr && isArguments(value),
      isBuff = !isArr && !isArg && isBuffer(value),
      isType = !isArr && !isArg && !isBuff && isTypedArray(value),
      skipIndexes = isArr || isArg || isBuff || isType,
      result = skipIndexes ? baseTimes(value.length, String) : [],
      length = result.length;

  for (var key in value) {
    if ((inherited || hasOwnProperty.call(value, key)) &&
        !(skipIndexes && (
           // Safari 9 has enumerable `arguments.length` in strict mode.
           key == 'length' ||
           // Node.js 0.10 has enumerable non-index properties on buffers.
           (isBuff && (key == 'offset' || key == 'parent')) ||
           // PhantomJS 2 has enumerable non-index properties on typed arrays.
           (isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset')) ||
           // Skip index properties.
           isIndex(key, length)
        ))) {
      result.push(key);
    }
  }
  return result;
}

/**
 * Gets the index at which the `key` is found in `array` of key-value pairs.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} key The key to search for.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
function assocIndexOf(array, key) {
  var length = array.length;
  while (length--) {
    if (eq(array[length][0], key)) {
      return length;
    }
  }
  return -1;
}

/**
 * The base implementation of `getAllKeys` and `getAllKeysIn` which uses
 * `keysFunc` and `symbolsFunc` to get the enumerable property names and
 * symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Function} keysFunc The function to get the keys of `object`.
 * @param {Function} symbolsFunc The function to get the symbols of `object`.
 * @returns {Array} Returns the array of property names and symbols.
 */
function baseGetAllKeys(object, keysFunc, symbolsFunc) {
  var result = keysFunc(object);
  return isArray(object) ? result : arrayPush(result, symbolsFunc(object));
}

/**
 * The base implementation of `getTag` without fallbacks for buggy environments.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */
function baseGetTag(value) {
  if (value == null) {
    return value === undefined ? undefinedTag : nullTag;
  }
  return (symToStringTag && symToStringTag in Object(value))
    ? getRawTag(value)
    : objectToString(value);
}

/**
 * The base implementation of `_.isArguments`.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
 */
function baseIsArguments(value) {
  return isObjectLike(value) && baseGetTag(value) == argsTag;
}

/**
 * The base implementation of `_.isEqual` which supports partial comparisons
 * and tracks traversed objects.
 *
 * @private
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @param {boolean} bitmask The bitmask flags.
 *  1 - Unordered comparison
 *  2 - Partial comparison
 * @param {Function} [customizer] The function to customize comparisons.
 * @param {Object} [stack] Tracks traversed `value` and `other` objects.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 */
function baseIsEqual(value, other, bitmask, customizer, stack) {
  if (value === other) {
    return true;
  }
  if (value == null || other == null || (!isObjectLike(value) && !isObjectLike(other))) {
    return value !== value && other !== other;
  }
  return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
}

/**
 * A specialized version of `baseIsEqual` for arrays and objects which performs
 * deep comparisons and tracks traversed objects enabling objects with circular
 * references to be compared.
 *
 * @private
 * @param {Object} object The object to compare.
 * @param {Object} other The other object to compare.
 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
 * @param {Function} customizer The function to customize comparisons.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Object} [stack] Tracks traversed `object` and `other` objects.
 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
 */
function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
  var objIsArr = isArray(object),
      othIsArr = isArray(other),
      objTag = objIsArr ? arrayTag : getTag(object),
      othTag = othIsArr ? arrayTag : getTag(other);

  objTag = objTag == argsTag ? objectTag : objTag;
  othTag = othTag == argsTag ? objectTag : othTag;

  var objIsObj = objTag == objectTag,
      othIsObj = othTag == objectTag,
      isSameTag = objTag == othTag;

  if (isSameTag && isBuffer(object)) {
    if (!isBuffer(other)) {
      return false;
    }
    objIsArr = true;
    objIsObj = false;
  }
  if (isSameTag && !objIsObj) {
    stack || (stack = new Stack);
    return (objIsArr || isTypedArray(object))
      ? equalArrays(object, other, bitmask, customizer, equalFunc, stack)
      : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
  }
  if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
    var objIsWrapped = objIsObj && hasOwnProperty.call(object, '__wrapped__'),
        othIsWrapped = othIsObj && hasOwnProperty.call(other, '__wrapped__');

    if (objIsWrapped || othIsWrapped) {
      var objUnwrapped = objIsWrapped ? object.value() : object,
          othUnwrapped = othIsWrapped ? other.value() : other;

      stack || (stack = new Stack);
      return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
    }
  }
  if (!isSameTag) {
    return false;
  }
  stack || (stack = new Stack);
  return equalObjects(object, other, bitmask, customizer, equalFunc, stack);
}

/**
 * The base implementation of `_.isNative` without bad shim checks.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a native function,
 *  else `false`.
 */
function baseIsNative(value) {
  if (!isObject(value) || isMasked(value)) {
    return false;
  }
  var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
  return pattern.test(toSource(value));
}

/**
 * The base implementation of `_.isTypedArray` without Node.js optimizations.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
 */
function baseIsTypedArray(value) {
  return isObjectLike(value) &&
    isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
}

/**
 * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */
function baseKeys(object) {
  if (!isPrototype(object)) {
    return nativeKeys(object);
  }
  var result = [];
  for (var key in Object(object)) {
    if (hasOwnProperty.call(object, key) && key != 'constructor') {
      result.push(key);
    }
  }
  return result;
}

/**
 * A specialized version of `baseIsEqualDeep` for arrays with support for
 * partial deep comparisons.
 *
 * @private
 * @param {Array} array The array to compare.
 * @param {Array} other The other array to compare.
 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
 * @param {Function} customizer The function to customize comparisons.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Object} stack Tracks traversed `array` and `other` objects.
 * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.
 */
function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
  var isPartial = bitmask & COMPARE_PARTIAL_FLAG,
      arrLength = array.length,
      othLength = other.length;

  if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
    return false;
  }
  // Assume cyclic values are equal.
  var stacked = stack.get(array);
  if (stacked && stack.get(other)) {
    return stacked == other;
  }
  var index = -1,
      result = true,
      seen = (bitmask & COMPARE_UNORDERED_FLAG) ? new SetCache : undefined;

  stack.set(array, other);
  stack.set(other, array);

  // Ignore non-index properties.
  while (++index < arrLength) {
    var arrValue = array[index],
        othValue = other[index];

    if (customizer) {
      var compared = isPartial
        ? customizer(othValue, arrValue, index, other, array, stack)
        : customizer(arrValue, othValue, index, array, other, stack);
    }
    if (compared !== undefined) {
      if (compared) {
        continue;
      }
      result = false;
      break;
    }
    // Recursively compare arrays (susceptible to call stack limits).
    if (seen) {
      if (!arraySome(other, function(othValue, othIndex) {
            if (!cacheHas(seen, othIndex) &&
                (arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
              return seen.push(othIndex);
            }
          })) {
        result = false;
        break;
      }
    } else if (!(
          arrValue === othValue ||
            equalFunc(arrValue, othValue, bitmask, customizer, stack)
        )) {
      result = false;
      break;
    }
  }
  stack['delete'](array);
  stack['delete'](other);
  return result;
}

/**
 * A specialized version of `baseIsEqualDeep` for comparing objects of
 * the same `toStringTag`.
 *
 * **Note:** This function only supports comparing values with tags of
 * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
 *
 * @private
 * @param {Object} object The object to compare.
 * @param {Object} other The other object to compare.
 * @param {string} tag The `toStringTag` of the objects to compare.
 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
 * @param {Function} customizer The function to customize comparisons.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Object} stack Tracks traversed `object` and `other` objects.
 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
 */
function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
  switch (tag) {
    case dataViewTag:
      if ((object.byteLength != other.byteLength) ||
          (object.byteOffset != other.byteOffset)) {
        return false;
      }
      object = object.buffer;
      other = other.buffer;

    case arrayBufferTag:
      if ((object.byteLength != other.byteLength) ||
          !equalFunc(new Uint8Array(object), new Uint8Array(other))) {
        return false;
      }
      return true;

    case boolTag:
    case dateTag:
    case numberTag:
      // Coerce booleans to `1` or `0` and dates to milliseconds.
      // Invalid dates are coerced to `NaN`.
      return eq(+object, +other);

    case errorTag:
      return object.name == other.name && object.message == other.message;

    case regexpTag:
    case stringTag:
      // Coerce regexes to strings and treat strings, primitives and objects,
      // as equal. See http://www.ecma-international.org/ecma-262/7.0/#sec-regexp.prototype.tostring
      // for more details.
      return object == (other + '');

    case mapTag:
      var convert = mapToArray;

    case setTag:
      var isPartial = bitmask & COMPARE_PARTIAL_FLAG;
      convert || (convert = setToArray);

      if (object.size != other.size && !isPartial) {
        return false;
      }
      // Assume cyclic values are equal.
      var stacked = stack.get(object);
      if (stacked) {
        return stacked == other;
      }
      bitmask |= COMPARE_UNORDERED_FLAG;

      // Recursively compare objects (susceptible to call stack limits).
      stack.set(object, other);
      var result = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
      stack['delete'](object);
      return result;

    case symbolTag:
      if (symbolValueOf) {
        return symbolValueOf.call(object) == symbolValueOf.call(other);
      }
  }
  return false;
}

/**
 * A specialized version of `baseIsEqualDeep` for objects with support for
 * partial deep comparisons.
 *
 * @private
 * @param {Object} object The object to compare.
 * @param {Object} other The other object to compare.
 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
 * @param {Function} customizer The function to customize comparisons.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Object} stack Tracks traversed `object` and `other` objects.
 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
 */
function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
  var isPartial = bitmask & COMPARE_PARTIAL_FLAG,
      objProps = getAllKeys(object),
      objLength = objProps.length,
      othProps = getAllKeys(other),
      othLength = othProps.length;

  if (objLength != othLength && !isPartial) {
    return false;
  }
  var index = objLength;
  while (index--) {
    var key = objProps[index];
    if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {
      return false;
    }
  }
  // Assume cyclic values are equal.
  var stacked = stack.get(object);
  if (stacked && stack.get(other)) {
    return stacked == other;
  }
  var result = true;
  stack.set(object, other);
  stack.set(other, object);

  var skipCtor = isPartial;
  while (++index < objLength) {
    key = objProps[index];
    var objValue = object[key],
        othValue = other[key];

    if (customizer) {
      var compared = isPartial
        ? customizer(othValue, objValue, key, other, object, stack)
        : customizer(objValue, othValue, key, object, other, stack);
    }
    // Recursively compare objects (susceptible to call stack limits).
    if (!(compared === undefined
          ? (objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack))
          : compared
        )) {
      result = false;
      break;
    }
    skipCtor || (skipCtor = key == 'constructor');
  }
  if (result && !skipCtor) {
    var objCtor = object.constructor,
        othCtor = other.constructor;

    // Non `Object` object instances with different constructors are not equal.
    if (objCtor != othCtor &&
        ('constructor' in object && 'constructor' in other) &&
        !(typeof objCtor == 'function' && objCtor instanceof objCtor &&
          typeof othCtor == 'function' && othCtor instanceof othCtor)) {
      result = false;
    }
  }
  stack['delete'](object);
  stack['delete'](other);
  return result;
}

/**
 * Creates an array of own enumerable property names and symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names and symbols.
 */
function getAllKeys(object) {
  return baseGetAllKeys(object, keys, getSymbols);
}

/**
 * Gets the data for `map`.
 *
 * @private
 * @param {Object} map The map to query.
 * @param {string} key The reference key.
 * @returns {*} Returns the map data.
 */
function getMapData(map, key) {
  var data = map.__data__;
  return isKeyable(key)
    ? data[typeof key == 'string' ? 'string' : 'hash']
    : data.map;
}

/**
 * Gets the native function at `key` of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {string} key The key of the method to get.
 * @returns {*} Returns the function if it's native, else `undefined`.
 */
function getNative(object, key) {
  var value = getValue(object, key);
  return baseIsNative(value) ? value : undefined;
}

/**
 * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the raw `toStringTag`.
 */
function getRawTag(value) {
  var isOwn = hasOwnProperty.call(value, symToStringTag),
      tag = value[symToStringTag];

  try {
    value[symToStringTag] = undefined;
    var unmasked = true;
  } catch (e) {}

  var result = nativeObjectToString.call(value);
  if (unmasked) {
    if (isOwn) {
      value[symToStringTag] = tag;
    } else {
      delete value[symToStringTag];
    }
  }
  return result;
}

/**
 * Creates an array of the own enumerable symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of symbols.
 */
var getSymbols = !nativeGetSymbols ? stubArray : function(object) {
  if (object == null) {
    return [];
  }
  object = Object(object);
  return arrayFilter(nativeGetSymbols(object), function(symbol) {
    return propertyIsEnumerable.call(object, symbol);
  });
};

/**
 * Gets the `toStringTag` of `value`.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */
var getTag = baseGetTag;

// Fallback for data views, maps, sets, and weak maps in IE 11 and promises in Node.js < 6.
if ((DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag) ||
    (Map && getTag(new Map) != mapTag) ||
    (Promise && getTag(Promise.resolve()) != promiseTag) ||
    (Set && getTag(new Set) != setTag) ||
    (WeakMap && getTag(new WeakMap) != weakMapTag)) {
  getTag = function(value) {
    var result = baseGetTag(value),
        Ctor = result == objectTag ? value.constructor : undefined,
        ctorString = Ctor ? toSource(Ctor) : '';

    if (ctorString) {
      switch (ctorString) {
        case dataViewCtorString: return dataViewTag;
        case mapCtorString: return mapTag;
        case promiseCtorString: return promiseTag;
        case setCtorString: return setTag;
        case weakMapCtorString: return weakMapTag;
      }
    }
    return result;
  };
}

/**
 * Checks if `value` is a valid array-like index.
 *
 * @private
 * @param {*} value The value to check.
 * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
 * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
 */
function isIndex(value, length) {
  length = length == null ? MAX_SAFE_INTEGER : length;
  return !!length &&
    (typeof value == 'number' || reIsUint.test(value)) &&
    (value > -1 && value % 1 == 0 && value < length);
}

/**
 * Checks if `value` is suitable for use as unique object key.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
 */
function isKeyable(value) {
  var type = typeof value;
  return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')
    ? (value !== '__proto__')
    : (value === null);
}

/**
 * Checks if `func` has its source masked.
 *
 * @private
 * @param {Function} func The function to check.
 * @returns {boolean} Returns `true` if `func` is masked, else `false`.
 */
function isMasked(func) {
  return !!maskSrcKey && (maskSrcKey in func);
}

/**
 * Checks if `value` is likely a prototype object.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
 */
function isPrototype(value) {
  var Ctor = value && value.constructor,
      proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto;

  return value === proto;
}

/**
 * Converts `value` to a string using `Object.prototype.toString`.
 *
 * @private
 * @param {*} value The value to convert.
 * @returns {string} Returns the converted string.
 */
function objectToString(value) {
  return nativeObjectToString.call(value);
}

/**
 * Converts `func` to its source code.
 *
 * @private
 * @param {Function} func The function to convert.
 * @returns {string} Returns the source code.
 */
function toSource(func) {
  if (func != null) {
    try {
      return funcToString.call(func);
    } catch (e) {}
    try {
      return (func + '');
    } catch (e) {}
  }
  return '';
}

/**
 * Performs a
 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * comparison between two values to determine if they are equivalent.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 * @example
 *
 * var object = { 'a': 1 };
 * var other = { 'a': 1 };
 *
 * _.eq(object, object);
 * // => true
 *
 * _.eq(object, other);
 * // => false
 *
 * _.eq('a', 'a');
 * // => true
 *
 * _.eq('a', Object('a'));
 * // => false
 *
 * _.eq(NaN, NaN);
 * // => true
 */
function eq(value, other) {
  return value === other || (value !== value && other !== other);
}

/**
 * Checks if `value` is likely an `arguments` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
 *  else `false`.
 * @example
 *
 * _.isArguments(function() { return arguments; }());
 * // => true
 *
 * _.isArguments([1, 2, 3]);
 * // => false
 */
var isArguments = baseIsArguments(function() { return arguments; }()) ? baseIsArguments : function(value) {
  return isObjectLike(value) && hasOwnProperty.call(value, 'callee') &&
    !propertyIsEnumerable.call(value, 'callee');
};

/**
 * Checks if `value` is classified as an `Array` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array, else `false`.
 * @example
 *
 * _.isArray([1, 2, 3]);
 * // => true
 *
 * _.isArray(document.body.children);
 * // => false
 *
 * _.isArray('abc');
 * // => false
 *
 * _.isArray(_.noop);
 * // => false
 */
var isArray = Array.isArray;

/**
 * Checks if `value` is array-like. A value is considered array-like if it's
 * not a function and has a `value.length` that's an integer greater than or
 * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
 * @example
 *
 * _.isArrayLike([1, 2, 3]);
 * // => true
 *
 * _.isArrayLike(document.body.children);
 * // => true
 *
 * _.isArrayLike('abc');
 * // => true
 *
 * _.isArrayLike(_.noop);
 * // => false
 */
function isArrayLike(value) {
  return value != null && isLength(value.length) && !isFunction(value);
}

/**
 * Checks if `value` is a buffer.
 *
 * @static
 * @memberOf _
 * @since 4.3.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
 * @example
 *
 * _.isBuffer(new Buffer(2));
 * // => true
 *
 * _.isBuffer(new Uint8Array(2));
 * // => false
 */
var isBuffer = nativeIsBuffer || stubFalse;

/**
 * Performs a deep comparison between two values to determine if they are
 * equivalent.
 *
 * **Note:** This method supports comparing arrays, array buffers, booleans,
 * date objects, error objects, maps, numbers, `Object` objects, regexes,
 * sets, strings, symbols, and typed arrays. `Object` objects are compared
 * by their own, not inherited, enumerable properties. Functions and DOM
 * nodes are compared by strict equality, i.e. `===`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 * @example
 *
 * var object = { 'a': 1 };
 * var other = { 'a': 1 };
 *
 * _.isEqual(object, other);
 * // => true
 *
 * object === other;
 * // => false
 */
function isEqual(value, other) {
  return baseIsEqual(value, other);
}

/**
 * Checks if `value` is classified as a `Function` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a function, else `false`.
 * @example
 *
 * _.isFunction(_);
 * // => true
 *
 * _.isFunction(/abc/);
 * // => false
 */
function isFunction(value) {
  if (!isObject(value)) {
    return false;
  }
  // The use of `Object#toString` avoids issues with the `typeof` operator
  // in Safari 9 which returns 'object' for typed arrays and other constructors.
  var tag = baseGetTag(value);
  return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
}

/**
 * Checks if `value` is a valid array-like length.
 *
 * **Note:** This method is loosely based on
 * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
 * @example
 *
 * _.isLength(3);
 * // => true
 *
 * _.isLength(Number.MIN_VALUE);
 * // => false
 *
 * _.isLength(Infinity);
 * // => false
 *
 * _.isLength('3');
 * // => false
 */
function isLength(value) {
  return typeof value == 'number' &&
    value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
}

/**
 * Checks if `value` is the
 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */
function isObject(value) {
  var type = typeof value;
  return value != null && (type == 'object' || type == 'function');
}

/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */
function isObjectLike(value) {
  return value != null && typeof value == 'object';
}

/**
 * Checks if `value` is classified as a typed array.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
 * @example
 *
 * _.isTypedArray(new Uint8Array);
 * // => true
 *
 * _.isTypedArray([]);
 * // => false
 */
var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;

/**
 * Creates an array of the own enumerable property names of `object`.
 *
 * **Note:** Non-object values are coerced to objects. See the
 * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
 * for more details.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.keys(new Foo);
 * // => ['a', 'b'] (iteration order is not guaranteed)
 *
 * _.keys('hi');
 * // => ['0', '1']
 */
function keys(object) {
  return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
}

/**
 * This method returns a new empty array.
 *
 * @static
 * @memberOf _
 * @since 4.13.0
 * @category Util
 * @returns {Array} Returns the new empty array.
 * @example
 *
 * var arrays = _.times(2, _.stubArray);
 *
 * console.log(arrays);
 * // => [[], []]
 *
 * console.log(arrays[0] === arrays[1]);
 * // => false
 */
function stubArray() {
  return [];
}

/**
 * This method returns `false`.
 *
 * @static
 * @memberOf _
 * @since 4.13.0
 * @category Util
 * @returns {boolean} Returns `false`.
 * @example
 *
 * _.times(2, _.stubFalse);
 * // => [false, false]
 */
function stubFalse() {
  return false;
}

module.exports = isEqual;

}).call(this)}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],218:[function(require,module,exports){
// @flow
// "lookup" algorithm http://tools.ietf.org/html/rfc4647#section-3.4
// assumes normalized language tags, and matches in a case sensitive manner
module.exports = function lookupClosestLocale (locale/*: string | string[] | void */, available/*: { [string]: any } */)/*: ?string */ {
  if (typeof locale === 'string' && available[locale]) return locale
  var locales = [].concat(locale || [])
  for (var l = 0, ll = locales.length; l < ll; ++l) {
    var current = locales[l].split('-')
    while (current.length) {
      var candidate = current.join('-')
      if (available[candidate]) return candidate
      current.pop()
    }
  }
}

},{}],219:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

/* global performance */
var perf = typeof performance !== 'undefined' && performance;

var now = perf && perf.now ? function () { return perf.now(); } : function () { return Date.now(); }

function throwIfEmpty (name) {
  if (!name) {
    throw new Error('name must be non-empty')
  }
}

// simple binary sort insertion
function insertSorted (arr, item) {
  var low = 0;
  var high = arr.length;
  var mid;
  while (low < high) {
    mid = (low + high) >>> 1; // like (num / 2) but faster
    if (arr[mid].startTime < item.startTime) {
      low = mid + 1;
    } else {
      high = mid;
    }
  }
  arr.splice(low, 0, item);
}

exports.mark = void 0;
exports.stop = void 0;
exports.getEntries = void 0;
exports.clear = void 0;

if (
  perf &&
  perf.mark &&
  perf.getEntriesByName &&
  perf.getEntriesByType &&
  perf.clearMeasures
) {
  exports.mark = function (name) {
    throwIfEmpty(name);
    perf.mark(("start " + name));
  };
  exports.stop = function (name) {
    throwIfEmpty(name);
    perf.mark(("end " + name));
    perf.measure(name, ("start " + name), ("end " + name));
    var entries = perf.getEntriesByName(name);
    return entries[entries.length - 1]
  };
  exports.getEntries = function () { return perf.getEntriesByType('measure'); };
  exports.clear = function () {
    perf.clearMarks();
    perf.clearMeasures();
  };
} else {
  var marks = {};
  var entries = [];
  exports.mark = function (name) {
    throwIfEmpty(name);
    var startTime = now();
    marks['$' + name] = startTime;
  };
  exports.stop = function (name) {
    throwIfEmpty(name);
    var endTime = now();
    var startTime = marks['$' + name];
    if (!startTime) {
      throw new Error(("no known mark: " + name))
    }
    var entry = {
      startTime: startTime,
      name: name,
      duration: endTime - startTime,
      entryType: 'measure'
    };
    // per the spec this should be at least 150:
    // https://www.w3.org/TR/resource-timing-1/#extensions-performance-interface
    // we just have no limit, per Chrome and Edge's de-facto behavior
    insertSorted(entries, entry);
    return entry
  };
  exports.getEntries = function () { return entries; };
  exports.clear = function () {
    marks = {};
    entries = [];
  };
}

},{}],220:[function(require,module,exports){
exports.getRenderingDataFromViewport = function (viewportProperties, uaDeviceWidth, uaDeviceHeight, uaMaxZoom, uaMinZoom) {

    var vw = uaDeviceWidth / 100;
    var vh = uaDeviceHeight / 100;

    // Following http://dev.w3.org/csswg/css-device-adapt/#translation-into-atviewport-descriptors
    // 'auto' is mapped to null by convention
    var maxZoom = null;
    var minZoom = null;
    var zoom = null;
    var minWidth = null;
    var minHeight = null;
    var maxWidth = null;
    var maxHeight = null;
    var width = null, height = null;
    var initialWidth = uaDeviceWidth;
    var initialHeight = uaDeviceHeight;
    var userZoom = "zoom";

    if (viewportProperties["maximum-scale"] !== undefined) {
        maxZoom = translateZoomProperty(viewportProperties["maximum-scale"]);
    }
    if (viewportProperties["minimum-scale"] !== undefined) {
        minZoom = translateZoomProperty(viewportProperties["minimum-scale"]);
    }
    if (viewportProperties["initial-scale"] !== undefined) {
        zoom = translateZoomProperty(viewportProperties["initial-scale"]);
    }


    /* For a viewport META element that translates into an @viewport rule
       with no ‘max-zoom’ declaration and a non-‘auto’ ‘min-zoom’ value
       that is larger than the ‘max-zoom’ value of the UA stylesheet,
       the ‘min-zoom’ declaration value is clamped to the UA stylesheet
       ‘max-zoom’ value.  */
    if (minZoom !== null && maxZoom === null) {
        minZoom = min(uaMaxZoom, translateZoomProperty(viewportProperties["minimum-scale"]));
    }

    if (viewportProperties["width"] !== undefined) {
        minWidth = "extend-to-zoom";
        maxWidth = translateLengthProperty(viewportProperties["width"], vw, vh);
    }

    if (viewportProperties["height"] !== undefined) {
        minHeight = "extend-to-zoom";
        maxHeight = translateLengthProperty(viewportProperties["height"], vw, vh);
    }

    // Following http://dev.w3.org/csswg/css-device-adapt/#user-scalable0
    if (viewportProperties["user-scalable"] !== undefined) {
        userZoom = viewportProperties["user-scalable"];
        if (typeof userZoom === "number") {
            if (userZoom >=1 || userZoom <= -1) {
                userZoom = "zoom";
            } else {
                userZoom = "fixed";
            }
        } else {
            switch(userZoom) {
            case "yes":
            case "device-width":
            case "device-height":
                userZoom = "zoom";
                break;
            case "no":
            default:
                userZoom = "fixed";
                break;
            }
        }
    }

    /* For a viewport META element that translates into an @viewport rule
       with a non-‘auto’ ‘zoom’ declaration and no ‘width’ declaration: */
    if (zoom !== null &&
        (viewportProperties["width"] === undefined || width === undefined)) {
        if (viewportProperties["height"] !== undefined) {
            // If it adds a ‘height’ descriptor, add: width: auto;
            minWidth = null;
            maxWidth = null;
        } else {
            // Otherwise, add: width: extend-to-zoom;
            minWidth = "extend-to-zoom";
            maxWidth = "extend-to-zoom";
        }
    }


    // Following http://dev.w3.org/csswg/css-device-adapt/#constraining-procedure

    // If min-zoom is not ‘auto’ and max-zoom is not ‘auto’,
    // set max-zoom = MAX(min-zoom, max-zoom)
    if (minZoom !== null && maxZoom !== null) {
        maxZoom = max(minZoom, maxZoom);
    }

    // If zoom is not ‘auto’, set zoom = MAX(min-zoom, MIN(max-zoom, zoom))
    if (zoom !== null) {
        zoom = clamp(zoom, minZoom, maxZoom);
    }

    // from "Resolving ‘extend-to-zoom’"
    var extendZoom = (zoom === null && maxZoom === null ? null : min(zoom, maxZoom));
    var extendWidth, extendHeight;
    if (extendZoom === null) {
        if (maxWidth === "extend-to-zoom") {
            maxWidth = null;
        }
        if (maxHeight === "extend-to-zoom") {
            maxHeight = null;
        }
        if (minWidth === "extend-to-zoom") {
            minWidth = maxWidth;
        }
        if (minHeight === "extend-to-zoom") {
            minHeight = maxHeight;
        }
    } else {
        extendWidth = initialWidth / extendZoom;
        extendHeight = initialHeight / extendZoom;

        if (maxWidth === "extend-to-zoom") {
            maxWidth = extendWidth;
        }
        if (maxHeight === "extend-to-zoom") {
            maxHeight = extendHeight;
        }
        if (minWidth === "extend-to-zoom") {
            minWidth = max(extendWidth, maxWidth);
        }
        if (minHeight === "extend-to-zoom") {
            minHeight = max(extendHeight, maxHeight);
        }
    }

    // Resolve initial width and height from min/max descriptors
    if (minWidth !== null || maxWidth !== null) {
        width = max(minWidth, min(maxWidth, initialWidth));
    }
    if (minHeight !== null || maxHeight !== null) {
        height = max(minHeight, min(maxHeight, initialHeight));
    }

    // Resolve width value
    if (width === null) {
        if (height === null) {
            width = initialWidth;
        } else {
            if (initialHeight !== 0) {
                width = Math.round(height * (initialWidth / initialHeight));
            } else {
                width = initialWidth;
            }
        }
    }
    if (height === null) {
        if (initialWidth !== 0) {
            height = Math.round(width * (initialHeight / initialWidth));
        } else {
            height = initialHeight;
        }
    }

    return { zoom: zoom, width: width, height: height, userZoom: userZoom};
};

function min(a, b) {
    if (a === null) return b;
    if (b === null) return a;
    return Math.min(a,b);
}

function max(a, b) {
    if (a === null) return b;
    if (b === null) return a;
    return Math.max(a,b);
}


function translateLengthProperty(prop, vw, vh) {
    // based on http://dev.w3.org/csswg/css-device-adapt/#width2
    if (typeof prop === "number") {
        if (prop >= 0) {
            // Non-negative number values are translated to pixel lengths, clamped to the range: [1px, 10000px]
            return clamp(prop, 1, 10000);
        } else {
            return undefined;
        }
    }
    if (prop === "device-width") {
        return 100*vw;
    }
    if (prop === "device-height") {
        return 100*vh;
    }
    return 1;
}

function translateZoomProperty(prop) {
    // based on http://dev.w3.org/csswg/css-device-adapt/#initial-scale0
    if (typeof prop === "number") {
        if (prop >= 0) {
            // Non-negative number values are translated to <number> values, clamped to the range [0.1, 10]
            return clamp(prop, 0.1, 10);
        } else {
            return undefined;
        }
    }
    if (prop === "yes") {
        return 1;
    }
    if (prop === "device-width" || prop === "device-height") {
        return 10;
    }
    if (prop === "no" || prop === null) {
        return 0.1;
    }
}

// return value if min <= value <= max, or the closest from min or max
function clamp(value, minv, maxv) {
    return max(min(value, maxv), minv);
}

/*
from http://dev.w3.org/csswg/css-device-adapt/#viewport-meta
 Parse-Content(S)
i ← 1
while i ≤ length[S]
    do while i ≤ length[S] and S[i] in [whitespace, separator, '=']
        do i ← i + 1
    if i ≤ length[S]
        then i ← Parse-Property(S, i)

Parse-Property(S, i)
start ← i
while i ≤ length[S] and S[i] not in [whitespace, separator, '=']
    do i ← i + 1
if i > length[S] or S[i] in [separator]
    then return i
property-name ← S[start .. (i - 1)]
while i ≤ length[S] and S[i] not in [separator, '=']
    do i ← i + 1
if i > length[S] or S[i] in [separator]
    then return i
while i ≤ length[S] and S[i] in [whitespace, '=']
    do i ← i + 1
if i > length[S] or S[i] in [separator]
    then return i
start ← i
while i ≤ length[S] and S[i] not in [whitespace, separator, '=']
    do i ← i + 1
property-value ← S[start .. (i - 1)]
Set-Property(property-name, property-value)
return i */
exports.parseMetaViewPortContent = function (S) {
    var parsedContent = {
        validProperties : {},
        unknownProperties: {},
        invalidValues : {}
    };
    var i = 1;
    while (i <= S.length) {
        while (i <= S.length && RegExp(' |\x0A|\x09|\0d|,|;|=').test(S[i-1])) {
            i++;
        }
        if (i <= S.length) {
            i = parseProperty(parsedContent, S, i);
        }
    }
    return parsedContent;
};

var propertyNames = ["width", "height", "initial-scale", "minimum-scale", "maximum-scale", "user-scalable", "shrink-to-fit", "viewport-fit"];

function parseProperty(parsedContent, S, i) {
    var start = i;
    while (i <= S.length && !RegExp(' |\x0A|\x09|\0d|,|;|=').test(S[i-1])) {
        i++;
    }
    if (i > S.length || RegExp(',|;').test(S[i-1])) {
        return i;
    }
    var propertyName = S.slice(start - 1, i-1);
    while (i <= S.length && !RegExp(',|;|=').test(S[i-1])) {
        i++;
    }
    if (i > S.length || RegExp(',|;').test(S[i-1])) {
        return i;
    }
    while (i <= S.length && RegExp(' |\x0A|\x09|\0d|=').test(S[i-1])) {
        i++;
    }
    if (i > S.length || RegExp(',|;').test(S[i-1])) {
        return i;
    }
    start = i;
    while (i <= S.length && !RegExp(' |\x0A|\x09|\0d|,|;|=').test(S[i-1])) {
        i++;
    }
    var propertyValue = S.slice(start - 1, i-1);
    setProperty(parsedContent, propertyName, propertyValue);
    return i;
}

function setProperty(parsedContent, name, value) {
    if (propertyNames.indexOf(name) >= 0) {
        var number = parseFloat(value);
        if (!isNaN(number)) {
            parsedContent.validProperties[name] = number;
            return;
        }
        var string = value.toLowerCase();

        if (string === "yes" || string === "no" || string === "device-width" || string === "device-height" ||

           // https://webkit.org/blog/7929/designing-websites-for-iphone-x/
           (name.toLowerCase() === 'viewport-fit' && (string === 'auto' || string === 'cover'))) {

            parsedContent.validProperties[name] = string;
            return;
        }

        parsedContent.validProperties[name] = null;
        parsedContent.invalidValues[name] = value;
    } else {
        parsedContent.unknownProperties[name] = value;
    }
}

exports.expectedValues = {
    "width": ["device-width", "device-height", "a positive number"],
    "height": ["device-width", "device-height", "a positive number"],
    "initial-scale": ["a positive number"],
    "minimum-scale": ["a positive number"],
    "maximum-scale": ["a positive number"],
    "user-scalable": ["yes", "no", "0", "1"],
    "shrink-to-fit": ["yes", "no"],
    "viewport-fit": ["auto", "cover"]
};

},{}],221:[function(require,module,exports){
module.exports = function parseCacheControl(field) {

  if (typeof field !== 'string') {
    return null;
  }

  /*
    Cache-Control   = 1#cache-directive
    cache-directive = token [ "=" ( token / quoted-string ) ]
    token           = [^\x00-\x20\(\)<>@\,;\:\\"\/\[\]\?\=\{\}\x7F]+
    quoted-string   = "(?:[^"\\]|\\.)*"
  */

  //                             1: directive                                        =   2: token                                              3: quoted-string
  var regex = /(?:^|(?:\s*\,\s*))([^\x00-\x20\(\)<>@\,;\:\\"\/\[\]\?\=\{\}\x7F]+)(?:\=(?:([^\x00-\x20\(\)<>@\,;\:\\"\/\[\]\?\=\{\}\x7F]+)|(?:\"((?:[^"\\]|\\.)*)\")))?/g;

  var header = {};
  var err = field.replace(regex, function($0, $1, $2, $3) {
    var value = $2 || $3;
    header[$1] = value ? value.toLowerCase() : true;
    return '';
  });

  if (header['max-age']) {
    try {
      var maxAge = parseInt(header['max-age'], 10);
      if (isNaN(maxAge)) {
        return null;
      }

      header['max-age'] = maxAge;
    }
    catch (err) { }
  }

  return (err ? null : header);
};

},{}],222:[function(require,module,exports){
(function (process){(function (){
// 'path' module extracted from Node.js v8.11.1 (only the posix part)
// transplited with Babel

// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';

function assertPath(path) {
  if (typeof path !== 'string') {
    throw new TypeError('Path must be a string. Received ' + JSON.stringify(path));
  }
}

// Resolves . and .. elements in a path with directory names
function normalizeStringPosix(path, allowAboveRoot) {
  var res = '';
  var lastSegmentLength = 0;
  var lastSlash = -1;
  var dots = 0;
  var code;
  for (var i = 0; i <= path.length; ++i) {
    if (i < path.length)
      code = path.charCodeAt(i);
    else if (code === 47 /*/*/)
      break;
    else
      code = 47 /*/*/;
    if (code === 47 /*/*/) {
      if (lastSlash === i - 1 || dots === 1) {
        // NOOP
      } else if (lastSlash !== i - 1 && dots === 2) {
        if (res.length < 2 || lastSegmentLength !== 2 || res.charCodeAt(res.length - 1) !== 46 /*.*/ || res.charCodeAt(res.length - 2) !== 46 /*.*/) {
          if (res.length > 2) {
            var lastSlashIndex = res.lastIndexOf('/');
            if (lastSlashIndex !== res.length - 1) {
              if (lastSlashIndex === -1) {
                res = '';
                lastSegmentLength = 0;
              } else {
                res = res.slice(0, lastSlashIndex);
                lastSegmentLength = res.length - 1 - res.lastIndexOf('/');
              }
              lastSlash = i;
              dots = 0;
              continue;
            }
          } else if (res.length === 2 || res.length === 1) {
            res = '';
            lastSegmentLength = 0;
            lastSlash = i;
            dots = 0;
            continue;
          }
        }
        if (allowAboveRoot) {
          if (res.length > 0)
            res += '/..';
          else
            res = '..';
          lastSegmentLength = 2;
        }
      } else {
        if (res.length > 0)
          res += '/' + path.slice(lastSlash + 1, i);
        else
          res = path.slice(lastSlash + 1, i);
        lastSegmentLength = i - lastSlash - 1;
      }
      lastSlash = i;
      dots = 0;
    } else if (code === 46 /*.*/ && dots !== -1) {
      ++dots;
    } else {
      dots = -1;
    }
  }
  return res;
}

function _format(sep, pathObject) {
  var dir = pathObject.dir || pathObject.root;
  var base = pathObject.base || (pathObject.name || '') + (pathObject.ext || '');
  if (!dir) {
    return base;
  }
  if (dir === pathObject.root) {
    return dir + base;
  }
  return dir + sep + base;
}

var posix = {
  // path.resolve([from ...], to)
  resolve: function resolve() {
    var resolvedPath = '';
    var resolvedAbsolute = false;
    var cwd;

    for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
      var path;
      if (i >= 0)
        path = arguments[i];
      else {
        if (cwd === undefined)
          cwd = process.cwd();
        path = cwd;
      }

      assertPath(path);

      // Skip empty entries
      if (path.length === 0) {
        continue;
      }

      resolvedPath = path + '/' + resolvedPath;
      resolvedAbsolute = path.charCodeAt(0) === 47 /*/*/;
    }

    // At this point the path should be resolved to a full absolute path, but
    // handle relative paths to be safe (might happen when process.cwd() fails)

    // Normalize the path
    resolvedPath = normalizeStringPosix(resolvedPath, !resolvedAbsolute);

    if (resolvedAbsolute) {
      if (resolvedPath.length > 0)
        return '/' + resolvedPath;
      else
        return '/';
    } else if (resolvedPath.length > 0) {
      return resolvedPath;
    } else {
      return '.';
    }
  },

  normalize: function normalize(path) {
    assertPath(path);

    if (path.length === 0) return '.';

    var isAbsolute = path.charCodeAt(0) === 47 /*/*/;
    var trailingSeparator = path.charCodeAt(path.length - 1) === 47 /*/*/;

    // Normalize the path
    path = normalizeStringPosix(path, !isAbsolute);

    if (path.length === 0 && !isAbsolute) path = '.';
    if (path.length > 0 && trailingSeparator) path += '/';

    if (isAbsolute) return '/' + path;
    return path;
  },

  isAbsolute: function isAbsolute(path) {
    assertPath(path);
    return path.length > 0 && path.charCodeAt(0) === 47 /*/*/;
  },

  join: function join() {
    if (arguments.length === 0)
      return '.';
    var joined;
    for (var i = 0; i < arguments.length; ++i) {
      var arg = arguments[i];
      assertPath(arg);
      if (arg.length > 0) {
        if (joined === undefined)
          joined = arg;
        else
          joined += '/' + arg;
      }
    }
    if (joined === undefined)
      return '.';
    return posix.normalize(joined);
  },

  relative: function relative(from, to) {
    assertPath(from);
    assertPath(to);

    if (from === to) return '';

    from = posix.resolve(from);
    to = posix.resolve(to);

    if (from === to) return '';

    // Trim any leading backslashes
    var fromStart = 1;
    for (; fromStart < from.length; ++fromStart) {
      if (from.charCodeAt(fromStart) !== 47 /*/*/)
        break;
    }
    var fromEnd = from.length;
    var fromLen = fromEnd - fromStart;

    // Trim any leading backslashes
    var toStart = 1;
    for (; toStart < to.length; ++toStart) {
      if (to.charCodeAt(toStart) !== 47 /*/*/)
        break;
    }
    var toEnd = to.length;
    var toLen = toEnd - toStart;

    // Compare paths to find the longest common path from root
    var length = fromLen < toLen ? fromLen : toLen;
    var lastCommonSep = -1;
    var i = 0;
    for (; i <= length; ++i) {
      if (i === length) {
        if (toLen > length) {
          if (to.charCodeAt(toStart + i) === 47 /*/*/) {
            // We get here if `from` is the exact base path for `to`.
            // For example: from='/foo/bar'; to='/foo/bar/baz'
            return to.slice(toStart + i + 1);
          } else if (i === 0) {
            // We get here if `from` is the root
            // For example: from='/'; to='/foo'
            return to.slice(toStart + i);
          }
        } else if (fromLen > length) {
          if (from.charCodeAt(fromStart + i) === 47 /*/*/) {
            // We get here if `to` is the exact base path for `from`.
            // For example: from='/foo/bar/baz'; to='/foo/bar'
            lastCommonSep = i;
          } else if (i === 0) {
            // We get here if `to` is the root.
            // For example: from='/foo'; to='/'
            lastCommonSep = 0;
          }
        }
        break;
      }
      var fromCode = from.charCodeAt(fromStart + i);
      var toCode = to.charCodeAt(toStart + i);
      if (fromCode !== toCode)
        break;
      else if (fromCode === 47 /*/*/)
        lastCommonSep = i;
    }

    var out = '';
    // Generate the relative path based on the path difference between `to`
    // and `from`
    for (i = fromStart + lastCommonSep + 1; i <= fromEnd; ++i) {
      if (i === fromEnd || from.charCodeAt(i) === 47 /*/*/) {
        if (out.length === 0)
          out += '..';
        else
          out += '/..';
      }
    }

    // Lastly, append the rest of the destination (`to`) path that comes after
    // the common path parts
    if (out.length > 0)
      return out + to.slice(toStart + lastCommonSep);
    else {
      toStart += lastCommonSep;
      if (to.charCodeAt(toStart) === 47 /*/*/)
        ++toStart;
      return to.slice(toStart);
    }
  },

  _makeLong: function _makeLong(path) {
    return path;
  },

  dirname: function dirname(path) {
    assertPath(path);
    if (path.length === 0) return '.';
    var code = path.charCodeAt(0);
    var hasRoot = code === 47 /*/*/;
    var end = -1;
    var matchedSlash = true;
    for (var i = path.length - 1; i >= 1; --i) {
      code = path.charCodeAt(i);
      if (code === 47 /*/*/) {
          if (!matchedSlash) {
            end = i;
            break;
          }
        } else {
        // We saw the first non-path separator
        matchedSlash = false;
      }
    }

    if (end === -1) return hasRoot ? '/' : '.';
    if (hasRoot && end === 1) return '//';
    return path.slice(0, end);
  },

  basename: function basename(path, ext) {
    if (ext !== undefined && typeof ext !== 'string') throw new TypeError('"ext" argument must be a string');
    assertPath(path);

    var start = 0;
    var end = -1;
    var matchedSlash = true;
    var i;

    if (ext !== undefined && ext.length > 0 && ext.length <= path.length) {
      if (ext.length === path.length && ext === path) return '';
      var extIdx = ext.length - 1;
      var firstNonSlashEnd = -1;
      for (i = path.length - 1; i >= 0; --i) {
        var code = path.charCodeAt(i);
        if (code === 47 /*/*/) {
            // If we reached a path separator that was not part of a set of path
            // separators at the end of the string, stop now
            if (!matchedSlash) {
              start = i + 1;
              break;
            }
          } else {
          if (firstNonSlashEnd === -1) {
            // We saw the first non-path separator, remember this index in case
            // we need it if the extension ends up not matching
            matchedSlash = false;
            firstNonSlashEnd = i + 1;
          }
          if (extIdx >= 0) {
            // Try to match the explicit extension
            if (code === ext.charCodeAt(extIdx)) {
              if (--extIdx === -1) {
                // We matched the extension, so mark this as the end of our path
                // component
                end = i;
              }
            } else {
              // Extension does not match, so our result is the entire path
              // component
              extIdx = -1;
              end = firstNonSlashEnd;
            }
          }
        }
      }

      if (start === end) end = firstNonSlashEnd;else if (end === -1) end = path.length;
      return path.slice(start, end);
    } else {
      for (i = path.length - 1; i >= 0; --i) {
        if (path.charCodeAt(i) === 47 /*/*/) {
            // If we reached a path separator that was not part of a set of path
            // separators at the end of the string, stop now
            if (!matchedSlash) {
              start = i + 1;
              break;
            }
          } else if (end === -1) {
          // We saw the first non-path separator, mark this as the end of our
          // path component
          matchedSlash = false;
          end = i + 1;
        }
      }

      if (end === -1) return '';
      return path.slice(start, end);
    }
  },

  extname: function extname(path) {
    assertPath(path);
    var startDot = -1;
    var startPart = 0;
    var end = -1;
    var matchedSlash = true;
    // Track the state of characters (if any) we see before our first dot and
    // after any path separator we find
    var preDotState = 0;
    for (var i = path.length - 1; i >= 0; --i) {
      var code = path.charCodeAt(i);
      if (code === 47 /*/*/) {
          // If we reached a path separator that was not part of a set of path
          // separators at the end of the string, stop now
          if (!matchedSlash) {
            startPart = i + 1;
            break;
          }
          continue;
        }
      if (end === -1) {
        // We saw the first non-path separator, mark this as the end of our
        // extension
        matchedSlash = false;
        end = i + 1;
      }
      if (code === 46 /*.*/) {
          // If this is our first dot, mark it as the start of our extension
          if (startDot === -1)
            startDot = i;
          else if (preDotState !== 1)
            preDotState = 1;
      } else if (startDot !== -1) {
        // We saw a non-dot and non-path separator before our dot, so we should
        // have a good chance at having a non-empty extension
        preDotState = -1;
      }
    }

    if (startDot === -1 || end === -1 ||
        // We saw a non-dot character immediately before the dot
        preDotState === 0 ||
        // The (right-most) trimmed path component is exactly '..'
        preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
      return '';
    }
    return path.slice(startDot, end);
  },

  format: function format(pathObject) {
    if (pathObject === null || typeof pathObject !== 'object') {
      throw new TypeError('The "pathObject" argument must be of type Object. Received type ' + typeof pathObject);
    }
    return _format('/', pathObject);
  },

  parse: function parse(path) {
    assertPath(path);

    var ret = { root: '', dir: '', base: '', ext: '', name: '' };
    if (path.length === 0) return ret;
    var code = path.charCodeAt(0);
    var isAbsolute = code === 47 /*/*/;
    var start;
    if (isAbsolute) {
      ret.root = '/';
      start = 1;
    } else {
      start = 0;
    }
    var startDot = -1;
    var startPart = 0;
    var end = -1;
    var matchedSlash = true;
    var i = path.length - 1;

    // Track the state of characters (if any) we see before our first dot and
    // after any path separator we find
    var preDotState = 0;

    // Get non-dir info
    for (; i >= start; --i) {
      code = path.charCodeAt(i);
      if (code === 47 /*/*/) {
          // If we reached a path separator that was not part of a set of path
          // separators at the end of the string, stop now
          if (!matchedSlash) {
            startPart = i + 1;
            break;
          }
          continue;
        }
      if (end === -1) {
        // We saw the first non-path separator, mark this as the end of our
        // extension
        matchedSlash = false;
        end = i + 1;
      }
      if (code === 46 /*.*/) {
          // If this is our first dot, mark it as the start of our extension
          if (startDot === -1) startDot = i;else if (preDotState !== 1) preDotState = 1;
        } else if (startDot !== -1) {
        // We saw a non-dot and non-path separator before our dot, so we should
        // have a good chance at having a non-empty extension
        preDotState = -1;
      }
    }

    if (startDot === -1 || end === -1 ||
    // We saw a non-dot character immediately before the dot
    preDotState === 0 ||
    // The (right-most) trimmed path component is exactly '..'
    preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
      if (end !== -1) {
        if (startPart === 0 && isAbsolute) ret.base = ret.name = path.slice(1, end);else ret.base = ret.name = path.slice(startPart, end);
      }
    } else {
      if (startPart === 0 && isAbsolute) {
        ret.name = path.slice(1, startDot);
        ret.base = path.slice(1, end);
      } else {
        ret.name = path.slice(startPart, startDot);
        ret.base = path.slice(startPart, end);
      }
      ret.ext = path.slice(startDot, end);
    }

    if (startPart > 0) ret.dir = path.slice(0, startPart - 1);else if (isAbsolute) ret.dir = '/';

    return ret;
  },

  sep: '/',
  delimiter: ':',
  win32: null,
  posix: null
};

posix.posix = posix;

module.exports = posix;

}).call(this)}).call(this,require('_process'))
},{"_process":223}],223:[function(require,module,exports){
// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) { return [] }

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };

},{}],224:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';

// If obj.hasOwnProperty has been overridden, then calling
// obj.hasOwnProperty(prop) will break.
// See: https://github.com/joyent/node/issues/1707
function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

module.exports = function(qs, sep, eq, options) {
  sep = sep || '&';
  eq = eq || '=';
  var obj = {};

  if (typeof qs !== 'string' || qs.length === 0) {
    return obj;
  }

  var regexp = /\+/g;
  qs = qs.split(sep);

  var maxKeys = 1000;
  if (options && typeof options.maxKeys === 'number') {
    maxKeys = options.maxKeys;
  }

  var len = qs.length;
  // maxKeys <= 0 means that we should not limit keys count
  if (maxKeys > 0 && len > maxKeys) {
    len = maxKeys;
  }

  for (var i = 0; i < len; ++i) {
    var x = qs[i].replace(regexp, '%20'),
        idx = x.indexOf(eq),
        kstr, vstr, k, v;

    if (idx >= 0) {
      kstr = x.substr(0, idx);
      vstr = x.substr(idx + 1);
    } else {
      kstr = x;
      vstr = '';
    }

    k = decodeURIComponent(kstr);
    v = decodeURIComponent(vstr);

    if (!hasOwnProperty(obj, k)) {
      obj[k] = v;
    } else if (isArray(obj[k])) {
      obj[k].push(v);
    } else {
      obj[k] = [obj[k], v];
    }
  }

  return obj;
};

var isArray = Array.isArray || function (xs) {
  return Object.prototype.toString.call(xs) === '[object Array]';
};

},{}],225:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';

var stringifyPrimitive = function(v) {
  switch (typeof v) {
    case 'string':
      return v;

    case 'boolean':
      return v ? 'true' : 'false';

    case 'number':
      return isFinite(v) ? v : '';

    default:
      return '';
  }
};

module.exports = function(obj, sep, eq, name) {
  sep = sep || '&';
  eq = eq || '=';
  if (obj === null) {
    obj = undefined;
  }

  if (typeof obj === 'object') {
    return map(objectKeys(obj), function(k) {
      var ks = encodeURIComponent(stringifyPrimitive(k)) + eq;
      if (isArray(obj[k])) {
        return map(obj[k], function(v) {
          return ks + encodeURIComponent(stringifyPrimitive(v));
        }).join(sep);
      } else {
        return ks + encodeURIComponent(stringifyPrimitive(obj[k]));
      }
    }).join(sep);

  }

  if (!name) return '';
  return encodeURIComponent(stringifyPrimitive(name)) + eq +
         encodeURIComponent(stringifyPrimitive(obj));
};

var isArray = Array.isArray || function (xs) {
  return Object.prototype.toString.call(xs) === '[object Array]';
};

function map (xs, f) {
  if (xs.map) return xs.map(f);
  var res = [];
  for (var i = 0; i < xs.length; i++) {
    res.push(f(xs[i], i));
  }
  return res;
}

var objectKeys = Object.keys || function (obj) {
  var res = [];
  for (var key in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, key)) res.push(key);
  }
  return res;
};

},{}],226:[function(require,module,exports){
'use strict';

exports.decode = exports.parse = require('./decode');
exports.encode = exports.stringify = require('./encode');

},{"./decode":224,"./encode":225}],227:[function(require,module,exports){
var URL = require('url').URL;

/**
 * Trims the white space from the start and end of the line.
 *
 * If the line is an array it will strip the white space from
 * the start and end of each element of the array.
 *
 * @param  {string|Array} line
 * @return {string|Array}
 * @private
 */
function trimLine(line) {
	if (!line) {
		return null;
	}

	if (Array.isArray(line)) {
		return line.map(trimLine);
	}

	return String(line).trim();
}

/**
 * Remove comments from lines
 *
 * @param {string} line 
 * @return {string}
 * @private
 */
function removeComments(line) {
	var commentStartIndex = line.indexOf('#');
	if (commentStartIndex > -1) {
		return line.substr(0, commentStartIndex);
	}

	return line;
}

/**
 * Splits a line at the first occurrence of :
 *
 * @param  {string} line
 * @return {Array.<string>}
 * @private
 */
function splitLine(line) {
	var idx = String(line).indexOf(':');

	if (!line || idx < 0) {
		return null;
	}

	return [line.slice(0, idx), line.slice(idx + 1)];
}

/**
 * Normalises the user-agent string by converting it to
 * lowercase and removing any version numbers.
 *
 * @param  {string} userAgent
 * @return {string}
 * @private
 */
function formatUserAgent(userAgent) {
	var formattedUserAgent = userAgent.toLowerCase();

	// Strip the version number from robot/1.0 user agents
	var idx = formattedUserAgent.indexOf('/');
	if (idx > -1) {
		formattedUserAgent = formattedUserAgent.substr(0, idx);
	}

	return formattedUserAgent.trim();
}

/**
 * Normalises the URL encoding of a path by encoding
 * unicode characters.
 * 
 * @param {string} path
 * @return {string}
 * @private
 */
function normaliseEncoding(path) {
	try {
		return urlEncodeToUpper(encodeURI(path).replace(/%25/g, '%'));
	} catch(e) {
		return path;
	}
}

/**
 * Convert URL encodings to upport case.
 * 
 * e.g.: %2a%ef becomes %2A%EF 
 * 
 * @param {string} path
 * @return {string}
 * @private
 */
function urlEncodeToUpper(path) {
	return path.replace(/%[0-9a-fA-F]{2}/g, function (match) {
		return match.toUpperCase();
	});
}

/**
 * Converts the pattern into a regexp if it is a wildcard
 * pattern.
 *
 * Returns a string if the pattern isn't a wildcard pattern
 *
 * @param  {string} pattern
 * @return {string|RegExp}
 * @private
 */
function parsePattern(pattern) {
	var regexSpecialChars = /[\-\[\]\/\{\}\(\)\+\?\.\\\^\$\|]/g;
	var wildCardPattern = /\*/g;
	var endOfLinePattern = /\\\$$/;

	pattern = normaliseEncoding(pattern)

	if (pattern.indexOf('*') < 0 && pattern.indexOf('$') < 0) {
		return pattern;
	}

	pattern = pattern
		.replace(regexSpecialChars, '\\$&')
		.replace(wildCardPattern, '(?:.*)')
		.replace(endOfLinePattern, '$');

	return new RegExp(pattern);
}

function parseRobots(contents, robots) {
	var newlineRegex = /\r\n|\r|\n/;
	var lines = contents
		.split(newlineRegex)
		.map(removeComments)
		.map(splitLine)
		.map(trimLine);

	var currentUserAgents = [];
	var isNoneUserAgentState = true;
	for (var i=0; i < lines.length; i++) {
		var line = lines[i];

		if (!line || !line[0]) {
			continue;
		}

		switch (line[0].toLowerCase()) {
			case 'user-agent':
				if (isNoneUserAgentState) {
					currentUserAgents.length = 0;
				}

				if (line[1]) {
					currentUserAgents.push(formatUserAgent(line[1]));
				}
				break;
			case 'disallow':
				robots.addRule(currentUserAgents, line[1], false, i + 1);
				break;
			case 'allow':
				robots.addRule(currentUserAgents, line[1], true, i + 1);
				break;
			case 'crawl-delay':
				robots.setCrawlDelay(currentUserAgents, line[1]);
				break;
			case 'sitemap':
				if (line[1]) {
					robots.addSitemap(line[1]);
				}
				break;
			case 'host':
				if (line[1]) {
					robots.setPreferredHost(line[1].toLowerCase());
				}
				break;
		}

		isNoneUserAgentState = line[0].toLowerCase() !== 'user-agent';
	}
}

/**
 * Returns if a pattern is allowed by the specified rules.
 *
 * @param  {string}  path
 * @param  {Array.<Object>}  rules
 * @return {Object?}
 * @private
 */
function findRule(path, rules) {
   var matchingRule = null;

   for (var i=0; i < rules.length; i++) {
	   var rule = rules[i];

	   if (typeof rule.pattern === 'string') {
		   if (path.indexOf(rule.pattern) !== 0) {
			   continue;
		   }

		   // The longest matching rule takes precedence
		   if (!matchingRule || rule.pattern.length > matchingRule.pattern.length) {
			   matchingRule = rule;
		   }
	   // The first matching pattern takes precedence
	   // over all other rules including other patterns
	   } else if (rule.pattern.test(path)) {
		   return rule;
	   }
   }

   return matchingRule;
}

/**
 * Converts provided string into an URL object.
 * 
 * Will return null if provided string is not a valid URL.
 * 
 * @param {string} url 
 * @return {?URL}
 * @private
 */
function parseUrl(url) {
	try {
		return new URL(url);
	} catch(e) {
		return null;
	}
}


function Robots(url, contents) {
	this._url = parseUrl(url) || {};
	this._url.port = this._url.port || 80;

	this._rules = {};
	this._sitemaps = [];
	this._preferedHost = null;

	parseRobots(contents || '', this);
}

/**
 * Adds the specified allow/deny rule to the rules
 * for the specified user-agents.
 *
 * @param {Array.<string>} userAgents
 * @param {string} pattern
 * @param {boolean} allow
 * @param {number} [lineNumber] Should use 1-based indexing
 */
Robots.prototype.addRule = function (userAgents, pattern, allow, lineNumber) {
	var rules = this._rules;

	userAgents.forEach(function (userAgent) {
		rules[userAgent] = rules[userAgent] || [];

		if (!pattern) {
			return;
		}

		rules[userAgent].push({
			pattern: parsePattern(pattern),
			allow: allow,
			lineNumber: lineNumber
		});
	});
};

/**
 * Adds the specified delay to the specified user agents.
 *
 * @param {Array.<string>} userAgents
 * @param {string} delayStr
 */
Robots.prototype.setCrawlDelay = function (userAgents, delayStr) {
	var rules = this._rules;
	var delay = Number(delayStr);

	userAgents.forEach(function (userAgent) {
		rules[userAgent] = rules[userAgent] || [];

		if (isNaN(delay)) {
			return;
		}

		rules[userAgent].crawlDelay = delay;
	});
};

/**
 * Add a sitemap
 *
 * @param {string} url
 */
Robots.prototype.addSitemap = function (url) {
	this._sitemaps.push(url);
};

/**
 * Sets the preferred host name
 *
 * @param {string} url
 */
Robots.prototype.setPreferredHost = function (url) {
	this._preferedHost = url;
};

Robots.prototype._getRule = function (url, ua) {
	var parsedUrl = parseUrl(url) || {};
	var userAgent = formatUserAgent(ua || '*');

	parsedUrl.port = parsedUrl.port || '80';

	// The base URL must match otherwise this robots.txt is not valid for it.
	if (parsedUrl.protocol !== this._url.protocol ||
		parsedUrl.hostname !== this._url.hostname ||
		parsedUrl.port !== this._url.port) {
		return;
	}

	var rules = this._rules[userAgent] || this._rules['*'] || [];
	var path = urlEncodeToUpper(parsedUrl.pathname + parsedUrl.search)
	var rule = findRule(path, rules);

	return rule;
};

/**
 * Returns true if allowed, false if not allowed.
 *
 * Will return undefined if the URL is not valid for
 * this robots.txt file.
 *
 * @param  {string}  url
 * @param  {string?}  ua
 * @return {boolean?}
 */
Robots.prototype.isAllowed = function (url, ua) {
	var rule = this._getRule(url, ua);

	if (typeof rule === 'undefined') {
		return;
	}

	return !rule || rule.allow;
};

/**
 * Returns the line number of the matching directive for the specified
 * URL and user-agent if any.
 *
 * The line numbers start at 1 and go up (1-based indexing).
 *
 * Return -1 if there is no matching directive. If a rule is manually
 * added without a lineNumber then this will return undefined for that
 * rule.
 *
 * @param  {string}  url
 * @param  {string?}  ua
 * @return {number?}
 */
Robots.prototype.getMatchingLineNumber = function (url, ua) {
	var rule = this._getRule(url, ua);

	return rule ? rule.lineNumber : -1;
};

/**
 * Returns the opposite of isAllowed()
 *
 * @param  {string}  url
 * @param  {string}  ua
 * @return {boolean}
 */
Robots.prototype.isDisallowed = function (url, ua) {
	return !this.isAllowed(url, ua);
};

/**
 * Gets the crawl delay if there is one.
 *
 * Will return undefined if there is no crawl delay set.
 *
 * @param  {string} ua
 * @return {number?}
 */
Robots.prototype.getCrawlDelay = function (ua) {
	var userAgent = formatUserAgent(ua || '*');

	return (this._rules[userAgent] || this._rules['*'] || {}).crawlDelay;
};

/**
 * Returns the preferred host if there is one.
 *
 * @return {string?}
 */
Robots.prototype.getPreferredHost = function () {
	return this._preferedHost;
};

/**
 * Returns an array of sitemap URLs if there are any.
 *
 * @return {Array.<string>}
 */
Robots.prototype.getSitemaps = function () {
	return this._sitemaps.slice(0);
};

module.exports = Robots;

},{"url":"url"}],228:[function(require,module,exports){
var Robots = require('./Robots');

module.exports = function (url, contents) {
	return new Robots(url, contents);
};
},{"./Robots":227}],229:[function(require,module,exports){
/*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
/* eslint-disable node/no-deprecated-api */
var buffer = require('buffer')
var Buffer = buffer.Buffer

// alternative to using Object.keys for old browsers
function copyProps (src, dst) {
  for (var key in src) {
    dst[key] = src[key]
  }
}
if (Buffer.from && Buffer.alloc && Buffer.allocUnsafe && Buffer.allocUnsafeSlow) {
  module.exports = buffer
} else {
  // Copy properties from require('buffer')
  copyProps(buffer, exports)
  exports.Buffer = SafeBuffer
}

function SafeBuffer (arg, encodingOrOffset, length) {
  return Buffer(arg, encodingOrOffset, length)
}

SafeBuffer.prototype = Object.create(Buffer.prototype)

// Copy static methods from Buffer
copyProps(Buffer, SafeBuffer)

SafeBuffer.from = function (arg, encodingOrOffset, length) {
  if (typeof arg === 'number') {
    throw new TypeError('Argument must not be a number')
  }
  return Buffer(arg, encodingOrOffset, length)
}

SafeBuffer.alloc = function (size, fill, encoding) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  var buf = Buffer(size)
  if (fill !== undefined) {
    if (typeof encoding === 'string') {
      buf.fill(fill, encoding)
    } else {
      buf.fill(fill)
    }
  } else {
    buf.fill(0)
  }
  return buf
}

SafeBuffer.allocUnsafe = function (size) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  return Buffer(size)
}

SafeBuffer.allocUnsafeSlow = function (size) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  return buffer.SlowBuffer(size)
}

},{"buffer":145}],230:[function(require,module,exports){
(function (process){(function (){
exports = module.exports = SemVer

var debug
/* istanbul ignore next */
if (typeof process === 'object' &&
    process.env &&
    process.env.NODE_DEBUG &&
    /\bsemver\b/i.test(process.env.NODE_DEBUG)) {
  debug = function () {
    var args = Array.prototype.slice.call(arguments, 0)
    args.unshift('SEMVER')
    console.log.apply(console, args)
  }
} else {
  debug = function () {}
}

// Note: this is the semver.org version of the spec that it implements
// Not necessarily the package version of this code.
exports.SEMVER_SPEC_VERSION = '2.0.0'

var MAX_LENGTH = 256
var MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER ||
  /* istanbul ignore next */ 9007199254740991

// Max safe segment length for coercion.
var MAX_SAFE_COMPONENT_LENGTH = 16

// The actual regexps go on exports.re
var re = exports.re = []
var src = exports.src = []
var R = 0

// The following Regular Expressions can be used for tokenizing,
// validating, and parsing SemVer version strings.

// ## Numeric Identifier
// A single `0`, or a non-zero digit followed by zero or more digits.

var NUMERICIDENTIFIER = R++
src[NUMERICIDENTIFIER] = '0|[1-9]\\d*'
var NUMERICIDENTIFIERLOOSE = R++
src[NUMERICIDENTIFIERLOOSE] = '[0-9]+'

// ## Non-numeric Identifier
// Zero or more digits, followed by a letter or hyphen, and then zero or
// more letters, digits, or hyphens.

var NONNUMERICIDENTIFIER = R++
src[NONNUMERICIDENTIFIER] = '\\d*[a-zA-Z-][a-zA-Z0-9-]*'

// ## Main Version
// Three dot-separated numeric identifiers.

var MAINVERSION = R++
src[MAINVERSION] = '(' + src[NUMERICIDENTIFIER] + ')\\.' +
                   '(' + src[NUMERICIDENTIFIER] + ')\\.' +
                   '(' + src[NUMERICIDENTIFIER] + ')'

var MAINVERSIONLOOSE = R++
src[MAINVERSIONLOOSE] = '(' + src[NUMERICIDENTIFIERLOOSE] + ')\\.' +
                        '(' + src[NUMERICIDENTIFIERLOOSE] + ')\\.' +
                        '(' + src[NUMERICIDENTIFIERLOOSE] + ')'

// ## Pre-release Version Identifier
// A numeric identifier, or a non-numeric identifier.

var PRERELEASEIDENTIFIER = R++
src[PRERELEASEIDENTIFIER] = '(?:' + src[NUMERICIDENTIFIER] +
                            '|' + src[NONNUMERICIDENTIFIER] + ')'

var PRERELEASEIDENTIFIERLOOSE = R++
src[PRERELEASEIDENTIFIERLOOSE] = '(?:' + src[NUMERICIDENTIFIERLOOSE] +
                                 '|' + src[NONNUMERICIDENTIFIER] + ')'

// ## Pre-release Version
// Hyphen, followed by one or more dot-separated pre-release version
// identifiers.

var PRERELEASE = R++
src[PRERELEASE] = '(?:-(' + src[PRERELEASEIDENTIFIER] +
                  '(?:\\.' + src[PRERELEASEIDENTIFIER] + ')*))'

var PRERELEASELOOSE = R++
src[PRERELEASELOOSE] = '(?:-?(' + src[PRERELEASEIDENTIFIERLOOSE] +
                       '(?:\\.' + src[PRERELEASEIDENTIFIERLOOSE] + ')*))'

// ## Build Metadata Identifier
// Any combination of digits, letters, or hyphens.

var BUILDIDENTIFIER = R++
src[BUILDIDENTIFIER] = '[0-9A-Za-z-]+'

// ## Build Metadata
// Plus sign, followed by one or more period-separated build metadata
// identifiers.

var BUILD = R++
src[BUILD] = '(?:\\+(' + src[BUILDIDENTIFIER] +
             '(?:\\.' + src[BUILDIDENTIFIER] + ')*))'

// ## Full Version String
// A main version, followed optionally by a pre-release version and
// build metadata.

// Note that the only major, minor, patch, and pre-release sections of
// the version string are capturing groups.  The build metadata is not a
// capturing group, because it should not ever be used in version
// comparison.

var FULL = R++
var FULLPLAIN = 'v?' + src[MAINVERSION] +
                src[PRERELEASE] + '?' +
                src[BUILD] + '?'

src[FULL] = '^' + FULLPLAIN + '$'

// like full, but allows v1.2.3 and =1.2.3, which people do sometimes.
// also, 1.0.0alpha1 (prerelease without the hyphen) which is pretty
// common in the npm registry.
var LOOSEPLAIN = '[v=\\s]*' + src[MAINVERSIONLOOSE] +
                 src[PRERELEASELOOSE] + '?' +
                 src[BUILD] + '?'

var LOOSE = R++
src[LOOSE] = '^' + LOOSEPLAIN + '$'

var GTLT = R++
src[GTLT] = '((?:<|>)?=?)'

// Something like "2.*" or "1.2.x".
// Note that "x.x" is a valid xRange identifer, meaning "any version"
// Only the first item is strictly required.
var XRANGEIDENTIFIERLOOSE = R++
src[XRANGEIDENTIFIERLOOSE] = src[NUMERICIDENTIFIERLOOSE] + '|x|X|\\*'
var XRANGEIDENTIFIER = R++
src[XRANGEIDENTIFIER] = src[NUMERICIDENTIFIER] + '|x|X|\\*'

var XRANGEPLAIN = R++
src[XRANGEPLAIN] = '[v=\\s]*(' + src[XRANGEIDENTIFIER] + ')' +
                   '(?:\\.(' + src[XRANGEIDENTIFIER] + ')' +
                   '(?:\\.(' + src[XRANGEIDENTIFIER] + ')' +
                   '(?:' + src[PRERELEASE] + ')?' +
                   src[BUILD] + '?' +
                   ')?)?'

var XRANGEPLAINLOOSE = R++
src[XRANGEPLAINLOOSE] = '[v=\\s]*(' + src[XRANGEIDENTIFIERLOOSE] + ')' +
                        '(?:\\.(' + src[XRANGEIDENTIFIERLOOSE] + ')' +
                        '(?:\\.(' + src[XRANGEIDENTIFIERLOOSE] + ')' +
                        '(?:' + src[PRERELEASELOOSE] + ')?' +
                        src[BUILD] + '?' +
                        ')?)?'

var XRANGE = R++
src[XRANGE] = '^' + src[GTLT] + '\\s*' + src[XRANGEPLAIN] + '$'
var XRANGELOOSE = R++
src[XRANGELOOSE] = '^' + src[GTLT] + '\\s*' + src[XRANGEPLAINLOOSE] + '$'

// Coercion.
// Extract anything that could conceivably be a part of a valid semver
var COERCE = R++
src[COERCE] = '(?:^|[^\\d])' +
              '(\\d{1,' + MAX_SAFE_COMPONENT_LENGTH + '})' +
              '(?:\\.(\\d{1,' + MAX_SAFE_COMPONENT_LENGTH + '}))?' +
              '(?:\\.(\\d{1,' + MAX_SAFE_COMPONENT_LENGTH + '}))?' +
              '(?:$|[^\\d])'

// Tilde ranges.
// Meaning is "reasonably at or greater than"
var LONETILDE = R++
src[LONETILDE] = '(?:~>?)'

var TILDETRIM = R++
src[TILDETRIM] = '(\\s*)' + src[LONETILDE] + '\\s+'
re[TILDETRIM] = new RegExp(src[TILDETRIM], 'g')
var tildeTrimReplace = '$1~'

var TILDE = R++
src[TILDE] = '^' + src[LONETILDE] + src[XRANGEPLAIN] + '$'
var TILDELOOSE = R++
src[TILDELOOSE] = '^' + src[LONETILDE] + src[XRANGEPLAINLOOSE] + '$'

// Caret ranges.
// Meaning is "at least and backwards compatible with"
var LONECARET = R++
src[LONECARET] = '(?:\\^)'

var CARETTRIM = R++
src[CARETTRIM] = '(\\s*)' + src[LONECARET] + '\\s+'
re[CARETTRIM] = new RegExp(src[CARETTRIM], 'g')
var caretTrimReplace = '$1^'

var CARET = R++
src[CARET] = '^' + src[LONECARET] + src[XRANGEPLAIN] + '$'
var CARETLOOSE = R++
src[CARETLOOSE] = '^' + src[LONECARET] + src[XRANGEPLAINLOOSE] + '$'

// A simple gt/lt/eq thing, or just "" to indicate "any version"
var COMPARATORLOOSE = R++
src[COMPARATORLOOSE] = '^' + src[GTLT] + '\\s*(' + LOOSEPLAIN + ')$|^$'
var COMPARATOR = R++
src[COMPARATOR] = '^' + src[GTLT] + '\\s*(' + FULLPLAIN + ')$|^$'

// An expression to strip any whitespace between the gtlt and the thing
// it modifies, so that `> 1.2.3` ==> `>1.2.3`
var COMPARATORTRIM = R++
src[COMPARATORTRIM] = '(\\s*)' + src[GTLT] +
                      '\\s*(' + LOOSEPLAIN + '|' + src[XRANGEPLAIN] + ')'

// this one has to use the /g flag
re[COMPARATORTRIM] = new RegExp(src[COMPARATORTRIM], 'g')
var comparatorTrimReplace = '$1$2$3'

// Something like `1.2.3 - 1.2.4`
// Note that these all use the loose form, because they'll be
// checked against either the strict or loose comparator form
// later.
var HYPHENRANGE = R++
src[HYPHENRANGE] = '^\\s*(' + src[XRANGEPLAIN] + ')' +
                   '\\s+-\\s+' +
                   '(' + src[XRANGEPLAIN] + ')' +
                   '\\s*$'

var HYPHENRANGELOOSE = R++
src[HYPHENRANGELOOSE] = '^\\s*(' + src[XRANGEPLAINLOOSE] + ')' +
                        '\\s+-\\s+' +
                        '(' + src[XRANGEPLAINLOOSE] + ')' +
                        '\\s*$'

// Star ranges basically just allow anything at all.
var STAR = R++
src[STAR] = '(<|>)?=?\\s*\\*'

// Compile to actual regexp objects.
// All are flag-free, unless they were created above with a flag.
for (var i = 0; i < R; i++) {
  debug(i, src[i])
  if (!re[i]) {
    re[i] = new RegExp(src[i])
  }
}

exports.parse = parse
function parse (version, options) {
  if (!options || typeof options !== 'object') {
    options = {
      loose: !!options,
      includePrerelease: false
    }
  }

  if (version instanceof SemVer) {
    return version
  }

  if (typeof version !== 'string') {
    return null
  }

  if (version.length > MAX_LENGTH) {
    return null
  }

  var r = options.loose ? re[LOOSE] : re[FULL]
  if (!r.test(version)) {
    return null
  }

  try {
    return new SemVer(version, options)
  } catch (er) {
    return null
  }
}

exports.valid = valid
function valid (version, options) {
  var v = parse(version, options)
  return v ? v.version : null
}

exports.clean = clean
function clean (version, options) {
  var s = parse(version.trim().replace(/^[=v]+/, ''), options)
  return s ? s.version : null
}

exports.SemVer = SemVer

function SemVer (version, options) {
  if (!options || typeof options !== 'object') {
    options = {
      loose: !!options,
      includePrerelease: false
    }
  }
  if (version instanceof SemVer) {
    if (version.loose === options.loose) {
      return version
    } else {
      version = version.version
    }
  } else if (typeof version !== 'string') {
    throw new TypeError('Invalid Version: ' + version)
  }

  if (version.length > MAX_LENGTH) {
    throw new TypeError('version is longer than ' + MAX_LENGTH + ' characters')
  }

  if (!(this instanceof SemVer)) {
    return new SemVer(version, options)
  }

  debug('SemVer', version, options)
  this.options = options
  this.loose = !!options.loose

  var m = version.trim().match(options.loose ? re[LOOSE] : re[FULL])

  if (!m) {
    throw new TypeError('Invalid Version: ' + version)
  }

  this.raw = version

  // these are actually numbers
  this.major = +m[1]
  this.minor = +m[2]
  this.patch = +m[3]

  if (this.major > MAX_SAFE_INTEGER || this.major < 0) {
    throw new TypeError('Invalid major version')
  }

  if (this.minor > MAX_SAFE_INTEGER || this.minor < 0) {
    throw new TypeError('Invalid minor version')
  }

  if (this.patch > MAX_SAFE_INTEGER || this.patch < 0) {
    throw new TypeError('Invalid patch version')
  }

  // numberify any prerelease numeric ids
  if (!m[4]) {
    this.prerelease = []
  } else {
    this.prerelease = m[4].split('.').map(function (id) {
      if (/^[0-9]+$/.test(id)) {
        var num = +id
        if (num >= 0 && num < MAX_SAFE_INTEGER) {
          return num
        }
      }
      return id
    })
  }

  this.build = m[5] ? m[5].split('.') : []
  this.format()
}

SemVer.prototype.format = function () {
  this.version = this.major + '.' + this.minor + '.' + this.patch
  if (this.prerelease.length) {
    this.version += '-' + this.prerelease.join('.')
  }
  return this.version
}

SemVer.prototype.toString = function () {
  return this.version
}

SemVer.prototype.compare = function (other) {
  debug('SemVer.compare', this.version, this.options, other)
  if (!(other instanceof SemVer)) {
    other = new SemVer(other, this.options)
  }

  return this.compareMain(other) || this.comparePre(other)
}

SemVer.prototype.compareMain = function (other) {
  if (!(other instanceof SemVer)) {
    other = new SemVer(other, this.options)
  }

  return compareIdentifiers(this.major, other.major) ||
         compareIdentifiers(this.minor, other.minor) ||
         compareIdentifiers(this.patch, other.patch)
}

SemVer.prototype.comparePre = function (other) {
  if (!(other instanceof SemVer)) {
    other = new SemVer(other, this.options)
  }

  // NOT having a prerelease is > having one
  if (this.prerelease.length && !other.prerelease.length) {
    return -1
  } else if (!this.prerelease.length && other.prerelease.length) {
    return 1
  } else if (!this.prerelease.length && !other.prerelease.length) {
    return 0
  }

  var i = 0
  do {
    var a = this.prerelease[i]
    var b = other.prerelease[i]
    debug('prerelease compare', i, a, b)
    if (a === undefined && b === undefined) {
      return 0
    } else if (b === undefined) {
      return 1
    } else if (a === undefined) {
      return -1
    } else if (a === b) {
      continue
    } else {
      return compareIdentifiers(a, b)
    }
  } while (++i)
}

// preminor will bump the version up to the next minor release, and immediately
// down to pre-release. premajor and prepatch work the same way.
SemVer.prototype.inc = function (release, identifier) {
  switch (release) {
    case 'premajor':
      this.prerelease.length = 0
      this.patch = 0
      this.minor = 0
      this.major++
      this.inc('pre', identifier)
      break
    case 'preminor':
      this.prerelease.length = 0
      this.patch = 0
      this.minor++
      this.inc('pre', identifier)
      break
    case 'prepatch':
      // If this is already a prerelease, it will bump to the next version
      // drop any prereleases that might already exist, since they are not
      // relevant at this point.
      this.prerelease.length = 0
      this.inc('patch', identifier)
      this.inc('pre', identifier)
      break
    // If the input is a non-prerelease version, this acts the same as
    // prepatch.
    case 'prerelease':
      if (this.prerelease.length === 0) {
        this.inc('patch', identifier)
      }
      this.inc('pre', identifier)
      break

    case 'major':
      // If this is a pre-major version, bump up to the same major version.
      // Otherwise increment major.
      // 1.0.0-5 bumps to 1.0.0
      // 1.1.0 bumps to 2.0.0
      if (this.minor !== 0 ||
          this.patch !== 0 ||
          this.prerelease.length === 0) {
        this.major++
      }
      this.minor = 0
      this.patch = 0
      this.prerelease = []
      break
    case 'minor':
      // If this is a pre-minor version, bump up to the same minor version.
      // Otherwise increment minor.
      // 1.2.0-5 bumps to 1.2.0
      // 1.2.1 bumps to 1.3.0
      if (this.patch !== 0 || this.prerelease.length === 0) {
        this.minor++
      }
      this.patch = 0
      this.prerelease = []
      break
    case 'patch':
      // If this is not a pre-release version, it will increment the patch.
      // If it is a pre-release it will bump up to the same patch version.
      // 1.2.0-5 patches to 1.2.0
      // 1.2.0 patches to 1.2.1
      if (this.prerelease.length === 0) {
        this.patch++
      }
      this.prerelease = []
      break
    // This probably shouldn't be used publicly.
    // 1.0.0 "pre" would become 1.0.0-0 which is the wrong direction.
    case 'pre':
      if (this.prerelease.length === 0) {
        this.prerelease = [0]
      } else {
        var i = this.prerelease.length
        while (--i >= 0) {
          if (typeof this.prerelease[i] === 'number') {
            this.prerelease[i]++
            i = -2
          }
        }
        if (i === -1) {
          // didn't increment anything
          this.prerelease.push(0)
        }
      }
      if (identifier) {
        // 1.2.0-beta.1 bumps to 1.2.0-beta.2,
        // 1.2.0-beta.fooblz or 1.2.0-beta bumps to 1.2.0-beta.0
        if (this.prerelease[0] === identifier) {
          if (isNaN(this.prerelease[1])) {
            this.prerelease = [identifier, 0]
          }
        } else {
          this.prerelease = [identifier, 0]
        }
      }
      break

    default:
      throw new Error('invalid increment argument: ' + release)
  }
  this.format()
  this.raw = this.version
  return this
}

exports.inc = inc
function inc (version, release, loose, identifier) {
  if (typeof (loose) === 'string') {
    identifier = loose
    loose = undefined
  }

  try {
    return new SemVer(version, loose).inc(release, identifier).version
  } catch (er) {
    return null
  }
}

exports.diff = diff
function diff (version1, version2) {
  if (eq(version1, version2)) {
    return null
  } else {
    var v1 = parse(version1)
    var v2 = parse(version2)
    var prefix = ''
    if (v1.prerelease.length || v2.prerelease.length) {
      prefix = 'pre'
      var defaultResult = 'prerelease'
    }
    for (var key in v1) {
      if (key === 'major' || key === 'minor' || key === 'patch') {
        if (v1[key] !== v2[key]) {
          return prefix + key
        }
      }
    }
    return defaultResult // may be undefined
  }
}

exports.compareIdentifiers = compareIdentifiers

var numeric = /^[0-9]+$/
function compareIdentifiers (a, b) {
  var anum = numeric.test(a)
  var bnum = numeric.test(b)

  if (anum && bnum) {
    a = +a
    b = +b
  }

  return a === b ? 0
    : (anum && !bnum) ? -1
    : (bnum && !anum) ? 1
    : a < b ? -1
    : 1
}

exports.rcompareIdentifiers = rcompareIdentifiers
function rcompareIdentifiers (a, b) {
  return compareIdentifiers(b, a)
}

exports.major = major
function major (a, loose) {
  return new SemVer(a, loose).major
}

exports.minor = minor
function minor (a, loose) {
  return new SemVer(a, loose).minor
}

exports.patch = patch
function patch (a, loose) {
  return new SemVer(a, loose).patch
}

exports.compare = compare
function compare (a, b, loose) {
  return new SemVer(a, loose).compare(new SemVer(b, loose))
}

exports.compareLoose = compareLoose
function compareLoose (a, b) {
  return compare(a, b, true)
}

exports.rcompare = rcompare
function rcompare (a, b, loose) {
  return compare(b, a, loose)
}

exports.sort = sort
function sort (list, loose) {
  return list.sort(function (a, b) {
    return exports.compare(a, b, loose)
  })
}

exports.rsort = rsort
function rsort (list, loose) {
  return list.sort(function (a, b) {
    return exports.rcompare(a, b, loose)
  })
}

exports.gt = gt
function gt (a, b, loose) {
  return compare(a, b, loose) > 0
}

exports.lt = lt
function lt (a, b, loose) {
  return compare(a, b, loose) < 0
}

exports.eq = eq
function eq (a, b, loose) {
  return compare(a, b, loose) === 0
}

exports.neq = neq
function neq (a, b, loose) {
  return compare(a, b, loose) !== 0
}

exports.gte = gte
function gte (a, b, loose) {
  return compare(a, b, loose) >= 0
}

exports.lte = lte
function lte (a, b, loose) {
  return compare(a, b, loose) <= 0
}

exports.cmp = cmp
function cmp (a, op, b, loose) {
  switch (op) {
    case '===':
      if (typeof a === 'object')
        a = a.version
      if (typeof b === 'object')
        b = b.version
      return a === b

    case '!==':
      if (typeof a === 'object')
        a = a.version
      if (typeof b === 'object')
        b = b.version
      return a !== b

    case '':
    case '=':
    case '==':
      return eq(a, b, loose)

    case '!=':
      return neq(a, b, loose)

    case '>':
      return gt(a, b, loose)

    case '>=':
      return gte(a, b, loose)

    case '<':
      return lt(a, b, loose)

    case '<=':
      return lte(a, b, loose)

    default:
      throw new TypeError('Invalid operator: ' + op)
  }
}

exports.Comparator = Comparator
function Comparator (comp, options) {
  if (!options || typeof options !== 'object') {
    options = {
      loose: !!options,
      includePrerelease: false
    }
  }

  if (comp instanceof Comparator) {
    if (comp.loose === !!options.loose) {
      return comp
    } else {
      comp = comp.value
    }
  }

  if (!(this instanceof Comparator)) {
    return new Comparator(comp, options)
  }

  debug('comparator', comp, options)
  this.options = options
  this.loose = !!options.loose
  this.parse(comp)

  if (this.semver === ANY) {
    this.value = ''
  } else {
    this.value = this.operator + this.semver.version
  }

  debug('comp', this)
}

var ANY = {}
Comparator.prototype.parse = function (comp) {
  var r = this.options.loose ? re[COMPARATORLOOSE] : re[COMPARATOR]
  var m = comp.match(r)

  if (!m) {
    throw new TypeError('Invalid comparator: ' + comp)
  }

  this.operator = m[1]
  if (this.operator === '=') {
    this.operator = ''
  }

  // if it literally is just '>' or '' then allow anything.
  if (!m[2]) {
    this.semver = ANY
  } else {
    this.semver = new SemVer(m[2], this.options.loose)
  }
}

Comparator.prototype.toString = function () {
  return this.value
}

Comparator.prototype.test = function (version) {
  debug('Comparator.test', version, this.options.loose)

  if (this.semver === ANY) {
    return true
  }

  if (typeof version === 'string') {
    version = new SemVer(version, this.options)
  }

  return cmp(version, this.operator, this.semver, this.options)
}

Comparator.prototype.intersects = function (comp, options) {
  if (!(comp instanceof Comparator)) {
    throw new TypeError('a Comparator is required')
  }

  if (!options || typeof options !== 'object') {
    options = {
      loose: !!options,
      includePrerelease: false
    }
  }

  var rangeTmp

  if (this.operator === '') {
    rangeTmp = new Range(comp.value, options)
    return satisfies(this.value, rangeTmp, options)
  } else if (comp.operator === '') {
    rangeTmp = new Range(this.value, options)
    return satisfies(comp.semver, rangeTmp, options)
  }

  var sameDirectionIncreasing =
    (this.operator === '>=' || this.operator === '>') &&
    (comp.operator === '>=' || comp.operator === '>')
  var sameDirectionDecreasing =
    (this.operator === '<=' || this.operator === '<') &&
    (comp.operator === '<=' || comp.operator === '<')
  var sameSemVer = this.semver.version === comp.semver.version
  var differentDirectionsInclusive =
    (this.operator === '>=' || this.operator === '<=') &&
    (comp.operator === '>=' || comp.operator === '<=')
  var oppositeDirectionsLessThan =
    cmp(this.semver, '<', comp.semver, options) &&
    ((this.operator === '>=' || this.operator === '>') &&
    (comp.operator === '<=' || comp.operator === '<'))
  var oppositeDirectionsGreaterThan =
    cmp(this.semver, '>', comp.semver, options) &&
    ((this.operator === '<=' || this.operator === '<') &&
    (comp.operator === '>=' || comp.operator === '>'))

  return sameDirectionIncreasing || sameDirectionDecreasing ||
    (sameSemVer && differentDirectionsInclusive) ||
    oppositeDirectionsLessThan || oppositeDirectionsGreaterThan
}

exports.Range = Range
function Range (range, options) {
  if (!options || typeof options !== 'object') {
    options = {
      loose: !!options,
      includePrerelease: false
    }
  }

  if (range instanceof Range) {
    if (range.loose === !!options.loose &&
        range.includePrerelease === !!options.includePrerelease) {
      return range
    } else {
      return new Range(range.raw, options)
    }
  }

  if (range instanceof Comparator) {
    return new Range(range.value, options)
  }

  if (!(this instanceof Range)) {
    return new Range(range, options)
  }

  this.options = options
  this.loose = !!options.loose
  this.includePrerelease = !!options.includePrerelease

  // First, split based on boolean or ||
  this.raw = range
  this.set = range.split(/\s*\|\|\s*/).map(function (range) {
    return this.parseRange(range.trim())
  }, this).filter(function (c) {
    // throw out any that are not relevant for whatever reason
    return c.length
  })

  if (!this.set.length) {
    throw new TypeError('Invalid SemVer Range: ' + range)
  }

  this.format()
}

Range.prototype.format = function () {
  this.range = this.set.map(function (comps) {
    return comps.join(' ').trim()
  }).join('||').trim()
  return this.range
}

Range.prototype.toString = function () {
  return this.range
}

Range.prototype.parseRange = function (range) {
  var loose = this.options.loose
  range = range.trim()
  // `1.2.3 - 1.2.4` => `>=1.2.3 <=1.2.4`
  var hr = loose ? re[HYPHENRANGELOOSE] : re[HYPHENRANGE]
  range = range.replace(hr, hyphenReplace)
  debug('hyphen replace', range)
  // `> 1.2.3 < 1.2.5` => `>1.2.3 <1.2.5`
  range = range.replace(re[COMPARATORTRIM], comparatorTrimReplace)
  debug('comparator trim', range, re[COMPARATORTRIM])

  // `~ 1.2.3` => `~1.2.3`
  range = range.replace(re[TILDETRIM], tildeTrimReplace)

  // `^ 1.2.3` => `^1.2.3`
  range = range.replace(re[CARETTRIM], caretTrimReplace)

  // normalize spaces
  range = range.split(/\s+/).join(' ')

  // At this point, the range is completely trimmed and
  // ready to be split into comparators.

  var compRe = loose ? re[COMPARATORLOOSE] : re[COMPARATOR]
  var set = range.split(' ').map(function (comp) {
    return parseComparator(comp, this.options)
  }, this).join(' ').split(/\s+/)
  if (this.options.loose) {
    // in loose mode, throw out any that are not valid comparators
    set = set.filter(function (comp) {
      return !!comp.match(compRe)
    })
  }
  set = set.map(function (comp) {
    return new Comparator(comp, this.options)
  }, this)

  return set
}

Range.prototype.intersects = function (range, options) {
  if (!(range instanceof Range)) {
    throw new TypeError('a Range is required')
  }

  return this.set.some(function (thisComparators) {
    return thisComparators.every(function (thisComparator) {
      return range.set.some(function (rangeComparators) {
        return rangeComparators.every(function (rangeComparator) {
          return thisComparator.intersects(rangeComparator, options)
        })
      })
    })
  })
}

// Mostly just for testing and legacy API reasons
exports.toComparators = toComparators
function toComparators (range, options) {
  return new Range(range, options).set.map(function (comp) {
    return comp.map(function (c) {
      return c.value
    }).join(' ').trim().split(' ')
  })
}

// comprised of xranges, tildes, stars, and gtlt's at this point.
// already replaced the hyphen ranges
// turn into a set of JUST comparators.
function parseComparator (comp, options) {
  debug('comp', comp, options)
  comp = replaceCarets(comp, options)
  debug('caret', comp)
  comp = replaceTildes(comp, options)
  debug('tildes', comp)
  comp = replaceXRanges(comp, options)
  debug('xrange', comp)
  comp = replaceStars(comp, options)
  debug('stars', comp)
  return comp
}

function isX (id) {
  return !id || id.toLowerCase() === 'x' || id === '*'
}

// ~, ~> --> * (any, kinda silly)
// ~2, ~2.x, ~2.x.x, ~>2, ~>2.x ~>2.x.x --> >=2.0.0 <3.0.0
// ~2.0, ~2.0.x, ~>2.0, ~>2.0.x --> >=2.0.0 <2.1.0
// ~1.2, ~1.2.x, ~>1.2, ~>1.2.x --> >=1.2.0 <1.3.0
// ~1.2.3, ~>1.2.3 --> >=1.2.3 <1.3.0
// ~1.2.0, ~>1.2.0 --> >=1.2.0 <1.3.0
function replaceTildes (comp, options) {
  return comp.trim().split(/\s+/).map(function (comp) {
    return replaceTilde(comp, options)
  }).join(' ')
}

function replaceTilde (comp, options) {
  var r = options.loose ? re[TILDELOOSE] : re[TILDE]
  return comp.replace(r, function (_, M, m, p, pr) {
    debug('tilde', comp, _, M, m, p, pr)
    var ret

    if (isX(M)) {
      ret = ''
    } else if (isX(m)) {
      ret = '>=' + M + '.0.0 <' + (+M + 1) + '.0.0'
    } else if (isX(p)) {
      // ~1.2 == >=1.2.0 <1.3.0
      ret = '>=' + M + '.' + m + '.0 <' + M + '.' + (+m + 1) + '.0'
    } else if (pr) {
      debug('replaceTilde pr', pr)
      ret = '>=' + M + '.' + m + '.' + p + '-' + pr +
            ' <' + M + '.' + (+m + 1) + '.0'
    } else {
      // ~1.2.3 == >=1.2.3 <1.3.0
      ret = '>=' + M + '.' + m + '.' + p +
            ' <' + M + '.' + (+m + 1) + '.0'
    }

    debug('tilde return', ret)
    return ret
  })
}

// ^ --> * (any, kinda silly)
// ^2, ^2.x, ^2.x.x --> >=2.0.0 <3.0.0
// ^2.0, ^2.0.x --> >=2.0.0 <3.0.0
// ^1.2, ^1.2.x --> >=1.2.0 <2.0.0
// ^1.2.3 --> >=1.2.3 <2.0.0
// ^1.2.0 --> >=1.2.0 <2.0.0
function replaceCarets (comp, options) {
  return comp.trim().split(/\s+/).map(function (comp) {
    return replaceCaret(comp, options)
  }).join(' ')
}

function replaceCaret (comp, options) {
  debug('caret', comp, options)
  var r = options.loose ? re[CARETLOOSE] : re[CARET]
  return comp.replace(r, function (_, M, m, p, pr) {
    debug('caret', comp, _, M, m, p, pr)
    var ret

    if (isX(M)) {
      ret = ''
    } else if (isX(m)) {
      ret = '>=' + M + '.0.0 <' + (+M + 1) + '.0.0'
    } else if (isX(p)) {
      if (M === '0') {
        ret = '>=' + M + '.' + m + '.0 <' + M + '.' + (+m + 1) + '.0'
      } else {
        ret = '>=' + M + '.' + m + '.0 <' + (+M + 1) + '.0.0'
      }
    } else if (pr) {
      debug('replaceCaret pr', pr)
      if (M === '0') {
        if (m === '0') {
          ret = '>=' + M + '.' + m + '.' + p + '-' + pr +
                ' <' + M + '.' + m + '.' + (+p + 1)
        } else {
          ret = '>=' + M + '.' + m + '.' + p + '-' + pr +
                ' <' + M + '.' + (+m + 1) + '.0'
        }
      } else {
        ret = '>=' + M + '.' + m + '.' + p + '-' + pr +
              ' <' + (+M + 1) + '.0.0'
      }
    } else {
      debug('no pr')
      if (M === '0') {
        if (m === '0') {
          ret = '>=' + M + '.' + m + '.' + p +
                ' <' + M + '.' + m + '.' + (+p + 1)
        } else {
          ret = '>=' + M + '.' + m + '.' + p +
                ' <' + M + '.' + (+m + 1) + '.0'
        }
      } else {
        ret = '>=' + M + '.' + m + '.' + p +
              ' <' + (+M + 1) + '.0.0'
      }
    }

    debug('caret return', ret)
    return ret
  })
}

function replaceXRanges (comp, options) {
  debug('replaceXRanges', comp, options)
  return comp.split(/\s+/).map(function (comp) {
    return replaceXRange(comp, options)
  }).join(' ')
}

function replaceXRange (comp, options) {
  comp = comp.trim()
  var r = options.loose ? re[XRANGELOOSE] : re[XRANGE]
  return comp.replace(r, function (ret, gtlt, M, m, p, pr) {
    debug('xRange', comp, ret, gtlt, M, m, p, pr)
    var xM = isX(M)
    var xm = xM || isX(m)
    var xp = xm || isX(p)
    var anyX = xp

    if (gtlt === '=' && anyX) {
      gtlt = ''
    }

    if (xM) {
      if (gtlt === '>' || gtlt === '<') {
        // nothing is allowed
        ret = '<0.0.0'
      } else {
        // nothing is forbidden
        ret = '*'
      }
    } else if (gtlt && anyX) {
      // we know patch is an x, because we have any x at all.
      // replace X with 0
      if (xm) {
        m = 0
      }
      p = 0

      if (gtlt === '>') {
        // >1 => >=2.0.0
        // >1.2 => >=1.3.0
        // >1.2.3 => >= 1.2.4
        gtlt = '>='
        if (xm) {
          M = +M + 1
          m = 0
          p = 0
        } else {
          m = +m + 1
          p = 0
        }
      } else if (gtlt === '<=') {
        // <=0.7.x is actually <0.8.0, since any 0.7.x should
        // pass.  Similarly, <=7.x is actually <8.0.0, etc.
        gtlt = '<'
        if (xm) {
          M = +M + 1
        } else {
          m = +m + 1
        }
      }

      ret = gtlt + M + '.' + m + '.' + p
    } else if (xm) {
      ret = '>=' + M + '.0.0 <' + (+M + 1) + '.0.0'
    } else if (xp) {
      ret = '>=' + M + '.' + m + '.0 <' + M + '.' + (+m + 1) + '.0'
    }

    debug('xRange return', ret)

    return ret
  })
}

// Because * is AND-ed with everything else in the comparator,
// and '' means "any version", just remove the *s entirely.
function replaceStars (comp, options) {
  debug('replaceStars', comp, options)
  // Looseness is ignored here.  star is always as loose as it gets!
  return comp.trim().replace(re[STAR], '')
}

// This function is passed to string.replace(re[HYPHENRANGE])
// M, m, patch, prerelease, build
// 1.2 - 3.4.5 => >=1.2.0 <=3.4.5
// 1.2.3 - 3.4 => >=1.2.0 <3.5.0 Any 3.4.x will do
// 1.2 - 3.4 => >=1.2.0 <3.5.0
function hyphenReplace ($0,
  from, fM, fm, fp, fpr, fb,
  to, tM, tm, tp, tpr, tb) {
  if (isX(fM)) {
    from = ''
  } else if (isX(fm)) {
    from = '>=' + fM + '.0.0'
  } else if (isX(fp)) {
    from = '>=' + fM + '.' + fm + '.0'
  } else {
    from = '>=' + from
  }

  if (isX(tM)) {
    to = ''
  } else if (isX(tm)) {
    to = '<' + (+tM + 1) + '.0.0'
  } else if (isX(tp)) {
    to = '<' + tM + '.' + (+tm + 1) + '.0'
  } else if (tpr) {
    to = '<=' + tM + '.' + tm + '.' + tp + '-' + tpr
  } else {
    to = '<=' + to
  }

  return (from + ' ' + to).trim()
}

// if ANY of the sets match ALL of its comparators, then pass
Range.prototype.test = function (version) {
  if (!version) {
    return false
  }

  if (typeof version === 'string') {
    version = new SemVer(version, this.options)
  }

  for (var i = 0; i < this.set.length; i++) {
    if (testSet(this.set[i], version, this.options)) {
      return true
    }
  }
  return false
}

function testSet (set, version, options) {
  for (var i = 0; i < set.length; i++) {
    if (!set[i].test(version)) {
      return false
    }
  }

  if (version.prerelease.length && !options.includePrerelease) {
    // Find the set of versions that are allowed to have prereleases
    // For example, ^1.2.3-pr.1 desugars to >=1.2.3-pr.1 <2.0.0
    // That should allow `1.2.3-pr.2` to pass.
    // However, `1.2.4-alpha.notready` should NOT be allowed,
    // even though it's within the range set by the comparators.
    for (i = 0; i < set.length; i++) {
      debug(set[i].semver)
      if (set[i].semver === ANY) {
        continue
      }

      if (set[i].semver.prerelease.length > 0) {
        var allowed = set[i].semver
        if (allowed.major === version.major &&
            allowed.minor === version.minor &&
            allowed.patch === version.patch) {
          return true
        }
      }
    }

    // Version has a -pre, but it's not one of the ones we like.
    return false
  }

  return true
}

exports.satisfies = satisfies
function satisfies (version, range, options) {
  try {
    range = new Range(range, options)
  } catch (er) {
    return false
  }
  return range.test(version)
}

exports.maxSatisfying = maxSatisfying
function maxSatisfying (versions, range, options) {
  var max = null
  var maxSV = null
  try {
    var rangeObj = new Range(range, options)
  } catch (er) {
    return null
  }
  versions.forEach(function (v) {
    if (rangeObj.test(v)) {
      // satisfies(v, range, options)
      if (!max || maxSV.compare(v) === -1) {
        // compare(max, v, true)
        max = v
        maxSV = new SemVer(max, options)
      }
    }
  })
  return max
}

exports.minSatisfying = minSatisfying
function minSatisfying (versions, range, options) {
  var min = null
  var minSV = null
  try {
    var rangeObj = new Range(range, options)
  } catch (er) {
    return null
  }
  versions.forEach(function (v) {
    if (rangeObj.test(v)) {
      // satisfies(v, range, options)
      if (!min || minSV.compare(v) === 1) {
        // compare(min, v, true)
        min = v
        minSV = new SemVer(min, options)
      }
    }
  })
  return min
}

exports.minVersion = minVersion
function minVersion (range, loose) {
  range = new Range(range, loose)

  var minver = new SemVer('0.0.0')
  if (range.test(minver)) {
    return minver
  }

  minver = new SemVer('0.0.0-0')
  if (range.test(minver)) {
    return minver
  }

  minver = null
  for (var i = 0; i < range.set.length; ++i) {
    var comparators = range.set[i]

    comparators.forEach(function (comparator) {
      // Clone to avoid manipulating the comparator's semver object.
      var compver = new SemVer(comparator.semver.version)
      switch (comparator.operator) {
        case '>':
          if (compver.prerelease.length === 0) {
            compver.patch++
          } else {
            compver.prerelease.push(0)
          }
          compver.raw = compver.format()
          /* fallthrough */
        case '':
        case '>=':
          if (!minver || gt(minver, compver)) {
            minver = compver
          }
          break
        case '<':
        case '<=':
          /* Ignore maximum versions */
          break
        /* istanbul ignore next */
        default:
          throw new Error('Unexpected operation: ' + comparator.operator)
      }
    })
  }

  if (minver && range.test(minver)) {
    return minver
  }

  return null
}

exports.validRange = validRange
function validRange (range, options) {
  try {
    // Return '*' instead of '' so that truthiness works.
    // This will throw if it's invalid anyway
    return new Range(range, options).range || '*'
  } catch (er) {
    return null
  }
}

// Determine if version is less than all the versions possible in the range
exports.ltr = ltr
function ltr (version, range, options) {
  return outside(version, range, '<', options)
}

// Determine if version is greater than all the versions possible in the range.
exports.gtr = gtr
function gtr (version, range, options) {
  return outside(version, range, '>', options)
}

exports.outside = outside
function outside (version, range, hilo, options) {
  version = new SemVer(version, options)
  range = new Range(range, options)

  var gtfn, ltefn, ltfn, comp, ecomp
  switch (hilo) {
    case '>':
      gtfn = gt
      ltefn = lte
      ltfn = lt
      comp = '>'
      ecomp = '>='
      break
    case '<':
      gtfn = lt
      ltefn = gte
      ltfn = gt
      comp = '<'
      ecomp = '<='
      break
    default:
      throw new TypeError('Must provide a hilo val of "<" or ">"')
  }

  // If it satisifes the range it is not outside
  if (satisfies(version, range, options)) {
    return false
  }

  // From now on, variable terms are as if we're in "gtr" mode.
  // but note that everything is flipped for the "ltr" function.

  for (var i = 0; i < range.set.length; ++i) {
    var comparators = range.set[i]

    var high = null
    var low = null

    comparators.forEach(function (comparator) {
      if (comparator.semver === ANY) {
        comparator = new Comparator('>=0.0.0')
      }
      high = high || comparator
      low = low || comparator
      if (gtfn(comparator.semver, high.semver, options)) {
        high = comparator
      } else if (ltfn(comparator.semver, low.semver, options)) {
        low = comparator
      }
    })

    // If the edge version comparator has a operator then our version
    // isn't outside it
    if (high.operator === comp || high.operator === ecomp) {
      return false
    }

    // If the lowest version comparator has an operator and our version
    // is less than it then it isn't higher than the range
    if ((!low.operator || low.operator === comp) &&
        ltefn(version, low.semver)) {
      return false
    } else if (low.operator === ecomp && ltfn(version, low.semver)) {
      return false
    }
  }
  return true
}

exports.prerelease = prerelease
function prerelease (version, options) {
  var parsed = parse(version, options)
  return (parsed && parsed.prerelease.length) ? parsed.prerelease : null
}

exports.intersects = intersects
function intersects (r1, r2, options) {
  r1 = new Range(r1, options)
  r2 = new Range(r2, options)
  return r1.intersects(r2)
}

exports.coerce = coerce
function coerce (version) {
  if (version instanceof SemVer) {
    return version
  }

  if (typeof version !== 'string') {
    return null
  }

  var match = version.match(re[COERCE])

  if (match == null) {
    return null
  }

  return parse(match[1] +
    '.' + (match[2] || '0') +
    '.' + (match[3] || '0'))
}

}).call(this)}).call(this,require('_process'))
},{"_process":223}],231:[function(require,module,exports){
(function (Buffer){(function (){
'use strict';

const fs = require('fs');
const jpeg = require('jpeg-js');

/**
 * @typedef {import('../speedline').IncludeType} IncludeType
 * @typedef {import('../speedline').Options<IncludeType>} Options
 * @typedef {import('../speedline').TraceEvent} TraceEvent
 * @typedef {import('../speedline').Output['frames'][number]} Frame
 * @typedef {import('jpeg-js').RawImageData<Buffer>} ImageData
 */

/**
 * @param {number} x
 * @param {number} y
 * @param {number} channel
 * @param {number} width
 * @param {Buffer} buff
 */
function getPixel(x, y, channel, width, buff) {
	return buff[(x + y * width) * 4 + channel];
}

/**
 * @param {number} i
 * @param {number} j
 * @param {ImageData} img
 */
function isWhitePixel(i, j, img) {
	return getPixel(i, j, 0, img.width, img.data) >= 249 &&
			getPixel(i, j, 1, img.width, img.data) >= 249 &&
			getPixel(i, j, 2, img.width, img.data) >= 249;
}

/** @param {ImageData} img */
function convertPixelsToHistogram(img) {
	const createHistogramArray = function () {
		const ret = [];
		for (let i = 0; i < 256; i++) {
			ret[i] = 0;
		}
		return ret;
	};

	const width = img.width;
	const height = img.height;

	const histograms = [
		createHistogramArray(),
		createHistogramArray(),
		createHistogramArray()
	];

	for (let j = 0; j < height; j++) {
		for (let i = 0; i < width; i++) {
			// Erase pixels considered as white
			if (isWhitePixel(i, j, img)) {
				continue;
			}

			for (let channel = 0; channel < histograms.length; channel++) {
				const pixelValue = getPixel(i, j, channel, width, img.data);
				histograms[channel][pixelValue]++;
			}
		}
	}

	return histograms;
}

/** @param {Array<Frame>} frames */
function synthesizeWhiteFrame(frames) {
	const firstImageData = jpeg.decode(frames[0].getImage());
	const width = firstImageData.width;
	const height = firstImageData.height;

	const frameData = Buffer.alloc(width * height * 4);
	let i = 0;
	while (i < frameData.length) {
		frameData[i++] = 0xFF; // red
		frameData[i++] = 0xFF; // green
		frameData[i++] = 0xFF; // blue
		frameData[i++] = 0xFF; // alpha - ignored in JPEGs
	}

	var jpegImageData = jpeg.encode({
		data: frameData,
		width: width,
		height: height
	});
	return jpegImageData.data;
}

const screenshotTraceCategory = 'disabled-by-default-devtools.screenshot';

/**
 * @param {string|Array<TraceEvent>|{traceEvents: Array<TraceEvent>}} timeline
 * @param {Options} opts
 */
function extractFramesFromTimeline(timeline, opts) {
	opts = opts || {};
	/** @type {Array<TraceEvent>|{traceEvents: Array<TraceEvent>}} */
	let trace;
	timeline = typeof timeline === 'string' ? fs.readFileSync(timeline, 'utf-8') : timeline;
	try {
		trace = typeof timeline === 'string' ? JSON.parse(timeline) : timeline;
	} catch (e) {
		throw new Error('Speedline: Invalid JSON' + e.message);
	}
	/** @type {Array<TraceEvent>} */
	let events = trace.traceEvents || trace;

	let startTs = Number.MAX_VALUE;
	let endTs = -Number.MAX_VALUE;
	events.forEach(e => {
		if (e.ts === 0) {
			return;
		}

		startTs = Math.min(startTs, e.ts);
		endTs = Math.max(endTs, e.ts);
	});

	startTs = (opts.timeOrigin || startTs) / 1000;
	endTs /= 1000;

	/** @type {?string} */
	let lastFrame = null;
	const rawScreenshots = events.filter(e => e.cat.includes(screenshotTraceCategory) && e.ts >= startTs * 1000);
	rawScreenshots.sort((a, b) => a.ts - b.ts);

	/** @type {Array<Frame>} */
	const uniqueFrames = rawScreenshots.map(function (evt) {
		const base64img = evt.args && evt.args.snapshot;
		const timestamp = evt.ts / 1000;

		if (base64img === lastFrame) {
			return null;
		}

		lastFrame = base64img;
		const imgBuff = Buffer.from(base64img, 'base64');
		return frame(imgBuff, timestamp);
	}).filter(Boolean);

	if (uniqueFrames.length === 0) {
		return Promise.reject(new Error('No screenshots found in trace'));
	}
	// add white frame to beginning of trace
	const fakeWhiteFrame = frame(synthesizeWhiteFrame(uniqueFrames), startTs);
	uniqueFrames.unshift(fakeWhiteFrame);

	const data = {
		startTs,
		endTs,
		frames: uniqueFrames
	};
	return Promise.resolve(data);
}

/**
 * @param {Buffer} imgBuff
 * @param {number} ts
 * @return {Frame}
 */
function frame(imgBuff, ts) {
	/** @type {?Array<Array<number>>} */
	let _histogram = null;
	/** @type {?number} */
	let _progress = null;
	/** @type {?boolean} */
	let _isProgressInterpolated = null;
	/** @type {?number} */
	let _perceptualProgress = null;
	/** @type {?boolean} */
	let _isPerceptualProgressInterpolated = null;
	/** @type {?ImageData} */
	let _parsedImage = null;

	return {
		getHistogram: function () {
			if (_histogram) {
				return _histogram;
			}

			const pixels = this.getParsedImage();
			_histogram = convertPixelsToHistogram(pixels);
			return _histogram;
		},

		getTimeStamp: function () {
			return ts;
		},

		setProgress: function (progress, isInterpolated) {
			_progress = progress;
			_isProgressInterpolated = Boolean(isInterpolated);
		},

		setPerceptualProgress: function (progress, isInterpolated) {
			_perceptualProgress = progress;
			_isPerceptualProgressInterpolated = Boolean(isInterpolated);
		},

		getImage: function () {
			return imgBuff;
		},

		getParsedImage: function () {
			if (!_parsedImage) {
				_parsedImage = jpeg.decode(imgBuff);
			}
			return _parsedImage;
		},

		getProgress: function () {
			return _progress;
		},

		isProgressInterpolated: function () {
			return _isProgressInterpolated;
		},

		getPerceptualProgress: function () {
			return _perceptualProgress;
		},

		isPerceptualProgressInterpolated: function () {
			return _isPerceptualProgressInterpolated;
		}
	};
}

module.exports = {
	extractFramesFromTimeline,
	create: frame
};

}).call(this)}).call(this,require("buffer").Buffer)
},{"buffer":145,"fs":144,"jpeg-js":185}],232:[function(require,module,exports){
'use strict';

const frame = require('./frame');
const speedIndex = require('./speed-index');

/**
 * @typedef {import('../speedline').TraceEvent} TraceEvent
 * @typedef {import('../speedline').IncludeType} IncludeType
 * @typedef {import('../speedline').Output['frames'][number]} Frame
 */

/**
 * @param {Array<Frame>} frames
 * @param {{startTs: number, endTs: number}} data
 */
function calculateValues(frames, data) {
	const indexes = speedIndex.calculateSpeedIndexes(frames, data);
	const duration = Math.floor(data.endTs - data.startTs);
	const first = Math.floor(indexes.firstPaintTs - data.startTs);
	const complete = Math.floor(indexes.visuallyCompleteTs - data.startTs);

	return {
		beginning: data.startTs,
		end: data.endTs,
		frames,
		first,
		complete,
		duration,
		speedIndex: indexes.speedIndex,
		perceptualSpeedIndex: indexes.perceptualSpeedIndex
	};
}

/** @type {{All: 'all', pSI: 'perceptualSpeedIndex', SI: 'speedIndex'}} */
const Include = {
	All: 'all',
	pSI: 'perceptualSpeedIndex',
	SI: 'speedIndex'
};

/**
 * Retrieve speed index informations
 * @template {IncludeType} I
 * @param {string|Array<TraceEvent>} timeline
 * @param {import('../speedline').Options<I>} opts
 * @return {Promise<import('../speedline').Output<I>>}
 */
module.exports = function (timeline, opts) {
	const include = opts && opts.include || Include.All;
	// Check for invalid `include` values
	if (!Object.keys(Include).some(key => Include[key] === include)) {
		throw new Error(`Unrecognized include option: ${include}`);
	}

	return frame.extractFramesFromTimeline(timeline, opts).then(function (data) {
		const frames = data.frames;

		if (include === Include.All || include === Include.SI) {
			speedIndex.calculateVisualProgress(frames, opts);
		}

		if (include === Include.All || include === Include.pSI) {
			speedIndex.calculatePerceptualProgress(frames, opts);
		}

		return calculateValues(frames, data);
	});
};

},{"./frame":231,"./speed-index":233}],233:[function(require,module,exports){
'use strict';

const imageSSIM = require('image-ssim');

/* BEGIN FAST MODE CONSTANTS - See function doc for explanation */
const fastModeAllowableChangeMax = 5;
const fastModeAllowableChangeMedian = 3;
const fastModeAllowableChangeMin = -1;

const fastModeConstant = fastModeAllowableChangeMin;
const fastModeMultiplier = fastModeAllowableChangeMax - fastModeConstant;
const fastModeExponentiationCoefficient = Math.log((fastModeAllowableChangeMedian - fastModeConstant) / fastModeMultiplier);
/* END FAST MODE CONSTANTS - See function doc for explanation */

/** @typedef {import('../speedline').Output['frames'][number]} Frame */

/**
 * This computes the allowed percentage of change between two frames in fast mode where we won't examine the frames in between them.
 * It follows an exponential function such that:
 *  - We allow up to FAST_MODE_ALLOWABLE_CHANGE_MAX percent difference when the frames are ~0s apart.
 *  - We allow up to FAST_MODE_ALLOWABLE_CHANGE_MEDIAN percent difference when the frames are ~1s apart.
 *  - We allow up to FAST_MODE_ALLOWABLE_CHANGE_MIN percent difference when the frames are very far apart.
 *
 *  f(t) = FAST_MODE_MULTIPLIER * e^(FAST_MODE_EXPONENTIATION_COEFFICIENT * t) + FAST_MODE_CONSTANT
 * @param {number} elapsedTime
 */
function calculateFastModeAllowableChange(elapsedTime) {
	const elapsedTimeInSeconds = elapsedTime / 1000;
	const allowableChange = fastModeMultiplier * Math.exp(fastModeExponentiationCoefficient * elapsedTimeInSeconds) + fastModeConstant;
	return allowableChange;
}

/**
 * @param {Frame} current
 * @param {Frame} initial
 * @param {Frame} target
 */
function calculateFrameProgress(current, initial, target) {
	let total = 0;
	let match = 0;

	const currentHist = current.getHistogram();
	const initialHist = initial.getHistogram();
	const targetHist = target.getHistogram();

	for (let channel = 0; channel < 3; channel++) {
		for (let pixelVal = 0; pixelVal < 256; pixelVal++) {
			const currentCount = currentHist[channel][pixelVal];
			const initialCount = initialHist[channel][pixelVal];
			const targetCount = targetHist[channel][pixelVal];

			const currentDiff = Math.abs(currentCount - initialCount);
			const targetDiff = Math.abs(targetCount - initialCount);

			match += Math.min(currentDiff, targetDiff);
			total += targetDiff;
		}
	}

	let progress;
	if (match === 0 && total === 0) {	// All images are the same
		progress = 100;
	} else {													// When images differs
		progress = Math.floor(match / total * 100);
	}
	return progress;
}

/**
 * @param {Array<Frame>} frames
 * @param {number} lowerBound
 * @param {number} upperBound
 * @param {boolean} isFastMode
 * @param {function(Frame): number} getProgress
 * @param {function(Frame, number, boolean): void} setProgress
 */
function calculateProgressBetweenFrames(frames, lowerBound, upperBound, isFastMode, getProgress, setProgress) {
	if (!isFastMode) {
		frames.forEach(frame => setProgress(frame, getProgress(frame), false));
		return;
	}

	const lowerFrame = frames[lowerBound];
	const upperFrame = frames[upperBound];
	const elapsedTime = upperFrame.getTimeStamp() - lowerFrame.getTimeStamp();

	const lowerProgress = getProgress(lowerFrame);
	const upperProgress = getProgress(upperFrame);

	setProgress(lowerFrame, lowerProgress, false);
	setProgress(upperFrame, upperProgress, false);

	if (Math.abs(lowerProgress - upperProgress) < calculateFastModeAllowableChange(elapsedTime)) {
		for (let i = lowerBound + 1; i < upperBound; i++) {
			setProgress(frames[i], lowerProgress, true);
		}
	} else if (upperBound - lowerBound > 1) {
		const midpoint = Math.floor((lowerBound + upperBound) / 2);
		calculateProgressBetweenFrames(frames, lowerBound, midpoint, isFastMode, getProgress, setProgress);
		calculateProgressBetweenFrames(frames, midpoint, upperBound, isFastMode, getProgress, setProgress);
	}
}

/**
 * @param {Array<Frame>} frames
 * @param {{fastMode?: boolean}} opts
 */
function calculateVisualProgress(frames, opts) {
	const initial = frames[0];
	const target = frames[frames.length - 1];

	/** @param {Frame} frame */
	function getProgress(frame) {
		if (typeof frame.getProgress() === 'number') {
			return frame.getProgress();
		}

		return calculateFrameProgress(frame, initial, target);
	}

	/**
	 * @param {Frame} frame
	 * @param {number} progress
	 * @param {boolean} isInterpolated
	 */
	function setProgress(frame, progress, isInterpolated) {
		return frame.setProgress(progress, isInterpolated);
	}

	calculateProgressBetweenFrames(
		frames,
		0,
		frames.length - 1,
		opts && opts.fastMode,
		getProgress,
		setProgress
	);

	return frames;
}

/**
 * @param {Frame} frame
 * @param {Frame} target
 * @return {number}
 */
function calculateFrameSimilarity(frame, target) {
	const defaultImageConfig = {
		// image-ssim uses this to interpret the arraybuffer NOT the desired channels to consider
		// jpeg-js encodes each pixel with an alpha channel set to 0xFF, so 4 channel interpretation is required
		channels: 4
	};

	const frameData = Object.assign(frame.getParsedImage(), defaultImageConfig);
	const targetData = Object.assign(target.getParsedImage(), defaultImageConfig);

	const diff = imageSSIM.compare(frameData, targetData);
	return diff.ssim;
}

/**
 * @param {Array<Frame>} frames
 * @param {{fastMode?: boolean}} opts
 */
function calculatePerceptualProgress(frames, opts) {
	const initial = frames[0];
	const target = frames[frames.length - 1];
	const initialSimilarity = calculateFrameSimilarity(initial, target);

	/** @param {Frame} frame */
	function getProgress(frame) {
		if (typeof frame.getPerceptualProgress() === 'number') {
			return frame.getPerceptualProgress();
		}

		const ssim = calculateFrameSimilarity(frame, target);
		return Math.max(100 * (ssim - initialSimilarity) / (1 - initialSimilarity), 0);
	}

	/**
	 * @param {Frame} frame
	 * @param {number} progress
	 * @param {boolean} isInterpolated
	 */
	function setProgress(frame, progress, isInterpolated) {
		return frame.setPerceptualProgress(progress, isInterpolated);
	}

	calculateProgressBetweenFrames(
		frames,
		0,
		frames.length - 1,
		opts && opts.fastMode,
		getProgress,
		setProgress
	);

	return frames;
}

/**
 * @param {Array<Frame>} frames
 * @param {{startTs: number}} data
 * @return {{firstPaintTs: number, visuallyCompleteTs: number, speedIndex?: number, perceptualSpeedIndex?: number}}
 */
function calculateSpeedIndexes(frames, data) {
	const hasVisualProgress = typeof frames[0].getProgress() === 'number';
	const hasPerceptualProgress = typeof frames[0].getPerceptualProgress() === 'number';
	const progressToUse = hasVisualProgress ? 'getProgress' : 'getPerceptualProgress';
	const startTs = data.startTs;
	let visuallyCompleteTs;
	/** @type {number|undefined} */
	let firstPaintTs;

	// find first paint
	for (let i = 0; i < frames.length && !firstPaintTs; i++) {
		if (frames[i][progressToUse]() > 0) {
			firstPaintTs = frames[i].getTimeStamp();
		}
	}

	// find visually complete
	for (let i = 0; i < frames.length && !visuallyCompleteTs; i++) {
		if (frames[i][progressToUse]() >= 100) {
			visuallyCompleteTs = frames[i].getTimeStamp();
		}
	}

	let prevFrameTs = frames[0].getTimeStamp();
	let prevProgress = frames[0].getProgress();
	let prevPerceptualProgress = frames[0].getPerceptualProgress();

	// SI = firstPaint + sum(fP to VC){1-VC%}
	//     github.com/pmdartus/speedline/issues/28#issuecomment-244127192
	/** @type {number|undefined} */
	let speedIndex = firstPaintTs - startTs;
	/** @type {number|undefined} */
	let perceptualSpeedIndex = firstPaintTs - startTs;

	frames.forEach(function (frame) {
		// skip frames from 0 to fP
		if (frame.getTimeStamp() > firstPaintTs) {
			const elapsed = frame.getTimeStamp() - prevFrameTs;
			speedIndex += elapsed * (1 - prevProgress);
			perceptualSpeedIndex += elapsed * (1 - prevPerceptualProgress);
		}

		prevFrameTs = frame.getTimeStamp();
		prevProgress = frame.getProgress() / 100;
		prevPerceptualProgress = frame.getPerceptualProgress() / 100;
	});

	speedIndex = hasVisualProgress ? speedIndex : undefined;
	perceptualSpeedIndex = hasPerceptualProgress ? perceptualSpeedIndex : undefined;

	return {
		firstPaintTs,
		visuallyCompleteTs,
		speedIndex,
		perceptualSpeedIndex
	};
}

module.exports = {
	calculateFastModeAllowableChange,
	calculateFrameSimilarity,
	calculateVisualProgress,
	calculatePerceptualProgress,
	calculateSpeedIndexes
};

},{"image-ssim":173}],234:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

module.exports = Stream;

var EE = require('events').EventEmitter;
var inherits = require('inherits');

inherits(Stream, EE);
Stream.Readable = require('readable-stream/lib/_stream_readable.js');
Stream.Writable = require('readable-stream/lib/_stream_writable.js');
Stream.Duplex = require('readable-stream/lib/_stream_duplex.js');
Stream.Transform = require('readable-stream/lib/_stream_transform.js');
Stream.PassThrough = require('readable-stream/lib/_stream_passthrough.js');
Stream.finished = require('readable-stream/lib/internal/streams/end-of-stream.js')
Stream.pipeline = require('readable-stream/lib/internal/streams/pipeline.js')

// Backwards-compat with node 0.4.x
Stream.Stream = Stream;



// old-style streams.  Note that the pipe method (the only relevant
// part of this class) is overridden in the Readable class.

function Stream() {
  EE.call(this);
}

Stream.prototype.pipe = function(dest, options) {
  var source = this;

  function ondata(chunk) {
    if (dest.writable) {
      if (false === dest.write(chunk) && source.pause) {
        source.pause();
      }
    }
  }

  source.on('data', ondata);

  function ondrain() {
    if (source.readable && source.resume) {
      source.resume();
    }
  }

  dest.on('drain', ondrain);

  // If the 'end' option is not supplied, dest.end() will be called when
  // source gets the 'end' or 'close' events.  Only dest.end() once.
  if (!dest._isStdio && (!options || options.end !== false)) {
    source.on('end', onend);
    source.on('close', onclose);
  }

  var didOnEnd = false;
  function onend() {
    if (didOnEnd) return;
    didOnEnd = true;

    dest.end();
  }


  function onclose() {
    if (didOnEnd) return;
    didOnEnd = true;

    if (typeof dest.destroy === 'function') dest.destroy();
  }

  // don't leave dangling pipes when there are errors.
  function onerror(er) {
    cleanup();
    if (EE.listenerCount(this, 'error') === 0) {
      throw er; // Unhandled stream error in pipe.
    }
  }

  source.on('error', onerror);
  dest.on('error', onerror);

  // remove all the event listeners that were added.
  function cleanup() {
    source.removeListener('data', ondata);
    dest.removeListener('drain', ondrain);

    source.removeListener('end', onend);
    source.removeListener('close', onclose);

    source.removeListener('error', onerror);
    dest.removeListener('error', onerror);

    source.removeListener('end', cleanup);
    source.removeListener('close', cleanup);

    dest.removeListener('close', cleanup);
  }

  source.on('end', cleanup);
  source.on('close', cleanup);

  dest.on('close', cleanup);

  dest.emit('pipe', source);

  // Allow for unix-like usage: A.pipe(B).pipe(C)
  return dest;
};

},{"events":162,"inherits":174,"readable-stream/lib/_stream_duplex.js":236,"readable-stream/lib/_stream_passthrough.js":237,"readable-stream/lib/_stream_readable.js":238,"readable-stream/lib/_stream_transform.js":239,"readable-stream/lib/_stream_writable.js":240,"readable-stream/lib/internal/streams/end-of-stream.js":244,"readable-stream/lib/internal/streams/pipeline.js":246}],235:[function(require,module,exports){
'use strict';

function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }

var codes = {};

function createErrorType(code, message, Base) {
  if (!Base) {
    Base = Error;
  }

  function getMessage(arg1, arg2, arg3) {
    if (typeof message === 'string') {
      return message;
    } else {
      return message(arg1, arg2, arg3);
    }
  }

  var NodeError =
  /*#__PURE__*/
  function (_Base) {
    _inheritsLoose(NodeError, _Base);

    function NodeError(arg1, arg2, arg3) {
      return _Base.call(this, getMessage(arg1, arg2, arg3)) || this;
    }

    return NodeError;
  }(Base);

  NodeError.prototype.name = Base.name;
  NodeError.prototype.code = code;
  codes[code] = NodeError;
} // https://github.com/nodejs/node/blob/v10.8.0/lib/internal/errors.js


function oneOf(expected, thing) {
  if (Array.isArray(expected)) {
    var len = expected.length;
    expected = expected.map(function (i) {
      return String(i);
    });

    if (len > 2) {
      return "one of ".concat(thing, " ").concat(expected.slice(0, len - 1).join(', '), ", or ") + expected[len - 1];
    } else if (len === 2) {
      return "one of ".concat(thing, " ").concat(expected[0], " or ").concat(expected[1]);
    } else {
      return "of ".concat(thing, " ").concat(expected[0]);
    }
  } else {
    return "of ".concat(thing, " ").concat(String(expected));
  }
} // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/startsWith


function startsWith(str, search, pos) {
  return str.substr(!pos || pos < 0 ? 0 : +pos, search.length) === search;
} // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/endsWith


function endsWith(str, search, this_len) {
  if (this_len === undefined || this_len > str.length) {
    this_len = str.length;
  }

  return str.substring(this_len - search.length, this_len) === search;
} // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/includes


function includes(str, search, start) {
  if (typeof start !== 'number') {
    start = 0;
  }

  if (start + search.length > str.length) {
    return false;
  } else {
    return str.indexOf(search, start) !== -1;
  }
}

createErrorType('ERR_INVALID_OPT_VALUE', function (name, value) {
  return 'The value "' + value + '" is invalid for option "' + name + '"';
}, TypeError);
createErrorType('ERR_INVALID_ARG_TYPE', function (name, expected, actual) {
  // determiner: 'must be' or 'must not be'
  var determiner;

  if (typeof expected === 'string' && startsWith(expected, 'not ')) {
    determiner = 'must not be';
    expected = expected.replace(/^not /, '');
  } else {
    determiner = 'must be';
  }

  var msg;

  if (endsWith(name, ' argument')) {
    // For cases like 'first argument'
    msg = "The ".concat(name, " ").concat(determiner, " ").concat(oneOf(expected, 'type'));
  } else {
    var type = includes(name, '.') ? 'property' : 'argument';
    msg = "The \"".concat(name, "\" ").concat(type, " ").concat(determiner, " ").concat(oneOf(expected, 'type'));
  }

  msg += ". Received type ".concat(typeof actual);
  return msg;
}, TypeError);
createErrorType('ERR_STREAM_PUSH_AFTER_EOF', 'stream.push() after EOF');
createErrorType('ERR_METHOD_NOT_IMPLEMENTED', function (name) {
  return 'The ' + name + ' method is not implemented';
});
createErrorType('ERR_STREAM_PREMATURE_CLOSE', 'Premature close');
createErrorType('ERR_STREAM_DESTROYED', function (name) {
  return 'Cannot call ' + name + ' after a stream was destroyed';
});
createErrorType('ERR_MULTIPLE_CALLBACK', 'Callback called multiple times');
createErrorType('ERR_STREAM_CANNOT_PIPE', 'Cannot pipe, not readable');
createErrorType('ERR_STREAM_WRITE_AFTER_END', 'write after end');
createErrorType('ERR_STREAM_NULL_VALUES', 'May not write null values to stream', TypeError);
createErrorType('ERR_UNKNOWN_ENCODING', function (arg) {
  return 'Unknown encoding: ' + arg;
}, TypeError);
createErrorType('ERR_STREAM_UNSHIFT_AFTER_END_EVENT', 'stream.unshift() after end event');
module.exports.codes = codes;

},{}],236:[function(require,module,exports){
(function (process){(function (){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
// a duplex stream is just a stream that is both readable and writable.
// Since JS doesn't have multiple prototypal inheritance, this class
// prototypally inherits from Readable, and then parasitically from
// Writable.
'use strict';
/*<replacement>*/

var objectKeys = Object.keys || function (obj) {
  var keys = [];

  for (var key in obj) {
    keys.push(key);
  }

  return keys;
};
/*</replacement>*/


module.exports = Duplex;

var Readable = require('./_stream_readable');

var Writable = require('./_stream_writable');

require('inherits')(Duplex, Readable);

{
  // Allow the keys array to be GC'ed.
  var keys = objectKeys(Writable.prototype);

  for (var v = 0; v < keys.length; v++) {
    var method = keys[v];
    if (!Duplex.prototype[method]) Duplex.prototype[method] = Writable.prototype[method];
  }
}

function Duplex(options) {
  if (!(this instanceof Duplex)) return new Duplex(options);
  Readable.call(this, options);
  Writable.call(this, options);
  this.allowHalfOpen = true;

  if (options) {
    if (options.readable === false) this.readable = false;
    if (options.writable === false) this.writable = false;

    if (options.allowHalfOpen === false) {
      this.allowHalfOpen = false;
      this.once('end', onend);
    }
  }
}

Object.defineProperty(Duplex.prototype, 'writableHighWaterMark', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._writableState.highWaterMark;
  }
});
Object.defineProperty(Duplex.prototype, 'writableBuffer', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._writableState && this._writableState.getBuffer();
  }
});
Object.defineProperty(Duplex.prototype, 'writableLength', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._writableState.length;
  }
}); // the no-half-open enforcer

function onend() {
  // If the writable side ended, then we're ok.
  if (this._writableState.ended) return; // no more data can be written.
  // But allow more writes to happen in this tick.

  process.nextTick(onEndNT, this);
}

function onEndNT(self) {
  self.end();
}

Object.defineProperty(Duplex.prototype, 'destroyed', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    if (this._readableState === undefined || this._writableState === undefined) {
      return false;
    }

    return this._readableState.destroyed && this._writableState.destroyed;
  },
  set: function set(value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (this._readableState === undefined || this._writableState === undefined) {
      return;
    } // backward compatibility, the user is explicitly
    // managing destroyed


    this._readableState.destroyed = value;
    this._writableState.destroyed = value;
  }
});
}).call(this)}).call(this,require('_process'))
},{"./_stream_readable":238,"./_stream_writable":240,"_process":223,"inherits":174}],237:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
// a passthrough stream.
// basically just the most minimal sort of Transform stream.
// Every written chunk gets output as-is.
'use strict';

module.exports = PassThrough;

var Transform = require('./_stream_transform');

require('inherits')(PassThrough, Transform);

function PassThrough(options) {
  if (!(this instanceof PassThrough)) return new PassThrough(options);
  Transform.call(this, options);
}

PassThrough.prototype._transform = function (chunk, encoding, cb) {
  cb(null, chunk);
};
},{"./_stream_transform":239,"inherits":174}],238:[function(require,module,exports){
(function (process,global){(function (){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
'use strict';

module.exports = Readable;
/*<replacement>*/

var Duplex;
/*</replacement>*/

Readable.ReadableState = ReadableState;
/*<replacement>*/

var EE = require('events').EventEmitter;

var EElistenerCount = function EElistenerCount(emitter, type) {
  return emitter.listeners(type).length;
};
/*</replacement>*/

/*<replacement>*/


var Stream = require('./internal/streams/stream');
/*</replacement>*/


var Buffer = require('buffer').Buffer;

var OurUint8Array = global.Uint8Array || function () {};

function _uint8ArrayToBuffer(chunk) {
  return Buffer.from(chunk);
}

function _isUint8Array(obj) {
  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;
}
/*<replacement>*/


var debugUtil = require('util');

var debug;

if (debugUtil && debugUtil.debuglog) {
  debug = debugUtil.debuglog('stream');
} else {
  debug = function debug() {};
}
/*</replacement>*/


var BufferList = require('./internal/streams/buffer_list');

var destroyImpl = require('./internal/streams/destroy');

var _require = require('./internal/streams/state'),
    getHighWaterMark = _require.getHighWaterMark;

var _require$codes = require('../errors').codes,
    ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE,
    ERR_STREAM_PUSH_AFTER_EOF = _require$codes.ERR_STREAM_PUSH_AFTER_EOF,
    ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED,
    ERR_STREAM_UNSHIFT_AFTER_END_EVENT = _require$codes.ERR_STREAM_UNSHIFT_AFTER_END_EVENT; // Lazy loaded to improve the startup performance.


var StringDecoder;
var createReadableStreamAsyncIterator;
var from;

require('inherits')(Readable, Stream);

var errorOrDestroy = destroyImpl.errorOrDestroy;
var kProxyEvents = ['error', 'close', 'destroy', 'pause', 'resume'];

function prependListener(emitter, event, fn) {
  // Sadly this is not cacheable as some libraries bundle their own
  // event emitter implementation with them.
  if (typeof emitter.prependListener === 'function') return emitter.prependListener(event, fn); // This is a hack to make sure that our error handler is attached before any
  // userland ones.  NEVER DO THIS. This is here only because this code needs
  // to continue to work with older versions of Node.js that do not include
  // the prependListener() method. The goal is to eventually remove this hack.

  if (!emitter._events || !emitter._events[event]) emitter.on(event, fn);else if (Array.isArray(emitter._events[event])) emitter._events[event].unshift(fn);else emitter._events[event] = [fn, emitter._events[event]];
}

function ReadableState(options, stream, isDuplex) {
  Duplex = Duplex || require('./_stream_duplex');
  options = options || {}; // Duplex streams are both readable and writable, but share
  // the same options object.
  // However, some cases require setting options to different
  // values for the readable and the writable sides of the duplex stream.
  // These options can be provided separately as readableXXX and writableXXX.

  if (typeof isDuplex !== 'boolean') isDuplex = stream instanceof Duplex; // object stream flag. Used to make read(n) ignore n and to
  // make all the buffer merging and length checks go away

  this.objectMode = !!options.objectMode;
  if (isDuplex) this.objectMode = this.objectMode || !!options.readableObjectMode; // the point at which it stops calling _read() to fill the buffer
  // Note: 0 is a valid value, means "don't call _read preemptively ever"

  this.highWaterMark = getHighWaterMark(this, options, 'readableHighWaterMark', isDuplex); // A linked list is used to store data chunks instead of an array because the
  // linked list can remove elements from the beginning faster than
  // array.shift()

  this.buffer = new BufferList();
  this.length = 0;
  this.pipes = null;
  this.pipesCount = 0;
  this.flowing = null;
  this.ended = false;
  this.endEmitted = false;
  this.reading = false; // a flag to be able to tell if the event 'readable'/'data' is emitted
  // immediately, or on a later tick.  We set this to true at first, because
  // any actions that shouldn't happen until "later" should generally also
  // not happen before the first read call.

  this.sync = true; // whenever we return null, then we set a flag to say
  // that we're awaiting a 'readable' event emission.

  this.needReadable = false;
  this.emittedReadable = false;
  this.readableListening = false;
  this.resumeScheduled = false;
  this.paused = true; // Should close be emitted on destroy. Defaults to true.

  this.emitClose = options.emitClose !== false; // Should .destroy() be called after 'end' (and potentially 'finish')

  this.autoDestroy = !!options.autoDestroy; // has it been destroyed

  this.destroyed = false; // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.

  this.defaultEncoding = options.defaultEncoding || 'utf8'; // the number of writers that are awaiting a drain event in .pipe()s

  this.awaitDrain = 0; // if true, a maybeReadMore has been scheduled

  this.readingMore = false;
  this.decoder = null;
  this.encoding = null;

  if (options.encoding) {
    if (!StringDecoder) StringDecoder = require('string_decoder/').StringDecoder;
    this.decoder = new StringDecoder(options.encoding);
    this.encoding = options.encoding;
  }
}

function Readable(options) {
  Duplex = Duplex || require('./_stream_duplex');
  if (!(this instanceof Readable)) return new Readable(options); // Checking for a Stream.Duplex instance is faster here instead of inside
  // the ReadableState constructor, at least with V8 6.5

  var isDuplex = this instanceof Duplex;
  this._readableState = new ReadableState(options, this, isDuplex); // legacy

  this.readable = true;

  if (options) {
    if (typeof options.read === 'function') this._read = options.read;
    if (typeof options.destroy === 'function') this._destroy = options.destroy;
  }

  Stream.call(this);
}

Object.defineProperty(Readable.prototype, 'destroyed', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    if (this._readableState === undefined) {
      return false;
    }

    return this._readableState.destroyed;
  },
  set: function set(value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (!this._readableState) {
      return;
    } // backward compatibility, the user is explicitly
    // managing destroyed


    this._readableState.destroyed = value;
  }
});
Readable.prototype.destroy = destroyImpl.destroy;
Readable.prototype._undestroy = destroyImpl.undestroy;

Readable.prototype._destroy = function (err, cb) {
  cb(err);
}; // Manually shove something into the read() buffer.
// This returns true if the highWaterMark has not been hit yet,
// similar to how Writable.write() returns true if you should
// write() some more.


Readable.prototype.push = function (chunk, encoding) {
  var state = this._readableState;
  var skipChunkCheck;

  if (!state.objectMode) {
    if (typeof chunk === 'string') {
      encoding = encoding || state.defaultEncoding;

      if (encoding !== state.encoding) {
        chunk = Buffer.from(chunk, encoding);
        encoding = '';
      }

      skipChunkCheck = true;
    }
  } else {
    skipChunkCheck = true;
  }

  return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);
}; // Unshift should *always* be something directly out of read()


Readable.prototype.unshift = function (chunk) {
  return readableAddChunk(this, chunk, null, true, false);
};

function readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {
  debug('readableAddChunk', chunk);
  var state = stream._readableState;

  if (chunk === null) {
    state.reading = false;
    onEofChunk(stream, state);
  } else {
    var er;
    if (!skipChunkCheck) er = chunkInvalid(state, chunk);

    if (er) {
      errorOrDestroy(stream, er);
    } else if (state.objectMode || chunk && chunk.length > 0) {
      if (typeof chunk !== 'string' && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer.prototype) {
        chunk = _uint8ArrayToBuffer(chunk);
      }

      if (addToFront) {
        if (state.endEmitted) errorOrDestroy(stream, new ERR_STREAM_UNSHIFT_AFTER_END_EVENT());else addChunk(stream, state, chunk, true);
      } else if (state.ended) {
        errorOrDestroy(stream, new ERR_STREAM_PUSH_AFTER_EOF());
      } else if (state.destroyed) {
        return false;
      } else {
        state.reading = false;

        if (state.decoder && !encoding) {
          chunk = state.decoder.write(chunk);
          if (state.objectMode || chunk.length !== 0) addChunk(stream, state, chunk, false);else maybeReadMore(stream, state);
        } else {
          addChunk(stream, state, chunk, false);
        }
      }
    } else if (!addToFront) {
      state.reading = false;
      maybeReadMore(stream, state);
    }
  } // We can push more data if we are below the highWaterMark.
  // Also, if we have no data yet, we can stand some more bytes.
  // This is to work around cases where hwm=0, such as the repl.


  return !state.ended && (state.length < state.highWaterMark || state.length === 0);
}

function addChunk(stream, state, chunk, addToFront) {
  if (state.flowing && state.length === 0 && !state.sync) {
    state.awaitDrain = 0;
    stream.emit('data', chunk);
  } else {
    // update the buffer info.
    state.length += state.objectMode ? 1 : chunk.length;
    if (addToFront) state.buffer.unshift(chunk);else state.buffer.push(chunk);
    if (state.needReadable) emitReadable(stream);
  }

  maybeReadMore(stream, state);
}

function chunkInvalid(state, chunk) {
  var er;

  if (!_isUint8Array(chunk) && typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {
    er = new ERR_INVALID_ARG_TYPE('chunk', ['string', 'Buffer', 'Uint8Array'], chunk);
  }

  return er;
}

Readable.prototype.isPaused = function () {
  return this._readableState.flowing === false;
}; // backwards compatibility.


Readable.prototype.setEncoding = function (enc) {
  if (!StringDecoder) StringDecoder = require('string_decoder/').StringDecoder;
  var decoder = new StringDecoder(enc);
  this._readableState.decoder = decoder; // If setEncoding(null), decoder.encoding equals utf8

  this._readableState.encoding = this._readableState.decoder.encoding; // Iterate over current buffer to convert already stored Buffers:

  var p = this._readableState.buffer.head;
  var content = '';

  while (p !== null) {
    content += decoder.write(p.data);
    p = p.next;
  }

  this._readableState.buffer.clear();

  if (content !== '') this._readableState.buffer.push(content);
  this._readableState.length = content.length;
  return this;
}; // Don't raise the hwm > 1GB


var MAX_HWM = 0x40000000;

function computeNewHighWaterMark(n) {
  if (n >= MAX_HWM) {
    // TODO(ronag): Throw ERR_VALUE_OUT_OF_RANGE.
    n = MAX_HWM;
  } else {
    // Get the next highest power of 2 to prevent increasing hwm excessively in
    // tiny amounts
    n--;
    n |= n >>> 1;
    n |= n >>> 2;
    n |= n >>> 4;
    n |= n >>> 8;
    n |= n >>> 16;
    n++;
  }

  return n;
} // This function is designed to be inlinable, so please take care when making
// changes to the function body.


function howMuchToRead(n, state) {
  if (n <= 0 || state.length === 0 && state.ended) return 0;
  if (state.objectMode) return 1;

  if (n !== n) {
    // Only flow one buffer at a time
    if (state.flowing && state.length) return state.buffer.head.data.length;else return state.length;
  } // If we're asking for more than the current hwm, then raise the hwm.


  if (n > state.highWaterMark) state.highWaterMark = computeNewHighWaterMark(n);
  if (n <= state.length) return n; // Don't have enough

  if (!state.ended) {
    state.needReadable = true;
    return 0;
  }

  return state.length;
} // you can override either this method, or the async _read(n) below.


Readable.prototype.read = function (n) {
  debug('read', n);
  n = parseInt(n, 10);
  var state = this._readableState;
  var nOrig = n;
  if (n !== 0) state.emittedReadable = false; // if we're doing read(0) to trigger a readable event, but we
  // already have a bunch of data in the buffer, then just trigger
  // the 'readable' event and move on.

  if (n === 0 && state.needReadable && ((state.highWaterMark !== 0 ? state.length >= state.highWaterMark : state.length > 0) || state.ended)) {
    debug('read: emitReadable', state.length, state.ended);
    if (state.length === 0 && state.ended) endReadable(this);else emitReadable(this);
    return null;
  }

  n = howMuchToRead(n, state); // if we've ended, and we're now clear, then finish it up.

  if (n === 0 && state.ended) {
    if (state.length === 0) endReadable(this);
    return null;
  } // All the actual chunk generation logic needs to be
  // *below* the call to _read.  The reason is that in certain
  // synthetic stream cases, such as passthrough streams, _read
  // may be a completely synchronous operation which may change
  // the state of the read buffer, providing enough data when
  // before there was *not* enough.
  //
  // So, the steps are:
  // 1. Figure out what the state of things will be after we do
  // a read from the buffer.
  //
  // 2. If that resulting state will trigger a _read, then call _read.
  // Note that this may be asynchronous, or synchronous.  Yes, it is
  // deeply ugly to write APIs this way, but that still doesn't mean
  // that the Readable class should behave improperly, as streams are
  // designed to be sync/async agnostic.
  // Take note if the _read call is sync or async (ie, if the read call
  // has returned yet), so that we know whether or not it's safe to emit
  // 'readable' etc.
  //
  // 3. Actually pull the requested chunks out of the buffer and return.
  // if we need a readable event, then we need to do some reading.


  var doRead = state.needReadable;
  debug('need readable', doRead); // if we currently have less than the highWaterMark, then also read some

  if (state.length === 0 || state.length - n < state.highWaterMark) {
    doRead = true;
    debug('length less than watermark', doRead);
  } // however, if we've ended, then there's no point, and if we're already
  // reading, then it's unnecessary.


  if (state.ended || state.reading) {
    doRead = false;
    debug('reading or ended', doRead);
  } else if (doRead) {
    debug('do read');
    state.reading = true;
    state.sync = true; // if the length is currently zero, then we *need* a readable event.

    if (state.length === 0) state.needReadable = true; // call internal read method

    this._read(state.highWaterMark);

    state.sync = false; // If _read pushed data synchronously, then `reading` will be false,
    // and we need to re-evaluate how much data we can return to the user.

    if (!state.reading) n = howMuchToRead(nOrig, state);
  }

  var ret;
  if (n > 0) ret = fromList(n, state);else ret = null;

  if (ret === null) {
    state.needReadable = state.length <= state.highWaterMark;
    n = 0;
  } else {
    state.length -= n;
    state.awaitDrain = 0;
  }

  if (state.length === 0) {
    // If we have nothing in the buffer, then we want to know
    // as soon as we *do* get something into the buffer.
    if (!state.ended) state.needReadable = true; // If we tried to read() past the EOF, then emit end on the next tick.

    if (nOrig !== n && state.ended) endReadable(this);
  }

  if (ret !== null) this.emit('data', ret);
  return ret;
};

function onEofChunk(stream, state) {
  debug('onEofChunk');
  if (state.ended) return;

  if (state.decoder) {
    var chunk = state.decoder.end();

    if (chunk && chunk.length) {
      state.buffer.push(chunk);
      state.length += state.objectMode ? 1 : chunk.length;
    }
  }

  state.ended = true;

  if (state.sync) {
    // if we are sync, wait until next tick to emit the data.
    // Otherwise we risk emitting data in the flow()
    // the readable code triggers during a read() call
    emitReadable(stream);
  } else {
    // emit 'readable' now to make sure it gets picked up.
    state.needReadable = false;

    if (!state.emittedReadable) {
      state.emittedReadable = true;
      emitReadable_(stream);
    }
  }
} // Don't emit readable right away in sync mode, because this can trigger
// another read() call => stack overflow.  This way, it might trigger
// a nextTick recursion warning, but that's not so bad.


function emitReadable(stream) {
  var state = stream._readableState;
  debug('emitReadable', state.needReadable, state.emittedReadable);
  state.needReadable = false;

  if (!state.emittedReadable) {
    debug('emitReadable', state.flowing);
    state.emittedReadable = true;
    process.nextTick(emitReadable_, stream);
  }
}

function emitReadable_(stream) {
  var state = stream._readableState;
  debug('emitReadable_', state.destroyed, state.length, state.ended);

  if (!state.destroyed && (state.length || state.ended)) {
    stream.emit('readable');
    state.emittedReadable = false;
  } // The stream needs another readable event if
  // 1. It is not flowing, as the flow mechanism will take
  //    care of it.
  // 2. It is not ended.
  // 3. It is below the highWaterMark, so we can schedule
  //    another readable later.


  state.needReadable = !state.flowing && !state.ended && state.length <= state.highWaterMark;
  flow(stream);
} // at this point, the user has presumably seen the 'readable' event,
// and called read() to consume some data.  that may have triggered
// in turn another _read(n) call, in which case reading = true if
// it's in progress.
// However, if we're not ended, or reading, and the length < hwm,
// then go ahead and try to read some more preemptively.


function maybeReadMore(stream, state) {
  if (!state.readingMore) {
    state.readingMore = true;
    process.nextTick(maybeReadMore_, stream, state);
  }
}

function maybeReadMore_(stream, state) {
  // Attempt to read more data if we should.
  //
  // The conditions for reading more data are (one of):
  // - Not enough data buffered (state.length < state.highWaterMark). The loop
  //   is responsible for filling the buffer with enough data if such data
  //   is available. If highWaterMark is 0 and we are not in the flowing mode
  //   we should _not_ attempt to buffer any extra data. We'll get more data
  //   when the stream consumer calls read() instead.
  // - No data in the buffer, and the stream is in flowing mode. In this mode
  //   the loop below is responsible for ensuring read() is called. Failing to
  //   call read here would abort the flow and there's no other mechanism for
  //   continuing the flow if the stream consumer has just subscribed to the
  //   'data' event.
  //
  // In addition to the above conditions to keep reading data, the following
  // conditions prevent the data from being read:
  // - The stream has ended (state.ended).
  // - There is already a pending 'read' operation (state.reading). This is a
  //   case where the the stream has called the implementation defined _read()
  //   method, but they are processing the call asynchronously and have _not_
  //   called push() with new data. In this case we skip performing more
  //   read()s. The execution ends in this method again after the _read() ends
  //   up calling push() with more data.
  while (!state.reading && !state.ended && (state.length < state.highWaterMark || state.flowing && state.length === 0)) {
    var len = state.length;
    debug('maybeReadMore read 0');
    stream.read(0);
    if (len === state.length) // didn't get any data, stop spinning.
      break;
  }

  state.readingMore = false;
} // abstract method.  to be overridden in specific implementation classes.
// call cb(er, data) where data is <= n in length.
// for virtual (non-string, non-buffer) streams, "length" is somewhat
// arbitrary, and perhaps not very meaningful.


Readable.prototype._read = function (n) {
  errorOrDestroy(this, new ERR_METHOD_NOT_IMPLEMENTED('_read()'));
};

Readable.prototype.pipe = function (dest, pipeOpts) {
  var src = this;
  var state = this._readableState;

  switch (state.pipesCount) {
    case 0:
      state.pipes = dest;
      break;

    case 1:
      state.pipes = [state.pipes, dest];
      break;

    default:
      state.pipes.push(dest);
      break;
  }

  state.pipesCount += 1;
  debug('pipe count=%d opts=%j', state.pipesCount, pipeOpts);
  var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;
  var endFn = doEnd ? onend : unpipe;
  if (state.endEmitted) process.nextTick(endFn);else src.once('end', endFn);
  dest.on('unpipe', onunpipe);

  function onunpipe(readable, unpipeInfo) {
    debug('onunpipe');

    if (readable === src) {
      if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
        unpipeInfo.hasUnpiped = true;
        cleanup();
      }
    }
  }

  function onend() {
    debug('onend');
    dest.end();
  } // when the dest drains, it reduces the awaitDrain counter
  // on the source.  This would be more elegant with a .once()
  // handler in flow(), but adding and removing repeatedly is
  // too slow.


  var ondrain = pipeOnDrain(src);
  dest.on('drain', ondrain);
  var cleanedUp = false;

  function cleanup() {
    debug('cleanup'); // cleanup event handlers once the pipe is broken

    dest.removeListener('close', onclose);
    dest.removeListener('finish', onfinish);
    dest.removeListener('drain', ondrain);
    dest.removeListener('error', onerror);
    dest.removeListener('unpipe', onunpipe);
    src.removeListener('end', onend);
    src.removeListener('end', unpipe);
    src.removeListener('data', ondata);
    cleanedUp = true; // if the reader is waiting for a drain event from this
    // specific writer, then it would cause it to never start
    // flowing again.
    // So, if this is awaiting a drain, then we just call it now.
    // If we don't know, then assume that we are waiting for one.

    if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();
  }

  src.on('data', ondata);

  function ondata(chunk) {
    debug('ondata');
    var ret = dest.write(chunk);
    debug('dest.write', ret);

    if (ret === false) {
      // If the user unpiped during `dest.write()`, it is possible
      // to get stuck in a permanently paused state if that write
      // also returned false.
      // => Check whether `dest` is still a piping destination.
      if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {
        debug('false write response, pause', state.awaitDrain);
        state.awaitDrain++;
      }

      src.pause();
    }
  } // if the dest has an error, then stop piping into it.
  // however, don't suppress the throwing behavior for this.


  function onerror(er) {
    debug('onerror', er);
    unpipe();
    dest.removeListener('error', onerror);
    if (EElistenerCount(dest, 'error') === 0) errorOrDestroy(dest, er);
  } // Make sure our error handler is attached before userland ones.


  prependListener(dest, 'error', onerror); // Both close and finish should trigger unpipe, but only once.

  function onclose() {
    dest.removeListener('finish', onfinish);
    unpipe();
  }

  dest.once('close', onclose);

  function onfinish() {
    debug('onfinish');
    dest.removeListener('close', onclose);
    unpipe();
  }

  dest.once('finish', onfinish);

  function unpipe() {
    debug('unpipe');
    src.unpipe(dest);
  } // tell the dest that it's being piped to


  dest.emit('pipe', src); // start the flow if it hasn't been started already.

  if (!state.flowing) {
    debug('pipe resume');
    src.resume();
  }

  return dest;
};

function pipeOnDrain(src) {
  return function pipeOnDrainFunctionResult() {
    var state = src._readableState;
    debug('pipeOnDrain', state.awaitDrain);
    if (state.awaitDrain) state.awaitDrain--;

    if (state.awaitDrain === 0 && EElistenerCount(src, 'data')) {
      state.flowing = true;
      flow(src);
    }
  };
}

Readable.prototype.unpipe = function (dest) {
  var state = this._readableState;
  var unpipeInfo = {
    hasUnpiped: false
  }; // if we're not piping anywhere, then do nothing.

  if (state.pipesCount === 0) return this; // just one destination.  most common case.

  if (state.pipesCount === 1) {
    // passed in one, but it's not the right one.
    if (dest && dest !== state.pipes) return this;
    if (!dest) dest = state.pipes; // got a match.

    state.pipes = null;
    state.pipesCount = 0;
    state.flowing = false;
    if (dest) dest.emit('unpipe', this, unpipeInfo);
    return this;
  } // slow case. multiple pipe destinations.


  if (!dest) {
    // remove all.
    var dests = state.pipes;
    var len = state.pipesCount;
    state.pipes = null;
    state.pipesCount = 0;
    state.flowing = false;

    for (var i = 0; i < len; i++) {
      dests[i].emit('unpipe', this, {
        hasUnpiped: false
      });
    }

    return this;
  } // try to find the right one.


  var index = indexOf(state.pipes, dest);
  if (index === -1) return this;
  state.pipes.splice(index, 1);
  state.pipesCount -= 1;
  if (state.pipesCount === 1) state.pipes = state.pipes[0];
  dest.emit('unpipe', this, unpipeInfo);
  return this;
}; // set up data events if they are asked for
// Ensure readable listeners eventually get something


Readable.prototype.on = function (ev, fn) {
  var res = Stream.prototype.on.call(this, ev, fn);
  var state = this._readableState;

  if (ev === 'data') {
    // update readableListening so that resume() may be a no-op
    // a few lines down. This is needed to support once('readable').
    state.readableListening = this.listenerCount('readable') > 0; // Try start flowing on next tick if stream isn't explicitly paused

    if (state.flowing !== false) this.resume();
  } else if (ev === 'readable') {
    if (!state.endEmitted && !state.readableListening) {
      state.readableListening = state.needReadable = true;
      state.flowing = false;
      state.emittedReadable = false;
      debug('on readable', state.length, state.reading);

      if (state.length) {
        emitReadable(this);
      } else if (!state.reading) {
        process.nextTick(nReadingNextTick, this);
      }
    }
  }

  return res;
};

Readable.prototype.addListener = Readable.prototype.on;

Readable.prototype.removeListener = function (ev, fn) {
  var res = Stream.prototype.removeListener.call(this, ev, fn);

  if (ev === 'readable') {
    // We need to check if there is someone still listening to
    // readable and reset the state. However this needs to happen
    // after readable has been emitted but before I/O (nextTick) to
    // support once('readable', fn) cycles. This means that calling
    // resume within the same tick will have no
    // effect.
    process.nextTick(updateReadableListening, this);
  }

  return res;
};

Readable.prototype.removeAllListeners = function (ev) {
  var res = Stream.prototype.removeAllListeners.apply(this, arguments);

  if (ev === 'readable' || ev === undefined) {
    // We need to check if there is someone still listening to
    // readable and reset the state. However this needs to happen
    // after readable has been emitted but before I/O (nextTick) to
    // support once('readable', fn) cycles. This means that calling
    // resume within the same tick will have no
    // effect.
    process.nextTick(updateReadableListening, this);
  }

  return res;
};

function updateReadableListening(self) {
  var state = self._readableState;
  state.readableListening = self.listenerCount('readable') > 0;

  if (state.resumeScheduled && !state.paused) {
    // flowing needs to be set to true now, otherwise
    // the upcoming resume will not flow.
    state.flowing = true; // crude way to check if we should resume
  } else if (self.listenerCount('data') > 0) {
    self.resume();
  }
}

function nReadingNextTick(self) {
  debug('readable nexttick read 0');
  self.read(0);
} // pause() and resume() are remnants of the legacy readable stream API
// If the user uses them, then switch into old mode.


Readable.prototype.resume = function () {
  var state = this._readableState;

  if (!state.flowing) {
    debug('resume'); // we flow only if there is no one listening
    // for readable, but we still have to call
    // resume()

    state.flowing = !state.readableListening;
    resume(this, state);
  }

  state.paused = false;
  return this;
};

function resume(stream, state) {
  if (!state.resumeScheduled) {
    state.resumeScheduled = true;
    process.nextTick(resume_, stream, state);
  }
}

function resume_(stream, state) {
  debug('resume', state.reading);

  if (!state.reading) {
    stream.read(0);
  }

  state.resumeScheduled = false;
  stream.emit('resume');
  flow(stream);
  if (state.flowing && !state.reading) stream.read(0);
}

Readable.prototype.pause = function () {
  debug('call pause flowing=%j', this._readableState.flowing);

  if (this._readableState.flowing !== false) {
    debug('pause');
    this._readableState.flowing = false;
    this.emit('pause');
  }

  this._readableState.paused = true;
  return this;
};

function flow(stream) {
  var state = stream._readableState;
  debug('flow', state.flowing);

  while (state.flowing && stream.read() !== null) {
    ;
  }
} // wrap an old-style stream as the async data source.
// This is *not* part of the readable stream interface.
// It is an ugly unfortunate mess of history.


Readable.prototype.wrap = function (stream) {
  var _this = this;

  var state = this._readableState;
  var paused = false;
  stream.on('end', function () {
    debug('wrapped end');

    if (state.decoder && !state.ended) {
      var chunk = state.decoder.end();
      if (chunk && chunk.length) _this.push(chunk);
    }

    _this.push(null);
  });
  stream.on('data', function (chunk) {
    debug('wrapped data');
    if (state.decoder) chunk = state.decoder.write(chunk); // don't skip over falsy values in objectMode

    if (state.objectMode && (chunk === null || chunk === undefined)) return;else if (!state.objectMode && (!chunk || !chunk.length)) return;

    var ret = _this.push(chunk);

    if (!ret) {
      paused = true;
      stream.pause();
    }
  }); // proxy all the other methods.
  // important when wrapping filters and duplexes.

  for (var i in stream) {
    if (this[i] === undefined && typeof stream[i] === 'function') {
      this[i] = function methodWrap(method) {
        return function methodWrapReturnFunction() {
          return stream[method].apply(stream, arguments);
        };
      }(i);
    }
  } // proxy certain important events.


  for (var n = 0; n < kProxyEvents.length; n++) {
    stream.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));
  } // when we try to consume some more bytes, simply unpause the
  // underlying stream.


  this._read = function (n) {
    debug('wrapped _read', n);

    if (paused) {
      paused = false;
      stream.resume();
    }
  };

  return this;
};

if (typeof Symbol === 'function') {
  Readable.prototype[Symbol.asyncIterator] = function () {
    if (createReadableStreamAsyncIterator === undefined) {
      createReadableStreamAsyncIterator = require('./internal/streams/async_iterator');
    }

    return createReadableStreamAsyncIterator(this);
  };
}

Object.defineProperty(Readable.prototype, 'readableHighWaterMark', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._readableState.highWaterMark;
  }
});
Object.defineProperty(Readable.prototype, 'readableBuffer', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._readableState && this._readableState.buffer;
  }
});
Object.defineProperty(Readable.prototype, 'readableFlowing', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._readableState.flowing;
  },
  set: function set(state) {
    if (this._readableState) {
      this._readableState.flowing = state;
    }
  }
}); // exposed for testing purposes only.

Readable._fromList = fromList;
Object.defineProperty(Readable.prototype, 'readableLength', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._readableState.length;
  }
}); // Pluck off n bytes from an array of buffers.
// Length is the combined lengths of all the buffers in the list.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.

function fromList(n, state) {
  // nothing buffered
  if (state.length === 0) return null;
  var ret;
  if (state.objectMode) ret = state.buffer.shift();else if (!n || n >= state.length) {
    // read it all, truncate the list
    if (state.decoder) ret = state.buffer.join('');else if (state.buffer.length === 1) ret = state.buffer.first();else ret = state.buffer.concat(state.length);
    state.buffer.clear();
  } else {
    // read part of list
    ret = state.buffer.consume(n, state.decoder);
  }
  return ret;
}

function endReadable(stream) {
  var state = stream._readableState;
  debug('endReadable', state.endEmitted);

  if (!state.endEmitted) {
    state.ended = true;
    process.nextTick(endReadableNT, state, stream);
  }
}

function endReadableNT(state, stream) {
  debug('endReadableNT', state.endEmitted, state.length); // Check that we didn't get one last unshift.

  if (!state.endEmitted && state.length === 0) {
    state.endEmitted = true;
    stream.readable = false;
    stream.emit('end');

    if (state.autoDestroy) {
      // In case of duplex streams we need a way to detect
      // if the writable side is ready for autoDestroy as well
      var wState = stream._writableState;

      if (!wState || wState.autoDestroy && wState.finished) {
        stream.destroy();
      }
    }
  }
}

if (typeof Symbol === 'function') {
  Readable.from = function (iterable, opts) {
    if (from === undefined) {
      from = require('./internal/streams/from');
    }

    return from(Readable, iterable, opts);
  };
}

function indexOf(xs, x) {
  for (var i = 0, l = xs.length; i < l; i++) {
    if (xs[i] === x) return i;
  }

  return -1;
}
}).call(this)}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../errors":235,"./_stream_duplex":236,"./internal/streams/async_iterator":241,"./internal/streams/buffer_list":242,"./internal/streams/destroy":243,"./internal/streams/from":245,"./internal/streams/state":247,"./internal/streams/stream":248,"_process":223,"buffer":145,"events":162,"inherits":174,"string_decoder/":249,"util":133}],239:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
// a transform stream is a readable/writable stream where you do
// something with the data.  Sometimes it's called a "filter",
// but that's not a great name for it, since that implies a thing where
// some bits pass through, and others are simply ignored.  (That would
// be a valid example of a transform, of course.)
//
// While the output is causally related to the input, it's not a
// necessarily symmetric or synchronous transformation.  For example,
// a zlib stream might take multiple plain-text writes(), and then
// emit a single compressed chunk some time in the future.
//
// Here's how this works:
//
// The Transform stream has all the aspects of the readable and writable
// stream classes.  When you write(chunk), that calls _write(chunk,cb)
// internally, and returns false if there's a lot of pending writes
// buffered up.  When you call read(), that calls _read(n) until
// there's enough pending readable data buffered up.
//
// In a transform stream, the written data is placed in a buffer.  When
// _read(n) is called, it transforms the queued up data, calling the
// buffered _write cb's as it consumes chunks.  If consuming a single
// written chunk would result in multiple output chunks, then the first
// outputted bit calls the readcb, and subsequent chunks just go into
// the read buffer, and will cause it to emit 'readable' if necessary.
//
// This way, back-pressure is actually determined by the reading side,
// since _read has to be called to start processing a new chunk.  However,
// a pathological inflate type of transform can cause excessive buffering
// here.  For example, imagine a stream where every byte of input is
// interpreted as an integer from 0-255, and then results in that many
// bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in
// 1kb of data being output.  In this case, you could write a very small
// amount of input, and end up with a very large amount of output.  In
// such a pathological inflating mechanism, there'd be no way to tell
// the system to stop doing the transform.  A single 4MB write could
// cause the system to run out of memory.
//
// However, even in such a pathological case, only a single written chunk
// would be consumed, and then the rest would wait (un-transformed) until
// the results of the previous transformed chunk were consumed.
'use strict';

module.exports = Transform;

var _require$codes = require('../errors').codes,
    ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED,
    ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK,
    ERR_TRANSFORM_ALREADY_TRANSFORMING = _require$codes.ERR_TRANSFORM_ALREADY_TRANSFORMING,
    ERR_TRANSFORM_WITH_LENGTH_0 = _require$codes.ERR_TRANSFORM_WITH_LENGTH_0;

var Duplex = require('./_stream_duplex');

require('inherits')(Transform, Duplex);

function afterTransform(er, data) {
  var ts = this._transformState;
  ts.transforming = false;
  var cb = ts.writecb;

  if (cb === null) {
    return this.emit('error', new ERR_MULTIPLE_CALLBACK());
  }

  ts.writechunk = null;
  ts.writecb = null;
  if (data != null) // single equals check for both `null` and `undefined`
    this.push(data);
  cb(er);
  var rs = this._readableState;
  rs.reading = false;

  if (rs.needReadable || rs.length < rs.highWaterMark) {
    this._read(rs.highWaterMark);
  }
}

function Transform(options) {
  if (!(this instanceof Transform)) return new Transform(options);
  Duplex.call(this, options);
  this._transformState = {
    afterTransform: afterTransform.bind(this),
    needTransform: false,
    transforming: false,
    writecb: null,
    writechunk: null,
    writeencoding: null
  }; // start out asking for a readable event once data is transformed.

  this._readableState.needReadable = true; // we have implemented the _read method, and done the other things
  // that Readable wants before the first _read call, so unset the
  // sync guard flag.

  this._readableState.sync = false;

  if (options) {
    if (typeof options.transform === 'function') this._transform = options.transform;
    if (typeof options.flush === 'function') this._flush = options.flush;
  } // When the writable side finishes, then flush out anything remaining.


  this.on('prefinish', prefinish);
}

function prefinish() {
  var _this = this;

  if (typeof this._flush === 'function' && !this._readableState.destroyed) {
    this._flush(function (er, data) {
      done(_this, er, data);
    });
  } else {
    done(this, null, null);
  }
}

Transform.prototype.push = function (chunk, encoding) {
  this._transformState.needTransform = false;
  return Duplex.prototype.push.call(this, chunk, encoding);
}; // This is the part where you do stuff!
// override this function in implementation classes.
// 'chunk' is an input chunk.
//
// Call `push(newChunk)` to pass along transformed output
// to the readable side.  You may call 'push' zero or more times.
//
// Call `cb(err)` when you are done with this chunk.  If you pass
// an error, then that'll put the hurt on the whole operation.  If you
// never call cb(), then you'll never get another chunk.


Transform.prototype._transform = function (chunk, encoding, cb) {
  cb(new ERR_METHOD_NOT_IMPLEMENTED('_transform()'));
};

Transform.prototype._write = function (chunk, encoding, cb) {
  var ts = this._transformState;
  ts.writecb = cb;
  ts.writechunk = chunk;
  ts.writeencoding = encoding;

  if (!ts.transforming) {
    var rs = this._readableState;
    if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);
  }
}; // Doesn't matter what the args are here.
// _transform does all the work.
// That we got here means that the readable side wants more data.


Transform.prototype._read = function (n) {
  var ts = this._transformState;

  if (ts.writechunk !== null && !ts.transforming) {
    ts.transforming = true;

    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
  } else {
    // mark that we need a transform, so that any data that comes in
    // will get processed, now that we've asked for it.
    ts.needTransform = true;
  }
};

Transform.prototype._destroy = function (err, cb) {
  Duplex.prototype._destroy.call(this, err, function (err2) {
    cb(err2);
  });
};

function done(stream, er, data) {
  if (er) return stream.emit('error', er);
  if (data != null) // single equals check for both `null` and `undefined`
    stream.push(data); // TODO(BridgeAR): Write a test for these two error cases
  // if there's nothing in the write buffer, then that means
  // that nothing more will ever be provided

  if (stream._writableState.length) throw new ERR_TRANSFORM_WITH_LENGTH_0();
  if (stream._transformState.transforming) throw new ERR_TRANSFORM_ALREADY_TRANSFORMING();
  return stream.push(null);
}
},{"../errors":235,"./_stream_duplex":236,"inherits":174}],240:[function(require,module,exports){
(function (process,global){(function (){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
// A bit simpler than readable streams.
// Implement an async ._write(chunk, encoding, cb), and it'll handle all
// the drain event emission and buffering.
'use strict';

module.exports = Writable;
/* <replacement> */

function WriteReq(chunk, encoding, cb) {
  this.chunk = chunk;
  this.encoding = encoding;
  this.callback = cb;
  this.next = null;
} // It seems a linked list but it is not
// there will be only 2 of these for each stream


function CorkedRequest(state) {
  var _this = this;

  this.next = null;
  this.entry = null;

  this.finish = function () {
    onCorkedFinish(_this, state);
  };
}
/* </replacement> */

/*<replacement>*/


var Duplex;
/*</replacement>*/

Writable.WritableState = WritableState;
/*<replacement>*/

var internalUtil = {
  deprecate: require('util-deprecate')
};
/*</replacement>*/

/*<replacement>*/

var Stream = require('./internal/streams/stream');
/*</replacement>*/


var Buffer = require('buffer').Buffer;

var OurUint8Array = global.Uint8Array || function () {};

function _uint8ArrayToBuffer(chunk) {
  return Buffer.from(chunk);
}

function _isUint8Array(obj) {
  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;
}

var destroyImpl = require('./internal/streams/destroy');

var _require = require('./internal/streams/state'),
    getHighWaterMark = _require.getHighWaterMark;

var _require$codes = require('../errors').codes,
    ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE,
    ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED,
    ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK,
    ERR_STREAM_CANNOT_PIPE = _require$codes.ERR_STREAM_CANNOT_PIPE,
    ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED,
    ERR_STREAM_NULL_VALUES = _require$codes.ERR_STREAM_NULL_VALUES,
    ERR_STREAM_WRITE_AFTER_END = _require$codes.ERR_STREAM_WRITE_AFTER_END,
    ERR_UNKNOWN_ENCODING = _require$codes.ERR_UNKNOWN_ENCODING;

var errorOrDestroy = destroyImpl.errorOrDestroy;

require('inherits')(Writable, Stream);

function nop() {}

function WritableState(options, stream, isDuplex) {
  Duplex = Duplex || require('./_stream_duplex');
  options = options || {}; // Duplex streams are both readable and writable, but share
  // the same options object.
  // However, some cases require setting options to different
  // values for the readable and the writable sides of the duplex stream,
  // e.g. options.readableObjectMode vs. options.writableObjectMode, etc.

  if (typeof isDuplex !== 'boolean') isDuplex = stream instanceof Duplex; // object stream flag to indicate whether or not this stream
  // contains buffers or objects.

  this.objectMode = !!options.objectMode;
  if (isDuplex) this.objectMode = this.objectMode || !!options.writableObjectMode; // the point at which write() starts returning false
  // Note: 0 is a valid value, means that we always return false if
  // the entire buffer is not flushed immediately on write()

  this.highWaterMark = getHighWaterMark(this, options, 'writableHighWaterMark', isDuplex); // if _final has been called

  this.finalCalled = false; // drain event flag.

  this.needDrain = false; // at the start of calling end()

  this.ending = false; // when end() has been called, and returned

  this.ended = false; // when 'finish' is emitted

  this.finished = false; // has it been destroyed

  this.destroyed = false; // should we decode strings into buffers before passing to _write?
  // this is here so that some node-core streams can optimize string
  // handling at a lower level.

  var noDecode = options.decodeStrings === false;
  this.decodeStrings = !noDecode; // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.

  this.defaultEncoding = options.defaultEncoding || 'utf8'; // not an actual buffer we keep track of, but a measurement
  // of how much we're waiting to get pushed to some underlying
  // socket or file.

  this.length = 0; // a flag to see when we're in the middle of a write.

  this.writing = false; // when true all writes will be buffered until .uncork() call

  this.corked = 0; // a flag to be able to tell if the onwrite cb is called immediately,
  // or on a later tick.  We set this to true at first, because any
  // actions that shouldn't happen until "later" should generally also
  // not happen before the first write call.

  this.sync = true; // a flag to know if we're processing previously buffered items, which
  // may call the _write() callback in the same tick, so that we don't
  // end up in an overlapped onwrite situation.

  this.bufferProcessing = false; // the callback that's passed to _write(chunk,cb)

  this.onwrite = function (er) {
    onwrite(stream, er);
  }; // the callback that the user supplies to write(chunk,encoding,cb)


  this.writecb = null; // the amount that is being written when _write is called.

  this.writelen = 0;
  this.bufferedRequest = null;
  this.lastBufferedRequest = null; // number of pending user-supplied write callbacks
  // this must be 0 before 'finish' can be emitted

  this.pendingcb = 0; // emit prefinish if the only thing we're waiting for is _write cbs
  // This is relevant for synchronous Transform streams

  this.prefinished = false; // True if the error was already emitted and should not be thrown again

  this.errorEmitted = false; // Should close be emitted on destroy. Defaults to true.

  this.emitClose = options.emitClose !== false; // Should .destroy() be called after 'finish' (and potentially 'end')

  this.autoDestroy = !!options.autoDestroy; // count buffered requests

  this.bufferedRequestCount = 0; // allocate the first CorkedRequest, there is always
  // one allocated and free to use, and we maintain at most two

  this.corkedRequestsFree = new CorkedRequest(this);
}

WritableState.prototype.getBuffer = function getBuffer() {
  var current = this.bufferedRequest;
  var out = [];

  while (current) {
    out.push(current);
    current = current.next;
  }

  return out;
};

(function () {
  try {
    Object.defineProperty(WritableState.prototype, 'buffer', {
      get: internalUtil.deprecate(function writableStateBufferGetter() {
        return this.getBuffer();
      }, '_writableState.buffer is deprecated. Use _writableState.getBuffer ' + 'instead.', 'DEP0003')
    });
  } catch (_) {}
})(); // Test _writableState for inheritance to account for Duplex streams,
// whose prototype chain only points to Readable.


var realHasInstance;

if (typeof Symbol === 'function' && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === 'function') {
  realHasInstance = Function.prototype[Symbol.hasInstance];
  Object.defineProperty(Writable, Symbol.hasInstance, {
    value: function value(object) {
      if (realHasInstance.call(this, object)) return true;
      if (this !== Writable) return false;
      return object && object._writableState instanceof WritableState;
    }
  });
} else {
  realHasInstance = function realHasInstance(object) {
    return object instanceof this;
  };
}

function Writable(options) {
  Duplex = Duplex || require('./_stream_duplex'); // Writable ctor is applied to Duplexes, too.
  // `realHasInstance` is necessary because using plain `instanceof`
  // would return false, as no `_writableState` property is attached.
  // Trying to use the custom `instanceof` for Writable here will also break the
  // Node.js LazyTransform implementation, which has a non-trivial getter for
  // `_writableState` that would lead to infinite recursion.
  // Checking for a Stream.Duplex instance is faster here instead of inside
  // the WritableState constructor, at least with V8 6.5

  var isDuplex = this instanceof Duplex;
  if (!isDuplex && !realHasInstance.call(Writable, this)) return new Writable(options);
  this._writableState = new WritableState(options, this, isDuplex); // legacy.

  this.writable = true;

  if (options) {
    if (typeof options.write === 'function') this._write = options.write;
    if (typeof options.writev === 'function') this._writev = options.writev;
    if (typeof options.destroy === 'function') this._destroy = options.destroy;
    if (typeof options.final === 'function') this._final = options.final;
  }

  Stream.call(this);
} // Otherwise people can pipe Writable streams, which is just wrong.


Writable.prototype.pipe = function () {
  errorOrDestroy(this, new ERR_STREAM_CANNOT_PIPE());
};

function writeAfterEnd(stream, cb) {
  var er = new ERR_STREAM_WRITE_AFTER_END(); // TODO: defer error events consistently everywhere, not just the cb

  errorOrDestroy(stream, er);
  process.nextTick(cb, er);
} // Checks that a user-supplied chunk is valid, especially for the particular
// mode the stream is in. Currently this means that `null` is never accepted
// and undefined/non-string values are only allowed in object mode.


function validChunk(stream, state, chunk, cb) {
  var er;

  if (chunk === null) {
    er = new ERR_STREAM_NULL_VALUES();
  } else if (typeof chunk !== 'string' && !state.objectMode) {
    er = new ERR_INVALID_ARG_TYPE('chunk', ['string', 'Buffer'], chunk);
  }

  if (er) {
    errorOrDestroy(stream, er);
    process.nextTick(cb, er);
    return false;
  }

  return true;
}

Writable.prototype.write = function (chunk, encoding, cb) {
  var state = this._writableState;
  var ret = false;

  var isBuf = !state.objectMode && _isUint8Array(chunk);

  if (isBuf && !Buffer.isBuffer(chunk)) {
    chunk = _uint8ArrayToBuffer(chunk);
  }

  if (typeof encoding === 'function') {
    cb = encoding;
    encoding = null;
  }

  if (isBuf) encoding = 'buffer';else if (!encoding) encoding = state.defaultEncoding;
  if (typeof cb !== 'function') cb = nop;
  if (state.ending) writeAfterEnd(this, cb);else if (isBuf || validChunk(this, state, chunk, cb)) {
    state.pendingcb++;
    ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);
  }
  return ret;
};

Writable.prototype.cork = function () {
  this._writableState.corked++;
};

Writable.prototype.uncork = function () {
  var state = this._writableState;

  if (state.corked) {
    state.corked--;
    if (!state.writing && !state.corked && !state.bufferProcessing && state.bufferedRequest) clearBuffer(this, state);
  }
};

Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
  // node::ParseEncoding() requires lower case.
  if (typeof encoding === 'string') encoding = encoding.toLowerCase();
  if (!(['hex', 'utf8', 'utf-8', 'ascii', 'binary', 'base64', 'ucs2', 'ucs-2', 'utf16le', 'utf-16le', 'raw'].indexOf((encoding + '').toLowerCase()) > -1)) throw new ERR_UNKNOWN_ENCODING(encoding);
  this._writableState.defaultEncoding = encoding;
  return this;
};

Object.defineProperty(Writable.prototype, 'writableBuffer', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._writableState && this._writableState.getBuffer();
  }
});

function decodeChunk(state, chunk, encoding) {
  if (!state.objectMode && state.decodeStrings !== false && typeof chunk === 'string') {
    chunk = Buffer.from(chunk, encoding);
  }

  return chunk;
}

Object.defineProperty(Writable.prototype, 'writableHighWaterMark', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._writableState.highWaterMark;
  }
}); // if we're already writing something, then just put this
// in the queue, and wait our turn.  Otherwise, call _write
// If we return false, then we need a drain event, so set that flag.

function writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {
  if (!isBuf) {
    var newChunk = decodeChunk(state, chunk, encoding);

    if (chunk !== newChunk) {
      isBuf = true;
      encoding = 'buffer';
      chunk = newChunk;
    }
  }

  var len = state.objectMode ? 1 : chunk.length;
  state.length += len;
  var ret = state.length < state.highWaterMark; // we must ensure that previous needDrain will not be reset to false.

  if (!ret) state.needDrain = true;

  if (state.writing || state.corked) {
    var last = state.lastBufferedRequest;
    state.lastBufferedRequest = {
      chunk: chunk,
      encoding: encoding,
      isBuf: isBuf,
      callback: cb,
      next: null
    };

    if (last) {
      last.next = state.lastBufferedRequest;
    } else {
      state.bufferedRequest = state.lastBufferedRequest;
    }

    state.bufferedRequestCount += 1;
  } else {
    doWrite(stream, state, false, len, chunk, encoding, cb);
  }

  return ret;
}

function doWrite(stream, state, writev, len, chunk, encoding, cb) {
  state.writelen = len;
  state.writecb = cb;
  state.writing = true;
  state.sync = true;
  if (state.destroyed) state.onwrite(new ERR_STREAM_DESTROYED('write'));else if (writev) stream._writev(chunk, state.onwrite);else stream._write(chunk, encoding, state.onwrite);
  state.sync = false;
}

function onwriteError(stream, state, sync, er, cb) {
  --state.pendingcb;

  if (sync) {
    // defer the callback if we are being called synchronously
    // to avoid piling up things on the stack
    process.nextTick(cb, er); // this can emit finish, and it will always happen
    // after error

    process.nextTick(finishMaybe, stream, state);
    stream._writableState.errorEmitted = true;
    errorOrDestroy(stream, er);
  } else {
    // the caller expect this to happen before if
    // it is async
    cb(er);
    stream._writableState.errorEmitted = true;
    errorOrDestroy(stream, er); // this can emit finish, but finish must
    // always follow error

    finishMaybe(stream, state);
  }
}

function onwriteStateUpdate(state) {
  state.writing = false;
  state.writecb = null;
  state.length -= state.writelen;
  state.writelen = 0;
}

function onwrite(stream, er) {
  var state = stream._writableState;
  var sync = state.sync;
  var cb = state.writecb;
  if (typeof cb !== 'function') throw new ERR_MULTIPLE_CALLBACK();
  onwriteStateUpdate(state);
  if (er) onwriteError(stream, state, sync, er, cb);else {
    // Check if we're actually ready to finish, but don't emit yet
    var finished = needFinish(state) || stream.destroyed;

    if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
      clearBuffer(stream, state);
    }

    if (sync) {
      process.nextTick(afterWrite, stream, state, finished, cb);
    } else {
      afterWrite(stream, state, finished, cb);
    }
  }
}

function afterWrite(stream, state, finished, cb) {
  if (!finished) onwriteDrain(stream, state);
  state.pendingcb--;
  cb();
  finishMaybe(stream, state);
} // Must force callback to be called on nextTick, so that we don't
// emit 'drain' before the write() consumer gets the 'false' return
// value, and has a chance to attach a 'drain' listener.


function onwriteDrain(stream, state) {
  if (state.length === 0 && state.needDrain) {
    state.needDrain = false;
    stream.emit('drain');
  }
} // if there's something in the buffer waiting, then process it


function clearBuffer(stream, state) {
  state.bufferProcessing = true;
  var entry = state.bufferedRequest;

  if (stream._writev && entry && entry.next) {
    // Fast case, write everything using _writev()
    var l = state.bufferedRequestCount;
    var buffer = new Array(l);
    var holder = state.corkedRequestsFree;
    holder.entry = entry;
    var count = 0;
    var allBuffers = true;

    while (entry) {
      buffer[count] = entry;
      if (!entry.isBuf) allBuffers = false;
      entry = entry.next;
      count += 1;
    }

    buffer.allBuffers = allBuffers;
    doWrite(stream, state, true, state.length, buffer, '', holder.finish); // doWrite is almost always async, defer these to save a bit of time
    // as the hot path ends with doWrite

    state.pendingcb++;
    state.lastBufferedRequest = null;

    if (holder.next) {
      state.corkedRequestsFree = holder.next;
      holder.next = null;
    } else {
      state.corkedRequestsFree = new CorkedRequest(state);
    }

    state.bufferedRequestCount = 0;
  } else {
    // Slow case, write chunks one-by-one
    while (entry) {
      var chunk = entry.chunk;
      var encoding = entry.encoding;
      var cb = entry.callback;
      var len = state.objectMode ? 1 : chunk.length;
      doWrite(stream, state, false, len, chunk, encoding, cb);
      entry = entry.next;
      state.bufferedRequestCount--; // if we didn't call the onwrite immediately, then
      // it means that we need to wait until it does.
      // also, that means that the chunk and cb are currently
      // being processed, so move the buffer counter past them.

      if (state.writing) {
        break;
      }
    }

    if (entry === null) state.lastBufferedRequest = null;
  }

  state.bufferedRequest = entry;
  state.bufferProcessing = false;
}

Writable.prototype._write = function (chunk, encoding, cb) {
  cb(new ERR_METHOD_NOT_IMPLEMENTED('_write()'));
};

Writable.prototype._writev = null;

Writable.prototype.end = function (chunk, encoding, cb) {
  var state = this._writableState;

  if (typeof chunk === 'function') {
    cb = chunk;
    chunk = null;
    encoding = null;
  } else if (typeof encoding === 'function') {
    cb = encoding;
    encoding = null;
  }

  if (chunk !== null && chunk !== undefined) this.write(chunk, encoding); // .end() fully uncorks

  if (state.corked) {
    state.corked = 1;
    this.uncork();
  } // ignore unnecessary end() calls.


  if (!state.ending) endWritable(this, state, cb);
  return this;
};

Object.defineProperty(Writable.prototype, 'writableLength', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._writableState.length;
  }
});

function needFinish(state) {
  return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
}

function callFinal(stream, state) {
  stream._final(function (err) {
    state.pendingcb--;

    if (err) {
      errorOrDestroy(stream, err);
    }

    state.prefinished = true;
    stream.emit('prefinish');
    finishMaybe(stream, state);
  });
}

function prefinish(stream, state) {
  if (!state.prefinished && !state.finalCalled) {
    if (typeof stream._final === 'function' && !state.destroyed) {
      state.pendingcb++;
      state.finalCalled = true;
      process.nextTick(callFinal, stream, state);
    } else {
      state.prefinished = true;
      stream.emit('prefinish');
    }
  }
}

function finishMaybe(stream, state) {
  var need = needFinish(state);

  if (need) {
    prefinish(stream, state);

    if (state.pendingcb === 0) {
      state.finished = true;
      stream.emit('finish');

      if (state.autoDestroy) {
        // In case of duplex streams we need a way to detect
        // if the readable side is ready for autoDestroy as well
        var rState = stream._readableState;

        if (!rState || rState.autoDestroy && rState.endEmitted) {
          stream.destroy();
        }
      }
    }
  }

  return need;
}

function endWritable(stream, state, cb) {
  state.ending = true;
  finishMaybe(stream, state);

  if (cb) {
    if (state.finished) process.nextTick(cb);else stream.once('finish', cb);
  }

  state.ended = true;
  stream.writable = false;
}

function onCorkedFinish(corkReq, state, err) {
  var entry = corkReq.entry;
  corkReq.entry = null;

  while (entry) {
    var cb = entry.callback;
    state.pendingcb--;
    cb(err);
    entry = entry.next;
  } // reuse the free corkReq.


  state.corkedRequestsFree.next = corkReq;
}

Object.defineProperty(Writable.prototype, 'destroyed', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    if (this._writableState === undefined) {
      return false;
    }

    return this._writableState.destroyed;
  },
  set: function set(value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (!this._writableState) {
      return;
    } // backward compatibility, the user is explicitly
    // managing destroyed


    this._writableState.destroyed = value;
  }
});
Writable.prototype.destroy = destroyImpl.destroy;
Writable.prototype._undestroy = destroyImpl.undestroy;

Writable.prototype._destroy = function (err, cb) {
  cb(err);
};
}).call(this)}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../errors":235,"./_stream_duplex":236,"./internal/streams/destroy":243,"./internal/streams/state":247,"./internal/streams/stream":248,"_process":223,"buffer":145,"inherits":174,"util-deprecate":254}],241:[function(require,module,exports){
(function (process){(function (){
'use strict';

var _Object$setPrototypeO;

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var finished = require('./end-of-stream');

var kLastResolve = Symbol('lastResolve');
var kLastReject = Symbol('lastReject');
var kError = Symbol('error');
var kEnded = Symbol('ended');
var kLastPromise = Symbol('lastPromise');
var kHandlePromise = Symbol('handlePromise');
var kStream = Symbol('stream');

function createIterResult(value, done) {
  return {
    value: value,
    done: done
  };
}

function readAndResolve(iter) {
  var resolve = iter[kLastResolve];

  if (resolve !== null) {
    var data = iter[kStream].read(); // we defer if data is null
    // we can be expecting either 'end' or
    // 'error'

    if (data !== null) {
      iter[kLastPromise] = null;
      iter[kLastResolve] = null;
      iter[kLastReject] = null;
      resolve(createIterResult(data, false));
    }
  }
}

function onReadable(iter) {
  // we wait for the next tick, because it might
  // emit an error with process.nextTick
  process.nextTick(readAndResolve, iter);
}

function wrapForNext(lastPromise, iter) {
  return function (resolve, reject) {
    lastPromise.then(function () {
      if (iter[kEnded]) {
        resolve(createIterResult(undefined, true));
        return;
      }

      iter[kHandlePromise](resolve, reject);
    }, reject);
  };
}

var AsyncIteratorPrototype = Object.getPrototypeOf(function () {});
var ReadableStreamAsyncIteratorPrototype = Object.setPrototypeOf((_Object$setPrototypeO = {
  get stream() {
    return this[kStream];
  },

  next: function next() {
    var _this = this;

    // if we have detected an error in the meanwhile
    // reject straight away
    var error = this[kError];

    if (error !== null) {
      return Promise.reject(error);
    }

    if (this[kEnded]) {
      return Promise.resolve(createIterResult(undefined, true));
    }

    if (this[kStream].destroyed) {
      // We need to defer via nextTick because if .destroy(err) is
      // called, the error will be emitted via nextTick, and
      // we cannot guarantee that there is no error lingering around
      // waiting to be emitted.
      return new Promise(function (resolve, reject) {
        process.nextTick(function () {
          if (_this[kError]) {
            reject(_this[kError]);
          } else {
            resolve(createIterResult(undefined, true));
          }
        });
      });
    } // if we have multiple next() calls
    // we will wait for the previous Promise to finish
    // this logic is optimized to support for await loops,
    // where next() is only called once at a time


    var lastPromise = this[kLastPromise];
    var promise;

    if (lastPromise) {
      promise = new Promise(wrapForNext(lastPromise, this));
    } else {
      // fast path needed to support multiple this.push()
      // without triggering the next() queue
      var data = this[kStream].read();

      if (data !== null) {
        return Promise.resolve(createIterResult(data, false));
      }

      promise = new Promise(this[kHandlePromise]);
    }

    this[kLastPromise] = promise;
    return promise;
  }
}, _defineProperty(_Object$setPrototypeO, Symbol.asyncIterator, function () {
  return this;
}), _defineProperty(_Object$setPrototypeO, "return", function _return() {
  var _this2 = this;

  // destroy(err, cb) is a private API
  // we can guarantee we have that here, because we control the
  // Readable class this is attached to
  return new Promise(function (resolve, reject) {
    _this2[kStream].destroy(null, function (err) {
      if (err) {
        reject(err);
        return;
      }

      resolve(createIterResult(undefined, true));
    });
  });
}), _Object$setPrototypeO), AsyncIteratorPrototype);

var createReadableStreamAsyncIterator = function createReadableStreamAsyncIterator(stream) {
  var _Object$create;

  var iterator = Object.create(ReadableStreamAsyncIteratorPrototype, (_Object$create = {}, _defineProperty(_Object$create, kStream, {
    value: stream,
    writable: true
  }), _defineProperty(_Object$create, kLastResolve, {
    value: null,
    writable: true
  }), _defineProperty(_Object$create, kLastReject, {
    value: null,
    writable: true
  }), _defineProperty(_Object$create, kError, {
    value: null,
    writable: true
  }), _defineProperty(_Object$create, kEnded, {
    value: stream._readableState.endEmitted,
    writable: true
  }), _defineProperty(_Object$create, kHandlePromise, {
    value: function value(resolve, reject) {
      var data = iterator[kStream].read();

      if (data) {
        iterator[kLastPromise] = null;
        iterator[kLastResolve] = null;
        iterator[kLastReject] = null;
        resolve(createIterResult(data, false));
      } else {
        iterator[kLastResolve] = resolve;
        iterator[kLastReject] = reject;
      }
    },
    writable: true
  }), _Object$create));
  iterator[kLastPromise] = null;
  finished(stream, function (err) {
    if (err && err.code !== 'ERR_STREAM_PREMATURE_CLOSE') {
      var reject = iterator[kLastReject]; // reject if we are waiting for data in the Promise
      // returned by next() and store the error

      if (reject !== null) {
        iterator[kLastPromise] = null;
        iterator[kLastResolve] = null;
        iterator[kLastReject] = null;
        reject(err);
      }

      iterator[kError] = err;
      return;
    }

    var resolve = iterator[kLastResolve];

    if (resolve !== null) {
      iterator[kLastPromise] = null;
      iterator[kLastResolve] = null;
      iterator[kLastReject] = null;
      resolve(createIterResult(undefined, true));
    }

    iterator[kEnded] = true;
  });
  stream.on('readable', onReadable.bind(null, iterator));
  return iterator;
};

module.exports = createReadableStreamAsyncIterator;
}).call(this)}).call(this,require('_process'))
},{"./end-of-stream":244,"_process":223}],242:[function(require,module,exports){
'use strict';

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var _require = require('buffer'),
    Buffer = _require.Buffer;

var _require2 = require('util'),
    inspect = _require2.inspect;

var custom = inspect && inspect.custom || 'inspect';

function copyBuffer(src, target, offset) {
  Buffer.prototype.copy.call(src, target, offset);
}

module.exports =
/*#__PURE__*/
function () {
  function BufferList() {
    _classCallCheck(this, BufferList);

    this.head = null;
    this.tail = null;
    this.length = 0;
  }

  _createClass(BufferList, [{
    key: "push",
    value: function push(v) {
      var entry = {
        data: v,
        next: null
      };
      if (this.length > 0) this.tail.next = entry;else this.head = entry;
      this.tail = entry;
      ++this.length;
    }
  }, {
    key: "unshift",
    value: function unshift(v) {
      var entry = {
        data: v,
        next: this.head
      };
      if (this.length === 0) this.tail = entry;
      this.head = entry;
      ++this.length;
    }
  }, {
    key: "shift",
    value: function shift() {
      if (this.length === 0) return;
      var ret = this.head.data;
      if (this.length === 1) this.head = this.tail = null;else this.head = this.head.next;
      --this.length;
      return ret;
    }
  }, {
    key: "clear",
    value: function clear() {
      this.head = this.tail = null;
      this.length = 0;
    }
  }, {
    key: "join",
    value: function join(s) {
      if (this.length === 0) return '';
      var p = this.head;
      var ret = '' + p.data;

      while (p = p.next) {
        ret += s + p.data;
      }

      return ret;
    }
  }, {
    key: "concat",
    value: function concat(n) {
      if (this.length === 0) return Buffer.alloc(0);
      var ret = Buffer.allocUnsafe(n >>> 0);
      var p = this.head;
      var i = 0;

      while (p) {
        copyBuffer(p.data, ret, i);
        i += p.data.length;
        p = p.next;
      }

      return ret;
    } // Consumes a specified amount of bytes or characters from the buffered data.

  }, {
    key: "consume",
    value: function consume(n, hasStrings) {
      var ret;

      if (n < this.head.data.length) {
        // `slice` is the same for buffers and strings.
        ret = this.head.data.slice(0, n);
        this.head.data = this.head.data.slice(n);
      } else if (n === this.head.data.length) {
        // First chunk is a perfect match.
        ret = this.shift();
      } else {
        // Result spans more than one buffer.
        ret = hasStrings ? this._getString(n) : this._getBuffer(n);
      }

      return ret;
    }
  }, {
    key: "first",
    value: function first() {
      return this.head.data;
    } // Consumes a specified amount of characters from the buffered data.

  }, {
    key: "_getString",
    value: function _getString(n) {
      var p = this.head;
      var c = 1;
      var ret = p.data;
      n -= ret.length;

      while (p = p.next) {
        var str = p.data;
        var nb = n > str.length ? str.length : n;
        if (nb === str.length) ret += str;else ret += str.slice(0, n);
        n -= nb;

        if (n === 0) {
          if (nb === str.length) {
            ++c;
            if (p.next) this.head = p.next;else this.head = this.tail = null;
          } else {
            this.head = p;
            p.data = str.slice(nb);
          }

          break;
        }

        ++c;
      }

      this.length -= c;
      return ret;
    } // Consumes a specified amount of bytes from the buffered data.

  }, {
    key: "_getBuffer",
    value: function _getBuffer(n) {
      var ret = Buffer.allocUnsafe(n);
      var p = this.head;
      var c = 1;
      p.data.copy(ret);
      n -= p.data.length;

      while (p = p.next) {
        var buf = p.data;
        var nb = n > buf.length ? buf.length : n;
        buf.copy(ret, ret.length - n, 0, nb);
        n -= nb;

        if (n === 0) {
          if (nb === buf.length) {
            ++c;
            if (p.next) this.head = p.next;else this.head = this.tail = null;
          } else {
            this.head = p;
            p.data = buf.slice(nb);
          }

          break;
        }

        ++c;
      }

      this.length -= c;
      return ret;
    } // Make sure the linked list only shows the minimal necessary information.

  }, {
    key: custom,
    value: function value(_, options) {
      return inspect(this, _objectSpread({}, options, {
        // Only inspect one level.
        depth: 0,
        // It should not recurse.
        customInspect: false
      }));
    }
  }]);

  return BufferList;
}();
},{"buffer":145,"util":133}],243:[function(require,module,exports){
(function (process){(function (){
'use strict'; // undocumented cb() API, needed for core, not for public API

function destroy(err, cb) {
  var _this = this;

  var readableDestroyed = this._readableState && this._readableState.destroyed;
  var writableDestroyed = this._writableState && this._writableState.destroyed;

  if (readableDestroyed || writableDestroyed) {
    if (cb) {
      cb(err);
    } else if (err) {
      if (!this._writableState) {
        process.nextTick(emitErrorNT, this, err);
      } else if (!this._writableState.errorEmitted) {
        this._writableState.errorEmitted = true;
        process.nextTick(emitErrorNT, this, err);
      }
    }

    return this;
  } // we set destroyed to true before firing error callbacks in order
  // to make it re-entrance safe in case destroy() is called within callbacks


  if (this._readableState) {
    this._readableState.destroyed = true;
  } // if this is a duplex stream mark the writable part as destroyed as well


  if (this._writableState) {
    this._writableState.destroyed = true;
  }

  this._destroy(err || null, function (err) {
    if (!cb && err) {
      if (!_this._writableState) {
        process.nextTick(emitErrorAndCloseNT, _this, err);
      } else if (!_this._writableState.errorEmitted) {
        _this._writableState.errorEmitted = true;
        process.nextTick(emitErrorAndCloseNT, _this, err);
      } else {
        process.nextTick(emitCloseNT, _this);
      }
    } else if (cb) {
      process.nextTick(emitCloseNT, _this);
      cb(err);
    } else {
      process.nextTick(emitCloseNT, _this);
    }
  });

  return this;
}

function emitErrorAndCloseNT(self, err) {
  emitErrorNT(self, err);
  emitCloseNT(self);
}

function emitCloseNT(self) {
  if (self._writableState && !self._writableState.emitClose) return;
  if (self._readableState && !self._readableState.emitClose) return;
  self.emit('close');
}

function undestroy() {
  if (this._readableState) {
    this._readableState.destroyed = false;
    this._readableState.reading = false;
    this._readableState.ended = false;
    this._readableState.endEmitted = false;
  }

  if (this._writableState) {
    this._writableState.destroyed = false;
    this._writableState.ended = false;
    this._writableState.ending = false;
    this._writableState.finalCalled = false;
    this._writableState.prefinished = false;
    this._writableState.finished = false;
    this._writableState.errorEmitted = false;
  }
}

function emitErrorNT(self, err) {
  self.emit('error', err);
}

function errorOrDestroy(stream, err) {
  // We have tests that rely on errors being emitted
  // in the same tick, so changing this is semver major.
  // For now when you opt-in to autoDestroy we allow
  // the error to be emitted nextTick. In a future
  // semver major update we should change the default to this.
  var rState = stream._readableState;
  var wState = stream._writableState;
  if (rState && rState.autoDestroy || wState && wState.autoDestroy) stream.destroy(err);else stream.emit('error', err);
}

module.exports = {
  destroy: destroy,
  undestroy: undestroy,
  errorOrDestroy: errorOrDestroy
};
}).call(this)}).call(this,require('_process'))
},{"_process":223}],244:[function(require,module,exports){
// Ported from https://github.com/mafintosh/end-of-stream with
// permission from the author, Mathias Buus (@mafintosh).
'use strict';

var ERR_STREAM_PREMATURE_CLOSE = require('../../../errors').codes.ERR_STREAM_PREMATURE_CLOSE;

function once(callback) {
  var called = false;
  return function () {
    if (called) return;
    called = true;

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    callback.apply(this, args);
  };
}

function noop() {}

function isRequest(stream) {
  return stream.setHeader && typeof stream.abort === 'function';
}

function eos(stream, opts, callback) {
  if (typeof opts === 'function') return eos(stream, null, opts);
  if (!opts) opts = {};
  callback = once(callback || noop);
  var readable = opts.readable || opts.readable !== false && stream.readable;
  var writable = opts.writable || opts.writable !== false && stream.writable;

  var onlegacyfinish = function onlegacyfinish() {
    if (!stream.writable) onfinish();
  };

  var writableEnded = stream._writableState && stream._writableState.finished;

  var onfinish = function onfinish() {
    writable = false;
    writableEnded = true;
    if (!readable) callback.call(stream);
  };

  var readableEnded = stream._readableState && stream._readableState.endEmitted;

  var onend = function onend() {
    readable = false;
    readableEnded = true;
    if (!writable) callback.call(stream);
  };

  var onerror = function onerror(err) {
    callback.call(stream, err);
  };

  var onclose = function onclose() {
    var err;

    if (readable && !readableEnded) {
      if (!stream._readableState || !stream._readableState.ended) err = new ERR_STREAM_PREMATURE_CLOSE();
      return callback.call(stream, err);
    }

    if (writable && !writableEnded) {
      if (!stream._writableState || !stream._writableState.ended) err = new ERR_STREAM_PREMATURE_CLOSE();
      return callback.call(stream, err);
    }
  };

  var onrequest = function onrequest() {
    stream.req.on('finish', onfinish);
  };

  if (isRequest(stream)) {
    stream.on('complete', onfinish);
    stream.on('abort', onclose);
    if (stream.req) onrequest();else stream.on('request', onrequest);
  } else if (writable && !stream._writableState) {
    // legacy streams
    stream.on('end', onlegacyfinish);
    stream.on('close', onlegacyfinish);
  }

  stream.on('end', onend);
  stream.on('finish', onfinish);
  if (opts.error !== false) stream.on('error', onerror);
  stream.on('close', onclose);
  return function () {
    stream.removeListener('complete', onfinish);
    stream.removeListener('abort', onclose);
    stream.removeListener('request', onrequest);
    if (stream.req) stream.req.removeListener('finish', onfinish);
    stream.removeListener('end', onlegacyfinish);
    stream.removeListener('close', onlegacyfinish);
    stream.removeListener('finish', onfinish);
    stream.removeListener('end', onend);
    stream.removeListener('error', onerror);
    stream.removeListener('close', onclose);
  };
}

module.exports = eos;
},{"../../../errors":235}],245:[function(require,module,exports){
module.exports = function () {
  throw new Error('Readable.from is not available in the browser')
};

},{}],246:[function(require,module,exports){
// Ported from https://github.com/mafintosh/pump with
// permission from the author, Mathias Buus (@mafintosh).
'use strict';

var eos;

function once(callback) {
  var called = false;
  return function () {
    if (called) return;
    called = true;
    callback.apply(void 0, arguments);
  };
}

var _require$codes = require('../../../errors').codes,
    ERR_MISSING_ARGS = _require$codes.ERR_MISSING_ARGS,
    ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED;

function noop(err) {
  // Rethrow the error if it exists to avoid swallowing it
  if (err) throw err;
}

function isRequest(stream) {
  return stream.setHeader && typeof stream.abort === 'function';
}

function destroyer(stream, reading, writing, callback) {
  callback = once(callback);
  var closed = false;
  stream.on('close', function () {
    closed = true;
  });
  if (eos === undefined) eos = require('./end-of-stream');
  eos(stream, {
    readable: reading,
    writable: writing
  }, function (err) {
    if (err) return callback(err);
    closed = true;
    callback();
  });
  var destroyed = false;
  return function (err) {
    if (closed) return;
    if (destroyed) return;
    destroyed = true; // request.destroy just do .end - .abort is what we want

    if (isRequest(stream)) return stream.abort();
    if (typeof stream.destroy === 'function') return stream.destroy();
    callback(err || new ERR_STREAM_DESTROYED('pipe'));
  };
}

function call(fn) {
  fn();
}

function pipe(from, to) {
  return from.pipe(to);
}

function popCallback(streams) {
  if (!streams.length) return noop;
  if (typeof streams[streams.length - 1] !== 'function') return noop;
  return streams.pop();
}

function pipeline() {
  for (var _len = arguments.length, streams = new Array(_len), _key = 0; _key < _len; _key++) {
    streams[_key] = arguments[_key];
  }

  var callback = popCallback(streams);
  if (Array.isArray(streams[0])) streams = streams[0];

  if (streams.length < 2) {
    throw new ERR_MISSING_ARGS('streams');
  }

  var error;
  var destroys = streams.map(function (stream, i) {
    var reading = i < streams.length - 1;
    var writing = i > 0;
    return destroyer(stream, reading, writing, function (err) {
      if (!error) error = err;
      if (err) destroys.forEach(call);
      if (reading) return;
      destroys.forEach(call);
      callback(error);
    });
  });
  return streams.reduce(pipe);
}

module.exports = pipeline;
},{"../../../errors":235,"./end-of-stream":244}],247:[function(require,module,exports){
'use strict';

var ERR_INVALID_OPT_VALUE = require('../../../errors').codes.ERR_INVALID_OPT_VALUE;

function highWaterMarkFrom(options, isDuplex, duplexKey) {
  return options.highWaterMark != null ? options.highWaterMark : isDuplex ? options[duplexKey] : null;
}

function getHighWaterMark(state, options, duplexKey, isDuplex) {
  var hwm = highWaterMarkFrom(options, isDuplex, duplexKey);

  if (hwm != null) {
    if (!(isFinite(hwm) && Math.floor(hwm) === hwm) || hwm < 0) {
      var name = isDuplex ? duplexKey : 'highWaterMark';
      throw new ERR_INVALID_OPT_VALUE(name, hwm);
    }

    return Math.floor(hwm);
  } // Default value


  return state.objectMode ? 16 : 16 * 1024;
}

module.exports = {
  getHighWaterMark: getHighWaterMark
};
},{"../../../errors":235}],248:[function(require,module,exports){
module.exports = require('events').EventEmitter;

},{"events":162}],249:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';

/*<replacement>*/

var Buffer = require('safe-buffer').Buffer;
/*</replacement>*/

var isEncoding = Buffer.isEncoding || function (encoding) {
  encoding = '' + encoding;
  switch (encoding && encoding.toLowerCase()) {
    case 'hex':case 'utf8':case 'utf-8':case 'ascii':case 'binary':case 'base64':case 'ucs2':case 'ucs-2':case 'utf16le':case 'utf-16le':case 'raw':
      return true;
    default:
      return false;
  }
};

function _normalizeEncoding(enc) {
  if (!enc) return 'utf8';
  var retried;
  while (true) {
    switch (enc) {
      case 'utf8':
      case 'utf-8':
        return 'utf8';
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return 'utf16le';
      case 'latin1':
      case 'binary':
        return 'latin1';
      case 'base64':
      case 'ascii':
      case 'hex':
        return enc;
      default:
        if (retried) return; // undefined
        enc = ('' + enc).toLowerCase();
        retried = true;
    }
  }
};

// Do not cache `Buffer.isEncoding` when checking encoding names as some
// modules monkey-patch it to support additional encodings
function normalizeEncoding(enc) {
  var nenc = _normalizeEncoding(enc);
  if (typeof nenc !== 'string' && (Buffer.isEncoding === isEncoding || !isEncoding(enc))) throw new Error('Unknown encoding: ' + enc);
  return nenc || enc;
}

// StringDecoder provides an interface for efficiently splitting a series of
// buffers into a series of JS strings without breaking apart multi-byte
// characters.
exports.StringDecoder = StringDecoder;
function StringDecoder(encoding) {
  this.encoding = normalizeEncoding(encoding);
  var nb;
  switch (this.encoding) {
    case 'utf16le':
      this.text = utf16Text;
      this.end = utf16End;
      nb = 4;
      break;
    case 'utf8':
      this.fillLast = utf8FillLast;
      nb = 4;
      break;
    case 'base64':
      this.text = base64Text;
      this.end = base64End;
      nb = 3;
      break;
    default:
      this.write = simpleWrite;
      this.end = simpleEnd;
      return;
  }
  this.lastNeed = 0;
  this.lastTotal = 0;
  this.lastChar = Buffer.allocUnsafe(nb);
}

StringDecoder.prototype.write = function (buf) {
  if (buf.length === 0) return '';
  var r;
  var i;
  if (this.lastNeed) {
    r = this.fillLast(buf);
    if (r === undefined) return '';
    i = this.lastNeed;
    this.lastNeed = 0;
  } else {
    i = 0;
  }
  if (i < buf.length) return r ? r + this.text(buf, i) : this.text(buf, i);
  return r || '';
};

StringDecoder.prototype.end = utf8End;

// Returns only complete characters in a Buffer
StringDecoder.prototype.text = utf8Text;

// Attempts to complete a partial non-UTF-8 character using bytes from a Buffer
StringDecoder.prototype.fillLast = function (buf) {
  if (this.lastNeed <= buf.length) {
    buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);
    return this.lastChar.toString(this.encoding, 0, this.lastTotal);
  }
  buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);
  this.lastNeed -= buf.length;
};

// Checks the type of a UTF-8 byte, whether it's ASCII, a leading byte, or a
// continuation byte. If an invalid byte is detected, -2 is returned.
function utf8CheckByte(byte) {
  if (byte <= 0x7F) return 0;else if (byte >> 5 === 0x06) return 2;else if (byte >> 4 === 0x0E) return 3;else if (byte >> 3 === 0x1E) return 4;
  return byte >> 6 === 0x02 ? -1 : -2;
}

// Checks at most 3 bytes at the end of a Buffer in order to detect an
// incomplete multi-byte UTF-8 character. The total number of bytes (2, 3, or 4)
// needed to complete the UTF-8 character (if applicable) are returned.
function utf8CheckIncomplete(self, buf, i) {
  var j = buf.length - 1;
  if (j < i) return 0;
  var nb = utf8CheckByte(buf[j]);
  if (nb >= 0) {
    if (nb > 0) self.lastNeed = nb - 1;
    return nb;
  }
  if (--j < i || nb === -2) return 0;
  nb = utf8CheckByte(buf[j]);
  if (nb >= 0) {
    if (nb > 0) self.lastNeed = nb - 2;
    return nb;
  }
  if (--j < i || nb === -2) return 0;
  nb = utf8CheckByte(buf[j]);
  if (nb >= 0) {
    if (nb > 0) {
      if (nb === 2) nb = 0;else self.lastNeed = nb - 3;
    }
    return nb;
  }
  return 0;
}

// Validates as many continuation bytes for a multi-byte UTF-8 character as
// needed or are available. If we see a non-continuation byte where we expect
// one, we "replace" the validated continuation bytes we've seen so far with
// a single UTF-8 replacement character ('\ufffd'), to match v8's UTF-8 decoding
// behavior. The continuation byte check is included three times in the case
// where all of the continuation bytes for a character exist in the same buffer.
// It is also done this way as a slight performance increase instead of using a
// loop.
function utf8CheckExtraBytes(self, buf, p) {
  if ((buf[0] & 0xC0) !== 0x80) {
    self.lastNeed = 0;
    return '\ufffd';
  }
  if (self.lastNeed > 1 && buf.length > 1) {
    if ((buf[1] & 0xC0) !== 0x80) {
      self.lastNeed = 1;
      return '\ufffd';
    }
    if (self.lastNeed > 2 && buf.length > 2) {
      if ((buf[2] & 0xC0) !== 0x80) {
        self.lastNeed = 2;
        return '\ufffd';
      }
    }
  }
}

// Attempts to complete a multi-byte UTF-8 character using bytes from a Buffer.
function utf8FillLast(buf) {
  var p = this.lastTotal - this.lastNeed;
  var r = utf8CheckExtraBytes(this, buf, p);
  if (r !== undefined) return r;
  if (this.lastNeed <= buf.length) {
    buf.copy(this.lastChar, p, 0, this.lastNeed);
    return this.lastChar.toString(this.encoding, 0, this.lastTotal);
  }
  buf.copy(this.lastChar, p, 0, buf.length);
  this.lastNeed -= buf.length;
}

// Returns all complete UTF-8 characters in a Buffer. If the Buffer ended on a
// partial character, the character's bytes are buffered until the required
// number of bytes are available.
function utf8Text(buf, i) {
  var total = utf8CheckIncomplete(this, buf, i);
  if (!this.lastNeed) return buf.toString('utf8', i);
  this.lastTotal = total;
  var end = buf.length - (total - this.lastNeed);
  buf.copy(this.lastChar, 0, end);
  return buf.toString('utf8', i, end);
}

// For UTF-8, a replacement character is added when ending on a partial
// character.
function utf8End(buf) {
  var r = buf && buf.length ? this.write(buf) : '';
  if (this.lastNeed) return r + '\ufffd';
  return r;
}

// UTF-16LE typically needs two bytes per character, but even if we have an even
// number of bytes available, we need to check if we end on a leading/high
// surrogate. In that case, we need to wait for the next two bytes in order to
// decode the last character properly.
function utf16Text(buf, i) {
  if ((buf.length - i) % 2 === 0) {
    var r = buf.toString('utf16le', i);
    if (r) {
      var c = r.charCodeAt(r.length - 1);
      if (c >= 0xD800 && c <= 0xDBFF) {
        this.lastNeed = 2;
        this.lastTotal = 4;
        this.lastChar[0] = buf[buf.length - 2];
        this.lastChar[1] = buf[buf.length - 1];
        return r.slice(0, -1);
      }
    }
    return r;
  }
  this.lastNeed = 1;
  this.lastTotal = 2;
  this.lastChar[0] = buf[buf.length - 1];
  return buf.toString('utf16le', i, buf.length - 1);
}

// For UTF-16LE we do not explicitly append special replacement characters if we
// end on a partial character, we simply let v8 handle that.
function utf16End(buf) {
  var r = buf && buf.length ? this.write(buf) : '';
  if (this.lastNeed) {
    var end = this.lastTotal - this.lastNeed;
    return r + this.lastChar.toString('utf16le', 0, end);
  }
  return r;
}

function base64Text(buf, i) {
  var n = (buf.length - i) % 3;
  if (n === 0) return buf.toString('base64', i);
  this.lastNeed = 3 - n;
  this.lastTotal = 3;
  if (n === 1) {
    this.lastChar[0] = buf[buf.length - 1];
  } else {
    this.lastChar[0] = buf[buf.length - 2];
    this.lastChar[1] = buf[buf.length - 1];
  }
  return buf.toString('base64', i, buf.length - n);
}

function base64End(buf) {
  var r = buf && buf.length ? this.write(buf) : '';
  if (this.lastNeed) return r + this.lastChar.toString('base64', 0, 3 - this.lastNeed);
  return r;
}

// Pass bytes on through for single-byte encodings (e.g. ascii, latin1, hex)
function simpleWrite(buf) {
  return buf.toString(this.encoding);
}

function simpleEnd(buf) {
  return buf && buf.length ? this.write(buf) : '';
}
},{"safe-buffer":229}],250:[function(require,module,exports){
module.exports=[{"name":"Facebook","homepage":"https://www.facebook.com","categories":["social"],"domains":["*.atlassbx.com","*.facebook.com","*.fbsbx.com","fbcdn-photos-e-a.akamaihd.net","*.facebook.net","*.fbcdn.net"],"products":[{"name":"Facebook Messenger Customer Chat","urlPatterns":["REGEXP:connect\\.facebook\\.net\\/.*\\/sdk\\/xfbml\\.customerchat\\.js"],"facades":[{"name":"React Live Chat Loader","repo":"https://github.com/calibreapp/react-live-chat-loader"}]}]},{"name":"Google Analytics","company":"Google","homepage":"https://www.google.com/analytics/analytics/","categories":["analytics"],"domains":["*.google-analytics.com","*.urchin.com","analytics.google.com"]},{"name":"Google CDN","company":"Google","homepage":"https://developers.google.com/speed/libraries/","categories":["cdn"],"domains":["ajax.googleapis.com","commondatastorage.googleapis.com","www.gstatic.com"]},{"name":"Google Tag Manager","company":"Google","homepage":"https://marketingplatform.google.com/about/tag-manager/","categories":["tag-manager"],"domains":["*.googletagmanager.com"]},{"name":"Google/Doubleclick Ads","company":"Google","homepage":"https://www.doubleclickbygoogle.com/","categories":["ad"],"domains":["adservice.google.com","adservice.google.com.au","adservice.google.com.sg","adservice.google.com.br","adservice.google.com.ua","adservice.google.co.uk","adservice.google.co.jp","adservice.google.co.in","adservice.google.co.kr","adservice.google.co.id","adservice.google.co.nz","adservice.google.ie","adservice.google.se","adservice.google.de","adservice.google.ca","adservice.google.be","adservice.google.es","adservice.google.ch","adservice.google.fr","adservice.google.nl","*.googleadservices.com","*.googlesyndication.com","*.googletagservices.com","*.2mdn.net","*.doubleclick.net"]},{"name":"Other Google APIs/SDKs","company":"Google","homepage":"https://developers.google.com/apis-explorer/#p/","categories":["utility"],"domains":["accounts.google.com","apis.google.com","calendar.google.com","clients2.google.com","cse.google.com","news.google.com","pay.google.com","payments.google.com","play.google.com","smartlock.google.com","www.google.com","www.google.de","www.google.co.jp","www.google.com.au","www.google.co.uk","www.google.ie","www.google.com.sg","www.google.co.in","www.google.com.br","www.google.ca","www.google.co.kr","www.google.co.nz","www.google.co.id","www.google.fr","www.google.be","www.google.com.ua","www.google.nl","www.google.ru","www.google.se","imasdk.googleapis.com","storage.googleapis.com","translate.googleapis.com","lh3.googleusercontent.com","csi.gstatic.com"]},{"name":"YouTube","homepage":"https://youtube.com","categories":["video"],"domains":["*.ggpht.com","*.youtube-nocookie.com","*.youtube.com","*.ytimg.com"],"products":[{"name":"YouTube Embedded Player","urlPatterns":["youtube.com/embed/"],"facades":[{"name":"Lite YouTube","repo":"https://github.com/paulirish/lite-youtube-embed"}]}]},{"name":"Yandex Metrica","company":"Yandex","homepage":"https://metrica.yandex.com/about?","categories":["analytics"],"domains":["d31j93rd8oukbv.cloudfront.net","mc.yandex.ru"]},{"name":"Google Maps","company":"Google","homepage":"https://www.google.com/maps","categories":["utility"],"domains":["maps.google.com","maps-api-ssl.google.com","maps.googleapis.com","mts.googleapis.com","maps.gstatic.com"]},{"name":"Twitter","homepage":"https://twitter.com","categories":["social"],"domains":["*.vine.co","*.twimg.com","*.twitpic.com","platform.twitter.com","syndication.twitter.com"]},{"name":"Hotjar","homepage":"https://www.hotjar.com/","categories":["analytics"],"domains":["*.hotjar.com","*.hotjar.io"]},{"name":"jQuery CDN","homepage":"https://code.jquery.com/","categories":["cdn"],"domains":["*.jquery.com"]},{"name":"AddThis","homepage":"http://www.addthis.com/","categories":["social"],"domains":["*.addthis.com","*.addthiscdn.com","*.addthisedge.com"]},{"name":"Cloudflare CDN","homepage":"https://cdnjs.com/","categories":["cdn"],"domains":["amp.cloudflare.com","cdnjs.cloudflare.com"]},{"name":"Shopify","homepage":"https://www.shopify.com/","categories":["hosting"],"domains":["*.shopify.com","*.shopifyapps.com","*.shopifycdn.com","*.shopifysvc.com"]},{"name":"JSDelivr CDN","homepage":"https://www.jsdelivr.com/","categories":["cdn"],"domains":["*.jsdelivr.net"]},{"name":"WordPress","company":"Automattic","homepage":"https://wp.com/","categories":["hosting"],"domains":["*.wordpress.com","s0.wp.com","s2.wp.com","*.w.org","c0.wp.com","s1.wp.com","widgets.wp.com"]},{"name":"AMP","homepage":"https://amp.dev/","categories":["content"],"domains":["*.ampproject.org"]},{"name":"ZenDesk","homepage":"https://zendesk.com/","categories":["customer-success"],"domains":["*.zdassets.com","*.zendesk.com","*.zopim.com"]},{"name":"Tawk.to","homepage":"https://www.tawk.to/","categories":["customer-success"],"domains":["*.tawk.to"]},{"name":"Criteo","homepage":"https://www.criteo.com/","categories":["ad"],"domains":["*.criteo.com","*.emailretargeting.com","*.criteo.net"]},{"name":"Wix","homepage":"https://www.wix.com/","categories":["hosting"],"domains":["*.parastorage.com","*.wix.com","*.wixstatic.com","*.wixapps.net"]},{"name":"Cloudflare","homepage":"https://www.cloudflare.com/website-optimization/","categories":["utility"],"domains":["ajax.cloudflare.com"]},{"name":"Pubmatic","homepage":"https://pubmatic.com/","categories":["ad"],"domains":["*.pubmatic.com"]},{"name":"Adroll","homepage":"https://www.adroll.com/","categories":["ad"],"domains":["*.adroll.com","*.adroll.mgr.consensu.org"]},{"name":"FontAwesome CDN","homepage":"https://fontawesome.com/","categories":["cdn"],"domains":["*.fontawesome.com"]},{"name":"Jivochat","homepage":"https://www.jivochat.com/","categories":["customer-success"],"domains":["*.jivosite.com"]},{"name":"ShareThis","homepage":"https://www.sharethis.com/","categories":["social"],"domains":["*.sharethis.com"]},{"name":"Squarespace","homepage":"https://www.squarespace.com/","categories":["hosting"],"domains":["*.squarespace.com"]},{"name":"Rubicon Project","homepage":"https://rubiconproject.com/","categories":["ad"],"domains":["*.chango.com","*.fimserve.com","*.rubiconproject.com"]},{"name":"Amazon Web Services","homepage":"https://aws.amazon.com/s3/","categories":["other"],"domains":["*.amazon.com","*.amazonaws.com","*.amazonwebapps.com","*.amazonwebservices.com","*.elasticbeanstalk.com","*.images-amazon.com","*.amazon.co.uk"]},{"name":"Hubspot","homepage":"https://hubspot.com/","categories":["marketing"],"domains":["*.hs-scripts.com","*.hubspot.com","*.leadin.com","*.hs-analytics.net","*.hscollectedforms.net","*.hscta.net","*.hsforms.net","*.hsleadflows.net","*.hsstatic.net","*.hubspot.net"]},{"name":"Adobe Tag Manager","company":"Adobe","homepage":"https://www.adobe.com/experience-platform/","categories":["tag-manager"],"domains":["*.adobedtm.com","*.demdex.net","*.everesttech.net"]},{"name":"Yandex APIs","company":"Yandex","homepage":"https://yandex.ru/","categories":["utility"],"domains":["api-maps.yandex.ru","money.yandex.ru"]},{"name":"Yandex Ads","company":"Yandex","homepage":"https://yandex.com/adv/","categories":["ad"],"domains":["an.yandex.ru"]},{"name":"Amazon Ads","homepage":"https://ad.amazon.com/","categories":["ad"],"domains":["*.amazon-adsystem.com"]},{"name":"Taboola","homepage":"https://www.taboola.com/","categories":["ad"],"domains":["*.taboola.com","*.taboolasyndication.com"]},{"name":"AddToAny","homepage":"https://www.addtoany.com/","categories":["social"],"domains":["*.addtoany.com"]},{"name":"Yandex CDN","company":"Yandex","homepage":"https://yandex.ru/","categories":["cdn"],"domains":["*.yandex.st","*.yastatic.net"]},{"name":"Blogger","homepage":"http://www.blogger.com/","categories":["hosting"],"domains":["*.blogblog.com","*.blogger.com","*.blogspot.com","images-blogger-opensocial.googleusercontent.com"]},{"name":"Stripe","homepage":"https://stripe.com","categories":["utility"],"domains":["*.stripe.com","*.stripecdn.com","*.stripe.network"]},{"name":"Mailchimp","homepage":"https://mailchimp.com/","categories":["marketing"],"domains":["*.chimpstatic.com","*.list-manage.com","*.mailchimp.com"]},{"name":"Tynt","company":"33 Across","categories":["ad"],"domains":["*.tynt.com"]},{"name":"Cookiebot","homepage":"https://www.cookiebot.com/","categories":["utility"],"domains":["*.cookiebot.com"]},{"name":"Optimizely","homepage":"https://www.optimizely.com/","categories":["analytics"],"domains":["*.optimizely.com"]},{"name":"LiveChat","homepage":"https://www.livechatinc.com/","categories":["customer-success"],"domains":["*.livechatinc.com"]},{"name":"WordAds","company":"Automattic","homepage":"https://wordads.co/","categories":["ad"],"domains":["*.pubmine.com"]},{"name":"Sumo","homepage":"https://sumo.com/","categories":["marketing"],"domains":["*.sumo.com","*.sumome.com","sumo.b-cdn.net"]},{"name":"Adobe TypeKit","company":"Adobe","homepage":"https://fonts.adobe.com/","categories":["cdn"],"domains":["*.typekit.com","*.typekit.net"]},{"name":"Kakao","categories":["social"],"domains":["*.daum.net","*.daumcdn.net"]},{"name":"Pinterest","homepage":"https://pinterest.com/","categories":["social"],"domains":["*.pinimg.com","*.pinterest.com"]},{"name":"POWr","homepage":"https://www.powr.io","categories":["utility"],"domains":["*.powr.io"]},{"name":"Skimbit","categories":["ad"],"domains":["*.redirectingat.com","*.skimresources.com","*.skimresources.net"]},{"name":"Bing Ads","homepage":"https://bingads.microsoft.com","categories":["ad"],"domains":["*.bing.com","*.microsoft.com","*.msn.com","*.s-msft.com","*.s-msn.com","*.msads.net","*.msecnd.net","*.windows.net"]},{"name":"Intercom","homepage":"https://www.intercom.com","categories":["customer-success"],"domains":["*.intercomcdn.com","*.intercom.io"],"products":[{"name":"Intercom Widget","urlPatterns":["widget.intercom.io","js.intercomcdn.com/shim.latest.js"],"facades":[{"name":"React Live Chat Loader","repo":"https://github.com/calibreapp/react-live-chat-loader"}]}]},{"name":"PayPal","homepage":"https://paypal.com","categories":["utility"],"domains":["*.paypal.com","*.paypalobjects.com"]},{"name":"PIXNET","homepage":"https://www.pixnet.net/","categories":["social"],"domains":["*.pixfs.net","*.pixnet.net"]},{"name":"Trust Pilot","categories":["analytics"],"domains":["*.trustpilot.com"]},{"name":"Klaviyo","categories":["ad"],"domains":["*.klaviyo.com"]},{"name":"Media.net","homepage":"https://www.media.net/","categories":["ad"],"domains":["*.media.net","*.mnet-ad.net"]},{"name":"Bridgewell DSP","homepage":"https://www.bridgewell.com/","categories":["ad"],"domains":["*.scupio.com"]},{"name":"LinkedIn","homepage":"https://www.linkedin.com/","categories":["social"],"domains":["*.bizographics.com","platform.linkedin.com","*.slideshare.com","*.slidesharecdn.com"]},{"name":"Yotpo","homepage":"https://www.yotpo.com/","categories":["marketing"],"domains":["*.yotpo.com"]},{"name":"Histats","homepage":"http://histats.com/","categories":["analytics"],"domains":["*.histats.com"]},{"name":"VK","homepage":"https://vk.com/","categories":["social"],"domains":["*.vk.com"]},{"name":"Snapchat","homepage":"https://www.snapchat.com","categories":["analytics"],"domains":["*.snapchat.com","*.sc-static.net"]},{"name":"Weebly","homepage":"https://www.weebly.com/","categories":["hosting"],"domains":["*.editmysite.com"]},{"name":"Hatena Blog","homepage":"https://hatenablog.com/","categories":["hosting"],"domains":["*.st-hatena.com","*.hatena.ne.jp"]},{"name":"mPulse","homepage":"https://developer.akamai.com/akamai-mpulse","categories":["analytics"],"domains":["*.akstat.io","*.go-mpulse.net","*.mpulse.net","*.mpstat.us"]},{"name":"Bold Commerce","categories":["utility"],"domains":["*.shappify-cdn.com","*.shappify.com","*.boldapps.net"]},{"name":"Wistia","homepage":"https://wistia.com/","categories":["video"],"domains":["*.wistia.com","embedwistia-a.akamaihd.net","*.wistia.net"]},{"name":"New Relic","homepage":"https://newrelic.com/","categories":["utility"],"domains":["*.newrelic.com","*.nr-data.net"]},{"name":"Privy","categories":["ad"],"domains":["*.privy.com","*.privymktg.com"]},{"name":"iubenda","categories":["utility"],"domains":["*.iubenda.com"]},{"name":"DTSCOUT","categories":["ad"],"domains":["*.dtscout.com"]},{"name":"Smartsupp","company":"Smartsupp.com","homepage":"https://www.smartsupp.com","categories":["customer-success"],"domains":["*.smartsuppchat.com","*.smartsupp.com","smartsupp-widget-161959.c.cdn77.org","*.smartsuppcdn.com"]},{"name":"Tidio Live Chat","company":"Tidio","homepage":"https://www.tidiochat.com/en/","categories":["customer-success"],"domains":["*.tidiochat.com"]},{"name":"Tealium","homepage":"https://tealium.com/","categories":["tag-manager"],"domains":["*.aniview.com","*.delvenetworks.com","*.limelight.com","*.tiqcdn.com","*.llnwd.net","*.tealiumiq.com"]},{"name":"Nielsen NetRatings SiteCensus","company":"The Nielsen Company","homepage":"http://www.nielsen-online.com/intlpage.html","categories":["analytics"],"domains":["*.imrworldwide.com"]},{"name":"Salesforce","homepage":"https://www.salesforce.com/products/marketing-cloud/","categories":["analytics"],"domains":["*.krxd.net"]},{"name":"Baidu Analytics","homepage":"https://tongji.baidu.com/web/welcome/login","categories":["analytics"],"domains":["hm.baidu.com","hmcdn.baidu.com"]},{"name":"Azure Web Services","company":"Microsoft","categories":["cdn"],"domains":["*.azurewebsites.net","*.azureedge.net","*.msedge.net"]},{"name":"Vimeo","homepage":"http://vimeo.com/","categories":["video"],"domains":["*.vimeo.com","*.vimeocdn.com"],"products":[{"name":"Vimeo Embedded Player","urlPatterns":["player.vimeo.com/video/"],"facades":[{"name":"Lite Vimeo","repo":"https://github.com/slightlyoff/lite-vimeo"},{"name":"Lite Vimeo Embed","repo":"https://github.com/luwes/lite-vimeo-embed"}]}]},{"name":"Bigcommerce","categories":["marketing"],"domains":["*.bigcommerce.com"]},{"name":"Permutive","categories":["ad"],"domains":["*.permutive.com","d3alqb8vzo7fun.cloudfront.net"]},{"name":"Segment","homepage":"https://segment.com/","categories":["analytics"],"domains":["*.segment.com","*.segment.io"]},{"name":"Instagram","homepage":"https://www.instagram.com","categories":["social"],"domains":["*.cdninstagram.com","*.instagram.com"]},{"name":"Sentry","homepage":"https://sentry.io/","categories":["utility"],"domains":["*.getsentry.com","*.ravenjs.com","*.sentry-cdn.com"]},{"name":"Bugsnag","categories":["utility"],"domains":["*.bugsnag.com","d2wy8f7a9ursnm.cloudfront.net"]},{"name":"Dealer","homepage":"https://www.dealer.com/","categories":["hosting"],"domains":["*.dealer.com"]},{"name":"Judge.me","homepage":"https://judge.me/","categories":["marketing"],"domains":["*.judge.me"]},{"name":"MGID","homepage":"https://www.mgid.com/","categories":["ad"],"domains":["*.mgid.com","*.dt07.net"]},{"name":"Outbrain","homepage":"https://www.outbrain.com/","categories":["ad"],"domains":["*.outbrain.com","*.outbrainimg.com","*.visualrevenue.com"]},{"name":"Optanon","homepage":"https://www.cookielaw.org/","categories":["utility"],"domains":["*.onetrust.com","*.cookielaw.org"]},{"name":"Intent Media","homepage":"https://intent.com/","categories":["ad"],"domains":["*.intentmedia.net"]},{"name":"Integral Ad Science","homepage":"https://integralads.com/uk/","categories":["ad"],"domains":["*.adsafeprotected.com","*.iasds01.com"]},{"name":"Tumblr","homepage":"https://tumblr.com/","categories":["social"],"domains":["*.tumblr.com"]},{"name":"Rambler","company":"Rambler & Co","categories":["utility"],"domains":["*.rambler.ru"]},{"name":"FullStory","categories":["analytics"],"domains":["*.fullstory.com"]},{"name":"Lucky Orange","homepage":"https://www.luckyorange.com/","categories":["analytics"],"domains":["*.luckyorange.com","d10lpsik1i8c69.cloudfront.net","*.luckyorange.net"]},{"name":"Mixpanel","homepage":"https://mixpanel.com/","categories":["analytics"],"domains":["*.mixpanel.com","*.mxpnl.com"]},{"name":"OptinMonster","homepage":"https://optinmonster.com/","categories":["marketing"],"domains":["*.opmnstr.com","*.optmnstr.com","*.optmstr.com"]},{"name":"Tilda","homepage":"http://tilda.cc/","categories":["hosting"],"domains":["*.tildacdn.com"]},{"name":"Akamai","homepage":"https://www.akamai.com/","categories":["cdn"],"domains":["23.62.3.183","*.akamaitechnologies.com","*.akamaitechnologies.fr","*.akamai.net","*.akamaiedge.net","*.akamaihd.net","*.akamaized.net","*.edgefcs.net","*.edgekey.net","edgesuite.net","*.srip.net"]},{"name":"VigLink","categories":["ad"],"domains":["*.viglink.com"]},{"name":"CallRail","categories":["analytics"],"domains":["*.callrail.com"]},{"name":"Scorecard Research","homepage":"https://www.scorecardresearch.com/","categories":["ad"],"domains":["*.scorecardresearch.com"]},{"name":"Olark","homepage":"https://www.olark.com/","categories":["customer-success"],"domains":["*.olark.com"]},{"name":"Moat","homepage":"https://moat.com/","categories":["ad"],"domains":["*.moatads.com","*.moatpixel.com"]},{"name":"Adform","categories":["ad"],"domains":["*.adform.net","*.adformdsp.net"]},{"name":"Fastly","categories":["utility"],"domains":["*.fastly.net"]},{"name":"GoDaddy","homepage":"https://www.godaddy.com/","categories":["utility"],"domains":["*.godaddy.com","*.wsimg.com"]},{"name":"Unpkg","homepage":"https://unpkg.com","categories":["cdn"],"domains":["*.unpkg.com","*.npmcdn.com"]},{"name":"Brightcove","homepage":"https://www.brightcove.com/en/","categories":["video"],"domains":["*.brightcove.com","*.brightcove.net","*.zencdn.net"]},{"name":"Drift","homepage":"https://www.drift.com/","categories":["marketing"],"domains":["*.drift.com","*.driftt.com"],"products":[{"name":"Drift Live Chat","urlPatterns":["REGEXP:js\\.driftt\\.com\\/include\\/.*\\/.*\\.js"],"facades":[{"name":"React Live Chat Loader","repo":"https://github.com/calibreapp/react-live-chat-loader"}]}]},{"name":"RD Station","homepage":"https://www.rdstation.com/en/","categories":["marketing"],"domains":["d335luupugsy2.cloudfront.net"]},{"name":"Mediavine","homepage":"https://www.mediavine.com/","categories":["ad"],"domains":["*.mediavine.com"]},{"name":"Yahoo!","homepage":"https://www.yahoo.com/","categories":["ad"],"domains":["*.bluelithium.com","*.hostingprod.com","*.lexity.com","*.yahoo.com","*.yahooapis.com","*.yimg.com","*.yimg.jp","*.zenfs.com","*.yahoo.net"]},{"name":"Snowplow","homepage":"https://snowplowanalytics.com/","categories":["analytics"],"domains":["d32hwlnfiv2gyn.cloudfront.net"]},{"name":"Adloox","categories":["ad"],"domains":["*.adlooxtracking.com"]},{"name":"Amazon Pay","homepage":"https://pay.amazon.com","categories":["utility"],"domains":["payments.amazon.com","*.payments-amazon.com"]},{"name":"Trusted Shops","categories":["utility"],"domains":["*.trustedshops.com"]},{"name":"Inspectlet","categories":["analytics"],"domains":["*.inspectlet.com"]},{"name":"Embedly","categories":["content"],"domains":["*.embedly.com","*.embed.ly"]},{"name":"Mapbox","categories":["utility"],"domains":["*.mapbox.com"]},{"name":"LINE Corporation","categories":["ad"],"domains":["*.line-scdn.net","*.line.me"]},{"name":"Parking Crew","homepage":"http://parkingcrew.net/","categories":["other"],"domains":["d1lxhc4jvstzrp.cloudfront.net","*.parkingcrew.net"]},{"name":"MailMunch","categories":["ad"],"domains":["*.mailmunch.co"]},{"name":"Crazy Egg","homepage":"https://www.crazyegg.com/","categories":["analytics"],"domains":["*.cetrk.com","*.crazyegg.com","*.hellobar.com","dnn506yrbagrg.cloudfront.net"]},{"name":"Index Exchange","company":"WPP","categories":["ad"],"domains":["*.casalemedia.com","*.indexww.com"]},{"name":"Microsoft Hosted Libs","company":"Microsoft","categories":["cdn"],"domains":["*.aspnetcdn.com"]},{"name":"Treasure Data","categories":["analytics"],"domains":["*.treasuredata.com"]},{"name":"VWO","homepage":"https://vwo.com","categories":["analytics"],"domains":["*.visualwebsiteoptimizer.com"]},{"name":"sovrn","categories":["ad"],"domains":["*.lijit.com"]},{"name":"Pure Chat","categories":["customer-success"],"domains":["*.purechat.com"]},{"name":"Gemius","categories":["ad"],"domains":["*.gemius.pl"]},{"name":"Chartbeat","categories":["analytics"],"domains":["*.chartbeat.com","*.chartbeat.net"]},{"name":"SoundCloud","homepage":"https://www.soundcloud.com/","categories":["content"],"domains":["*.sndcdn.com","*.soundcloud.com","*.stratus.sc"]},{"name":"Cxense","categories":["ad"],"domains":["*.cxense.com","*.cxpublic.com","*.emediate.dk","*.emediate.eu"]},{"name":"LivePerson","categories":["customer-success"],"homepage":"https://www.liveperson.com/","domains":["*.liveperson.com","*.look.io","*.liveperson.net","*.lpsnmedia.net"]},{"name":"Searchanise","categories":["analytics"],"domains":["*.searchanise.com"]},{"name":"Monotype","categories":["cdn"],"domains":["*.fonts.com","*.fonts.net"]},{"name":"Beeketing","homepage":"https://beeketing.com/","categories":["marketing"],"domains":["*.beeketing.com"]},{"name":"FreakOut","categories":["ad"],"domains":["*.fout.jp"]},{"name":"Quantcast","homepage":"https://www.quantcast.com","categories":["analytics"],"domains":["*.brtstats.com","*.quantcount.com","*.quantserve.com","*.semantictec.com","*.ntv.io"]},{"name":"Ensighten","homepage":"https://www.ensighten.com/","categories":["tag-manager"],"domains":["*.ensighten.com"]},{"name":"WordPress Site Stats","company":"Automattic","homepage":"https://wp.com/","categories":["analytics"],"domains":["pixel.wp.com","stats.wp.com"]},{"name":"Infolinks","categories":["ad"],"domains":["*.infolinks.com"]},{"name":"LiveJournal","categories":["social"],"domains":["*.livejournal.com","*.livejournal.net"]},{"name":"BrightTag / Signal","company":"Signal","homepage":"https://www.signal.co","categories":["tag-manager"],"domains":["*.btstatic.com","*.thebrighttag.com"]},{"name":"Unbounce","categories":["ad"],"domains":["*.ubembed.com","*.unbounce.com","d2xxq4ijfwetlm.cloudfront.net","d9hhrg4mnvzow.cloudfront.net"]},{"name":"Accessibe","homepage":"https://accessibe.com/","categories":["utility"],"domains":["*.accessibe.com","*.acsbap.com"]},{"name":"CreateJS CDN","homepage":"http://code.createjs.com/","categories":["cdn"],"domains":["*.createjs.com"]},{"name":"Teads","categories":["ad"],"domains":["*.teads.tv"]},{"name":"LongTail Ad Solutions","categories":["ad"],"domains":["*.jwpcdn.com","*.jwplatform.com","*.jwplayer.com","*.jwpltx.com","*.jwpsrv.com","*.longtailvideo.com"]},{"name":"CDK Dealer Management","company":"CDK Global","homepage":"https://www.cdkglobal.com/us","categories":["hosting"],"domains":["*.assets-cdk.com"]},{"name":"StatCounter","categories":["analytics"],"domains":["*.statcounter.com"]},{"name":"Parse.ly","categories":["analytics"],"domains":["*.parsely.com","d1z2jf7jlzjs58.cloudfront.net"]},{"name":"ContactAtOnce","homepage":"https://www.contactatonce.com/","categories":["customer-success"],"domains":["*.contactatonce.com"]},{"name":"i-mobile","company":"i-mobile","categories":["ad"],"domains":["*.i-mobile.co.jp"]},{"name":"Spotify","homepage":"https://www.spotify.com/","categories":["content"],"domains":["*.scdn.co","*.spotify.com"]},{"name":"Adobe Business Catalyst","homepage":"https://www.businesscatalyst.com/","categories":["hosting"],"domains":["*.businesscatalyst.com"]},{"name":"Tray Commerce","homepage":"https://www.tray.com.br/","categories":["marketing"],"domains":["*.tcdn.com.br"]},{"name":"OpenX","homepage":"https://www.openx.com/","categories":["ad"],"domains":["*.deliverimp.com","*.openxadexchange.com","*.servedbyopenx.com","*.jump-time.net","*.openx.net"]},{"name":"AB Tasty","categories":["analytics"],"domains":["*.abtasty.com","d1447tq2m68ekg.cloudfront.net"]},{"name":"PushCrew","categories":["ad"],"domains":["*.pushcrew.com"]},{"name":"Popads","homepage":"https://www.popads.net/","categories":["ad"],"domains":["*.popads.net"]},{"name":"GumGum","categories":["ad"],"domains":["*.gumgum.com"]},{"name":"PureCars","homepage":"https://www.purecars.com/","categories":["marketing"],"domains":["*.purecars.com"]},{"name":"Smart AdServer","categories":["ad"],"domains":["*.01net.com","*.sascdn.com","*.sasqos.com","*.smartadserver.com"]},{"name":"Salesforce Commerce Cloud","homepage":"https://www.salesforce.com/products/commerce-cloud/overview/","categories":["hosting"],"domains":["*.cquotient.com","*.demandware.net","demandware.edgesuite.net"]},{"name":"SnapWidget","categories":["content"],"domains":["*.snapwidget.com"]},{"name":"District M","categories":["ad"],"domains":["*.districtm.io"]},{"name":"Heap","categories":["analytics"],"domains":["*.heapanalytics.com"]},{"name":"Net Reviews","categories":["analytics"],"domains":["*.avis-verifies.com"]},{"name":"Marchex","categories":["analytics"],"domains":["*.voicestar.com","*.marchex.io"]},{"name":"Affirm","categories":["utility"],"domains":["*.affirm.com"]},{"name":"Amplitude Mobile Analytics","company":"Amplitude","categories":["analytics"],"domains":["*.amplitude.com","d24n15hnbwhuhn.cloudfront.net"]},{"name":"MaxCDN Enterprise","company":"MaxCDN","categories":["utility"],"domains":["*.netdna-cdn.com","*.netdna-ssl.com"]},{"name":"TikTok","company":"ByteDance Ltd","homepage":"https://www.tiktok.com/en/","categories":["social"],"domains":["*.tiktok.com","*.ipstatp.com"]},{"name":"LightWidget","categories":["utility"],"domains":["*.lightwidget.com"]},{"name":"uLogin","categories":["other"],"domains":["*.ulogin.ru"]},{"name":"BlueKai","company":"Oracle","categories":["ad"],"domains":["*.bkrtx.com","*.bluekai.com"]},{"name":"Gigya","categories":["analytics"],"domains":["*.gigya.com"]},{"name":"Tencent","categories":["content"],"domains":["*.qq.com","*.ywxi.net"]},{"name":"Fraudlogix","categories":["utility"],"domains":["*.yabidos.com"]},{"name":"Research Online","company":"Skills Development Scotland","categories":["content"],"domains":["*.researchonline.org.uk"]},{"name":"Help Scout","homepage":"https://www.helpscout.net/","categories":["customer-success"],"domains":["djtflbt20bdde.cloudfront.net","*.helpscout.net"],"products":[{"name":"Help Scout Beacon","urlPatterns":["beacon-v2.helpscout.net"],"facades":[{"name":"React Live Chat Loader","repo":"https://github.com/calibreapp/react-live-chat-loader"}]}]},{"name":"Secomapp","categories":["utility"],"domains":["*.secomapp.com"]},{"name":"fam","company":"Fing Co Ltd.","homepage":"http://admin.fam-ad.com/report/","categories":["ad"],"domains":["*.fam-ad.com"]},{"name":"SocialShopWave","categories":["social"],"domains":["*.socialshopwave.com"]},{"name":"TrafficStars","categories":["ad"],"domains":["*.trafficstars.com","*.tsyndicate.com"]},{"name":"Heroku","categories":["other"],"domains":["*.herokuapp.com"]},{"name":"iPerceptions","categories":["customer-success"],"domains":["*.iperceptions.com"]},{"name":"Nosto","categories":["analytics"],"domains":["*.nosto.com"]},{"name":"issuu","categories":["content"],"domains":["*.issuu.com","*.isu.pub"]},{"name":"Albacross","homepage":"https://albacross.com/","categories":["marketing"],"domains":["*.albacross.com"]},{"name":"Ve","company":"Ve Interactive","categories":["marketing"],"domains":["*.veinteractive.com"]},{"name":"Bazaarvoice","categories":["analytics"],"domains":["*.bazaarvoice.com","*.feedmagnet.com"]},{"name":"Dailymotion","categories":["content"],"domains":["*.dailymotion.com","*.dmxleo.com","*.dm.gg","*.pxlad.io","*.dmcdn.net","*.sublimevideo.net"]},{"name":"GetSiteControl","company":"GetWebCraft","categories":["utility"],"domains":["*.getsitecontrol.com"]},{"name":"DoubleVerify","homepage":"https://www.doubleverify.com/","categories":["ad"],"domains":["*.doubleverify.com","*.dvtps.com","*.iqfp1.com"]},{"name":"Esri ArcGIS","company":"Esri","categories":["utility"],"domains":["*.arcgis.com","*.arcgisonline.com"]},{"name":"Signyfyd","categories":["utility"],"domains":["*.signifyd.com"]},{"name":"Feefo.com","company":"Feefo","categories":["analytics"],"domains":["*.feefo.com"]},{"name":"Booking.com","categories":["content"],"domains":["*.bstatic.com"]},{"name":"Sharethrough","categories":["ad"],"domains":["*.sharethrough.com"]},{"name":"Seznam","categories":["utility"],"domains":["*.imedia.cz"]},{"name":"etracker","categories":["analytics"],"domains":["*.etracker.com","*.etracker.de"]},{"name":"Roxr Software","categories":["analytics"],"domains":["*.getclicky.com"]},{"name":"OptiMonk","categories":["ad"],"domains":["*.optimonk.com"]},{"name":"Perfect Market","categories":["ad"],"domains":["*.perfectmarket.com"]},{"name":"OpenTable","company":"Priceline Group","categories":["content"],"domains":["*.opentable.com","*.opentable.co.uk","*.toptable.co.uk"]},{"name":"Sortable","categories":["ad"],"domains":["*.deployads.com"]},{"name":"Swiftype","categories":["utility"],"domains":["*.swiftype.com","*.swiftypecdn.com"]},{"name":"Siteimprove","categories":["utility"],"domains":["*.siteimprove.com","*.siteimproveanalytics.com"]},{"name":"JuicyAds","categories":["ad"],"domains":["*.juicyads.com"]},{"name":"Accuweather","categories":["content"],"domains":["*.accuweather.com"]},{"name":"Sizmek","homepage":"https://www.sizmek.com/","categories":["ad"],"domains":["*.serving-sys.com","*.peer39.net"]},{"name":"Key CDN","categories":["utility"],"domains":["*.kxcdn.com"]},{"name":"Bootstrap CDN","homepage":"https://www.bootstrapcdn.com/","categories":["cdn"],"domains":["*.bootstrapcdn.com"]},{"name":"Pardot","categories":["marketing"],"domains":["*.pardot.com"]},{"name":"Foursixty","categories":["customer-success"],"domains":["*.foursixty.com"]},{"name":"Ecwid","categories":["hosting"],"domains":["*.ecwid.com","*.shopsettings.com","d3fi9i0jj23cau.cloudfront.net","d3j0zfs7paavns.cloudfront.net"]},{"name":"BounceX","categories":["analytics"],"homepage":"https://www.bouncex.com/","domains":["*.bounceexchange.com","*.bouncex.net"]},{"name":"TrustArc","homepage":"https://www.trustarc.com/","categories":["utility"],"domains":["*.trustarc.com"]},{"name":"iZooto","homepage":"https://www.izooto.com","categories":["marketing"],"domains":["*.izooto.com"]},{"name":"ContentSquare","categories":["analytics"],"domains":["d1m6l9dfulcyw7.cloudfront.net","*.content-square.net","*.contentsquare.net"]},{"name":"Marketo","homepage":"https://www.marketo.com","categories":["analytics"],"domains":["*.marketo.com","*.mktoresp.com","*.marketo.net"]},{"name":"LKQD","categories":["ad"],"domains":["*.lkqd.net"]},{"name":"Ezoic","categories":["analytics"],"domains":["*.ezoic.net"]},{"name":"Comm100","categories":["customer-success"],"domains":["*.comm100.com"]},{"name":"Refersion","categories":["ad"],"domains":["*.refersion.com"]},{"name":"Constant Contact","categories":["ad"],"domains":["*.ctctcdn.com"]},{"name":"UserReport","categories":["analytics"],"domains":["*.userreport.com"]},{"name":"Bizible","categories":["ad"],"domains":["*.bizible.com","*.bizibly.com"]},{"name":"LoyaltyLion","categories":["ad"],"domains":["*.loyaltylion.com","*.loyaltylion.net","dg1f2pfrgjxdq.cloudfront.net"]},{"name":"PageSense","homepage":"https://www.zoho.com/pagesense/","categories":["analytics"],"domains":["*.pagesense.io"]},{"name":"AppDynamics","homepage":"https://www.appdynamics.com/","categories":["utility"],"domains":["*.appdynamics.com","*.eum-appdynamics.com","d3tjaysgumg9lf.cloudfront.net"]},{"name":"Disqus","homepage":"http://disqus.com/","categories":["social"],"domains":["*.disqus.com","*.disquscdn.com"]},{"name":"AppNexus","homepage":"https://www.appnexus.com/","categories":["ad"],"domains":["*.adnxs.com","*.ctasnet.com","*.adrdgt.com"]},{"name":"ResponsiveVoice","categories":["other"],"domains":["*.responsivevoice.org"]},{"name":"Adyoulike","categories":["ad"],"domains":["*.adyoulike.com","*.omnitagjs.com","*.adyoulike.net"]},{"name":"ExoClick","categories":["ad"],"domains":["*.exoclick.com"]},{"name":"RevJet","homepage":"https://www.revjet.com/","categories":["ad"],"domains":["*.revjet.com"]},{"name":"Rakuten Marketing","company":"Rakuten","categories":["ad"],"domains":["*.rakuten-static.com","*.rmtag.com"]},{"name":"Attentive","homepage":"https://attentivemobile.com/","categories":["ad"],"domains":["*.attn.tv","*.attentivemobile.com"]},{"name":"Unruly Media","categories":["ad"],"domains":["*.unrulymedia.com"]},{"name":"33 Across","homepage":"https://33across.com/","categories":["ad"],"domains":["*.33across.com"]},{"name":"piano","categories":["ad"],"domains":["*.npttech.com","*.tinypass.com"]},{"name":"Smart Insight Tracking","company":"Emarsys","categories":["analytics"],"domains":["*.scarabresearch.com"]},{"name":"Geniee","categories":["ad"],"domains":["*.href.asia","*.genieessp.jp","*.genieesspv.jp","*.gssprt.jp"]},{"name":"Medium","categories":["content"],"domains":["*.medium.com"]},{"name":"Vidible","categories":["ad"],"domains":["*.vidible.tv"]},{"name":"Revolver Maps","categories":["analytics"],"domains":["*.revolvermaps.com"]},{"name":"SublimeSkinz","categories":["ad"],"domains":["*.ayads.co"]},{"name":"Kampyle","categories":["analytics"],"domains":["*.kampyle.com"]},{"name":"Nativo","categories":["ad"],"domains":["*.postrelease.com"]},{"name":"SnapEngage","categories":["customer-success"],"domains":["*.snapengage.com"]},{"name":"Sift Science","categories":["utility"],"domains":["*.siftscience.com"]},{"name":"Riskified","categories":["utility"],"domains":["*.riskified.com"]},{"name":"Listrak","homepage":"https://www.listrak.com/","categories":["marketing"],"domains":["*.listrak.com","*.listrakbi.com"]},{"name":"GetResponse","categories":["ad"],"domains":["*.getresponse.com"]},{"name":"TagCommander","categories":["tag-manager"],"domains":["*.commander1.com","*.tagcommander.com"]},{"name":"Twitch","homepage":"https://twitch.tv/","categories":["video"],"domains":["*.twitch.tv"]},{"name":"Evidon","categories":["analytics"],"domains":["*.evidon.com"]},{"name":"Bronto Software","categories":["marketing"],"domains":["*.bm23.com","*.bronto.com","*.brontops.com"]},{"name":"Tribal Fusion","company":"Exponential Interactive","categories":["ad"],"domains":["*.tribalfusion.com"]},{"name":"PowerReviews","categories":["analytics"],"domains":["*.powerreviews.com"]},{"name":"Admixer for Publishers","company":"Admixer","categories":["ad"],"domains":["*.admixer.net"]},{"name":"Salesforce.com","categories":["ad"],"domains":["*.force.com","*.salesforce.com"]},{"name":"Covert Pics","categories":["content"],"domains":["*.covet.pics"]},{"name":"Keen","company":"Keen","homepage":"https://keen.io/","categories":["analytics"],"domains":["*.keen.io","d26b395fwzu5fz.cloudfront.net"]},{"name":"Branch Metrics","categories":["ad"],"domains":["*.branch.io","*.app.link"]},{"name":"GitHub","categories":["utility"],"domains":["*.github.com","*.githubusercontent.com","*.github.io","*.rawgit.com"]},{"name":"Dynamic Yield","categories":["customer-success"],"domains":["*.dynamicyield.com"]},{"name":"ForeSee","company":"Answers","categories":["analytics"],"domains":["*.4seeresults.com","*.answerscloud.com","*.foresee.com","*.foreseeresults.com"]},{"name":"Clerk.io ApS","categories":["analytics"],"domains":["*.clerk.io"]},{"name":"iovation","categories":["utility"],"domains":["*.iesnare.com"]},{"name":"Convert Insights","categories":["analytics"],"domains":["*.convertexperiments.com"]},{"name":"STINGRAY","company":"FlexOne","categories":["ad"],"domains":["*.impact-ad.jp"]},{"name":"iAdvize SAS","categories":["customer-success"],"domains":["*.iadvize.com"]},{"name":"Digioh","categories":["ad"],"domains":["*.lightboxcdn.com"]},{"name":"Polar","homepage":"https://polar.me/","categories":["ad"],"domains":["*.polarmobile.ca","*.mediaeverywhere.com","*.mediavoice.com","*.plrsrvcs.com","*.polarcdn-engine.com","*.polarcdn-meraxes.com","*.polarcdn-pentos.com","*.polarcdn-static.com","*.polarcdn-terrax.com","*.polarcdn.com","*.polarmobile.com","*.poweredbypolar.com","*.mediaconductor.me","*.polaracademy.me"]},{"name":"eBay","categories":["ad"],"domains":["*.ebay.com","*.ebayimg.com","*.fetchback.com"]},{"name":"Pendo","homepage":"https://www.pendo.io","categories":["analytics"],"domains":["*.pendo.io"]},{"name":"Clicktale","categories":["analytics"],"domains":["*.cdngc.net","*.clicktale.net"]},{"name":"Symantec","categories":["utility"],"domains":["*.norton.com","*.symantec.com","*.symcb.com","*.symcd.com"]},{"name":"Nend","categories":["ad"],"domains":["*.nend.net"]},{"name":"StickyADS.tv","categories":["ad"],"domains":["*.stickyadstv.com"]},{"name":"TrackJS","categories":["analytics"],"domains":["*.trackjs.com","d2zah9y47r7bi2.cloudfront.net"]},{"name":"Usabilla","homepage":"https://usabilla.com","categories":["analytics"],"domains":["*.usabilla.com","d6tizftlrpuof.cloudfront.net"]},{"name":"Technorati","company":"Synacor","categories":["ad"],"domains":["*.technoratimedia.com"]},{"name":"SessionCam","company":"ServiceTick","categories":["analytics"],"domains":["*.sessioncam.com","d2oh4tlt9mrke9.cloudfront.net"]},{"name":"SpringServer","categories":["ad"],"domains":["*.springserve.com"]},{"name":"Hotmart","homepage":"https://www.hotmart.com/","categories":["content"],"domains":["*.hotmart.com"]},{"name":"WisePops","categories":["utility"],"domains":["*.wisepops.com"]},{"name":"IBM Digital Analytics","company":"IBM","categories":["analytics"],"domains":["*.cmcore.com","coremetrics.com","data.coremetrics.com","data.de.coremetrics.com","libs.de.coremetrics.com","tmscdn.de.coremetrics.com","iocdn.coremetrics.com","libs.coremetrics.com","tmscdn.coremetrics.com","*.s81c.com","*.unica.com","*.coremetrics.eu"]},{"name":"ZEDO","categories":["ad"],"domains":["*.zedo.com"]},{"name":"AdMatic","categories":["ad"],"domains":["*.admatic.com.tr"]},{"name":"Wishpond Technologies","categories":["marketing"],"domains":["*.wishpond.com","*.wishpond.net"]},{"name":"Monetate","categories":["analytics"],"domains":["*.monetate.net"]},{"name":"AOL / Oath / Verizon Media","homepage":"https://www.oath.com/","categories":["ad"],"domains":["*.advertising.com","*.aol.com","*.aolcdn.com","*.blogsmithmedia.com","*.oath.com","*.aol.net","*.tacoda.net","*.aol.co.uk"]},{"name":"IPONWEB","categories":["ad"],"domains":["*.company-target.com","*.liadm.com","*.iponweb.net","*.p161.net"]},{"name":"Fort Awesome","categories":["cdn"],"domains":["*.fortawesome.com"]},{"name":"Affiliate Window","company":"Digital Window","categories":["ad"],"domains":["*.dwin1.com"]},{"name":"Forter","categories":["utility"],"domains":["*.forter.com"]},{"name":"WebsiteBuilder.com","homepage":"https://www.websitebuilder.com","categories":["hosting"],"domains":["*.mywebsitebuilder.com"]},{"name":"Reviews.co.uk","categories":["analytics"],"domains":["*.reviews.co.uk"]},{"name":"Maxymiser","categories":["analytics"],"domains":["*.maxymiser.net"]},{"name":"Adocean","company":"Gemius","categories":["ad"],"domains":["*.adocean.pl"]},{"name":"Lytics","categories":["ad"],"domains":["*.lytics.io"]},{"name":"plista","categories":["ad"],"domains":["*.plista.com"]},{"name":"Bootstrap Chinese network","categories":["cdn"],"domains":["*.bootcss.com"]},{"name":"Snacktools","categories":["ad"],"domains":["*.bannersnack.com"]},{"name":"Skype","categories":["other"],"domains":["*.skype.com"]},{"name":"Okas Concepts","categories":["utility"],"domains":["*.okasconcepts.com"]},{"name":"Freshdesk","homepage":"https://freshdesk.com/","categories":["customer-success"],"domains":["d36mpcpuzc4ztk.cloudfront.net"]},{"name":"AIR.TV","categories":["ad"],"domains":["*.air.tv"]},{"name":"Rackspace","categories":["hosting"],"domains":["*.rackcdn.com","*.rackspacecloud.com","*.raxcdn.com","*.websitetestlink.com"]},{"name":"Shareaholic","homepage":"https://www.shareaholic.com/","categories":["social"],"domains":["*.shareaholic.com","dsms0mj1bbhn4.cloudfront.net"]},{"name":"Meetrics","categories":["ad"],"domains":["*.de.com","*.meetrics.net","*.mxcdn.net"]},{"name":"LiveTex","categories":["customer-success"],"domains":["*.livetex.ru"]},{"name":"Media Management Technologies","categories":["ad"],"domains":["*.speedshiftmedia.com"]},{"name":"Opentag","company":"Qubit","categories":["tag-manager"],"domains":["*.qutics.com","d3c3cq33003psk.cloudfront.net"]},{"name":"Crowd Control","company":"Lotame","categories":["ad"],"domains":["*.crwdcntrl.net"]},{"name":"Wufoo","categories":["utility"],"domains":["*.wufoo.com"]},{"name":"Exponea","categories":["analytics"],"domains":["*.exponea.com"]},{"name":"Forensiq","categories":["utility"],"domains":["*.fqtag.com"]},{"name":"fluct","categories":["ad"],"domains":["*.adingo.jp"]},{"name":"Pagely","categories":["other"],"domains":["*.optnmstr.com"]},{"name":"ClickDesk","categories":["customer-success"],"domains":["*.clickdesk.com","d1gwclp1pmzk26.cloudfront.net"]},{"name":"Alexa","homepage":"https://www.alexa.com/","categories":["analytics"],"domains":["*.alexametrics.com","d31qbv1cthcecs.cloudfront.net"]},{"name":"Radar","company":"Cedexis","homepage":"https://www.cedexis.com/radar/","categories":["analytics"],"domains":["*.cedexis-test.com","*.cedexis.com","*.cmdolb.com","cedexis.leasewebcdn.com","*.cedexis-radar.net","*.cedexis.net","cedexis-test01.insnw.net","cedexisakamaitest.azureedge.net","cedexispub.cdnetworks.net","cs600.wac.alphacdn.net","cs600.wpc.edgecastdns.net","global2.cmdolb.com","img-cedexis.mncdn.com","a-cedexis.msedge.net","zn3vgszfh.fastestcdn.net"]},{"name":"Talkable","categories":["ad"],"domains":["*.talkable.com","d2jjzw81hqbuqv.cloudfront.net"]},{"name":"WebEngage","categories":["customer-success"],"domains":["*.webengage.co","*.webengage.com","d23nd6ymopvz52.cloudfront.net","d3701cc9l7v9a6.cloudfront.net"]},{"name":"rewardStyle.com","categories":["ad"],"domains":["*.rewardstyle.com"]},{"name":"Revcontent","categories":["content"],"domains":["*.revcontent.com"]},{"name":"iBillboard","categories":["ad"],"domains":["*.ibillboard.com"]},{"name":"Decibel Insight","categories":["analytics"],"domains":["*.decibelinsight.net"]},{"name":"Vidyard","homepage":"https://www.vidyard.com/","categories":["utility"],"domains":["*.vidyard.com"]},{"name":"Quantum Metric","homepage":"https://www.quantummetric.com/","categories":["analytics"],"domains":["*.quantummetric.com"]},{"name":"Civic","categories":["hosting"],"domains":["*.civiccomputing.com"]},{"name":"Highcharts","categories":["utility"],"domains":["*.highcharts.com"]},{"name":"Dynatrace","categories":["analytics"],"domains":["*.ruxit.com","js-cdn.dynatrace.com"]},{"name":"Auto Link Maker","company":"Apple","categories":["ad"],"domains":["*.apple.com"]},{"name":"Appier","categories":["ad"],"domains":["*.appier.net"]},{"name":"Yieldify","categories":["ad"],"domains":["*.yieldify.com","*.yieldifylabs.com","d33wq5gej88ld6.cloudfront.net","dwmvwp56lzq5t.cloudfront.net"]},{"name":"Sooqr Search","company":"Sooqr","categories":["utility"],"domains":["*.sooqr.com"]},{"name":"Kaltura Video Platform","company":"Kaltura","categories":["content"],"domains":["*.kaltura.com"]},{"name":"BoldChat","company":"LogMeIn","categories":["customer-success"],"domains":["*.boldchat.com"]},{"name":"FirstImpression","categories":["ad"],"domains":["*.firstimpression.io"]},{"name":"Picreel","categories":["analytics"],"domains":["*.pcrl.co","*.picreel.com"]},{"name":"DigiTrust","homepage":"http://www.digitru.st/","categories":["analytics"],"domains":["*.digitru.st"]},{"name":"AdsWizz","categories":["ad"],"domains":["*.adswizz.com"]},{"name":"SaleCycle","categories":["ad"],"domains":["*.salecycle.com","d16fk4ms6rqz1v.cloudfront.net","d22j4fzzszoii2.cloudfront.net","d30ke5tqu2tkyx.cloudfront.net","dn1i8v75r669j.cloudfront.net"]},{"name":"Flowplayer","categories":["content"],"domains":["*.flowplayer.org"]},{"name":"LoopMe","categories":["ad"],"domains":["*.loopme.biz","*.loopme.com","*.vntsm.com","*.loopme.me"]},{"name":"Tail Target","company":"Tail","categories":["ad"],"domains":["*.tailtarget.com"]},{"name":"AddShoppers","categories":["social"],"domains":["*.addshoppers.com","d3rr3d0n31t48m.cloudfront.net","*.shop.pe"]},{"name":"Browsealoud","homepage":"https://www.texthelp.com/en-gb/products/browsealoud/","categories":["other"],"domains":["*.browsealoud.com","*.texthelp.com"]},{"name":"LinkedIn Ads","categories":["ad"],"domains":["*.licdn.com","ads.linkedin.com","www.linkedin.com"]},{"name":"Audience 360","company":"Datapoint Media","categories":["ad"],"domains":["*.dpmsrv.com"]},{"name":"Tag Inspector","company":"InfoTrust","categories":["analytics"],"domains":["d22xmn10vbouk4.cloudfront.net"]},{"name":"MonetizeMore","categories":["ad"],"domains":["*.m2.ai"]},{"name":"Mather Economics","categories":["analytics"],"domains":["*.matheranalytics.com"]},{"name":"Fresh Relevance","categories":["analytics"],"domains":["*.freshrelevance.com","*.cloudfront.ne","d1y9qtn9cuc3xw.cloudfront.net","d81mfvml8p5ml.cloudfront.net","dkpklk99llpj0.cloudfront.net"]},{"name":"Supership","homepage":"https://supership.jp/","categories":["ad"],"domains":["*.socdm.com"]},{"name":"Fastly Insights","homepage":"https://insights.fastlylabs.com","categories":["analytics"],"domains":["*.fastly-insights.com"]},{"name":"Keywee","categories":["ad"],"domains":["*.keywee.co"]},{"name":"LiveHelpNow","categories":["customer-success"],"domains":["*.livehelpnow.net"]},{"name":"AudienceSearch","company":"Intimate Merger","categories":["ad"],"domains":["*.im-apps.net"]},{"name":"Evergage","categories":["analytics"],"domains":["*.evergage.com","*.evgnet.com"]},{"name":"Wicked Reports","homepage":"https://www.wickedreports.com/","categories":["marketing"],"domains":["*.wickedreports.com"]},{"name":"ReadSpeaker","homepage":"https://www.readspeaker.com","categories":["other"],"domains":["*.readspeaker.com"]},{"name":"WebpageFX","categories":["ad"],"domains":["*.leadmanagerfx.com"]},{"name":"Adobe Scene7","company":"Adobe Systems","categories":["content"],"domains":["wwwimages.adobe.com","*.scene7.com","*.everestads.net","*.everestjs.net"]},{"name":"IBM Acoustic Campaign","company":"IBM","categories":["analytics"],"domains":["www.sc.pages01.net","www.sc.pages02.net","www.sc.pages03.net","www.sc.pages04.net","www.sc.pages05.net","www.sc.pages06.net","www.sc.pages07.net","www.sc.pages08.net","www.sc.pages09.net","www.sc.pagesA.net"]},{"name":"The Trade Desk","homepage":"https://www.thetradedesk.com/","categories":["ad"],"domains":["d1eoo1tco6rr5e.cloudfront.net","*.adsrvr.org"]},{"name":"Google Plus","company":"Google","categories":["social"],"domains":["plus.google.com"]},{"name":"SearchSpring","categories":["utility"],"domains":["*.searchspring.net"]},{"name":"Curalate","categories":["marketing"],"domains":["*.curalate.com","d116tqlcqfmz3v.cloudfront.net"]},{"name":"Pixlee","categories":["social"],"domains":["*.pixlee.com"]},{"name":"Weborama","categories":["ad"],"domains":["*.weborama.com","*.weborama.fr"]},{"name":"Apester","categories":["analytics"],"domains":["*.apester.com","*.qmerce.com"]},{"name":"Sekindo","categories":["content"],"domains":["*.sekindo.com"]},{"name":"FoxyCart","categories":["utility"],"domains":["*.foxycart.com"]},{"name":"MaxMind","categories":["utility"],"domains":["*.maxmind.com"]},{"name":"Braze","homepage":"https://www.braze.com","categories":["analytics"],"domains":["*.appboycdn.com"]},{"name":"smartclip","categories":["ad"],"domains":["*.smartclip.net"]},{"name":"Opta","company":"Perform Group","categories":["content"],"domains":["*.opta.net"]},{"name":"Interpublic Group","categories":["ad"],"domains":["*.mbww.com"]},{"name":"Between Digital","categories":["ad"],"domains":["*.betweendigital.com"]},{"name":"CyberSource (Visa)","categories":["utility"],"domains":["*.authorize.net"]},{"name":"JustPremium Ads","company":"JustPremium","categories":["ad"],"domains":["*.justpremium.com"]},{"name":"Concert","homepage":"https://concert.io/","categories":["ad"],"domains":["*.concert.io"]},{"name":"Vox Media","homepage":"https://www.voxmedia.com/","categories":["content"],"domains":["*.vox-cdn.com","*.voxmedia.com"]},{"name":"CPEx","categories":["content"],"domains":["*.cpex.cz"]},{"name":"TripAdvisor","categories":["content"],"domains":["*.jscache.com","*.tacdn.com","*.tamgrt.com","*.tripadvisor.com","*.viator.com","*.tripadvisor.co.uk"]},{"name":"Ipify","homepage":"https://www.ipify.org","categories":["utility"],"domains":["*.ipify.org"]},{"name":"Click Guardian","homepage":"https://www.clickguardian.co.uk/","categories":["advertising"],"domains":["*.clickguardian.app","*.clickguardian.co.uk"]},{"name":"Autopilot","categories":["ad"],"domains":["*.autopilothq.com"]},{"name":"KISSmetrics","categories":["analytics"],"domains":["*.kissmetrics.com","doug1izaerwt3.cloudfront.net","dsyszv14g9ymi.cloudfront.net"]},{"name":"Yieldmo","categories":["ad"],"domains":["*.yieldmo.com"]},{"name":"Simplicity Marketing","categories":["ad"],"domains":["*.flashtalking.com"]},{"name":"mParticle","homepage":"https://www.mparticle.com/","categories":["utility"],"domains":["*.mparticle.com"]},{"name":"Global-e","categories":["hosting"],"domains":["*.global-e.com"]},{"name":"SurveyMonkey","categories":["analytics"],"domains":["*.surveymonkey.com"]},{"name":"Connatix","categories":["ad"],"domains":["*.connatix.com"]},{"name":"Drip","company":"The Numa Group","categories":["ad"],"domains":["*.getdrip.com"]},{"name":"BannerFlow","company":"Nordic Factory Solutions","categories":["ad"],"domains":["*.bannerflow.com"]},{"name":"DemandBase","categories":["marketing"],"domains":["*.demandbase.com"]},{"name":"DMD Marketing","homepage":"https://www.dmdconnects.com/","categories":["ad"],"domains":["*.medtargetsystem.com"]},{"name":"Omniconvert","categories":["analytics"],"domains":["*.omniconvert.com","d2tgfbvjf3q6hn.cloudfront.net","d3vbj265bmdenw.cloudfront.net"]},{"name":"Yottaa","categories":["hosting"],"domains":["*.yottaa.com","*.yottaa.net"]},{"name":"Sirv","categories":["other"],"domains":["*.sirv.com"]},{"name":"TripleLift","categories":["ad"],"domains":["*.3lift.com"]},{"name":"Edge Web Fonts","company":"Adobe Systems","categories":["cdn"],"domains":["*.edgefonts.net"]},{"name":"Tradelab","categories":["ad"],"domains":["*.tradelab.fr"]},{"name":"DialogTech","categories":["ad"],"domains":["*.dialogtech.com"]},{"name":"Calendly","categories":["other"],"domains":["*.calendly.com"]},{"name":"Media Math","homepage":"http://www.mediamath.com/","categories":["ad"],"domains":["*.mathads.com","*.mathtag.com"]},{"name":"Typepad","categories":["hosting"],"domains":["*.typepad.com"]},{"name":"Qualaroo","categories":["analytics"],"domains":["*.qualaroo.com"]},{"name":"Drawbridge","homepage":"https://www.drawbridge.com/","categories":["ad"],"domains":["*.adsymptotic.com"]},{"name":"Stamped.io","categories":["analytics"],"domains":["*.stamped.io"]},{"name":"Feedbackify","company":"InsideMetrics","categories":["analytics"],"domains":["*.feedbackify.com"]},{"name":"Auth0","homepage":"https://auth0.com/","categories":["utility"],"domains":["*.auth0.com"]},{"name":"Datawrapper","categories":["utility"],"domains":["*.datawrapper.de","*.dwcdn.net"]},{"name":"Reviews.io","categories":["analytics"],"domains":["*.reviews.io"]},{"name":"Adscale","categories":["ad"],"domains":["*.adscale.de"]},{"name":"SpotXchange","categories":["ad"],"domains":["*.spotxcdn.com","*.spotxchange.com","*.spotx.tv"]},{"name":"Stackla PTY","categories":["social"],"domains":["*.stackla.com"]},{"name":"linkpulse","categories":["analytics"],"domains":["*.lp4.io"]},{"name":"Market GID","homepage":"https://www.marketgid.com/","categories":["ad"],"domains":["*.marketgid.com"]},{"name":"CleverTap","categories":["analytics"],"domains":["d2r1yp2w7bby2u.cloudfront.net"]},{"name":"Infinity Tracking","categories":["analytics"],"domains":["*.infinity-tracking.net"]},{"name":"Mouseflow","categories":["analytics"],"domains":["*.mouseflow.com"]},{"name":"Luigi’s Box","company":"Luigi’s Box","homepage":"https://www.luigisbox.com/","categories":["utility"],"domains":["*.luigisbox.com"]},{"name":"Shopgate","categories":["utility"],"domains":["*.shopgate.com"]},{"name":"Reklama","categories":["ad"],"domains":["*.o2.pl","*.wp.pl"]},{"name":"Survicate","categories":["analytics"],"domains":["*.survicate.com"]},{"name":"Ad6Media","categories":["ad"],"domains":["*.ad6media.fr"]},{"name":"GetIntent RTBSuite","company":"GetIntent","categories":["ad"],"domains":["*.adhigh.net"]},{"name":"Snack Media","categories":["content"],"domains":["*.snack-media.com"]},{"name":"Cloudinary","categories":["content"],"domains":["*.cloudinary.com"]},{"name":"ThreatMetrix","categories":["utility"],"domains":["*.online-metrix.net"]},{"name":"Delta Projects AB","categories":["ad"],"domains":["*.de17a.com"]},{"name":"Adition","homepage":"https://www.adition.com","categories":["ad"],"domains":["*.adition.com"]},{"name":"Rocket Fuel","categories":["ad"],"domains":["*.rfihub.com","*.ru4.com","*.rfihub.net","*.ad1x.com"]},{"name":"Marketplace Web Service","company":"Amazon","categories":["other"],"domains":["*.ssl-images-amazon.com"]},{"name":"OneSignal","homepage":"https://onesignal.com/","categories":["utility"],"domains":["*.onesignal.com"]},{"name":"Customer.io","categories":["ad"],"domains":["*.customer.io"]},{"name":"Gleam","categories":["marketing"],"domains":["*.gleam.io"]},{"name":"Petametrics","categories":["analytics"],"domains":["*.petametrics.com"]},{"name":"ResponseTap","categories":["analytics"],"domains":["*.adinsight.com","*.responsetap.com"]},{"name":"TINT","categories":["content"],"domains":["*.71n7.com","d33w9bm0n1egwm.cloudfront.net","d36hc0p18k1aoc.cloudfront.net","d3l7tj34e9fc43.cloudfront.net"]},{"name":"Zanox","categories":["ad"],"domains":["*.zanox.com","*.zanox.ws"]},{"name":"infogr.am","categories":["utility"],"domains":["*.infogr.am","*.jifo.co"]},{"name":"Playbuzz","categories":["hosting"],"domains":["*.playbuzz.com"]},{"name":"Klevu Search","company":"Klevu","categories":["utility"],"domains":["*.klevu.com"]},{"name":"Conversio","categories":["ad"],"domains":["*.conversio.com"]},{"name":"Sidecar","categories":["other"],"domains":["*.getsidecar.com","d3v27wwd40f0xu.cloudfront.net"]},{"name":"Sajari Pty","categories":["utility"],"domains":["*.sajari.com"]},{"name":"Profitshare","categories":["ad"],"domains":["*.profitshare.ro"]},{"name":"Qubit Deliver","company":"Qubit","categories":["analytics"],"domains":["d1m54pdnjzjnhe.cloudfront.net","d22rutvoghj3db.cloudfront.net","dd6zx4ibq538k.cloudfront.net"]},{"name":"Arbor","company":"LiveRamp","categories":["other"],"domains":["*.pippio.com"]},{"name":"Best Of Media S.A.","categories":["content"],"domains":["*.servebom.com"]},{"name":"Impact Radius","categories":["ad"],"domains":["*.impactradius-event.com","*.impactradius-go.com","*.7eer.net","d3cxv97fi8q177.cloudfront.net","*.evyy.net","*.ojrq.net"]},{"name":"Matomo","company":"InnoCraft","homepage":"https://matomo.org/","categories":["analytics"],"domains":["*.matomo.cloud"]},{"name":"Flickr","categories":["content"],"domains":["*.flickr.com","*.staticflickr.com"]},{"name":"Fanplayr","categories":["analytics"],"domains":["*.fanplayr.com","d38nbbai6u794i.cloudfront.net"]},{"name":"Navegg","categories":["ad"],"domains":["*.navdmp.com"]},{"name":"Ambassador","categories":["ad"],"domains":["*.getambassador.com"]},{"name":"Intercept Interactive","categories":["ad"],"domains":["*.undertone.com"]},{"name":"Cookie-Script.com","categories":["utility"],"domains":["*.cookie-script.com"]},{"name":"GIPHY","categories":["content"],"domains":["*.giphy.com"]},{"name":"Kaizen Platform","categories":["analytics"],"domains":["*.kaizenplatform.net"]},{"name":"Bluecore","categories":["analytics"],"domains":["*.bluecore.com"]},{"name":"Exponential Interactive","categories":["ad"],"domains":["*.exponential.com"]},{"name":"Hupso Website Analyzer","company":"Hupso","categories":["analytics"],"domains":["*.hupso.com"]},{"name":"Adkontekst","categories":["ad"],"domains":["*.adkontekst.pl"]},{"name":"Rakuten LinkShare","company":"Rakuten","categories":["ad"],"domains":["*.linksynergy.com"]},{"name":"WebSpectator","categories":["ad"],"domains":["*.webspectator.com"]},{"name":"The Hut Group","categories":["content"],"domains":["*.thcdn.com"]},{"name":"Underdog Media","categories":["ad"],"domains":["*.underdog.media","*.udmserve.net"]},{"name":"Steelhouse","categories":["ad"],"domains":["*.steelhousemedia.com"]},{"name":"Bolt","homepage":"https://www.bolt.com/","categories":["utility"],"domains":["*.bolt.com"]},{"name":"AdRiver","categories":["ad"],"domains":["*.adriver.ru"]},{"name":"Viacom","categories":["content"],"domains":["*.mtvnservices.com"]},{"name":"CleverDATA","categories":["ad"],"domains":["*.1dmp.io"]},{"name":"WalkMe","categories":["customer-success"],"domains":["*.walkme.com"]},{"name":"Flockler","categories":["ad"],"domains":["*.flockler.com"]},{"name":"Hola Networks","categories":["other"],"domains":["*.h-cdn.com"]},{"name":"Acceptable Ads","homepage":"https://acceptableads.com/","categories":["ad"],"domains":["*.aaxads.com","*.aaxdetect.com"]},{"name":"Socialphotos","categories":["social"],"domains":["*.slpht.com"]},{"name":"epoq internet services","categories":["analytics"],"domains":["*.epoq.de"]},{"name":"Livefyre","categories":["content"],"domains":["*.fyre.co","*.livefyre.com"]},{"name":"Turn","categories":["ad"],"domains":["*.turn.com"]},{"name":"Kargo","categories":["marketing"],"domains":["*.kargo.com"]},{"name":"Adyen","categories":["utility"],"domains":["*.adyen.com"]},{"name":"Knight Lab","company":"Northwestern University","categories":["utility"],"domains":["*.knightlab.com"]},{"name":"Ziff Davis Tech","categories":["ad"],"domains":["*.adziff.com","*.zdbb.net"]},{"name":"Reevoo","categories":["analytics"],"domains":["*.reevoo.com"]},{"name":"The ADEX","categories":["ad"],"domains":["*.theadex.com"]},{"name":"AWeber","categories":["ad"],"domains":["*.aweber.com"]},{"name":"Proper Media","categories":["content"],"domains":["*.proper.io"]},{"name":"Pusher","homepage":"https://pusher.com/","categories":["utility"],"domains":["*.pusher.com","*.pusherapp.com"]},{"name":"Ooyala","categories":["ad"],"domains":["*.ooyala.com"]},{"name":"Mopinion","categories":["analytics"],"domains":["*.mopinion.com"]},{"name":"Netlify","homepage":"https://www.netlify.com/","categories":["utility"],"domains":["*.netlify.com","*.netlifyusercontent.com"]},{"name":"Experian Cross-Channel Marketing Platform","company":"Experian","categories":["marketing"],"domains":["*.eccmp.com","*.ccmp.eu"]},{"name":"Postcode Anywhere (Holdings)","categories":["utility"],"domains":["*.postcodeanywhere.co.uk"]},{"name":"reEmbed","categories":["other"],"domains":["*.reembed.com"]},{"name":"Vibrant Media","categories":["ad"],"domains":["*.intellitxt.com","*.picadmedia.com"]},{"name":"GoSquared","homepage":"https://www.gosquared.com","categories":["analytics"],"domains":["*.gosquared.com","d1l6p2sc9645hc.cloudfront.net"]},{"name":"Onet","categories":["ad"],"domains":["*.onet.pl"]},{"name":"SlimCut Media Outstream","company":"SlimCut Media","categories":["ad"],"domains":["*.freeskreen.com"]},{"name":"Sojern","categories":["marketing"],"domains":["*.sojern.com"]},{"name":"Tagboard","categories":["social"],"domains":["*.tagboard.com"]},{"name":"reddit","categories":["social"],"domains":["*.reddit.com","*.redditstatic.com"]},{"name":"bRealTime","categories":["ad"],"domains":["*.brealtime.com"]},{"name":"Woopra","categories":["analytics"],"domains":["*.woopra.com"]},{"name":"Cookie Reports","categories":["utility"],"domains":["*.cookiereports.com"]},{"name":"Usersnap","homepage":"https://usersnap.com","categories":["customer-success"],"domains":["*.usersnap.com"]},{"name":"NetAffiliation","company":"Kwanco","categories":["ad"],"domains":["*.metaffiliation.com"]},{"name":"Opinion Stage","categories":["analytics"],"domains":["*.opinionstage.com"]},{"name":"Kameleoon","categories":["analytics"],"domains":["*.kameleoon.com"]},{"name":"Zmags","categories":["marketing"],"domains":["*.zmags.com"]},{"name":"Celtra","categories":["ad"],"domains":["*.celtra.com"]},{"name":"Elastic Ad","categories":["ad"],"domains":["*.elasticad.net"]},{"name":"FLXone","company":"Teradata","categories":["ad"],"domains":["*.pangolin.blue","*.flx1.com","d2hlpp31teaww3.cloudfront.net","*.flxpxl.com"]},{"name":"StreamRail","categories":["ad"],"domains":["*.streamrail.com","*.streamrail.net"]},{"name":"Effective Measure","categories":["ad"],"domains":["*.effectivemeasure.net"]},{"name":"Touch Commerce","categories":["customer-success"],"domains":["*.inq.com","*.touchcommerce.com"]},{"name":"Resonance Insights","categories":["analytics"],"domains":["*.res-x.com"]},{"name":"Advance Magazine Group","categories":["content"],"domains":["*.condenastdigital.com","*.condenet.com","*.condenast.co.uk"]},{"name":"PerimeterX Bot Defender","company":"PerimeterX","categories":["utility"],"domains":["*.perimeterx.net","*.pxi.pub"]},{"name":"Reflektion","categories":["analytics"],"domains":["*.reflektion.com","d26opx5dl8t69i.cloudfront.net"]},{"name":"Clicktripz","categories":["content"],"domains":["*.clicktripz.com"]},{"name":"Barilliance","categories":["analytics"],"domains":["*.barilliance.net","dn3y71tq7jf07.cloudfront.net"]},{"name":"Qualtrics","categories":["analytics"],"domains":["*.qualtrics.com"]},{"name":"Sonobi","categories":["ad"],"domains":["*.sonobi.com"]},{"name":"Polldaddy","company":"Automattic","categories":["analytics"],"domains":["polldaddy.com"]},{"name":"Swoop","categories":["ad"],"domains":["*.swoop.com"]},{"name":"Mobify","categories":["utility"],"domains":["*.mobify.com","*.mobify.net"]},{"name":"Zarget","categories":["analytics"],"domains":["*.zarget.com"]},{"name":"TruConversion","categories":["analytics"],"domains":["*.truconversion.com"]},{"name":"Spot.IM","categories":["social"],"domains":["*.spot.im","*.spotim.market"]},{"name":"Bookatable","categories":["content"],"domains":["*.bookatable.com","*.livebookings.com"]},{"name":"Wow Analytics","categories":["analytics"],"domains":["*.wowanalytics.co.uk"]},{"name":"Clickagy Audience Lab","company":"Clickagy","categories":["ad"],"domains":["*.clickagy.com"]},{"name":"Verizon Digital Media CDN","homepage":"https://www.verizondigitalmedia.com/","categories":["cdn"],"domains":["*.edgecastcdn.net","*.edgecastdns.net"]},{"name":"Moxie","homepage":"https://www.gomoxie.com/","categories":["utility"],"domains":["*.gomoxie.solutions"]},{"name":"OnScroll","categories":["ad"],"domains":["*.onscroll.com"]},{"name":"OwnerIQ","categories":["ad"],"domains":["*.owneriq.net"]},{"name":"Friendbuy","categories":["ad"],"domains":["*.friendbuy.com","djnf6e5yyirys.cloudfront.net"]},{"name":"Transifex","categories":["utility"],"domains":["*.transifex.com"]},{"name":"Twitter Online Conversion Tracking","company":"Twitter","categories":["ad"],"domains":["*.ads-twitter.com","analytics.twitter.com"]},{"name":"PebblePost","categories":["ad"],"domains":["*.pbbl.co"]},{"name":"Cachefly","categories":["utility"],"domains":["*.cachefly.net"]},{"name":"Storygize","categories":["ad"],"domains":["*.storygize.net"]},{"name":"Vergic AB","categories":["customer-success"],"domains":["*.psplugin.com"]},{"name":"Republer","categories":["ad"],"domains":["*.republer.com"]},{"name":"Conversant Tag Manager","company":"Conversant","categories":["tag-manager"],"domains":["*.mplxtms.com"]},{"name":"Attribution","categories":["ad"],"domains":["*.attributionapp.com"]},{"name":"Netmining","company":"Ignition One","categories":["ad"],"domains":["*.netmng.com"]},{"name":"Betgenius","company":"Genius Sports","categories":["content"],"domains":["*.connextra.com"]},{"name":"Intent IQ","categories":["ad"],"domains":["*.intentiq.com"]},{"name":"Site24x7 Real User Monitoring","company":"Site24x7","categories":["analytics"],"domains":["*.site24x7rum.com"]},{"name":"Adobe Marketing Cloud","company":"Adobe Systems","categories":["ad"],"domains":["*.adobetag.com"]},{"name":"SkyScanner","categories":["content"],"domains":["*.skyscanner.net"]},{"name":"Madison Logic","categories":["marketing"],"domains":["*.ml314.com"]},{"name":"Foxentry","company":"AVANTRO","homepage":"https://foxentry.cz/","categories":["utility"],"domains":["*.foxentry.cz"]},{"name":"MailPlus","categories":["ad"],"domains":["*.mailplus.nl"]},{"name":"Mux","categories":["analytics"],"domains":["*.litix.io"]},{"name":"News","categories":["social"],"domains":["*.news.com.au","*.newsanalytics.com.au","*.newsapi.com.au","*.newscdn.com.au","*.newsdata.com.au","*.newsdiscover.com.au","*.news-static.com"]},{"name":"AdTrue","company":"FPT AdTrue","categories":["ad"],"domains":["*.adtrue.com"]},{"name":"Optimove","company":"Mobius Solutions","categories":["analytics"],"domains":["*.optimove.net"]},{"name":"SecuredVisit","company":"4Cite Marketing","categories":["ad"],"domains":["*.securedvisit.com"]},{"name":"Investis","categories":["utility"],"domains":["*.investis.com"]},{"name":"Vivocha S.p.A","categories":["customer-success"],"domains":["*.vivocha.com"]},{"name":"AdSniper","categories":["ad"],"domains":["*.adsniper.ru","*.sniperlog.ru"]},{"name":"Hull.js","categories":["utility"],"domains":["*.hull.io","*.hullapp.io"]},{"name":"ShopRunner","categories":["content"],"domains":["*.shoprunner.com","*.s-9.us"]},{"name":"InAuth","categories":["utility"],"homepage":"https://www.inauth.com/","domains":["*.cdn-net.com"]},{"name":"cloudIQ","categories":["analytics"],"domains":["*.cloud-iq.com"]},{"name":"BuySellAds","categories":["ad"],"domains":["*.buysellads.com","*.buysellads.net"]},{"name":"LiveRamp IdentityLink","homepage":"https://liveramp.com/discover-identitylink/","categories":["analytics"],"domains":["*.circulate.com","*.rlcdn.com"]},{"name":"Expedia","categories":["content"],"domains":["*.travel-assets.com","*.trvl-media.com","*.trvl-px.com","*.uciservice.com"]},{"name":"Aggregate Knowledge","company":"Neustar","categories":["ad"],"domains":["*.agkn.com"]},{"name":"DialogTech SourceTrak","company":"DialogTech","categories":["ad"],"domains":["d31y97ze264gaa.cloudfront.net"]},{"name":"Microad","categories":["ad"],"domains":["*.microad.jp"]},{"name":"Realytics","categories":["analytics"],"domains":["dcniko1cv0rz.cloudfront.net","*.realytics.net"]},{"name":"Holimetrix","homepage":"https://u360.d-bi.fr/","categories":["marketing"],"domains":["*.d-bi.fr"]},{"name":"Kiosked","categories":["ad"],"domains":["*.kiosked.com"]},{"name":"Webkul","company":"Webkul Software","categories":["utility"],"domains":["*.webkul.com"]},{"name":"ReCollect","categories":["utility"],"domains":["*.recollect.net"]},{"name":"CNET Content Solutions","company":"CBS Interactive","categories":["content"],"domains":["*.cnetcontent.com"]},{"name":"Triblio","categories":["marketing"],"domains":["*.tribl.io"]},{"name":"Alchemy","company":"AndBeyond.Media","categories":["ad"],"domains":["*.andbeyond.media"]},{"name":"Vergic Engage Platform","company":"Vergic","categories":["customer-success"],"domains":["*.vergic.com"]},{"name":"Braintree Payments","company":"Paypal","categories":["utility"],"domains":["*.braintreegateway.com"]},{"name":"Reactful","categories":["analytics"],"domains":["*.reactful.com"]},{"name":"[24]7","categories":["customer-success"],"domains":["*.247-inc.net","*.247inc.net","d1af033869koo7.cloudfront.net"]},{"name":"PlayAd Media Group","categories":["ad"],"domains":["*.youplay.se"]},{"name":"Sailthru","categories":["analytics"],"domains":["*.sail-horizon.com","*.sail-personalize.com","*.sail-track.com"]},{"name":"ShopStorm","categories":["utility"],"domains":["*.shopstorm.com"]},{"name":"Dataxu","categories":["marketing"],"domains":["*.w55c.net"]},{"name":"CANDDi","company":"Campaign and Digital Intelligence","categories":["ad"],"domains":["*.canddi.com"]},{"name":"Dynamic Converter","categories":["utility"],"domains":["*.dynamicconverter.com"]},{"name":"Meltwater Group","categories":["customer-success"],"domains":["*.meltwaternews.com"]},{"name":"Datacamp","categories":["utility"],"domains":["*.cdn77.org"]},{"name":"Janrain","categories":["analytics"],"domains":["*.janrain.com","*.janrainbackplane.com","*.rpxnow.com","d3hmp0045zy3cs.cloudfront.net"]},{"name":"Smartlook","company":"Smartsupp.com","homepage":"https://www.smartlook.com/","categories":["analytics"],"domains":["*.smartlook.com"]},{"name":"Iterate","homepage":"https://iteratehq.com/","categories":["analytics"],"domains":["*.iteratehq.com"]},{"name":"Perfect Audience","company":"Marin Software","categories":["ad"],"domains":["*.prfct.co","*.marinsm.com","*.perfectaudience.com"]},{"name":"OneSoon","categories":["analytics"],"domains":["*.adalyser.com"]},{"name":"Fonecall","categories":["analytics"],"domains":["*.web-call-analytics.com"]},{"name":"Oracle Recommendations On Demand","company":"Oracle","categories":["analytics"],"domains":["*.atgsvcs.com"]},{"name":"Salesforce Live Agent","company":"Salesforce.com","categories":["customer-success"],"domains":["*.salesforceliveagent.com"]},{"name":"InSkin Media","categories":["ad"],"domains":["*.inskinad.com","*.inskinmedia.com"]},{"name":"ContextWeb","categories":["ad"],"domains":["*.contextweb.com"]},{"name":"Ekm Systems","categories":["analytics"],"domains":["*.ekmsecure.com","*.ekmpinpoint.co.uk"]},{"name":"VidPulse","categories":["analytics"],"domains":["*.vidpulse.com"]},{"name":"RichRelevance","categories":["analytics"],"domains":["*.richrelevance.com"]},{"name":"Byside","homepage":"http://www.byside.com","categories":["analytics"],"domains":["*.byside.com"]},{"name":"AnswerDash","categories":["customer-success"],"domains":["*.answerdash.com"]},{"name":"Dash Hudson","company":"Dash Hudson","categories":["content"],"domains":["*.dashhudson.com"]},{"name":"Pingdom RUM","homepage":"https://www.pingdom.com/product/performance-monitoring/","categories":["analytics"],"domains":["*.pingdom.net"]},{"name":"Exactag","categories":["ad"],"domains":["*.exactag.com"]},{"name":"Sparkflow","company":"Intercept Interactive","categories":["ad"],"domains":["*.sparkflow.net"]},{"name":"MLveda","categories":["utility"],"domains":["*.mlveda.com"]},{"name":"Dropbox","categories":["utility"],"domains":["*.dropboxusercontent.com"]},{"name":"User Replay","categories":["analytics"],"domains":["*.userreplay.net"]},{"name":"TechTarget","categories":["content"],"domains":["*.techtarget.com","*.ttgtmedia.com"]},{"name":"LoginRadius","categories":["social"],"domains":["*.loginradius.com"]},{"name":"Gfycat","company":"Gycat","categories":["utility"],"domains":["*.gfycat.com"]},{"name":"PowerFront","categories":["hosting"],"domains":["*.inside-graph.com"]},{"name":"Raygun","categories":["utility"],"domains":["*.raygun.io"]},{"name":"Prezi","categories":["utility"],"domains":["*.prezi.com"]},{"name":"Adthink","company":"Adthink Media","categories":["ad"],"domains":["*.adxcore.com","*.dcoengine.com"]},{"name":"JingDong","categories":["content"],"domains":["*.3.com","*.jd.com"]},{"name":"Cardosa Enterprises","categories":["analytics"],"domains":["*.y-track.com"]},{"name":"Remintrex","company":"SmartUp Venture","categories":["ad"],"domains":["*.remintrex.com"]},{"name":"Polyfill service","company":"Polyfill.io","categories":["other"],"domains":["*.polyfill.io"]},{"name":"TRUSTe","categories":["utility"],"domains":["*.truste.com"]},{"name":"AI Media Group","categories":["ad"],"domains":["*.aimediagroup.com"]},{"name":"Alliance for Audited Media","categories":["ad"],"domains":["*.aamsitecertifier.com"]},{"name":"Segmento","categories":["ad"],"domains":["*.rutarget.ru"]},{"name":"Vee24","categories":["customer-success"],"domains":["*.vee24.com"]},{"name":"Performio","categories":["ad"],"domains":["*.performax.cz"]},{"name":"Beachfront Media","categories":["ad"],"domains":["*.bfmio.com"]},{"name":"Magnetic","categories":["ad"],"domains":["*.domdex.com","d3ezl4ajpp2zy8.cloudfront.net"]},{"name":"Web Dissector","company":"Beijing Gridsum Technologies","categories":["analytics"],"domains":["*.gridsumdissector.com","*.webdissector.com"]},{"name":"Chameleon","homepage":"https://www.trychameleon.com/","categories":["marketing"],"domains":["*.trychameleon.com"]},{"name":"UpSellit","categories":["analytics"],"domains":["*.upsellit.com"]},{"name":"UPS i-parcel","company":"UPS","categories":["other"],"domains":["*.i-parcel.com"]},{"name":"Filestack","categories":["content"],"domains":["*.filepicker.io"]},{"name":"MouseStats","categories":["analytics"],"domains":["*.mousestats.com"]},{"name":"MathJax","categories":["utility"],"domains":["*.mathjax.org"]},{"name":"OneTag","categories":["ad"],"domains":["*.onetag-sys.com"]},{"name":"StumbleUpon","categories":["content"],"domains":["*.stumble-upon.com","*.stumbleupon.com"]},{"name":"StackAdapt","categories":["ad"],"domains":["*.stackadapt.com"]},{"name":"TurnTo","homepage":"https://www.turntonetworks.com/","categories":["utility"],"domains":["*.turnto.com"]},{"name":"DemandJump","categories":["analytics"],"domains":["*.demandjump.com"]},{"name":"Xaxis","homepage":"https://www.xaxis.com/","categories":["ad"],"domains":["*.247realmedia.com","*.mookie1.com","*.gmads.net"]},{"name":"Council ad Network","categories":["ad"],"domains":["*.counciladvertising.net"]},{"name":"adKernel","categories":["ad"],"domains":["*.adkernel.com"]},{"name":"Trialfire","categories":["analytics"],"domains":["*.trialfire.com"]},{"name":"AdSupply","categories":["ad"],"domains":["*.doublepimp.com"]},{"name":"Moovweb","categories":["utility"],"domains":["*.moovweb.net"]},{"name":"Imgur","categories":["utility"],"domains":["*.imgur.com"]},{"name":"trueAnthem","categories":["social"],"domains":["*.tru.am"]},{"name":"Google Fonts","company":"Google","homepage":"https://fonts.google.com/","categories":["cdn"],"domains":["fonts.googleapis.com","fonts.gstatic.com"]},{"name":"DistroScale","categories":["ad"],"domains":["*.jsrdn.com"]},{"name":"Extole","categories":["ad"],"domains":["*.extole.com","*.extole.io"]},{"name":"Adverline Board","company":"Adverline","categories":["ad"],"domains":["*.adverline.com","*.adnext.fr"]},{"name":"Datonics","categories":["ad"],"domains":["*.pro-market.net"]},{"name":"StackExchange","categories":["social"],"domains":["*.sstatic.net"]},{"name":"Gravatar","homepage":"http://en.gravatar.com/","categories":["social"],"domains":["*.gravatar.com"]},{"name":"Better Business Bureau","categories":["analytics"],"domains":["*.bbb.org"]},{"name":"content.ad","categories":["ad"],"domains":["*.content.ad"]},{"name":"Freespee","categories":["customer-success"],"domains":["*.freespee.com"]},{"name":"Ceros","categories":["other"],"domains":["ceros.com","view.ceros.com"]},{"name":"Adobe Test & Target","company":"Adobe Systems","categories":["analytics"],"domains":["*.omtrdc.net"]},{"name":"SreamAMG","company":"StreamAMG","categories":["other"],"domains":["*.streamamg.com"]},{"name":"Browser-Update.org","categories":["other"],"domains":["*.browser-update.org"]},{"name":"Ruler Analytics","company":"Ruler","categories":["analytics"],"domains":["*.nyltx.com","*.ruleranalytics.com"]},{"name":"Multiview","categories":["content"],"domains":["*.multiview.com","*.track-mv.com"]},{"name":"Ada","homepage":"https://www.ada.support/","categories":["customer-success"],"domains":["*.ada.support"]},{"name":"Reach Group","categories":["ad"],"domains":["*.redintelligence.net"]},{"name":"Firebase","homepage":"https://developers.google.com/apis-explorer/#p/","categories":["utility"],"domains":["firebasestorage.googleapis.com","firestore.googleapis.com"]},{"name":"AddEvent","categories":["utility"],"domains":["*.addevent.com"]},{"name":"Fastest Forward","categories":["analytics"],"domains":["*.gaug.es"]},{"name":"Constructor.io","categories":["utility"],"domains":["*.cnstrc.com"]},{"name":"ARM","categories":["analytics"],"domains":["*.tag4arm.com"]},{"name":"Hawk Search","categories":["utility"],"domains":["*.hawksearch.com"]},{"name":"BlueCava","categories":["ad"],"domains":["*.bluecava.com"]},{"name":"Loop11","categories":["analytics"],"domains":["*.loop11.com"]},{"name":"AliveChat","company":"AYU Technology Solutions","categories":["customer-success"],"domains":["*.websitealive.com","*.websitealive7.com"]},{"name":"Retention Science","categories":["ad"],"domains":["*.retentionscience.com","d1stxfv94hrhia.cloudfront.net"]},{"name":"VoiceFive","categories":["analytics"],"domains":["*.voicefive.com"]},{"name":"YoYo","categories":["utility"],"domains":["*.goadservices.com"]},{"name":"Virtual Earth","company":"Microsoft","categories":["utility"],"domains":["*.virtualearth.net"]},{"name":"SPX","company":"Smaato","categories":["ad"],"domains":["*.smaato.net"]},{"name":"Klarna","categories":["utility"],"domains":["*.klarna.com"]},{"name":"Flipboard","categories":["social"],"domains":["*.flipboard.com"]},{"name":"Glassdoor","categories":["content"],"domains":["*.glassdoor.com"]},{"name":"Webtrends","categories":["analytics"],"domains":["*.webtrends.com","*.webtrendslive.com","d1q62gfb8siqnm.cloudfront.net"]},{"name":"NaviStone","categories":["ad"],"domains":["*.murdoog.com"]},{"name":"Catchpoint","homepage":"https://www.catchpoint.com/","categories":["analytics"],"domains":["*.3gl.net"]},{"name":"JotForm","categories":["utility"],"domains":["*.jotformpro.com"]},{"name":"Userzoom","categories":["analytics"],"domains":["*.userzoom.com"]},{"name":"Now Interact","categories":["analytics"],"domains":["*.nowinteract.com"]},{"name":"RecoBell","categories":["analytics"],"domains":["*.recobell.io"]},{"name":"EmpathyBroker Site Search","company":"EmpathyBroker","categories":["utility"],"domains":["*.empathybroker.com"]},{"name":"Boomtrain","categories":["ad"],"domains":["*.boomtrain.com","*.boomtrain.net"]},{"name":"Roomkey","categories":["content"],"domains":["*.roomkey.com"]},{"name":"Improve Digital","categories":["ad"],"domains":["*.360yield.com"]},{"name":"Webmarked","categories":["utility"],"domains":["*.webmarked.net"]},{"name":"Soundest","categories":["ad"],"domains":["*.soundestlink.com","*.soundest.net"]},{"name":"ESV Digital","categories":["analytics"],"domains":["*.esearchvision.com"]},{"name":"EmailCenter","categories":["ad"],"domains":["*.emailcenteruk.com"]},{"name":"Amplience","categories":["marketing"],"domains":["*.10cms.com","*.amplience.com","*.bigcontent.io","*.adis.ws"]},{"name":"The Publisher Desk","categories":["ad"],"domains":["*.206ads.com","*.publisherdesk.com"]},{"name":"HP Optimost","company":"Hewlett-Packard Development Company","categories":["marketing"],"domains":["*.hp.com","d2uncb19xzxhzx.cloudfront.net"]},{"name":"Azure Traffic Manager","company":"Microsoft","categories":["other"],"domains":["*.gateway.net","*.trafficmanager.net"]},{"name":"Peaks & Pies","categories":["analytics"],"domains":["*.bunchbox.co"]},{"name":"2AdPro Media Solutions","categories":["ad"],"domains":["*.2adpro.com"]},{"name":"Mediahawk","categories":["analytics"],"domains":["*.mediahawk.co.uk"]},{"name":"Trust Guard","categories":["utility"],"domains":["*.trust-guard.com"]},{"name":"RightNow Service Cloud","company":"Oracle","categories":["customer-success"],"domains":["*.rightnowtech.com","*.rnengage.com"]},{"name":"Trustev","company":"TransUnion","categories":["utility"],"domains":["*.trustev.com"]},{"name":"Ometria","categories":["analytics"],"domains":["*.ometria.com"]},{"name":"Tapad","categories":["ad"],"domains":["*.tapad.com"]},{"name":"Quora Ads","homepage":"https://www.quora.com/business/","categories":["ad"],"domains":["*.quora.com"]},{"name":"RebelMouse","categories":["ad"],"domains":["*.rebelmouse.com","*.rbl.ms"]},{"name":"Cross Pixel Media","categories":["ad"],"domains":["*.crsspxl.com"]},{"name":"Elecard StreamEye","company":"Elecard","categories":["other"],"domains":["*.streameye.net"]},{"name":"Sub2 Technologies","categories":["analytics"],"domains":["*.sub2tech.com"]},{"name":"Pixalate","categories":["utility"],"domains":["*.adrta.com"]},{"name":"Neodata","categories":["ad"],"domains":["*.neodatagroup.com"]},{"name":"HotelsCombined","categories":["content"],"domains":["*.datahc.com"]},{"name":"Infusionsoft","categories":["ad"],"domains":["*.infusionsoft.com"]},{"name":"Online republic","categories":["content"],"domains":["*.imallcdn.net"]},{"name":"MyRegistry","categories":["other"],"domains":["*.myregistry.com"]},{"name":"eGain","categories":["analytics"],"domains":["*.analytics-egain.com","*.egain.com"]},{"name":"Numberly","company":"1000mercis","categories":["ad"],"domains":["*.mmtro.com","*.nzaza.com"]},{"name":"Visual IQ","homepage":"https://www.visualiq.com","categories":["analytics"],"domains":["*.myvisualiq.net"]},{"name":"Click4Assistance","categories":["customer-success"],"domains":["*.click4assistance.co.uk"]},{"name":"Euroland","categories":["utility"],"domains":["*.euroland.com"]},{"name":"Sokrati","categories":["marketing"],"domains":["*.sokrati.com"]},{"name":"Acquisio","categories":["ad"],"domains":["*.acq.io"]},{"name":"AdvertServe","categories":["ad"],"domains":["*.advertserve.com"]},{"name":"eXTReMe digital","categories":["analytics"],"domains":["*.extreme-dm.com"]},{"name":"SAS Institute","categories":["ad"],"domains":["*.aimatch.com","*.sas.com"]},{"name":"Oracle","categories":["marketing"],"domains":["*.custhelp.com","*.eloqua.com","*.en25.com","*.estara.com","*.instantservice.com"]},{"name":"TrafficJunky","homepage":"https://www.trafficjunky.com/","categories":["ad"],"domains":["*.contentabc.com","*.trafficjunky.net"]},{"name":"Conversant","categories":["analytics"],"domains":["*.dotomi.com","*.dtmpub.com","*.emjcd.com","mediaplex.com","*.tqlkg.com","*.fastclick.net"]},{"name":"SiteScout","company":"Centro","categories":["ad"],"domains":["*.pixel.ad","*.sitescout.com"]},{"name":"Silverpop","company":"IBM","categories":["ad"],"domains":["*.mkt912.com","*.mkt922.com","*.mkt932.com","*.mkt941.com","*.mkt51.net","*.mkt61.net","*.pages01.net","*.pages02.net","*.pages03.net","*.pages04.net","*.pages05.net"]},{"name":"eXelate","categories":["ad"],"domains":["*.exelator.com"]},{"name":"SmarterHQ","categories":["analytics"],"domains":["*.smarterhq.io","d1n00d49gkbray.cloudfront.net","*.smarterremarketer.net"]},{"name":"Divido","categories":["utility"],"domains":["*.divido.com"]},{"name":"BidTheatre","categories":["ad"],"domains":["*.bidtheatre.com"]},{"name":"Certona","categories":["analytics"],"domains":["*.certona.net"]},{"name":"Reflow","company":"Scenestealer","categories":["ad"],"domains":["*.reflow.tv"]},{"name":"Account Kit","categories":["other"],"domains":["*.accountkit.com"]},{"name":"Yummley","categories":["other"],"domains":["*.yummly.com"]},{"name":"ZergNet","categories":["content"],"domains":["*.zergnet.com"]},{"name":"LeasdBoxer","company":"LeadBoxer","categories":["ad"],"domains":["*.leadboxer.com"]},{"name":"SalesLoft","homepage":"https://salesloft.com/","categories":["analytics","marketing"],"domains":["*.salesloft.com"]},{"name":"template-help.com","categories":["hosting"],"domains":["*.template-help.com"]},{"name":"Mention Me","categories":["ad"],"domains":["*.mention-me.com"]},{"name":"Borderfree","company":"pitney bowes","categories":["utility"],"domains":["*.borderfree.com","*.fiftyone.com"]},{"name":"360 picnic platform","company":"MediaV","categories":["ad"],"domains":["*.mediav.com"]},{"name":"Webtrekk","categories":["analytics"],"domains":["*.wbtrk.net","*.webtrekk-asia.net","*.webtrekk.net","*.wt-eu02.net"]},{"name":"Airship","categories":["marketing"],"domains":["*.urbanairship.com","*.aswpsdkus.com"]},{"name":"SpeedCurve LUX","company":"SpeedCurve","homepage":"https://speedcurve.com/features/lux/","categories":["analytics"],"domains":["*.speedcurve.com"]},{"name":"Adzerk","categories":["ad"],"domains":["*.adzerk.net"]},{"name":"AdCurve","categories":["ad"],"domains":["*.shop2market.com"]},{"name":"ToneMedia","categories":["ad"],"domains":["*.clickfuse.com"]},{"name":"F@N Communications","homepage":"https://www.fancs.com/","categories":["ad"],"domains":["*.ladsp.com"]},{"name":"Sophus3","categories":["analytics"],"domains":["*.s3ae.com","*.sophus3.com"]},{"name":"Bidtellect","categories":["ad"],"domains":["*.bttrack.com"]},{"name":"Adtech (AOL)","categories":["ad"],"domains":["*.adtechus.com"]},{"name":"Admedo","categories":["ad"],"domains":["*.a8723.com","*.adizio.com","*.admedo.com"]},{"name":"Heatmap","categories":["analytics"],"domains":["*.heatmap.it"]},{"name":"Widespace","homepage":"https://www.widespace.com","categories":["ad"],"domains":["*.widespace.com"]},{"name":"Rollbar","categories":["utility"],"domains":["*.rollbar.com","d37gvrvc0wt4s1.cloudfront.net"]},{"name":"Adnium","categories":["ad"],"domains":["*.adnium.com"]},{"name":"Business Message","categories":["ad"],"domains":["*.message-business.com"]},{"name":"PrintFriendly","categories":["utility"],"domains":["*.printfriendly.com"]},{"name":"RTB House AdPilot","company":"RTB House","categories":["ad"],"domains":["*.erne.co","*.creativecdn.com"]},{"name":"my6sense","categories":["ad"],"domains":["*.mynativeplatform.com"]},{"name":"Ambient","company":"Ericcson","categories":["other"],"domains":["*.adnetwork.vn","*.ambientplatform.vn"]},{"name":"Vertical Mass","categories":["ad"],"domains":["*.vmweb.net"]},{"name":"MyBuys","categories":["analytics"],"domains":["*.mybuys.com"]},{"name":"Recite Me","categories":["other"],"domains":["*.reciteme.com"]},{"name":"Admitad","categories":["ad"],"domains":["*.lenmit.com"]},{"name":"Infoline","categories":["analytics"],"domains":["*.ioam.de"]},{"name":"Adwise","categories":["ad"],"domains":["*.adwise.bg"]},{"name":"Tradedoubler","categories":["ad"],"domains":["*.pvnsolutions.com","*.tradedoubler.com"]},{"name":"Developer Media","categories":["ad"],"domains":["*.developermedia.com"]},{"name":"bd4travel","categories":["analytics"],"domains":["*.bd4travel.com"]},{"name":"Eyeota","categories":["ad"],"domains":["*.eyeota.net"]},{"name":"Fidelity Media","categories":["ad"],"domains":["*.fidelity-media.com"]},{"name":"Brandmetrics","homepage":"https://www.brandmetrics.com","categories":["analytics"],"domains":["*.brandmetrics.com"]},{"name":"LockerDome","categories":["analytics"],"domains":["*.lockerdome.com"]},{"name":"C3 Metrics","categories":["analytics"],"domains":["*.c3tag.com"]},{"name":"WebInsight","company":"dotMailer","categories":["analytics"],"domains":["*.trackedlink.net","*.trackedweb.net"]},{"name":"Captify Media","categories":["ad"],"domains":["*.cpx.to"]},{"name":"Datalicious","categories":["tag-manager"],"domains":["*.supert.ag","*.optimahub.com"]},{"name":"Movable Ink","categories":["analytics"],"domains":["*.micpn.com"]},{"name":"Okta","categories":["analytics"],"domains":["*.okta.com"]},{"name":"AdSpeed","categories":["ad"],"domains":["*.adspeed.net"]},{"name":"Ahalogy","categories":["social"],"domains":["*.ahalogy.com"]},{"name":"Queue-it","categories":["other"],"domains":["*.queue-it.net"]},{"name":"EMX Digital","homepage":"https://emxdigital.com","categories":["ad"],"domains":["*.emxdgt.com"]},{"name":"Internet Brands","categories":["content"],"domains":["*.ibpxl.com"]},{"name":"HyperInzerce","homepage":"https://hyperinzerce.cz","categories":["ad"],"domains":["*.hyperinzerce.cz"]},{"name":"Smarter Click","categories":["ad"],"domains":["*.smct.co","*.smarterclick.co.uk"]},{"name":"Accordant Media","categories":["ad"],"domains":["*.a3cloud.net"]},{"name":"Expedia USA","company":"Expedia","categories":["content"],"domains":["*.expedia.com"]},{"name":"ClickDimensions","categories":["ad"],"domains":["*.clickdimensions.com"]},{"name":"ipinfo.io","categories":["utility"],"domains":["*.ipinfo.io"]},{"name":"adnanny","categories":["ad"],"domains":["*.adserver01.de"]},{"name":"Force24","categories":["ad"],"domains":["*.force24.co.uk"]},{"name":"freewheel.tv","categories":["content"],"domains":["*.fwmrm.net"]},{"name":"Pulse Insights","categories":["analytics"],"domains":["*.pulseinsights.com"]},{"name":"Ido","categories":["customer-success"],"domains":["*.idio.co"]},{"name":"AirPR","categories":["analytics"],"domains":["*.airpr.com"]},{"name":"Loggly","homepage":"https://www.loggly.com/","categories":["analytics"],"domains":["*.loggly.com","d9jmv9u00p0mv.cloudfront.net"]},{"name":"EQ works","categories":["ad"],"domains":["*.eqads.com"]},{"name":"Segmint","categories":["analytics"],"domains":["*.segmint.net"]},{"name":"Jivox","categories":["ad"],"domains":["*.jivox.com"]},{"name":"Yellow Robot","categories":["ad"],"domains":["*.backinstock.org"]},{"name":"Adtegrity","categories":["ad"],"domains":["*.adtpix.com"]},{"name":"Macropod BugHerd","company":"Macropod","categories":["utility"],"domains":["*.bugherd.com"]},{"name":"Simpli.fi","categories":["ad"],"domains":["*.simpli.fi"]},{"name":"Indeed","categories":["content"],"domains":["*.indeed.com"]},{"name":"SLI Systems","categories":["utility"],"domains":["*.resultslist.com","*.resultspage.com","*.sli-spark.com"]},{"name":"j2 Cloud Services","categories":["ad"],"domains":["*.campaigner.com"]},{"name":"Imagini Holdings","categories":["ad"],"domains":["*.vdna-assets.com"]},{"name":"Business Week","company":"Bloomberg","categories":["social"],"domains":["*.bwbx.io"]},{"name":"WizRocket Technologies","categories":["analytics"],"domains":["*.wzrkt.com"]},{"name":"APSIS Profile Cloud","company":"APSIS","categories":["analytics"],"domains":["*.innomdc.com"]},{"name":"CogoCast","company":"Cogo Labs","categories":["ad"],"domains":["*.cogocast.net"]},{"name":"emetriq","homepage":"https://www.emetriq.com/","categories":["ad"],"domains":["*.emetriq.de","*.xplosion.de"]},{"name":"Crimtan","categories":["ad"],"domains":["*.ctnsnet.com"]},{"name":"Scroll","homepage":"https://scroll.com/","categories":["utility"],"domains":["*.scroll.com"]},{"name":"mbr targeting","categories":["ad"],"domains":["*.m6r.eu"]},{"name":"Thinglink","categories":["utility"],"domains":["*.thinglink.com"]},{"name":"Apptus eSales","company":"Apptus","categories":["analytics"],"domains":["*.apptus.com"]},{"name":"Kenshoo","categories":["marketing"],"domains":["*.xg4ken.com"]},{"name":"Adap.tv","categories":["ad"],"domains":["*.adap.tv"]},{"name":"ChannelAdvisor","categories":["ad"],"domains":["*.channeladvisor.com","*.searchmarketing.com"]},{"name":"Uniqodo","categories":["ad"],"domains":["*.uniqodo.com"]},{"name":"EpiServer","homepage":"https://www.episerver.com","categories":["content"],"domains":["*.episerver.net"]},{"name":"Vero","company":"Semblance","categories":["ad"],"domains":["*.getvero.com","d3qxef4rp70elm.cloudfront.net"]},{"name":"Targito","company":"VIVmail.cz","homepage":"https://www.targito.com","categories":["marketing"],"domains":["*.targito.com"]},{"name":"Burst Media","categories":["ad"],"domains":["*.burstnet.com","*.1rx.io"]},{"name":"Yahoo! Ad Exchange","company":"Yahoo!","categories":["ad"],"domains":["*.yieldmanager.com","*.browsiprod.com"]},{"name":"Confirmit","categories":["analytics"],"domains":["*.confirmit.com"]},{"name":"QuinStreet","categories":["ad"],"domains":["*.Quinstreet.com","*.b2btechleadform.com","*.qnsr.com","*.qsstats.com"]},{"name":"Vizury","categories":["ad"],"domains":["*.vizury.com"]},{"name":"Fospha","categories":["analytics"],"domains":["*.fospha.com"]},{"name":"Vizzit","homepage":"http://www.vizzit.se","categories":["analytics"],"domains":["*.vizzit.se"]},{"name":"Wibbitz","categories":["other"],"domains":["*.wibbitz.com"]},{"name":"rss2json","categories":["utility"],"domains":["*.rss2json.com"]},{"name":"BloomReach","categories":["ad"],"domains":["*.brcdn.com","*.brsrvr.com","*.brsvr.com"]},{"name":"PhotoBucket","categories":["content"],"domains":["*.photobucket.com"]},{"name":"Comodo","categories":["utility"],"domains":["*.comodo.com","*.trust-provider.com","*.trustlogo.com","usertrust.com","*.comodo.net"]},{"name":"Conversion Labs","categories":["ad"],"domains":["*.net.pl"]},{"name":"ObjectPlanet","categories":["analytics"],"domains":["*.easypolls.net"]},{"name":"Lifestreet Media","categories":["social"],"domains":["*.lfstmedia.com"]},{"name":"One by AOL","company":"AOL","categories":["ad"],"domains":["*.adtechjp.com","*.adtech.de"]},{"name":"Box","categories":["hosting"],"domains":["*.box.com"]},{"name":"Piwik","categories":["analytics"],"domains":["*.drtvtracker.com","*.piwikpro.com","*.raac33.net"]},{"name":"sage Pay","company":"Sage Pay Europe","categories":["utility"],"domains":["*.sagepay.com"]},{"name":"Effiliation sa","categories":["ad"],"domains":["*.effiliation.com"]},{"name":"JustUno","categories":["ad"],"domains":["*.justuno.com","d2j3qa5nc37287.cloudfront.net"]},{"name":"StrÃ¶er Digital Media","categories":["ad"],"domains":["*.stroeerdigitalmedia.de"]},{"name":"audioBoom","categories":["social"],"domains":["*.audioboom.com","*.audioboo.fm"]},{"name":"NEORY Marketing Cloud","company":"NEORY","categories":["marketing"],"domains":["*.ad-srv.net"]},{"name":"Provide Support","categories":["customer-success"],"domains":["*.providesupport.com"]},{"name":"Adara Media","categories":["ad"],"domains":["*.yieldoptimizer.com"]},{"name":"AdultWebmasterEmpire.Com","categories":["ad"],"domains":["*.awempire.com"]},{"name":"Flipp","categories":["analytics"],"domains":["*.wishabi.com","d2e0sxz09bo7k2.cloudfront.net","*.wishabi.net"]},{"name":"Carbon Ads","homepage":"https://www.carbonads.net/","categories":["ad"],"domains":["*.carbonads.net","*.carbonads.com"]},{"name":"Playground","homepage":"https://playground.xyz","categories":["ad"],"domains":["*.playground.xyz"]},{"name":"Pepperjam","homepage":"https://www.pepperjam.com/","categories":["marketing","analytics"],"domains":["*.pepperjam.com","*.affiliatetechnology.com"]},{"name":"Mynewsdesk","categories":["utility"],"domains":["*.mynewsdesk.com"]},{"name":"eKomi","categories":["analytics"],"domains":["*.ekomi.com","*.ekomi.de"]},{"name":"mainADV","categories":["ad"],"domains":["*.httptrack.com","*.solocpm.com"]},{"name":"Cludo","categories":["utility"],"domains":["*.cludo.com"]},{"name":"Digital Window","categories":["ad"],"domains":["*.awin1.com","*.zenaps.com"]},{"name":"SourceKnowledge","homepage":"http://www.sourceknowledge.com","categories":["ad"],"domains":["*.provenpixel.com"]},{"name":"Adblade","categories":["ad"],"domains":["*.adblade.com"]},{"name":"eDigital Research","categories":["customer-success"],"domains":["*.edigitalresearch.com","*.edigitalsurvey.com","*.edrcdn.com","*.ecustomeropinions.com"]},{"name":"Leaflet","categories":["utility"],"domains":["*.leafletjs.com"]},{"name":"Terminus","homepage":"https://terminus.com/","categories":["ad"],"domains":["*.terminus.services"]},{"name":"MyFonts","categories":["cdn"],"domains":["*.myfonts.net"]},{"name":"Nanigans","categories":["ad"],"domains":["*.nanigans.com"]},{"name":"Digital Millennium Copyright Act Services","categories":["utility"],"domains":["*.dmca.com"]},{"name":"Statuspage","company":"Atlassian","homepage":"https://www.statuspage.io","categories":["utility"],"domains":["*.statuspage.io"]},{"name":"Intilery","categories":["customer-success"],"domains":["*.intilery-analytics.com"]},{"name":"dianomi","categories":["ad"],"domains":["*.dianomi.com","*.dianomioffers.co.uk"]},{"name":"TinyURL","categories":["utility"],"domains":["*.tinyurl.com"]},{"name":"Lead Forensics","categories":["ad"],"domains":["*.200summit.com","*.baw5tracker.com","*.business-path-55.com","*.bux1le001.com","*.central-core-7.com","*.direct-azr-78.com","*.explore-123.com","*.forensics1000.com","*.gldsta-02-or.com","*.green-bloc9.com","*.lansrv040.com","*.lead-123.com","*.leadforensics.com","*.mavic852.com","*.mon-com-net.com","*.peak-ip-54.com","*.snta0034.com","*.svr-prc-01.com","*.syntace-094.com","*.tghbn12.com","*.trail-web.com","*.web-01-gbl.com","*.web-cntr-07.com","*.trackdiscovery.net"]},{"name":"IS Group","categories":["hosting"],"domains":["*.creative-serving.com"]},{"name":"AgilOne","categories":["marketing"],"domains":["*.agilone.com"]},{"name":"Qeryz","categories":["analytics"],"domains":["*.qeryz.com"]},{"name":"SFR","categories":["other"],"domains":["*.sfr.fr"]},{"name":"Emerse","homepage":"https://www.emerse.com/","categories":["ad"],"domains":["*.emerse.com"]},{"name":"AdRecover","categories":["ad"],"domains":["*.adrecover.com"]},{"name":"Sociomantic Labs","company":"DunnHumby","categories":["ad"],"domains":["*.sociomantic.com"]},{"name":"Beeswax","categories":["ad"],"domains":["*.bidr.io"]},{"name":"Yieldlab","categories":["ad"],"domains":["*.yieldlab.net"]},{"name":"Geoplugin","categories":["utility"],"domains":["*.geoplugin.com","*.geoplugin.net"]},{"name":"eyeReturn Marketing","categories":["marketing"],"domains":["*.eyereturn.com"]},{"name":"Psyma","categories":["ad"],"domains":["*.psyma.com"]},{"name":"Infopark","categories":["hosting"],"domains":["*.scrvt.com"]},{"name":"Lengow","categories":["hosting"],"domains":["*.lengow.com"]},{"name":"Vextras","categories":["other"],"domains":["*.vextras.com"]},{"name":"Agility","categories":["hosting"],"domains":["*.agilitycms.com"]},{"name":"Bizrate","categories":["analytics"],"domains":["*.bizrate.com"]},{"name":"PERFORM","categories":["content"],"domains":["*.performgroup.com"]},{"name":"CoolaData","categories":["analytics"],"domains":["*.cooladata.com"]},{"name":"Consumable","homepage":"http://consumable.com/","categories":["ad"],"domains":["*.serverbid.com"]},{"name":"HitsLink","categories":["analytics"],"domains":["*.hitslink.com"]},{"name":"VisualVisitor","categories":["ad"],"domains":["*.id-visitors.com"]},{"name":"GlobalSign","categories":["utility"],"domains":["*.globalsign.com","*.globalsign.net"]},{"name":"Adelphic","categories":["ad"],"domains":["*.ipredictive.com"]},{"name":"SecurityMetrics","categories":["utility"],"domains":["*.securitymetrics.com"]},{"name":"APSIS Forms","company":"APSIS","categories":["other"],"domains":["*.apsisforms.com"]},{"name":"Affiliatly","categories":["ad"],"domains":["*.affiliatly.com"]},{"name":"Blogg.se","categories":["hosting"],"domains":["*.cdnme.se","*.publishme.se"]},{"name":"Mark and Mini","categories":["ad"],"domains":["*.markandmini.com"]},{"name":"codigo","homepage":"http://www.codigo.se","categories":["analytics"],"domains":["*.codigo.se"]},{"name":"Sectigo","homepage":"https://sectigo.com/","categories":["utility"],"domains":["*.sectigo.com"]},{"name":"Google reCAPTCHA","company":"Google","categories":["utility"],"domains":["*.recaptcha.net"]},{"name":"Qode Interactive","categories":["hosting"],"domains":["*.qodeinteractive.com"]},{"name":"comScore","categories":["analytics"],"domains":["*.adxpose.com","*.comscore.com","*.sitestat.com","*.zqtk.net"]},{"name":"Blindado","categories":["utility"],"domains":["*.siteblindado.com"]},{"name":"MotionPoint","categories":["other"],"domains":["*.convertlanguage.com"]},{"name":"Webcore","categories":["ad"],"domains":["*.onefeed.co.uk"]},{"name":"Spiceworks","homepage":"https://www.spiceworks.com","categories":["analytics"],"domains":["*.spiceworks.com"]},{"name":"Trinity Mirror","categories":["content"],"domains":["*.mirror.co.uk"]},{"name":"PollDaddy (Automattic)","categories":["ad"],"domains":["static.polldaddy.com","*.poll.fm"]},{"name":"ShopiMind","company":"ShopIMind","categories":["ad"],"domains":["*.shopimind.com"]},{"name":"Net Applications","categories":["analytics"],"domains":["*.hitsprocessor.com"]},{"name":"LiveInternet","categories":["analytics"],"domains":["*.yadro.ru"]},{"name":"Vindico","company":"Viant","categories":["ad"],"domains":["*.vindicosuite.com"]},{"name":"PriceRunner","categories":["content"],"domains":["*.pricerunner.com"]},{"name":"dotMailer Surveys","company":"dotMailer","categories":["analytics"],"domains":["*.dotmailer-surveys.com"]},{"name":"OpinionBar","categories":["analytics"],"domains":["*.opinionbar.com"]},{"name":"A-FIS PTE","categories":["analytics"],"domains":["*.websta.me"]},{"name":"IcoMoon","categories":["cdn"],"domains":["d19ayerf5ehaab.cloudfront.net","d1azc1qln24ryf.cloudfront.net"]},{"name":"Improvely","categories":["analytics"],"domains":["*.iljmp.com"]},{"name":"eWAY","company":"Web Active Pty","categories":["utility"],"domains":["*.eway.com.au"]},{"name":"Adsty","categories":["ad"],"domains":["*.adx1.com"]},{"name":"MaxPoint Interactive","categories":["ad"],"domains":["*.mxptint.net"]},{"name":"Sweet Tooth","categories":["ad"],"domains":["*.sweettooth.io"]},{"name":"ADventori","categories":["ad"],"domains":["*.adventori.com"]},{"name":"Samba TV","company":"Samba","categories":["content"],"domains":["*.samba.tv"]},{"name":"Ghostery Enterprise","company":"Ghostery","categories":["marketing"],"domains":["*.betrad.com"]},{"name":"CJ Affiliate by Conversant","company":"Conversant","categories":["ad"],"domains":["*.ftjcfx.com"]},{"name":"Varick Media Management","categories":["ad"],"domains":["*.vmmpxl.com"]},{"name":"Bidswitch","homepage":"https://www.bidswitch.com/","categories":["ad"],"domains":["*.bidswitch.net"]},{"name":"AdTheorent","categories":["ad"],"domains":["*.adentifi.com"]}]
},{}],251:[function(require,module,exports){
module.exports = require("./lib/subsets/httparchive-nostats.js")

},{"./lib/subsets/httparchive-nostats.js":253}],252:[function(require,module,exports){
const DOMAIN_IN_URL_REGEX = /:\/\/(\S*?)(:\d+)?(\/|$)/
const DOMAIN_CHARACTERS = /([a-z0-9.-]+\.[a-z0-9]+|localhost)/i
const IP_REGEX = /^\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}$/
const ROOT_DOMAIN_REGEX = /[^.]+\.([^.]+|(gov|com|co|ne)\.\w{2})$/i

function getDomainFromOriginOrURL(originOrURL) {
  if (typeof originOrURL !== 'string') return null
  if (originOrURL.length > 10000 || originOrURL.startsWith('data:')) return null
  if (DOMAIN_IN_URL_REGEX.test(originOrURL)) return originOrURL.match(DOMAIN_IN_URL_REGEX)[1]
  if (DOMAIN_CHARACTERS.test(originOrURL)) return originOrURL.match(DOMAIN_CHARACTERS)[0]
  return null
}

function getRootDomain(originOrURL) {
  const domain = getDomainFromOriginOrURL(originOrURL)
  if (!domain) return null
  if (IP_REGEX.test(domain)) return domain
  const match = domain.match(ROOT_DOMAIN_REGEX)
  return (match && match[0]) || domain
}

function getEntityInDataset(entityByDomain, entityByRootDomain, originOrURL) {
  const domain = getDomainFromOriginOrURL(originOrURL)
  const rootDomain = getRootDomain(domain)
  if (!domain || !rootDomain) return undefined
  if (entityByDomain.has(domain)) return entityByDomain.get(domain)
  if (entityByRootDomain.has(rootDomain)) return entityByRootDomain.get(rootDomain)
  return undefined
}

function getProductInDataset(entityByDomain, entityByRootDomain, originOrURL) {
  const entity = getEntityInDataset(entityByDomain, entityByRootDomain, originOrURL)
  const products = entity && entity.products
  if (!products) return undefined
  if (typeof originOrURL !== 'string') return undefined

  for (const product of products) {
    for (const pattern of product.urlPatterns) {
      if (pattern instanceof RegExp && pattern.test(originOrURL)) return product
      if (typeof pattern === 'string' && originOrURL.includes(pattern)) return product
    }
  }
  return undefined
}

function cloneEntities(entities) {
  return entities.map(entity_ => {
    const entity = {
      company: entity_.name,
      ...entity_,
    }

    const products = (entity_.products || []).map(product => ({
      company: entity.company,
      categories: entity.categories,
      facades: [],
      ...product,
      urlPatterns: (product.urlPatterns || []).map(s =>
        s.startsWith('REGEXP:') ? new RegExp(s.slice('REGEXP:'.length)) : s
      ),
    }))

    entity.products = products
    return entity
  })
}

function createAPIFromDataset(entities_) {
  const entities = cloneEntities(entities_)
  const entityByDomain = new Map()
  const entityByRootDomain = new Map()

  for (const entity of entities) {
    entity.totalExecutionTime = Number(entity.totalExecutionTime) || 0
    entity.totalOccurrences = Number(entity.totalOccurrences) || 0
    entity.averageExecutionTime = entity.totalExecutionTime / entity.totalOccurrences

    for (const domain of entity.domains) {
      if (entityByDomain.has(domain)) {
        const duplicate = entityByDomain.get(domain)
        throw new Error(`Duplicate domain ${domain} (${entity.name} and ${duplicate.name})`)
      }

      entityByDomain.set(domain, entity)

      const rootDomain = getRootDomain(domain)
      if (domain.startsWith('*.')) {
        entityByRootDomain.set(rootDomain, entity)
      }
    }
  }

  for (const [rootDomain, entity] of entityByRootDomain.entries()) {
    if (!entity) entityByRootDomain.delete(rootDomain)
  }

  const getEntity = getEntityInDataset.bind(null, entityByDomain, entityByRootDomain)
  const getProduct = getProductInDataset.bind(null, entityByDomain, entityByRootDomain)
  return {getEntity, getProduct, getRootDomain, entities}
}

module.exports = {createAPIFromDataset}

},{}],253:[function(require,module,exports){
const {createAPIFromDataset} = require('../create-entity-finder-api.js')
const entities = require('../../dist/entities-httparchive-nostats.json')
module.exports = createAPIFromDataset(entities)

},{"../../dist/entities-httparchive-nostats.json":250,"../create-entity-finder-api.js":252}],254:[function(require,module,exports){
(function (global){(function (){

/**
 * Module exports.
 */

module.exports = deprecate;

/**
 * Mark that a method should not be used.
 * Returns a modified function which warns once by default.
 *
 * If `localStorage.noDeprecation = true` is set, then it is a no-op.
 *
 * If `localStorage.throwDeprecation = true` is set, then deprecated functions
 * will throw an Error when invoked.
 *
 * If `localStorage.traceDeprecation = true` is set, then deprecated functions
 * will invoke `console.trace()` instead of `console.error()`.
 *
 * @param {Function} fn - the function to deprecate
 * @param {String} msg - the string to print to the console when `fn` is invoked
 * @returns {Function} a new "deprecated" version of `fn`
 * @api public
 */

function deprecate (fn, msg) {
  if (config('noDeprecation')) {
    return fn;
  }

  var warned = false;
  function deprecated() {
    if (!warned) {
      if (config('throwDeprecation')) {
        throw new Error(msg);
      } else if (config('traceDeprecation')) {
        console.trace(msg);
      } else {
        console.warn(msg);
      }
      warned = true;
    }
    return fn.apply(this, arguments);
  }

  return deprecated;
}

/**
 * Checks `localStorage` for boolean values for the given `name`.
 *
 * @param {String} name
 * @returns {Boolean}
 * @api private
 */

function config (name) {
  // accessing global.localStorage can trigger a DOMException in sandboxed iframes
  try {
    if (!global.localStorage) return false;
  } catch (_) {
    return false;
  }
  var val = global.localStorage[name];
  if (null == val) return false;
  return String(val).toLowerCase() === 'true';
}

}).call(this)}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],255:[function(require,module,exports){
arguments[4][129][0].apply(exports,arguments)
},{"dup":129}],256:[function(require,module,exports){
// Currently in sync with Node.js lib/internal/util/types.js
// https://github.com/nodejs/node/commit/112cc7c27551254aa2b17098fb774867f05ed0d9

'use strict';

var isArgumentsObject = require('is-arguments');
var isGeneratorFunction = require('is-generator-function');
var whichTypedArray = require('which-typed-array');
var isTypedArray = require('is-typed-array');

function uncurryThis(f) {
  return f.call.bind(f);
}

var BigIntSupported = typeof BigInt !== 'undefined';
var SymbolSupported = typeof Symbol !== 'undefined';

var ObjectToString = uncurryThis(Object.prototype.toString);

var numberValue = uncurryThis(Number.prototype.valueOf);
var stringValue = uncurryThis(String.prototype.valueOf);
var booleanValue = uncurryThis(Boolean.prototype.valueOf);

if (BigIntSupported) {
  var bigIntValue = uncurryThis(BigInt.prototype.valueOf);
}

if (SymbolSupported) {
  var symbolValue = uncurryThis(Symbol.prototype.valueOf);
}

function checkBoxedPrimitive(value, prototypeValueOf) {
  if (typeof value !== 'object') {
    return false;
  }
  try {
    prototypeValueOf(value);
    return true;
  } catch(e) {
    return false;
  }
}

exports.isArgumentsObject = isArgumentsObject;
exports.isGeneratorFunction = isGeneratorFunction;
exports.isTypedArray = isTypedArray;

// Taken from here and modified for better browser support
// https://github.com/sindresorhus/p-is-promise/blob/cda35a513bda03f977ad5cde3a079d237e82d7ef/index.js
function isPromise(input) {
	return (
		(
			typeof Promise !== 'undefined' &&
			input instanceof Promise
		) ||
		(
			input !== null &&
			typeof input === 'object' &&
			typeof input.then === 'function' &&
			typeof input.catch === 'function'
		)
	);
}
exports.isPromise = isPromise;

function isArrayBufferView(value) {
  if (typeof ArrayBuffer !== 'undefined' && ArrayBuffer.isView) {
    return ArrayBuffer.isView(value);
  }

  return (
    isTypedArray(value) ||
    isDataView(value)
  );
}
exports.isArrayBufferView = isArrayBufferView;


function isUint8Array(value) {
  return whichTypedArray(value) === 'Uint8Array';
}
exports.isUint8Array = isUint8Array;

function isUint8ClampedArray(value) {
  return whichTypedArray(value) === 'Uint8ClampedArray';
}
exports.isUint8ClampedArray = isUint8ClampedArray;

function isUint16Array(value) {
  return whichTypedArray(value) === 'Uint16Array';
}
exports.isUint16Array = isUint16Array;

function isUint32Array(value) {
  return whichTypedArray(value) === 'Uint32Array';
}
exports.isUint32Array = isUint32Array;

function isInt8Array(value) {
  return whichTypedArray(value) === 'Int8Array';
}
exports.isInt8Array = isInt8Array;

function isInt16Array(value) {
  return whichTypedArray(value) === 'Int16Array';
}
exports.isInt16Array = isInt16Array;

function isInt32Array(value) {
  return whichTypedArray(value) === 'Int32Array';
}
exports.isInt32Array = isInt32Array;

function isFloat32Array(value) {
  return whichTypedArray(value) === 'Float32Array';
}
exports.isFloat32Array = isFloat32Array;

function isFloat64Array(value) {
  return whichTypedArray(value) === 'Float64Array';
}
exports.isFloat64Array = isFloat64Array;

function isBigInt64Array(value) {
  return whichTypedArray(value) === 'BigInt64Array';
}
exports.isBigInt64Array = isBigInt64Array;

function isBigUint64Array(value) {
  return whichTypedArray(value) === 'BigUint64Array';
}
exports.isBigUint64Array = isBigUint64Array;

function isMapToString(value) {
  return ObjectToString(value) === '[object Map]';
}
isMapToString.working = (
  typeof Map !== 'undefined' &&
  isMapToString(new Map())
);

function isMap(value) {
  if (typeof Map === 'undefined') {
    return false;
  }

  return isMapToString.working
    ? isMapToString(value)
    : value instanceof Map;
}
exports.isMap = isMap;

function isSetToString(value) {
  return ObjectToString(value) === '[object Set]';
}
isSetToString.working = (
  typeof Set !== 'undefined' &&
  isSetToString(new Set())
);
function isSet(value) {
  if (typeof Set === 'undefined') {
    return false;
  }

  return isSetToString.working
    ? isSetToString(value)
    : value instanceof Set;
}
exports.isSet = isSet;

function isWeakMapToString(value) {
  return ObjectToString(value) === '[object WeakMap]';
}
isWeakMapToString.working = (
  typeof WeakMap !== 'undefined' &&
  isWeakMapToString(new WeakMap())
);
function isWeakMap(value) {
  if (typeof WeakMap === 'undefined') {
    return false;
  }

  return isWeakMapToString.working
    ? isWeakMapToString(value)
    : value instanceof WeakMap;
}
exports.isWeakMap = isWeakMap;

function isWeakSetToString(value) {
  return ObjectToString(value) === '[object WeakSet]';
}
isWeakSetToString.working = (
  typeof WeakSet !== 'undefined' &&
  isWeakSetToString(new WeakSet())
);
function isWeakSet(value) {
  return isWeakSetToString(value);
}
exports.isWeakSet = isWeakSet;

function isArrayBufferToString(value) {
  return ObjectToString(value) === '[object ArrayBuffer]';
}
isArrayBufferToString.working = (
  typeof ArrayBuffer !== 'undefined' &&
  isArrayBufferToString(new ArrayBuffer())
);
function isArrayBuffer(value) {
  if (typeof ArrayBuffer === 'undefined') {
    return false;
  }

  return isArrayBufferToString.working
    ? isArrayBufferToString(value)
    : value instanceof ArrayBuffer;
}
exports.isArrayBuffer = isArrayBuffer;

function isDataViewToString(value) {
  return ObjectToString(value) === '[object DataView]';
}
isDataViewToString.working = (
  typeof ArrayBuffer !== 'undefined' &&
  typeof DataView !== 'undefined' &&
  isDataViewToString(new DataView(new ArrayBuffer(1), 0, 1))
);
function isDataView(value) {
  if (typeof DataView === 'undefined') {
    return false;
  }

  return isDataViewToString.working
    ? isDataViewToString(value)
    : value instanceof DataView;
}
exports.isDataView = isDataView;

function isSharedArrayBufferToString(value) {
  return ObjectToString(value) === '[object SharedArrayBuffer]';
}
isSharedArrayBufferToString.working = (
  typeof SharedArrayBuffer !== 'undefined' &&
  isSharedArrayBufferToString(new SharedArrayBuffer())
);
function isSharedArrayBuffer(value) {
  if (typeof SharedArrayBuffer === 'undefined') {
    return false;
  }

  return isSharedArrayBufferToString.working
    ? isSharedArrayBufferToString(value)
    : value instanceof SharedArrayBuffer;
}
exports.isSharedArrayBuffer = isSharedArrayBuffer;

function isAsyncFunction(value) {
  return ObjectToString(value) === '[object AsyncFunction]';
}
exports.isAsyncFunction = isAsyncFunction;

function isMapIterator(value) {
  return ObjectToString(value) === '[object Map Iterator]';
}
exports.isMapIterator = isMapIterator;

function isSetIterator(value) {
  return ObjectToString(value) === '[object Set Iterator]';
}
exports.isSetIterator = isSetIterator;

function isGeneratorObject(value) {
  return ObjectToString(value) === '[object Generator]';
}
exports.isGeneratorObject = isGeneratorObject;

function isWebAssemblyCompiledModule(value) {
  return ObjectToString(value) === '[object WebAssembly.Module]';
}
exports.isWebAssemblyCompiledModule = isWebAssemblyCompiledModule;

function isNumberObject(value) {
  return checkBoxedPrimitive(value, numberValue);
}
exports.isNumberObject = isNumberObject;

function isStringObject(value) {
  return checkBoxedPrimitive(value, stringValue);
}
exports.isStringObject = isStringObject;

function isBooleanObject(value) {
  return checkBoxedPrimitive(value, booleanValue);
}
exports.isBooleanObject = isBooleanObject;

function isBigIntObject(value) {
  return BigIntSupported && checkBoxedPrimitive(value, bigIntValue);
}
exports.isBigIntObject = isBigIntObject;

function isSymbolObject(value) {
  return SymbolSupported && checkBoxedPrimitive(value, symbolValue);
}
exports.isSymbolObject = isSymbolObject;

function isBoxedPrimitive(value) {
  return (
    isNumberObject(value) ||
    isStringObject(value) ||
    isBooleanObject(value) ||
    isBigIntObject(value) ||
    isSymbolObject(value)
  );
}
exports.isBoxedPrimitive = isBoxedPrimitive;

function isAnyArrayBuffer(value) {
  return typeof Uint8Array !== 'undefined' && (
    isArrayBuffer(value) ||
    isSharedArrayBuffer(value)
  );
}
exports.isAnyArrayBuffer = isAnyArrayBuffer;

['isProxy', 'isExternal', 'isModuleNamespaceObject'].forEach(function(method) {
  Object.defineProperty(exports, method, {
    enumerable: false,
    value: function() {
      throw new Error(method + ' is not supported in userland');
    }
  });
});

},{"is-arguments":181,"is-generator-function":183,"is-typed-array":184,"which-typed-array":258}],257:[function(require,module,exports){
(function (process){(function (){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

var getOwnPropertyDescriptors = Object.getOwnPropertyDescriptors ||
  function getOwnPropertyDescriptors(obj) {
    var keys = Object.keys(obj);
    var descriptors = {};
    for (var i = 0; i < keys.length; i++) {
      descriptors[keys[i]] = Object.getOwnPropertyDescriptor(obj, keys[i]);
    }
    return descriptors;
  };

var formatRegExp = /%[sdj%]/g;
exports.format = function(f) {
  if (!isString(f)) {
    var objects = [];
    for (var i = 0; i < arguments.length; i++) {
      objects.push(inspect(arguments[i]));
    }
    return objects.join(' ');
  }

  var i = 1;
  var args = arguments;
  var len = args.length;
  var str = String(f).replace(formatRegExp, function(x) {
    if (x === '%%') return '%';
    if (i >= len) return x;
    switch (x) {
      case '%s': return String(args[i++]);
      case '%d': return Number(args[i++]);
      case '%j':
        try {
          return JSON.stringify(args[i++]);
        } catch (_) {
          return '[Circular]';
        }
      default:
        return x;
    }
  });
  for (var x = args[i]; i < len; x = args[++i]) {
    if (isNull(x) || !isObject(x)) {
      str += ' ' + x;
    } else {
      str += ' ' + inspect(x);
    }
  }
  return str;
};


// Mark that a method should not be used.
// Returns a modified function which warns once by default.
// If --no-deprecation is set, then it is a no-op.
exports.deprecate = function(fn, msg) {
  if (typeof process !== 'undefined' && process.noDeprecation === true) {
    return fn;
  }

  // Allow for deprecating things in the process of starting up.
  if (typeof process === 'undefined') {
    return function() {
      return exports.deprecate(fn, msg).apply(this, arguments);
    };
  }

  var warned = false;
  function deprecated() {
    if (!warned) {
      if (process.throwDeprecation) {
        throw new Error(msg);
      } else if (process.traceDeprecation) {
        console.trace(msg);
      } else {
        console.error(msg);
      }
      warned = true;
    }
    return fn.apply(this, arguments);
  }

  return deprecated;
};


var debugs = {};
var debugEnvRegex = /^$/;

if (process.env.NODE_DEBUG) {
  var debugEnv = process.env.NODE_DEBUG;
  debugEnv = debugEnv.replace(/[|\\{}()[\]^$+?.]/g, '\\$&')
    .replace(/\*/g, '.*')
    .replace(/,/g, '$|^')
    .toUpperCase();
  debugEnvRegex = new RegExp('^' + debugEnv + '$', 'i');
}
exports.debuglog = function(set) {
  set = set.toUpperCase();
  if (!debugs[set]) {
    if (debugEnvRegex.test(set)) {
      var pid = process.pid;
      debugs[set] = function() {
        var msg = exports.format.apply(exports, arguments);
        console.error('%s %d: %s', set, pid, msg);
      };
    } else {
      debugs[set] = function() {};
    }
  }
  return debugs[set];
};


/**
 * Echos the value of a value. Trys to print the value out
 * in the best way possible given the different types.
 *
 * @param {Object} obj The object to print out.
 * @param {Object} opts Optional options object that alters the output.
 */
/* legacy: obj, showHidden, depth, colors*/
function inspect(obj, opts) {
  // default options
  var ctx = {
    seen: [],
    stylize: stylizeNoColor
  };
  // legacy...
  if (arguments.length >= 3) ctx.depth = arguments[2];
  if (arguments.length >= 4) ctx.colors = arguments[3];
  if (isBoolean(opts)) {
    // legacy...
    ctx.showHidden = opts;
  } else if (opts) {
    // got an "options" object
    exports._extend(ctx, opts);
  }
  // set default options
  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;
  if (isUndefined(ctx.depth)) ctx.depth = 2;
  if (isUndefined(ctx.colors)) ctx.colors = false;
  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;
  if (ctx.colors) ctx.stylize = stylizeWithColor;
  return formatValue(ctx, obj, ctx.depth);
}
exports.inspect = inspect;


// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics
inspect.colors = {
  'bold' : [1, 22],
  'italic' : [3, 23],
  'underline' : [4, 24],
  'inverse' : [7, 27],
  'white' : [37, 39],
  'grey' : [90, 39],
  'black' : [30, 39],
  'blue' : [34, 39],
  'cyan' : [36, 39],
  'green' : [32, 39],
  'magenta' : [35, 39],
  'red' : [31, 39],
  'yellow' : [33, 39]
};

// Don't use 'blue' not visible on cmd.exe
inspect.styles = {
  'special': 'cyan',
  'number': 'yellow',
  'boolean': 'yellow',
  'undefined': 'grey',
  'null': 'bold',
  'string': 'green',
  'date': 'magenta',
  // "name": intentionally not styling
  'regexp': 'red'
};


function stylizeWithColor(str, styleType) {
  var style = inspect.styles[styleType];

  if (style) {
    return '\u001b[' + inspect.colors[style][0] + 'm' + str +
           '\u001b[' + inspect.colors[style][1] + 'm';
  } else {
    return str;
  }
}


function stylizeNoColor(str, styleType) {
  return str;
}


function arrayToHash(array) {
  var hash = {};

  array.forEach(function(val, idx) {
    hash[val] = true;
  });

  return hash;
}


function formatValue(ctx, value, recurseTimes) {
  // Provide a hook for user-specified inspect functions.
  // Check that value is an object with an inspect function on it
  if (ctx.customInspect &&
      value &&
      isFunction(value.inspect) &&
      // Filter out the util module, it's inspect function is special
      value.inspect !== exports.inspect &&
      // Also filter out any prototype objects using the circular check.
      !(value.constructor && value.constructor.prototype === value)) {
    var ret = value.inspect(recurseTimes, ctx);
    if (!isString(ret)) {
      ret = formatValue(ctx, ret, recurseTimes);
    }
    return ret;
  }

  // Primitive types cannot have properties
  var primitive = formatPrimitive(ctx, value);
  if (primitive) {
    return primitive;
  }

  // Look up the keys of the object.
  var keys = Object.keys(value);
  var visibleKeys = arrayToHash(keys);

  if (ctx.showHidden) {
    keys = Object.getOwnPropertyNames(value);
  }

  // IE doesn't make error fields non-enumerable
  // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx
  if (isError(value)
      && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {
    return formatError(value);
  }

  // Some type of object without properties can be shortcutted.
  if (keys.length === 0) {
    if (isFunction(value)) {
      var name = value.name ? ': ' + value.name : '';
      return ctx.stylize('[Function' + name + ']', 'special');
    }
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    }
    if (isDate(value)) {
      return ctx.stylize(Date.prototype.toString.call(value), 'date');
    }
    if (isError(value)) {
      return formatError(value);
    }
  }

  var base = '', array = false, braces = ['{', '}'];

  // Make Array say that they are Array
  if (isArray(value)) {
    array = true;
    braces = ['[', ']'];
  }

  // Make functions say that they are functions
  if (isFunction(value)) {
    var n = value.name ? ': ' + value.name : '';
    base = ' [Function' + n + ']';
  }

  // Make RegExps say that they are RegExps
  if (isRegExp(value)) {
    base = ' ' + RegExp.prototype.toString.call(value);
  }

  // Make dates with properties first say the date
  if (isDate(value)) {
    base = ' ' + Date.prototype.toUTCString.call(value);
  }

  // Make error with message first say the error
  if (isError(value)) {
    base = ' ' + formatError(value);
  }

  if (keys.length === 0 && (!array || value.length == 0)) {
    return braces[0] + base + braces[1];
  }

  if (recurseTimes < 0) {
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    } else {
      return ctx.stylize('[Object]', 'special');
    }
  }

  ctx.seen.push(value);

  var output;
  if (array) {
    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
  } else {
    output = keys.map(function(key) {
      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
    });
  }

  ctx.seen.pop();

  return reduceToSingleString(output, base, braces);
}


function formatPrimitive(ctx, value) {
  if (isUndefined(value))
    return ctx.stylize('undefined', 'undefined');
  if (isString(value)) {
    var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '')
                                             .replace(/'/g, "\\'")
                                             .replace(/\\"/g, '"') + '\'';
    return ctx.stylize(simple, 'string');
  }
  if (isNumber(value))
    return ctx.stylize('' + value, 'number');
  if (isBoolean(value))
    return ctx.stylize('' + value, 'boolean');
  // For some reason typeof null is "object", so special case here.
  if (isNull(value))
    return ctx.stylize('null', 'null');
}


function formatError(value) {
  return '[' + Error.prototype.toString.call(value) + ']';
}


function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
  var output = [];
  for (var i = 0, l = value.length; i < l; ++i) {
    if (hasOwnProperty(value, String(i))) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          String(i), true));
    } else {
      output.push('');
    }
  }
  keys.forEach(function(key) {
    if (!key.match(/^\d+$/)) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          key, true));
    }
  });
  return output;
}


function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
  var name, str, desc;
  desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };
  if (desc.get) {
    if (desc.set) {
      str = ctx.stylize('[Getter/Setter]', 'special');
    } else {
      str = ctx.stylize('[Getter]', 'special');
    }
  } else {
    if (desc.set) {
      str = ctx.stylize('[Setter]', 'special');
    }
  }
  if (!hasOwnProperty(visibleKeys, key)) {
    name = '[' + key + ']';
  }
  if (!str) {
    if (ctx.seen.indexOf(desc.value) < 0) {
      if (isNull(recurseTimes)) {
        str = formatValue(ctx, desc.value, null);
      } else {
        str = formatValue(ctx, desc.value, recurseTimes - 1);
      }
      if (str.indexOf('\n') > -1) {
        if (array) {
          str = str.split('\n').map(function(line) {
            return '  ' + line;
          }).join('\n').substr(2);
        } else {
          str = '\n' + str.split('\n').map(function(line) {
            return '   ' + line;
          }).join('\n');
        }
      }
    } else {
      str = ctx.stylize('[Circular]', 'special');
    }
  }
  if (isUndefined(name)) {
    if (array && key.match(/^\d+$/)) {
      return str;
    }
    name = JSON.stringify('' + key);
    if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
      name = name.substr(1, name.length - 2);
      name = ctx.stylize(name, 'name');
    } else {
      name = name.replace(/'/g, "\\'")
                 .replace(/\\"/g, '"')
                 .replace(/(^"|"$)/g, "'");
      name = ctx.stylize(name, 'string');
    }
  }

  return name + ': ' + str;
}


function reduceToSingleString(output, base, braces) {
  var numLinesEst = 0;
  var length = output.reduce(function(prev, cur) {
    numLinesEst++;
    if (cur.indexOf('\n') >= 0) numLinesEst++;
    return prev + cur.replace(/\u001b\[\d\d?m/g, '').length + 1;
  }, 0);

  if (length > 60) {
    return braces[0] +
           (base === '' ? '' : base + '\n ') +
           ' ' +
           output.join(',\n  ') +
           ' ' +
           braces[1];
  }

  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
}


// NOTE: These type checking functions intentionally don't use `instanceof`
// because it is fragile and can be easily faked with `Object.create()`.
exports.types = require('./support/types');

function isArray(ar) {
  return Array.isArray(ar);
}
exports.isArray = isArray;

function isBoolean(arg) {
  return typeof arg === 'boolean';
}
exports.isBoolean = isBoolean;

function isNull(arg) {
  return arg === null;
}
exports.isNull = isNull;

function isNullOrUndefined(arg) {
  return arg == null;
}
exports.isNullOrUndefined = isNullOrUndefined;

function isNumber(arg) {
  return typeof arg === 'number';
}
exports.isNumber = isNumber;

function isString(arg) {
  return typeof arg === 'string';
}
exports.isString = isString;

function isSymbol(arg) {
  return typeof arg === 'symbol';
}
exports.isSymbol = isSymbol;

function isUndefined(arg) {
  return arg === void 0;
}
exports.isUndefined = isUndefined;

function isRegExp(re) {
  return isObject(re) && objectToString(re) === '[object RegExp]';
}
exports.isRegExp = isRegExp;
exports.types.isRegExp = isRegExp;

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}
exports.isObject = isObject;

function isDate(d) {
  return isObject(d) && objectToString(d) === '[object Date]';
}
exports.isDate = isDate;
exports.types.isDate = isDate;

function isError(e) {
  return isObject(e) &&
      (objectToString(e) === '[object Error]' || e instanceof Error);
}
exports.isError = isError;
exports.types.isNativeError = isError;

function isFunction(arg) {
  return typeof arg === 'function';
}
exports.isFunction = isFunction;

function isPrimitive(arg) {
  return arg === null ||
         typeof arg === 'boolean' ||
         typeof arg === 'number' ||
         typeof arg === 'string' ||
         typeof arg === 'symbol' ||  // ES6 symbol
         typeof arg === 'undefined';
}
exports.isPrimitive = isPrimitive;

exports.isBuffer = require('./support/isBuffer');

function objectToString(o) {
  return Object.prototype.toString.call(o);
}


function pad(n) {
  return n < 10 ? '0' + n.toString(10) : n.toString(10);
}


var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',
              'Oct', 'Nov', 'Dec'];

// 26 Feb 16:19:34
function timestamp() {
  var d = new Date();
  var time = [pad(d.getHours()),
              pad(d.getMinutes()),
              pad(d.getSeconds())].join(':');
  return [d.getDate(), months[d.getMonth()], time].join(' ');
}


// log is just a thin wrapper to console.log that prepends a timestamp
exports.log = function() {
  console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));
};


/**
 * Inherit the prototype methods from one constructor into another.
 *
 * The Function.prototype.inherits from lang.js rewritten as a standalone
 * function (not on Function.prototype). NOTE: If this file is to be loaded
 * during bootstrapping this function needs to be rewritten using some native
 * functions as prototype setup using normal JavaScript does not work as
 * expected during bootstrapping (see mirror.js in r114903).
 *
 * @param {function} ctor Constructor function which needs to inherit the
 *     prototype.
 * @param {function} superCtor Constructor function to inherit prototype from.
 */
exports.inherits = require('inherits');

exports._extend = function(origin, add) {
  // Don't do anything if add isn't an object
  if (!add || !isObject(add)) return origin;

  var keys = Object.keys(add);
  var i = keys.length;
  while (i--) {
    origin[keys[i]] = add[keys[i]];
  }
  return origin;
};

function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

var kCustomPromisifiedSymbol = typeof Symbol !== 'undefined' ? Symbol('util.promisify.custom') : undefined;

exports.promisify = function promisify(original) {
  if (typeof original !== 'function')
    throw new TypeError('The "original" argument must be of type Function');

  if (kCustomPromisifiedSymbol && original[kCustomPromisifiedSymbol]) {
    var fn = original[kCustomPromisifiedSymbol];
    if (typeof fn !== 'function') {
      throw new TypeError('The "util.promisify.custom" argument must be of type Function');
    }
    Object.defineProperty(fn, kCustomPromisifiedSymbol, {
      value: fn, enumerable: false, writable: false, configurable: true
    });
    return fn;
  }

  function fn() {
    var promiseResolve, promiseReject;
    var promise = new Promise(function (resolve, reject) {
      promiseResolve = resolve;
      promiseReject = reject;
    });

    var args = [];
    for (var i = 0; i < arguments.length; i++) {
      args.push(arguments[i]);
    }
    args.push(function (err, value) {
      if (err) {
        promiseReject(err);
      } else {
        promiseResolve(value);
      }
    });

    try {
      original.apply(this, args);
    } catch (err) {
      promiseReject(err);
    }

    return promise;
  }

  Object.setPrototypeOf(fn, Object.getPrototypeOf(original));

  if (kCustomPromisifiedSymbol) Object.defineProperty(fn, kCustomPromisifiedSymbol, {
    value: fn, enumerable: false, writable: false, configurable: true
  });
  return Object.defineProperties(
    fn,
    getOwnPropertyDescriptors(original)
  );
}

exports.promisify.custom = kCustomPromisifiedSymbol

function callbackifyOnRejected(reason, cb) {
  // `!reason` guard inspired by bluebird (Ref: https://goo.gl/t5IS6M).
  // Because `null` is a special error value in callbacks which means "no error
  // occurred", we error-wrap so the callback consumer can distinguish between
  // "the promise rejected with null" or "the promise fulfilled with undefined".
  if (!reason) {
    var newReason = new Error('Promise was rejected with a falsy value');
    newReason.reason = reason;
    reason = newReason;
  }
  return cb(reason);
}

function callbackify(original) {
  if (typeof original !== 'function') {
    throw new TypeError('The "original" argument must be of type Function');
  }

  // We DO NOT return the promise as it gives the user a false sense that
  // the promise is actually somehow related to the callback's execution
  // and that the callback throwing will reject the promise.
  function callbackified() {
    var args = [];
    for (var i = 0; i < arguments.length; i++) {
      args.push(arguments[i]);
    }

    var maybeCb = args.pop();
    if (typeof maybeCb !== 'function') {
      throw new TypeError('The last argument must be of type Function');
    }
    var self = this;
    var cb = function() {
      return maybeCb.apply(self, arguments);
    };
    // In true node style we process the callback on `nextTick` with all the
    // implications (stack, `uncaughtException`, `async_hooks`)
    original.apply(this, args)
      .then(function(ret) { process.nextTick(cb.bind(null, null, ret)) },
            function(rej) { process.nextTick(callbackifyOnRejected.bind(null, rej, cb)) });
  }

  Object.setPrototypeOf(callbackified, Object.getPrototypeOf(original));
  Object.defineProperties(callbackified,
                          getOwnPropertyDescriptors(original));
  return callbackified;
}
exports.callbackify = callbackify;

}).call(this)}).call(this,require('_process'))
},{"./support/isBuffer":255,"./support/types":256,"_process":223,"inherits":174}],258:[function(require,module,exports){
(function (global){(function (){
'use strict';

var forEach = require('foreach');
var availableTypedArrays = require('available-typed-arrays');
var callBound = require('call-bind/callBound');

var $toString = callBound('Object.prototype.toString');
var hasSymbols = require('has-symbols')();
var hasToStringTag = hasSymbols && typeof Symbol.toStringTag === 'symbol';

var typedArrays = availableTypedArrays();

var $slice = callBound('String.prototype.slice');
var toStrTags = {};
var gOPD = require('es-abstract/helpers/getOwnPropertyDescriptor');
var getPrototypeOf = Object.getPrototypeOf; // require('getprototypeof');
if (hasToStringTag && gOPD && getPrototypeOf) {
	forEach(typedArrays, function (typedArray) {
		if (typeof global[typedArray] === 'function') {
			var arr = new global[typedArray]();
			if (!(Symbol.toStringTag in arr)) {
				throw new EvalError('this engine has support for Symbol.toStringTag, but ' + typedArray + ' does not have the property! Please report this.');
			}
			var proto = getPrototypeOf(arr);
			var descriptor = gOPD(proto, Symbol.toStringTag);
			if (!descriptor) {
				var superProto = getPrototypeOf(proto);
				descriptor = gOPD(superProto, Symbol.toStringTag);
			}
			toStrTags[typedArray] = descriptor.get;
		}
	});
}

var tryTypedArrays = function tryAllTypedArrays(value) {
	var foundName = false;
	forEach(toStrTags, function (getter, typedArray) {
		if (!foundName) {
			try {
				var name = getter.call(value);
				if (name === typedArray) {
					foundName = name;
				}
			} catch (e) {}
		}
	});
	return foundName;
};

var isTypedArray = require('is-typed-array');

module.exports = function whichTypedArray(value) {
	if (!isTypedArray(value)) { return false; }
	if (!hasToStringTag) { return $slice($toString(value), 8, -1); }
	return tryTypedArrays(value);
};

}).call(this)}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"available-typed-arrays":131,"call-bind/callBound":146,"es-abstract/helpers/getOwnPropertyDescriptor":161,"foreach":163,"has-symbols":167,"is-typed-array":184}],259:[function(require,module,exports){
module.exports={
  "version": "8.1.0"
}
},{}],260:[function(require,module,exports){
/**
 * @license Copyright 2017 The Lighthouse Authors. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.
 */
'use strict';

const htmlReportAssets = require('./report-assets.js');

class ReportGenerator {
  /**
   * Replaces all the specified strings in source without serial replacements.
   * @param {string} source
   * @param {!Array<{search: string, replacement: string}>} replacements
   * @return {string}
   */
  static replaceStrings(source, replacements) {
    if (replacements.length === 0) {
      return source;
    }

    const firstReplacement = replacements[0];
    const nextReplacements = replacements.slice(1);
    return source
        .split(firstReplacement.search)
        .map(part => ReportGenerator.replaceStrings(part, nextReplacements))
        .join(firstReplacement.replacement);
  }

  /**
   * Returns the report HTML as a string with the report JSON and renderer JS inlined.
   * @param {LH.Result} lhr
   * @return {string}
   */
  static generateReportHtml(lhr) {
    const sanitizedJson = JSON.stringify(lhr)
      .replace(/</g, '\\u003c') // replaces opening script tags
      .replace(/\u2028/g, '\\u2028') // replaces line separators ()
      .replace(/\u2029/g, '\\u2029'); // replaces paragraph separators

    return ReportGenerator.replaceStrings(htmlReportAssets.REPORT_TEMPLATE, [
      {search: '%%LIGHTHOUSE_JSON%%', replacement: sanitizedJson},
      {search: '%%LIGHTHOUSE_JAVASCRIPT%%', replacement: htmlReportAssets.REPORT_JAVASCRIPT},
      {search: '/*%%LIGHTHOUSE_CSS%%*/', replacement: htmlReportAssets.REPORT_CSS},
      {search: '%%LIGHTHOUSE_TEMPLATES%%', replacement: htmlReportAssets.REPORT_TEMPLATES},
    ]);
  }

  /**
   * Converts the results to a CSV formatted string
   * Each row describes the result of 1 audit with
   *  - the name of the category the audit belongs to
   *  - the name of the audit
   *  - a description of the audit
   *  - the score type that is used for the audit
   *  - the score value of the audit
   *
   * @param {LH.Result} lhr
   * @return {string}
   */
  static generateReportCSV(lhr) {
    // To keep things "official" we follow the CSV specification (RFC4180)
    // The document describes how to deal with escaping commas and quotes etc.
    const CRLF = '\r\n';
    const separator = ',';
    /** @param {string} value @return {string} */
    const escape = value => `"${value.replace(/"/g, '""')}"`;
    /** @param {Array<string | number>} row @return {string[]} */
    const rowFormatter = row => row.map(value => value.toString()).map(escape);

    // Possible TODO: tightly couple headers and row values
    const header = ['requestedUrl', 'finalUrl', 'category', 'name', 'title', 'type', 'score'];
    const table = Object.keys(lhr.categories).map(categoryId => {
      const rows = [];
      const category = lhr.categories[categoryId];
      const overallCategoryScore = category.score === null ? -1 : category.score;
      rows.push(rowFormatter([lhr.requestedUrl, lhr.finalUrl, category.title,
        `${categoryId}-score`, `Overall ${category.title} Category Score`, 'numeric',
        overallCategoryScore]));
      return rows.concat(category.auditRefs.map(auditRef => {
        const audit = lhr.audits[auditRef.id];
        // CSV validator wants all scores to be numeric, use -1 for now
        const numericScore = audit.score === null ? -1 : audit.score;
        return rowFormatter([lhr.requestedUrl, lhr.finalUrl, category.title, audit.id, audit.title,
          audit.scoreDisplayMode, numericScore]);
      }));
    });

    return [header].concat(...table)
      .map(row => row.join(separator)).join(CRLF);
  }

  /**
   * Creates the results output in a format based on the `mode`.
   * @param {LH.Result} lhr
   * @param {LH.Config.Settings['output']} outputModes
   * @return {string|string[]}
   */
  static generateReport(lhr, outputModes) {
    const outputAsArray = Array.isArray(outputModes);
    if (typeof outputModes === 'string') outputModes = [outputModes];

    const output = outputModes.map(outputMode => {
      // HTML report.
      if (outputMode === 'html') {
        return ReportGenerator.generateReportHtml(lhr);
      }
      // CSV report.
      if (outputMode === 'csv') {
        return ReportGenerator.generateReportCSV(lhr);
      }
      // JSON report.
      if (outputMode === 'json') {
        return JSON.stringify(lhr, null, 2);
      }

      throw new Error('Invalid output mode: ' + outputMode);
    });

    return outputAsArray ? output : output[0];
  }
}

module.exports = ReportGenerator;

},{"./report-assets.js":144}],261:[function(require,module,exports){
(function (__dirname){(function (){
/**
 * @license Copyright 2021 The Lighthouse Authors. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.
 */
'use strict';

module.exports.LH_ROOT = __dirname;

}).call(this)}).call(this,"/")
},{}],262:[function(require,module,exports){
module.exports={
  "npm":{
    "@angular/core":[
      {"id":"SNYK-JS-ANGULARCORE-1070902","severity":"low","semver":{"vulnerable":["<11.0.5",">=11.1.0-next.0 <11.1.0-next.3"]}}
    ],
    "angular":[
      {"id":"SNYK-JS-ANGULAR-572020","severity":"high","semver":{"vulnerable":["<1.8.0"]}},
      {"id":"SNYK-JS-ANGULAR-570058","severity":"medium","semver":{"vulnerable":["<1.8.0"]}},
      {"id":"SNYK-JS-ANGULAR-534884","severity":"high","semver":{"vulnerable":[">=1.4.0-beta.6 <1.7.9"]}},
      {"id":"SNYK-JS-ANGULAR-471885","severity":"medium","semver":{"vulnerable":["<1.6.3"]}},
      {"id":"SNYK-JS-ANGULAR-471882","severity":"medium","semver":{"vulnerable":["<1.6.5"]}},
      {"id":"SNYK-JS-ANGULAR-471879","severity":"medium","semver":{"vulnerable":["<1.6.0-rc.0"]}},
      {"id":"npm:angular:20180202","severity":"medium","semver":{"vulnerable":["<1.6.9"]}},
      {"id":"npm:angular:20171018","severity":"medium","semver":{"vulnerable":["<1.6.7"]}},
      {"id":"npm:angular:20160527","severity":"medium","semver":{"vulnerable":[">=1.0.0 <1.2.30"]}},
      {"id":"npm:angular:20160122","severity":"medium","semver":{"vulnerable":[">=1.3.0 <1.5.0-rc.2"]}},
      {"id":"npm:angular:20140608","severity":"low","semver":{"vulnerable":["<1.3.0"]}},
      {"id":"npm:angular:20131113","severity":"high","semver":{"vulnerable":["<1.2.2"]}},
      {"id":"npm:angular:20140908","severity":"medium","semver":{"vulnerable":["<1.3.0-rc.4"]}},
      {"id":"npm:angular:20161101","severity":"medium","semver":{"vulnerable":[">=1.5.0 <1.5.9"]}},
      {"id":"npm:angular:20150909","severity":"high","semver":{"vulnerable":["<1.5.0-beta.2"]}},
      {"id":"npm:angular:20151205","severity":"medium","semver":{"vulnerable":["<1.5.0-rc.0"]}},
      {"id":"npm:angular:20151130","severity":"medium","semver":{"vulnerable":["<1.4.10"]}},
      {"id":"npm:angular:20130622","severity":"medium","semver":{"vulnerable":[">=1.0.0 <1.2.0"]}},
      {"id":"npm:angular:20150807-1","severity":"medium","semver":{"vulnerable":[">=1.3.1 <1.5.0-beta.0"]}},
      {"id":"npm:angular:20150807","severity":"high","semver":{"vulnerable":[">=1.0.0 <1.5.0-beta.0"]}},
      {"id":"npm:angular:20150315","severity":"medium","semver":{"vulnerable":["<1.6.1"]}},
      {"id":"npm:angular:20150310","severity":"high","semver":{"vulnerable":["<1.4.0-beta.6"]}},
      {"id":"npm:angular:20141104","severity":"medium","semver":{"vulnerable":["<1.3.2"]}},
      {"id":"npm:angular:20130621","severity":"medium","semver":{"vulnerable":["<1.2.0"]}},
      {"id":"npm:angular:20140909","severity":"high","semver":{"vulnerable":[">=1.2.19 <1.2.24"]}},
      {"id":"npm:angular:20130625","severity":"high","semver":{"vulnerable":["<1.1.5"]}}
    ],
    "backbone":[
      {"id":"npm:backbone:20160523","severity":"medium","semver":{"vulnerable":["<0.1.2"]}},
      {"id":"npm:backbone:20110701","severity":"medium","semver":{"vulnerable":["<0.5.0"]}}
    ],
    "bootstrap":[
      {"id":"SNYK-JS-BOOTSTRAP-173700","severity":"medium","semver":{"vulnerable":["<3.4.1",">=4.0.0 <4.3.1"]}},
      {"id":"SNYK-JS-BOOTSTRAP-73560","severity":"medium","semver":{"vulnerable":[">=4.0.0 <4.1.2"]}},
      {"id":"SNYK-JS-BOOTSTRAP-72890","severity":"medium","semver":{"vulnerable":["<3.4.0"]}},
      {"id":"SNYK-JS-BOOTSTRAP-72889","severity":"medium","semver":{"vulnerable":["<3.4.0"]}},
      {"id":"npm:bootstrap:20180529","severity":"medium","semver":{"vulnerable":["<3.4.0",">=4.0.0 <4.1.2"]}},
      {"id":"npm:bootstrap:20160627","severity":"medium","semver":{"vulnerable":["<3.4.0",">=4.0.0-alpha <4.0.0-beta.2"]}},
      {"id":"npm:bootstrap:20120510","severity":"medium","semver":{"vulnerable":["<2.1.0"]}}
    ],
    "dojo":[
      {"id":"SNYK-JS-DOJO-559224","severity":"medium","semver":{"vulnerable":["<1.11.10",">=1.12.1 <1.12.8",">=1.13.0 <1.13.7",">=1.14.0 <1.14.6",">=1.15.0 <1.15.3",">=1.16.0 <1.16.2"]}},
      {"id":"SNYK-JS-DOJO-174934","severity":"medium","semver":{"vulnerable":[">=1.0.0 <1.0.3",">=1.1.0 <1.1.2",">=1.2.0 <1.2.4",">=1.3.0 <1.3.3",">=1.4.0 <1.4.2"]}},
      {"id":"SNYK-JS-DOJO-174933","severity":"medium","semver":{"vulnerable":["<1.2.0"]}},
      {"id":"SNYK-JS-DOJO-72305","severity":"medium","semver":{"vulnerable":[">=1.14.0-pre <1.14.0",">=1.13.0 <1.13.1",">=1.12.1 <1.12.4",">=1.11.0-rc1 <1.11.6","<1.10.10"]}},
      {"id":"npm:dojo:20180818","severity":"medium","semver":{"vulnerable":["<1.10.10",">=1.11.0 <1.11.6",">=1.12.0 <1.12.4",">=1.13.0 <1.13.1"]}},
      {"id":"npm:dojo:20100614-6","severity":"medium","semver":{"vulnerable":["<1.4.2"]}},
      {"id":"npm:dojo:20100614","severity":"medium","semver":{"vulnerable":[">=0.4.0 <0.4.4",">=1.0.0 <1.0.3",">=1.1.0 <1.1.2",">=1.2.0 <1.2.4",">=1.3.0 <1.3.3",">=1.4.0 <1.4.2"]}}
    ],
    "foundation-sites":[
      {"id":"npm:foundation-sites:20170802","severity":"medium","semver":{"vulnerable":["<6.0.0"]}},
      {"id":"npm:foundation-sites:20150619","severity":"medium","semver":{"vulnerable":["<5.5.3"]}},
      {"id":"npm:foundation-sites:20120717","severity":"medium","semver":{"vulnerable":[">=3.0.0 <3.0.6"]}}
    ],
    "google-closure-library":[
      {"id":"SNYK-JS-GOOGLECLOSURELIBRARY-561341","severity":"medium","semver":{"vulnerable":["<20200315.0.0"]}},
      {"id":"SNYK-JS-GOOGLECLOSURELIBRARY-174519","severity":"medium","semver":{"vulnerable":[">=20190121.0.0 <20190301.0.0"]}}
    ],
    "gsap":[
      {"id":"SNYK-JS-GSAP-1054614","severity":"high","semver":{"vulnerable":["<3.6.0"]}}
    ],
    "handlebars":[
      {"id":"SNYK-JS-HANDLEBARS-1279029","severity":"medium","semver":{"vulnerable":["<4.7.7"]}},
      {"id":"SNYK-JS-HANDLEBARS-1056767","severity":"medium","semver":{"vulnerable":["<4.7.7"]}},
      {"id":"SNYK-JS-HANDLEBARS-567742","severity":"medium","semver":{"vulnerable":["<4.6.0"]}},
      {"id":"SNYK-JS-HANDLEBARS-534988","severity":"high","semver":{"vulnerable":[">=4.0.0 <4.5.3","<3.0.8"]}},
      {"id":"SNYK-JS-HANDLEBARS-534478","severity":"high","semver":{"vulnerable":[">=4.0.0 <4.5.3","<3.0.8"]}},
      {"id":"SNYK-JS-HANDLEBARS-480388","severity":"high","semver":{"vulnerable":[">=4.0.0 <4.4.5"]}},
      {"id":"SNYK-JS-HANDLEBARS-469063","severity":"high","semver":{"vulnerable":[">=4.0.0 <4.3.0","<3.8.0"]}},
      {"id":"SNYK-JS-HANDLEBARS-174183","severity":"high","semver":{"vulnerable":[">=3.0.0 <3.0.7",">=4.1.0 <4.1.2",">=4.0.0 <4.0.14"]}},
      {"id":"SNYK-JS-HANDLEBARS-173692","severity":"high","semver":{"vulnerable":["<4.0.14",">=4.1.0 <4.1.2"]}},
      {"id":"npm:handlebars:20151207","severity":"medium","semver":{"vulnerable":["<4.0.0"]}},
      {"id":"npm:handlebars:20110425","severity":"medium","semver":{"vulnerable":["<=1.0.0-beta.3"]}}
    ],
    "highcharts":[
      {"id":"SNYK-JS-HIGHCHARTS-1290057","severity":"medium","semver":{"vulnerable":["<9.0.0"]}},
      {"id":"SNYK-JS-HIGHCHARTS-1018906","severity":"medium","semver":{"vulnerable":["<9.0.0"]}},
      {"id":"SNYK-JS-HIGHCHARTS-571995","severity":"high","semver":{"vulnerable":["<7.2.2",">=8.0.0 <8.1.1"]}},
      {"id":"npm:highcharts:20180225","severity":"high","semver":{"vulnerable":["<6.1.0"]}}
    ],
    "jquery":[
      {"id":"SNYK-JS-JQUERY-569619","severity":"medium","semver":{"vulnerable":["<1.9.0"]}},
      {"id":"SNYK-JS-JQUERY-567880","severity":"medium","semver":{"vulnerable":[">=1.2.0 <3.5.0"]}},
      {"id":"SNYK-JS-JQUERY-565129","severity":"medium","semver":{"vulnerable":[">=1.5.1 <3.5.0"]}},
      {"id":"SNYK-JS-JQUERY-174006","severity":"medium","semver":{"vulnerable":["<3.4.0"]}},
      {"id":"npm:jquery:20160529","severity":"low","semver":{"vulnerable":[">=3.0.0-rc1 <3.0.0"]}},
      {"id":"npm:jquery:20150627","severity":"medium","semver":{"vulnerable":["<1.12.2",">=1.12.3 <2.2.2",">=2.2.3 <3.0.0"]}},
      {"id":"npm:jquery:20140902","severity":"medium","semver":{"vulnerable":[">=1.4.2 <1.6.2"]}},
      {"id":"npm:jquery:20120206","severity":"medium","semver":{"vulnerable":["<1.9.1"]}},
      {"id":"npm:jquery:20110606","severity":"medium","semver":{"vulnerable":["<1.6.3"]}}
    ],
    "jquery-mobile":[
      {"id":"SNYK-JS-JQUERYMOBILE-174599","severity":"medium","semver":{"vulnerable":["<=1.5.0-alpha.1"]}},
      {"id":"npm:jquery-mobile:20120802","severity":"medium","semver":{"vulnerable":["<1.2.0"]}}
    ],
    "jquery-ui":[
      {"id":"npm:jquery-ui:20121127","severity":"medium","semver":{"vulnerable":["<1.10.0"]}},
      {"id":"npm:jquery-ui:20100903","severity":"medium","semver":{"vulnerable":["<1.10.0"]}},
      {"id":"npm:jquery-ui:20160721","severity":"high","semver":{"vulnerable":["<1.12.0"]}}
    ],
    "knockout":[
      {"id":"npm:knockout:20180213","severity":"medium","semver":{"vulnerable":["<3.5.0-beta"]}},
      {"id":"npm:knockout:20130701","severity":"medium","semver":{"vulnerable":[">=2.1.0-pre <3.0.0"]}}
    ],
    "lodash":[
      {"id":"SNYK-JS-LODASH-1040724","severity":"high","semver":{"vulnerable":["<4.17.21"]}},
      {"id":"SNYK-JS-LODASH-1018905","severity":"medium","semver":{"vulnerable":["<4.17.21"]}},
      {"id":"SNYK-JS-LODASH-608086","severity":"high","semver":{"vulnerable":["<4.17.17"]}},
      {"id":"SNYK-JS-LODASH-590103","severity":"high","semver":{"vulnerable":["<4.17.20"]}},
      {"id":"SNYK-JS-LODASH-567746","severity":"medium","semver":{"vulnerable":["<4.17.16"]}},
      {"id":"SNYK-JS-LODASH-450202","severity":"high","semver":{"vulnerable":["<4.17.12"]}},
      {"id":"SNYK-JS-LODASH-73639","severity":"medium","semver":{"vulnerable":["<4.17.11"]}},
      {"id":"SNYK-JS-LODASH-73638","severity":"high","semver":{"vulnerable":["<4.17.11"]}},
      {"id":"npm:lodash:20180130","severity":"medium","semver":{"vulnerable":["<4.17.5"]}}
    ],
    "moment":[
      {"id":"npm:moment:20170905","severity":"low","semver":{"vulnerable":["<2.19.3"]}},
      {"id":"npm:moment:20161019","severity":"medium","semver":{"vulnerable":["<2.15.2"]}},
      {"id":"npm:moment:20160126","severity":"medium","semver":{"vulnerable":["<2.11.2"]}}
    ],
    "mustache":[
      {"id":"npm:mustache:20151207","severity":"medium","semver":{"vulnerable":["<2.2.1"]}},
      {"id":"npm:mustache:20110814","severity":"medium","semver":{"vulnerable":["< 0.3.1"]}}
    ],
    "next":[
      {"id":"SNYK-JS-NEXT-1063481","severity":"medium","semver":{"vulnerable":[">=9.5.0 <9.5.4"]}},
      {"id":"SNYK-JS-NEXT-571938","severity":"high","semver":{"vulnerable":["<5.1.0"]}},
      {"id":"SNYK-JS-NEXT-561584","severity":"medium","semver":{"vulnerable":["<9.3.2"]}},
      {"id":"SNYK-JS-NEXT-174590","severity":"high","semver":{"vulnerable":["<2.4.1"]}},
      {"id":"SNYK-JS-NEXT-72454","severity":"medium","semver":{"vulnerable":[">=7.0.0 <7.0.2"]}},
      {"id":"npm:next:20180124","severity":"high","semver":{"vulnerable":["<4.2.3"]}},
      {"id":"npm:next:20170607","severity":"medium","semver":{"vulnerable":["<2.4.3"]}},
      {"id":"npm:next:20170601","severity":"high","semver":{"vulnerable":["<2.4.1",">=3.0.0-beta1 <3.0.0-beta7"]}}
    ],
    "react":[
      {"id":"npm:react:20150318","severity":"high","semver":{"vulnerable":[">=0.0.1 <0.14.0"]}},
      {"id":"npm:react:20131217","severity":"medium","semver":{"vulnerable":[">=0.5.0 <0.5.2",">=0.4.0 <0.4.2"]}}
    ],
    "riot":[
      {"id":"npm:riot:20131114","severity":"medium","semver":{"vulnerable":["<0.9.6"]}}
    ],
    "socket.io":[
      {"id":"SNYK-JS-SOCKETIO-1024859","severity":"medium","semver":{"vulnerable":["<2.4.0"]}},
      {"id":"npm:socket.io:20120417","severity":"medium","semver":{"vulnerable":["<0.9.6"]}},
      {"id":"npm:socket.io:20120323","severity":"medium","semver":{"vulnerable":["<0.9.7"]}}
    ],
    "three":[
      {"id":"SNYK-JS-THREE-1064931","severity":"high","semver":{"vulnerable":["<0.125.0"]}}
    ],
    "underscore":[
      {"id":"SNYK-JS-UNDERSCORE-1080984","severity":"medium","semver":{"vulnerable":[">=1.13.0-0 <1.13.0-2",">=1.3.2 <1.12.1"]}}
    ],
    "vue":[
      {"id":"npm:vue:20170829","severity":"medium","semver":{"vulnerable":["<2.4.3"]}},
      {"id":"npm:vue:20170401","severity":"medium","semver":{"vulnerable":["<2.3.0-beta.1"]}},
      {"id":"npm:vue:20180802","severity":"medium","semver":{"vulnerable":["<2.5.17"]}},
      {"id":"npm:vue:20180222","severity":"low","semver":{"vulnerable":["<2.5.14"]}}
    ],
    "yui":[
      {"id":"npm:yui:20130604","severity":"medium","semver":{"vulnerable":[">=3.0.0 <3.10.1","=3.10.2"]}},
      {"id":"npm:yui:20130515","severity":"medium","semver":{"vulnerable":["<3.10.0 >=3.0.0"]}},
      {"id":"npm:yui:20121030","severity":"medium","semver":{"vulnerable":["<3.0.0 >=2.4.0"]}},
      {"id":"npm:yui:20120428","severity":"medium","semver":{"vulnerable":["<3.5.1 >=3.5.0-PR1"]}},
      {"id":"npm:yui:20101025","severity":"medium","semver":{"vulnerable":["<2.8.2 >=2.4.0"]}}
    ]
  }
}
},{}],"lighthouse-plugin-publisher-ads/audits/ad-blocking-tasks":[function(require,module,exports){
(function (__filename){(function (){
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

const AdRequestTime = require('../computed/ad-request-time');
const i18n = require('lighthouse/lighthouse-core/lib/i18n/i18n');
const LongTasks = require('../computed/long-tasks');
const {auditNotApplicable} = require('../messages/common-strings');
const {Audit} = require('lighthouse');
const {getAttributableUrl} = require('../utils/tasks');
const {isAdScript} = require('../utils/resource-classification');
const {URL} = require('url');

const UIStrings = {
  /* Title of the audit */
  title: 'No long tasks blocking ad-related network requests',
  failureTitle: 'Avoid long tasks that block ad-related network requests',
  description: 'Tasks blocking the main thread can delay ad requests and cause ' +
  'a poor user experience. Consider removing long blocking tasks or moving ' +
  'them off of the main thread. These tasks can be especially detrimental to ' +
  'performance on less powerful devices. [Learn more](' +
  'https://developers.google.com/publisher-ads-audits/reference/audits/ad-blocking-tasks' +
  ').',
  failureDisplayValue: '{timeInMs, number, seconds} s blocked',
  columnScript: 'Attributable URL',
  columnStartTime: 'Start',
  columnDuration: 'Duration',
};

const str_ = i18n.createMessageInstanceIdFn(__filename, UIStrings);
/**
 * @typedef {Object} TaskDetails
 * @property {number} startTime
 * @property {number} endTime
 * @property {number} duration
 * @property {string} script
 * @property {string} rawUrl
 * @property {boolean} isTopLevel
 */

/**
 * Table headings for audits details sections.
 * @type {LH.Audit.Details.Table['headings']}
 */
const HEADINGS = [
  {
    key: 'script',
    itemType: 'url',
    text: str_(UIStrings.columnScript),
  },
  {
    key: 'startTime',
    itemType: 'ms',
    text: str_(UIStrings.columnStartTime),
    granularity: 1,
  },
  {
    key: 'duration',
    itemType: 'ms',
    text: str_(UIStrings.columnDuration),
    granularity: 1,
  },
];

/** @inheritDoc */
class AdBlockingTasks extends Audit {
  /**
   * @return {LH.Audit.Meta}
   * @override
   */
  static get meta() {
    return {
      id: 'ad-blocking-tasks',
      title: str_(UIStrings.title),
      failureTitle: str_(UIStrings.failureTitle),
      description: str_(UIStrings.description),
      requiredArtifacts: ['traces', 'devtoolsLogs'],
    };
  }

  /**
   * @param {LH.Artifacts} artifacts
   * @param {LH.Audit.Context} context
   * @return {Promise<LH.Audit.Product>}
   * @override
   */
  static async audit(artifacts, context) {
  /**
   * Threshold to show long tasks in the report. We don't show shorter long
   * tasks since they each have a smaller impact on blocking ads.
   */
    const LONG_TASK_DUR_MS =
      context.settings.throttlingMethod == 'simulate' ? 200 : 100;
    const trace = artifacts.traces[Audit.DEFAULT_PASS];
    const devtoolsLog = artifacts.devtoolsLogs[Audit.DEFAULT_PASS];
    const metricData = {trace, devtoolsLog, settings: context.settings};
    let longTasks = [];
    try {
      longTasks = await LongTasks.request(metricData, context);
    } catch (e) {
      return auditNotApplicable.InvalidTiming;
    }

    if (!longTasks.length) {
      return auditNotApplicable.NoTasks;
    }

    const {timing: endTime} =
        await AdRequestTime.request(metricData, context);

    if (!(endTime > 0)) { // Handle NaN, etc.
      return auditNotApplicable.NoAdRelatedReq;
    }

    /** @type {TaskDetails[]} */ const blocking = [];
    for (const longTask of longTasks) {
      if (longTask.startTime > endTime ||
          longTask.duration < LONG_TASK_DUR_MS) {
        continue;
      }
      const scriptUrl = getAttributableUrl(longTask);
      if (scriptUrl && isAdScript(new URL(scriptUrl))) {
        continue;
      }

      const url = scriptUrl && new URL(scriptUrl);
      const displayUrl = url && (url.origin + url.pathname) || 'Other';

      blocking.push({
        // TODO(warrengm): Format the display URL so it fits on one line
        script: displayUrl,
        rawUrl: scriptUrl,
        startTime: longTask.startTime,
        endTime: longTask.endTime,
        duration: longTask.duration,
        isTopLevel: !longTask.parent,
      });
    }

    let filteredBlocking = Array.from(blocking);
    const taskLimit = 10;
    if (filteredBlocking.length > taskLimit) {
      // For the sake of brevity, we show at most 10 long tasks. If needed we
      // will filter tasks that are less actionable (child tasks or ones missing
      // attributable URLs).
      filteredBlocking = blocking
          .filter((b) => b.script !== 'Other' && b.isTopLevel)
      // Only show the longest tasks.
          .sort((a, b) => b.duration - a.duration)
          .splice(0, taskLimit)
          .sort((a, b) => a.startTime - b.startTime);
    }

    const blockedTime = filteredBlocking.reduce(
      (sum, t) => t.isTopLevel ? sum + t.duration : sum, 0);
    const failed = filteredBlocking.length > 0;
    return {
      score: failed ? 0 : 1,
      numericValue: blockedTime,
      numericUnit: 'millisecond',
      displayValue: failed ?
        str_(UIStrings.failureDisplayValue, {timeInMs: blockedTime}) :
        '',
      details: AdBlockingTasks.makeTableDetails(HEADINGS, filteredBlocking),
    };
  }
}

module.exports = AdBlockingTasks;
module.exports.UIStrings = UIStrings;

}).call(this)}).call(this,"/node_modules/lighthouse-plugin-publisher-ads/audits/ad-blocking-tasks.js")
},{"../computed/ad-request-time":194,"../computed/long-tasks":196,"../messages/common-strings":198,"../utils/resource-classification":206,"../utils/tasks":207,"lighthouse":78,"lighthouse/lighthouse-core/lib/i18n/i18n":96,"url":"url"}],"lighthouse-plugin-publisher-ads/audits/ad-render-blocking-resources":[function(require,module,exports){
(function (__filename){(function (){
// Copyright 2019 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

const i18n = require('lighthouse/lighthouse-core/lib/i18n/i18n');
const NetworkRecords = require('lighthouse/lighthouse-core/computed/network-records');
// @ts-ignore
const {auditNotApplicable} = require('../messages/common-strings');
const {Audit} = require('lighthouse');
const {getTimingsByRecord} = require('../utils/network-timing');
const {isAdTag} = require('../utils/resource-classification');
const {URL} = require('url');

const UIStrings = {
  title: 'Minimal render-blocking resources found',
  failureTitle: 'Avoid render-blocking resources',
  description: 'Render-blocking resources slow down tag load times. Consider ' +
  'loading critical JS/CSS inline or loading scripts asynchronously or ' +
  'loading the tag earlier in the head. [Learn more](' +
  'https://developers.google.com/web/tools/lighthouse/audits/blocking-resources' +
  ').',
  failureDisplayValue: 'Up to {timeInMs, number, seconds} s tag load time ' +
  'improvement',
  columnUrl: 'Resource',
  columnStartTime: 'Start',
  columnDuration: 'Duration',
};

/** @typedef {LH.Artifacts.NetworkRequest} NetworkRequest */
/** @typedef {LH.Gatherer.Simulation.NodeTiming} NodeTiming */

const str_ = i18n.createMessageInstanceIdFn(__filename, UIStrings);

const THRESHOLD_MS = 100;

/**
 * Table headings for audits details sections.
 * @type {LH.Audit.Details.Table['headings']}
 */
const HEADINGS = [
  {
    key: 'url',
    itemType: 'url',
    text: str_(UIStrings.columnUrl),
  },
  {
    key: 'startTime',
    itemType: 'ms',
    text: str_(UIStrings.columnStartTime),
    granularity: 1,
  },
  {
    key: 'duration',
    itemType: 'ms',
    text: str_(UIStrings.columnDuration),
    granularity: 1,
  },
];

/** Audits for render blocking resources */
class AdRenderBlockingResources extends Audit {
  /**
   * @return {LH.Audit.Meta}
   * @override
   */
  static get meta() {
    return {
      id: 'ad-render-blocking-resources',
      title: str_(UIStrings.title),
      failureTitle: str_(UIStrings.failureTitle),
      scoreDisplayMode: 'binary',
      description: str_(UIStrings.description),
      requiredArtifacts:
          ['LinkElements', 'ScriptElements', 'devtoolsLogs', 'traces'],
    };
  }

  /**
   * @param {LH.Artifacts} artifacts
   * @param {LH.Audit.Context} context
   * @return {Promise<LH.Audit.Product>}
   */
  static async audit(artifacts, context) {
    const devtoolsLog = artifacts.devtoolsLogs[Audit.DEFAULT_PASS];
    const trace = artifacts.traces[Audit.DEFAULT_PASS];
    const networkRecords = await NetworkRecords.request(devtoolsLog, context);
    const tag = networkRecords.find((req) => isAdTag(new URL(req.url)));
    if (!tag) {
      return auditNotApplicable.NoTag;
    }

    /** @type {Map<NetworkRequest, NodeTiming>} */
    const timingsByRecord =
      await getTimingsByRecord(trace, devtoolsLog, context);

    // NOTE(warrengm): Ideally we would key be requestId here but LinkElements
    // don't have request IDs.
    /** @type {Set<string>} */
    const blockingElementUrls = new Set();
    for (const link of artifacts.LinkElements) {
      // TODO(warrengm): Check for media queries? Or is the network filter below
      // sufficient?
      if (link.href && link.rel == 'stylesheet') {
        // NOTE that href here is normalized to the URL that went over the wire.
        blockingElementUrls.add(link.href);
      }
    }
    for (const script of artifacts.ScriptElements) {
      if (script.src && !script.defer && !script.async) {
        blockingElementUrls.add(script.src);
      }
    }

    const blockingNetworkRecords = networkRecords
        // Don't fail on sync resources loaded after the tag. This includes sync
        // resources loaded inside of iframes.
        .filter((r) => r.endTime < tag.startTime)
        .filter((r) => r != tag.initiatorRequest)
        // Sanity check to filter out duplicate requests which were async. If
        // type != parser then the resource was dynamically added and is
        // therefore async (non-blocking).
        .filter((r) => r.initiator.type = 'parser')
        .filter((r) => blockingElementUrls.has(r.url));

    const tableView = blockingNetworkRecords
        .map((r) => Object.assign({url: r.url}, timingsByRecord.get(r)));

    tableView.sort((a, b) => a.endTime - b.endTime);

    const tagTime = timingsByRecord.get(tag) || {startTime: Infinity};
    // @ts-ignore
    const startTimes = tableView.map((r) => r.startTime);
    // @ts-ignore
    const endTimes = tableView.map((r) => r.endTime);

    const blockingStart = Math.min(...startTimes);
    const blockingEnd = Math.min(Math.max(...endTimes), tagTime.startTime);
    const opportunity = blockingEnd - blockingStart;
    let displayValue = '';
    if (tableView.length > 0 && opportunity > 0) {
      displayValue = str_(
        UIStrings.failureDisplayValue, {timeInMs: opportunity});
    }

    const failed = tableView.length > 0 && opportunity > THRESHOLD_MS;
    return {
      score: failed ? 0 : 1,
      numericValue: tableView.length,
      numericUnit: 'unitless',
      displayValue,
      details: {
        opportunity,
        ...AdRenderBlockingResources.makeTableDetails(HEADINGS, tableView),
      },
    };
  }
}

module.exports = AdRenderBlockingResources;
module.exports.UIStrings = UIStrings;

}).call(this)}).call(this,"/node_modules/lighthouse-plugin-publisher-ads/audits/ad-render-blocking-resources.js")
},{"../messages/common-strings":198,"../utils/network-timing":204,"../utils/resource-classification":206,"lighthouse":78,"lighthouse/lighthouse-core/computed/network-records":40,"lighthouse/lighthouse-core/lib/i18n/i18n":96,"url":"url"}],"lighthouse-plugin-publisher-ads/audits/ad-request-critical-path":[function(require,module,exports){
(function (__filename){(function (){
// Copyright 2018 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

const ComputedAdRequestTime = require('../computed/ad-request-time');
const i18n = require('lighthouse/lighthouse-core/lib/i18n/i18n');
const {auditNotApplicable} = require('../messages/common-strings');
const {Audit} = require('lighthouse');
const {computeAdRequestWaterfall} = require('../utils/graph');

/** @typedef {LH.Gatherer.Simulation.NodeTiming} NodeTiming */
/** @typedef {import('../utils/graph').SimpleRequest} SimpleRequest */

const UIStrings = {
  title: 'Ad request waterfall',
  failureTitle: 'Reduce critical path for ad loading',
  description: 'Consider reducing the number of resources, loading multiple ' +
  'resources simultaneously, or loading resources earlier to improve ad ' +
  'speed. Requests that block ad loading can be found below. [Learn more](' +
  'https://developers.google.com/publisher-ads-audits/reference/audits/ad-request-critical-path' +
  ').',
  displayValue: '{serialResources, plural, =1 {1 serial resource} other {# serial resources}}',
  columnUrl: 'Request',
  columnType: 'Type',
  columnStartTime: 'Start',
  columnEndTime: 'End',
};

const str_ = i18n.createMessageInstanceIdFn(__filename, UIStrings);

/**
 * Table headings for audits details sections.
 * @type {LH.Audit.Details.Table['headings']}
 */
const HEADINGS = [
  {
    key: 'nameOrTld',
    itemType: 'text',
    text: str_(UIStrings.columnType),
  },
  {
    key: 'url',
    itemType: 'url',
    text: str_(UIStrings.columnUrl),
  },
  {
    key: 'startTime',
    itemType: 'ms',
    text: str_(UIStrings.columnStartTime),
    granularity: 1,
  },
  {
    key: 'endTime',
    itemType: 'ms',
    text: str_(UIStrings.columnEndTime),
    granularity: 1,
  },
];

/**
 * Computes the depth of the loading graph by comparing timings.
 * @param {SimpleRequest[]} requests
 * @return {number}
 */
function computeDepth(requests) {
  let prevEnd = 0;
  let hops = 0;
  for (const {startTime, endTime} of requests) {
    if (startTime > prevEnd) {
      ++hops;
      prevEnd = endTime;
    } else {
      prevEnd = Math.min(prevEnd, endTime);
    }
  }
  return hops;
}

const MINIMUM_NOTEWORTHY_IDLE_GAP_MS = 150;

/**
 * Computes idle times in the network loading graph
 * @param {SimpleRequest[]} blockingRequests A list of request that appear in
 *     the ad loading graph.
 * @return {number[]} List of idle durations.
 */
function computeIdleTimes(blockingRequests) {
  let maxEndSoFar = Infinity;
  const idleTimes = [];
  for (let i = 0; i < blockingRequests.length;) {
    const {startTime, endTime} = blockingRequests[i];
    if (startTime - maxEndSoFar > MINIMUM_NOTEWORTHY_IDLE_GAP_MS) {
      idleTimes.push(startTime - maxEndSoFar);
    }

    maxEndSoFar = endTime;
    while (++i < blockingRequests.length &&
        blockingRequests[i].startTime < maxEndSoFar) {
      maxEndSoFar = Math.max(maxEndSoFar, blockingRequests[i].endTime);
    }
  }
  return idleTimes;
}

/**
 * Audit to check the length of the critical path to load ads.
 * Also determines the critical path for visualization purposes.
 */
class AdRequestCriticalPath extends Audit {
  /**
   * @return {LH.Audit.Meta}
   * @override
   */
  static get meta() {
    return {
      id: 'ad-request-critical-path',
      title: str_(UIStrings.title),
      failureTitle: str_(UIStrings.failureTitle),
      description: str_(UIStrings.description),
      scoreDisplayMode: 'informative',
      requiredArtifacts: ['devtoolsLogs', 'traces'],
    };
  }

  /**
   * @param {LH.Artifacts} artifacts
   * @param {LH.Audit.Context} context
   * @return {Promise<LH.Audit.Product>}
   */
  static async audit(artifacts, context) {
    const trace = artifacts.traces[Audit.DEFAULT_PASS];
    const devtoolsLog = artifacts.devtoolsLogs[Audit.DEFAULT_PASS];
    const metricData = {trace, devtoolsLog, settings: context.settings};

    const adRequestTime =
      await ComputedAdRequestTime.request(metricData, context);

    const tableView =
      (await computeAdRequestWaterfall(trace, devtoolsLog, context))
          .filter((r) => r.startTime > 0 && r.startTime < r.endTime
          && r.endTime < adRequestTime.timing,
          );
    if (!tableView.length) {
      return auditNotApplicable.NoAds;
    }
    const depth = computeDepth(tableView);
    const failed = depth > 3;

    for (const row of tableView) {
      delete row.record; // Remove circular references before serialization.
    }

    const idleTimes = computeIdleTimes(tableView);
    const maxIdleTime = Math.max(...idleTimes);
    const totalIdleTime = idleTimes.reduce((total, time) => total + time, 0);

    return {
      numericValue: depth,
      numericUnit: 'unitless',
      score: failed ? 0 : 1,
      displayValue: str_(UIStrings.displayValue, {serialResources: depth}),
      details: {
        size: tableView.length,
        depth,
        maxIdleTime,
        totalIdleTime,
        ...AdRequestCriticalPath.makeTableDetails(HEADINGS, tableView),
      },
    };
  }
}

module.exports = AdRequestCriticalPath;
module.exports.UIStrings = UIStrings;

}).call(this)}).call(this,"/node_modules/lighthouse-plugin-publisher-ads/audits/ad-request-critical-path.js")
},{"../computed/ad-request-time":194,"../messages/common-strings":198,"../utils/graph":203,"lighthouse":78,"lighthouse/lighthouse-core/lib/i18n/i18n":96}],"lighthouse-plugin-publisher-ads/audits/ad-request-from-page-start":[function(require,module,exports){
(function (__filename){(function (){
// Copyright 2018 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

const ComputedAdRequestTime = require('../computed/ad-request-time');
const i18n = require('lighthouse/lighthouse-core/lib/i18n/i18n');
const {auditNotApplicable, runWarning} = require('../messages/common-strings');
const {Audit} = require('lighthouse');

const UIStrings = {
  title: 'First ad request time',
  failureTitle: 'Reduce time to send the first ad request',
  description: 'This metric measures the elapsed time from the start of page ' +
  'load until the first ad request is made. Delayed ad requests will ' +
  'decrease impressions and viewability, and have a negative impact on ad ' +
  'revenue. [Learn more](' +
  'https://developers.google.com/publisher-ads-audits/reference/audits/ad-request-from-page-start' +
  ').',
  displayValue: '{timeInMs, number, seconds} s',
};

const str_ = i18n.createMessageInstanceIdFn(__filename, UIStrings);

/**
 * Audit to determine time for first ad request relative to page start.
 */
class AdRequestFromPageStart extends Audit {
  /**
   * @return {LH.Audit.Meta}
   * @override
   */
  static get meta() {
    return {
      id: 'ad-request-from-page-start',
      title: str_(UIStrings.title),
      failureTitle: str_(UIStrings.failureTitle),
      description: str_(UIStrings.description),
      // @ts-ignore
      scoreDisplayMode: Audit.SCORING_MODES.NUMERIC,
      requiredArtifacts: ['devtoolsLogs', 'traces'],
    };
  }
  /**
   * @return {{
    *  simulate: LH.Audit.ScoreOptions, provided: LH.Audit.ScoreOptions
    * }}
    */
  static get defaultOptions() {
    return {
      simulate: {
        p10: 6500,
        median: 10000,
      },
      provided: {
        p10: 1900,
        median: 3500,
      },
    };
  }

  /**
   * @param {LH.Artifacts} artifacts
   * @param {LH.Audit.Context} context
   * @return {Promise<LH.Audit.Product>}
   */
  static async audit(artifacts, context) {
    const trace = artifacts.traces[Audit.DEFAULT_PASS];
    const devtoolsLog = artifacts.devtoolsLogs[Audit.DEFAULT_PASS];
    const metricData = {trace, devtoolsLog, settings: context.settings};
    const scoreOptions = context.options[
        context.settings.throttlingMethod == 'provided' ?
          'provided' :
          'simulate'
    ];

    const {timing} = await ComputedAdRequestTime.request(metricData, context);
    if (!(timing > 0)) { // Handle NaN, etc.
      const naAuditProduct = auditNotApplicable.NoAds;
      naAuditProduct.runWarnings = [runWarning.NoAds];
      return naAuditProduct;
    }

    return {
      numericValue: timing,
      numericUnit: 'millisecond',
      score: Audit.computeLogNormalScore(
        scoreOptions,
        timing,
      ),
      displayValue: str_(UIStrings.displayValue, {timeInMs: timing}),
    };
  }
}

module.exports = AdRequestFromPageStart;
module.exports.UIStrings = UIStrings;

}).call(this)}).call(this,"/node_modules/lighthouse-plugin-publisher-ads/audits/ad-request-from-page-start.js")
},{"../computed/ad-request-time":194,"../messages/common-strings":198,"lighthouse":78,"lighthouse/lighthouse-core/lib/i18n/i18n":96}],"lighthouse-plugin-publisher-ads/audits/ad-top-of-viewport":[function(require,module,exports){
(function (__filename){(function (){
// Copyright 2018 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

const i18n = require('lighthouse/lighthouse-core/lib/i18n/i18n');
const {auditNotApplicable} = require('../messages/common-strings');
const {Audit} = require('lighthouse');
const {isAdIframe} = require('../utils/resource-classification');

const UIStrings = {
  title: 'No ad found at the very top of the viewport',
  failureTitle: 'Move the top ad further down the page',
  description: 'Over 10% of ads are never viewed because users scroll past ' +
  'them before they become viewable. By moving ad slots away from the very ' +
  'top of the viewport, users are more likely to see ads before scrolling ' +
  'away. [Learn more](' +
  'https://developers.google.com/publisher-ads-audits/reference/audits/ad-top-of-viewport' +
  ').',
  failureDisplayValue: 'A scroll of {valueInPx, number} px would hide half of your topmost ad',
  columnSlot: 'Top Slot ID',
};

const str_ = i18n.createMessageInstanceIdFn(__filename, UIStrings);


const SCROLL_PX_THRESHOLD = 100;

/**
 * Table headings for audits details sections.
 * @type {LH.Audit.Details.Table['headings']}
 */
const HEADINGS = [
  {key: 'slot', itemType: 'text', text: str_(UIStrings.columnSlot)},
];


/** @inheritDoc */
class AdTopOfViewport extends Audit {
  /**
   * @return {AuditMetadata}
   * @override
   */
  static get meta() {
    return {
      id: 'ad-top-of-viewport',
      title: str_(UIStrings.title),
      failureTitle: str_(UIStrings.failureTitle),
      description: str_(UIStrings.description),
      requiredArtifacts: ['ViewportDimensions', 'IFrameElements'],
    };
  }

  /**
   * @override
   * @param {Artifacts} artifacts
   * @return {LH.Audit.Product}
   */
  static audit(artifacts) {
    const viewport = artifacts.ViewportDimensions;
    const slots = artifacts.IFrameElements.filter(isAdIframe)
        .filter((slot) =>
          slot.clientRect.width * slot.clientRect.height > 1
          && !slot.isPositionFixed)
        .map((slot) => ({
          midpoint: slot.clientRect.top + slot.clientRect.height / 2,
          id: slot.id,
        }));

    if (!slots.length) {
      return auditNotApplicable.NoVisibleSlots;
    }

    const topSlot = slots.reduce((a, b) => (a.midpoint < b.midpoint) ? a : b);

    const inViewport = topSlot.midpoint < viewport.innerHeight;

    if (!inViewport) {
      return auditNotApplicable.NoAdsViewport;
    }

    const score = inViewport && topSlot.midpoint < SCROLL_PX_THRESHOLD ? 0 : 1;

    return {
      score,
      numericValue: topSlot.midpoint,
      numericUnit: 'unitless',
      // No displayValue if passing, no changes to be made.
      displayValue: score ? '' :
        str_(UIStrings.failureDisplayValue, {valueInPx: topSlot.midpoint}),
      details: AdTopOfViewport.makeTableDetails(
        HEADINGS,
        score ? [] : [{slot: topSlot.id}],
      ),
    };
  }
}

module.exports = AdTopOfViewport;
module.exports.UIStrings = UIStrings;

}).call(this)}).call(this,"/node_modules/lighthouse-plugin-publisher-ads/audits/ad-top-of-viewport.js")
},{"../messages/common-strings":198,"../utils/resource-classification":206,"lighthouse":78,"lighthouse/lighthouse-core/lib/i18n/i18n":96}],"lighthouse-plugin-publisher-ads/audits/ads-in-viewport":[function(require,module,exports){
(function (__filename){(function (){
// Copyright 2018 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

const {auditNotApplicable} = require('../messages/common-strings');
const {Audit} = require('lighthouse');

const i18n = require('lighthouse/lighthouse-core/lib/i18n/i18n');
const {isBoxInViewport} = require('../utils/geometry');
const {isGptIframe} = require('../utils/resource-classification');

const UIStrings = {
  title: 'Few or no ads loaded outside viewport',
  failureTitle: 'Avoid loading ads until they are nearly on-screen',
  description: 'Too many ads loaded outside the viewport lowers viewability ' +
  'rates and impacts user experience. Consider loading ads below the fold ' +
  'lazily as the user scrolls down. Consider using GPT\'s [Lazy Loading API](' +
  'https://developers.google.com/doubleclick-gpt/reference#googletag.PubAdsService_enableLazyLoad' +
  '). [Learn more](' +
  'https://developers.google.com/publisher-ads-audits/reference/audits/ads-in-viewport' +
  ').',
  failureDisplayValue: '{hiddenAds, plural, =1 {1 ad} ' +
  'other {# ads}} out of view',
  columnSlot: 'Slots Outside Viewport',
};

const str_ = i18n.createMessageInstanceIdFn(__filename, UIStrings);

/**
 * Table headings for audits details sections.
 * @type {LH.Audit.Details.Table['headings']}
 */
const HEADINGS = [
  {key: 'slot', itemType: 'text', text: str_(UIStrings.columnSlot)},
];

/** @inheritDoc */
class AdsInViewport extends Audit {
  /**
   * @return {AuditMetadata}
   * @override
   */
  static get meta() {
    return {
      id: 'ads-in-viewport',
      title: str_(UIStrings.title),
      failureTitle: str_(UIStrings.failureTitle),
      description: str_(UIStrings.description),
      requiredArtifacts: ['ViewportDimensions', 'IFrameElements'],
    };
  }

  /**
   * @param {Artifacts} artifacts
   * @return {LH.Audit.Product}
   */
  static audit(artifacts) {
    const viewport = artifacts.ViewportDimensions;
    const slots = artifacts.IFrameElements
        .filter((iframe) => isGptIframe(iframe) &&
          iframe.clientRect.height * iframe.clientRect.width > 1);

    if (!slots.length) {
      return auditNotApplicable.NoVisibleSlots;
    }

    /** @type {Array<{slot: string}>} */
    const nonvisible = slots
        .filter((slot) => !isBoxInViewport(slot.clientRect, viewport))
        .map((slot) => ({slot: slot.id}))
        .sort((a, b) => a.slot.localeCompare(b.slot));

    const visibleCount = slots.length - nonvisible.length;

    return {
      numericValue: visibleCount / slots.length,
      numericUnit: 'unitless',
      score: nonvisible.length > 3 ? 0 : 1,
      displayValue: nonvisible.length ?
        str_(UIStrings.failureDisplayValue, {hiddenAds: nonvisible.length}) :
        '',
      details: AdsInViewport.makeTableDetails(HEADINGS, nonvisible),
    };
  }
}

module.exports = AdsInViewport;
module.exports.UIStrings = UIStrings;

}).call(this)}).call(this,"/node_modules/lighthouse-plugin-publisher-ads/audits/ads-in-viewport.js")
},{"../messages/common-strings":198,"../utils/geometry":202,"../utils/resource-classification":206,"lighthouse":78,"lighthouse/lighthouse-core/lib/i18n/i18n":96}],"lighthouse-plugin-publisher-ads/audits/async-ad-tags":[function(require,module,exports){
(function (__filename){(function (){
// Copyright 2018 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

const array = require('../utils/array.js');
const i18n = require('lighthouse/lighthouse-core/lib/i18n/i18n');
// @ts-ignore
const MainResource = require('lighthouse/lighthouse-core/computed/main-resource');
const NetworkRecords = require('lighthouse/lighthouse-core/computed/network-records');
const {auditNotApplicable} = require('../messages/common-strings');
const {Audit} = require('lighthouse');
const {isAdTag, isStaticRequest} = require('../utils/resource-classification');
const {URL} = require('url');

const UIStrings = {
  title: 'Ad tag is loaded asynchronously',
  failureTitle: 'Load ad tag asynchronously',
  description: 'Loading the ad tag synchronously blocks content rendering ' +
  'until the tag is fetched and loaded. Consider using the `async` attribute ' +
  'to load gpt.js and/or adsbygoogle.js asynchronously. [Learn more](' +
  'https://developers.google.com/publisher-ads-audits/reference/audits/async-ad-tags' +
  ').',
};

const str_ = i18n.createMessageInstanceIdFn(__filename, UIStrings);
/**
 * @param {LH.Artifacts.NetworkRequest} tagReq
 * @return {boolean}
 */
function isAsync(tagReq) {
  // Use request priority as proxy to determine if script tag is asynchronous.
  // See https://bugs.chromium.org/p/chromium/issues/detail?id=408229.
  // If preload, priority will be `High`, assume async in that case.
  // TODO(jburger): Properly handle preload && !async case.
  return tagReq.priority == 'Low' || isStaticRequest(tagReq);
}

/** @inheritDoc */
class AsyncAdTags extends Audit {
  /**
   * @return {LH.Audit.Meta}
   * @override
   */
  static get meta() {
    return {
      id: 'async-ad-tags',
      title: str_(UIStrings.title),
      failureTitle: str_(UIStrings.failureTitle),
      description: str_(UIStrings.description),
      requiredArtifacts: ['devtoolsLogs', 'URL'],
    };
  }

  /**
   * @param {LH.Artifacts} artifacts
   * @param {LH.Audit.Context} context
   * @return {Promise<LH.Audit.Product>}
   */
  static async audit(artifacts, context) {
    const devtoolsLog = artifacts.devtoolsLogs[Audit.DEFAULT_PASS];
    const networkRecords = await NetworkRecords.request(devtoolsLog, context);
    const mainResource =
        await MainResource.request({URL: artifacts.URL, devtoolsLog}, context);
    const tagReqs = networkRecords
        .filter((req) => isAdTag(new URL(req.url)))
        .filter((req) => req.frameId === mainResource.frameId);

    if (!tagReqs.length) {
      return auditNotApplicable.NoTag;
    }

    const numSync = array.count(tagReqs, isAsync) - tagReqs.length;
    const passed = (numSync === 0);
    return {
      score: Number(passed),
      numericValue: numSync,
      numericUnit: 'unitless',
    };
  }
}

module.exports = AsyncAdTags;
module.exports.UIStrings = UIStrings;

}).call(this)}).call(this,"/node_modules/lighthouse-plugin-publisher-ads/audits/async-ad-tags.js")
},{"../messages/common-strings":198,"../utils/array.js":199,"../utils/resource-classification":206,"lighthouse":78,"lighthouse/lighthouse-core/computed/main-resource":14,"lighthouse/lighthouse-core/computed/network-records":40,"lighthouse/lighthouse-core/lib/i18n/i18n":96,"url":"url"}],"lighthouse-plugin-publisher-ads/audits/bid-request-from-page-start":[function(require,module,exports){
(function (__filename){(function (){
// Copyright 2019 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

const ComputedBidRequestTime = require('../computed/bid-request-time');
const i18n = require('lighthouse/lighthouse-core/lib/i18n/i18n');
const {auditNotApplicable} = require('../messages/common-strings');
const {Audit} = require('lighthouse');

const UIStrings = {
  title: 'First bid request time',
  failureTitle: 'Reduce time to send the first bid request',
  description: 'This metric measures the elapsed time from the start of page ' +
  'load until the first bid request is made. Delayed bid requests will ' +
  'decrease impressions and viewability, and have a negative impact on ad ' +
  'revenue. [Learn More](' +
  'https://developers.google.com/publisher-ads-audits/reference/audits/bid-request-from-page-start' +
  ').',
  displayValue: '{timeInMs, number, seconds} s',
};

const str_ = i18n.createMessageInstanceIdFn(__filename, UIStrings);

/**
 * Audit to determine time for first ad request relative to page start.
 */
class BidRequestFromPageStart extends Audit {
  /**
   * @return {LH.Audit.Meta}
   * @override
   */
  static get meta() {
    return {
      id: 'bid-request-from-page-start',
      title: str_(UIStrings.title),
      failureTitle: str_(UIStrings.failureTitle),
      description: str_(UIStrings.description),
      // @ts-ignore
      scoreDisplayMode: Audit.SCORING_MODES.NUMERIC,
      requiredArtifacts: ['devtoolsLogs', 'traces'],
    };
  }

  /**
   * @return {{
    *  simulate: LH.Audit.ScoreOptions, provided: LH.Audit.ScoreOptions
    * }}
    */
  static get defaultOptions() {
    return {
      simulate: {
        p10: 4350,
        median: 8000,
      },
      provided: {
        p10: 1200,
        median: 2000,
      },
    };
  }

  /**
   * @param {LH.Artifacts} artifacts
   * @param {LH.Audit.Context} context
   * @return {Promise<LH.Audit.Product>}
   */
  static async audit(artifacts, context) {
    const trace = artifacts.traces[Audit.DEFAULT_PASS];
    const devtoolsLog = artifacts.devtoolsLogs[Audit.DEFAULT_PASS];
    const metricData = {trace, devtoolsLog, settings: context.settings};
    const scoreOptions = context.options[
        context.settings.throttlingMethod == 'provided' ?
          'provided' :
          'simulate'
    ];

    const {timing} = await ComputedBidRequestTime.request(metricData, context);
    if (!(timing > 0)) { // Handle NaN, etc.
      return auditNotApplicable.NoBids;
    }

    return {
      numericValue: timing,
      numericUnit: 'millisecond',
      score: Audit.computeLogNormalScore(
        scoreOptions,
        timing,
      ),
      displayValue: str_(UIStrings.displayValue, {timeInMs: timing}),
    };
  }
}

module.exports = BidRequestFromPageStart;
module.exports.UIStrings = UIStrings;

}).call(this)}).call(this,"/node_modules/lighthouse-plugin-publisher-ads/audits/bid-request-from-page-start.js")
},{"../computed/bid-request-time":195,"../messages/common-strings":198,"lighthouse":78,"lighthouse/lighthouse-core/lib/i18n/i18n":96}],"lighthouse-plugin-publisher-ads/audits/blocking-load-events":[function(require,module,exports){
(function (__filename){(function (){
// Copyright 2019 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

const i18n = require('lighthouse/lighthouse-core/lib/i18n/i18n');
const NetworkRecords = require('lighthouse/lighthouse-core/computed/network-records');
// @ts-ignore
const TraceOfTab = require('lighthouse/lighthouse-core/computed/trace-of-tab');
const {auditNotApplicable} = require('../messages/common-strings');
const {Audit} = require('lighthouse');
const {computeAdRequestWaterfall} = require('../utils/graph');
const {getTimingsByRecord} = require('../utils/network-timing');

/** @typedef {LH.Artifacts.NetworkRequest} NetworkRequest */
/** @typedef {LH.Gatherer.Simulation.NodeTiming} NodeTiming */

const UIStrings = {
  title: 'Ads not blocked by load events',
  failureTitle: 'Avoid waiting on load events',
  description: 'Waiting on load events increases ad latency. ' +
    'To speed up ads, eliminate the following load event handlers. ' +
    '[Learn More](' +
    'https://developers.google.com/publisher-ads-audits/reference/audits/blocking-load-events' +
    ').',
  displayValue: '{timeInMs, number, seconds} s blocked',
  columnEvent: 'Event Name',
  columnTime: 'Event Time',
  columnScript: 'Script',
  columnBlockedUrl: 'Blocked URL',
  columnFunctionName: 'Function',
};

const str_ = i18n.createMessageInstanceIdFn(__filename, UIStrings);

/**
 * Table headings for audits details sections.
 * @type {LH.Audit.Details.Table['headings']}
 */
const HEADINGS = [
  {key: 'eventName', itemType: 'text', text: str_(UIStrings.columnEvent)},
  {key: 'time', itemType: 'ms', text: str_(UIStrings.columnTime), granularity: 1},
  {key: 'url', itemType: 'url', text: str_(UIStrings.columnScript)},
  {key: 'functionName', itemType: 'text', text: str_(UIStrings.columnFunctionName)},
];

/** @typedef {import('../utils/graph').SimpleRequest} SimpleRequest */

/**
 * @param {SimpleRequest} request
 * @return {LH.Crdp.Runtime.CallFrame|undefined}
 */
function findOriginalCallFrame(request) {
  const {record} = request;
  let stack = record && record.initiator && record.initiator.stack;
  if (!stack) {
    return undefined;
  }
  while (stack.parent) {
    stack = stack.parent;
  }
  return stack.callFrames[stack.callFrames.length - 1];
}

/**
 * @param {LH.Crdp.Runtime.CallFrame} callFrame
 * @param {LH.TraceEvent[]} traceEvents
 */
function findTraceEventOfCallFrame(callFrame, traceEvents) {
  return traceEvents.find((e) => e.name == 'FunctionCall'
      && e.args.data &&
      // @ts-ignore
      e.args.data.functionName == callFrame.functionName &&
      // @ts-ignore
      e.args.data.scriptId == callFrame.scriptId &&
      // @ts-ignore
      e.args.data.url == callFrame.url &&
      // Tolerate off by one errors in line/column numbers.
      // @ts-ignore
      Math.abs(e.args.data.lineNumber == callFrame.lineNumber) < 2 &&
      // @ts-ignore
      Math.abs(e.args.data.columnNumber == callFrame.columnNumber) < 2);
}

/**
 * @typedef {Object} EventInterval
 * @property {number} start
 * @property {number} end
 * @property {string} eventName
 */

/**
 * Returns a list of time intervals corresponding to when each event handler
 * executed.
 * @param {string} eventName
 * @param {LH.TraceEvent[]} traceEvents
 * @return {EventInterval[]}
 */
function findEventIntervals(eventName, traceEvents) {
  /** @type {EventInterval} */ let openInterval = {};
  /** @type {EventInterval[]} */ const intervals = [];
  for (const e of traceEvents) {
    if (e.name == `${eventName}EventStart`) {
      openInterval = {start: e.ts, end: Infinity, eventName};
    } else if (e.name == `${eventName}EventEnd`) {
      openInterval.end = e.ts;
      intervals.push(openInterval);
    }
  }
  return intervals;
}

/**
 * @typedef {Object} BlockingEvent
 * @property {string} eventName
 * @property {string} blockedUrl
 * @property {number} time
 * @property {number} blockedTime
 */

/**
 * @param {BlockingEvent & LH.Crdp.Runtime.CallFrame} blockingEvent
 * @param {NetworkRequest[]} networkRecords
 * @param {Map<NetworkRequest, NodeTiming>} timingsByRecord
 * @return {number}
 */
function quantifyBlockedTime(blockingEvent, networkRecords, timingsByRecord) {
  const eventScript = networkRecords.find(
    (r) => r.url == blockingEvent.url);
  const blockedRequest = networkRecords.find(
    (r) => r.url == blockingEvent.blockedUrl);
  if (!eventScript || !blockedRequest) {
    return 0;
  }
  const scriptLoadTime = timingsByRecord.get(eventScript);
  const blockedRequestLoadTime = timingsByRecord.get(blockedRequest);
  if (!scriptLoadTime || !blockedRequestLoadTime) {
    return 0;
  }
  return blockedRequestLoadTime.startTime - scriptLoadTime.endTime;
}


/**
 * Audit to find blocking load events.
 */
class BlockingLoadEvents extends Audit {
  /**
   * @return {LH.Audit.Meta}
   * @override
   */
  static get meta() {
    return {
      id: 'blocking-load-events',
      title: str_(UIStrings.title),
      failureTitle: str_(UIStrings.failureTitle),
      description: str_(UIStrings.description),
      requiredArtifacts: ['devtoolsLogs', 'traces'],
    };
  }

  /**
   * @param {LH.Artifacts} artifacts
   * @param {LH.Audit.Context} context
   * @return {Promise<LH.Audit.Product>}
   */
  static async audit(artifacts, context) {
    const trace = artifacts.traces[Audit.DEFAULT_PASS];
    const devtoolsLog = artifacts.devtoolsLogs[Audit.DEFAULT_PASS];
    const networkRecords = await NetworkRecords.request(devtoolsLog, context);
    const {timings, processEvents} = await TraceOfTab.request(trace, context);
    /** @type {Map<NetworkRequest, NodeTiming>} */
    const timingsByRecord =
      await getTimingsByRecord(trace, devtoolsLog, context);

    const criticalRequests =
      (await computeAdRequestWaterfall(trace, devtoolsLog, context))
          // Sort by start time so we process the earliest requests first.
          .sort((a, b) => a.startTime - b.startTime);

    if (!criticalRequests.length) {
      return auditNotApplicable.NoAdRelatedReq;
    }

    const eventTimes = [
      ...findEventIntervals('domContentLoaded', processEvents),
      ...findEventIntervals('load', processEvents),
    ];
    const blockingEvents = [];
    const seen = new Set();
    for (const r of criticalRequests) {
      const callFrame = findOriginalCallFrame(r);
      if (!callFrame) {
        // Skip. This is expected of resources that weren't initiated by
        // scripts.
        continue;
      }
      const json = JSON.stringify(callFrame);
      if (seen.has(json)) {
        // Skip call frames that we already checked.
        continue;
      }
      seen.add(json);
      const traceEvent = findTraceEventOfCallFrame(callFrame, processEvents);
      if (!traceEvent) {
        continue;
      }
      const interval = eventTimes.find((interval) =>
        interval.start <= traceEvent.ts && traceEvent.ts <= interval.end);
      if (interval) {
        /** @type {BlockingEvent & LH.Crdp.Runtime.CallFrame} */
        const blockingEvent = Object.assign({
          eventName: interval.eventName,
          blockedUrl: r.url,
          time: timings[interval.eventName],
          blockedTime: Infinity,
        }, callFrame);
        blockingEvent.blockedTime = quantifyBlockedTime(
          blockingEvent, networkRecords, timingsByRecord);
        blockingEvents.push(blockingEvent);
      }
    }

    const failed = blockingEvents.length > 0;
    let blockedTime = 0;
    if (failed) {
      blockedTime = Math.min(...blockingEvents.map((e) => e.blockedTime));
    }
    return {
      numericValue: blockingEvents.length,
      numericUnit: 'unitless',
      score: failed ? 0 : 1,
      displayValue: failed && blockedTime ?
        str_(UIStrings.displayValue, {timeInMs: blockedTime}) :
        '',
      details: BlockingLoadEvents.makeTableDetails(HEADINGS, blockingEvents),
    };
  }
}

module.exports = BlockingLoadEvents;
module.exports.UIStrings = UIStrings;

}).call(this)}).call(this,"/node_modules/lighthouse-plugin-publisher-ads/audits/blocking-load-events.js")
},{"../messages/common-strings":198,"../utils/graph":203,"../utils/network-timing":204,"lighthouse":78,"lighthouse/lighthouse-core/computed/network-records":40,"lighthouse/lighthouse-core/computed/trace-of-tab":47,"lighthouse/lighthouse-core/lib/i18n/i18n":96}],"lighthouse-plugin-publisher-ads/audits/bottleneck-requests":[function(require,module,exports){
(function (__filename){(function (){
// Copyright 2019 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

const i18n = require('lighthouse/lighthouse-core/lib/i18n/i18n');
const {auditNotApplicable} = require('../messages/common-strings');
const {Audit} = require('lighthouse');
const {computeAdRequestWaterfall} = require('../utils/graph');
const {isAdScript, toURL} = require('../utils/resource-classification');

/** @typedef {LH.Artifacts.NetworkRequest} NetworkRequest */
/** @typedef {import('../utils/graph').SimpleRequest} SimpleRequest */

const UIStrings = {
  title: 'No bottleneck requests found',
  failureTitle: 'Avoid bottleneck requests',
  description: 'Speed up, load earlier, parallelize, or eliminate the ' +
    'following requests and their dependencies in order to speed up ad ' +
    'loading. [Learn More](' +
    'https://developers.google.com/publisher-ads-audits/reference/audits/bottleneck-requests' +
    ').',
  displayValue: '{blockedTime, number, seconds} s spent blocked on requests',
  columnUrl: 'Blocking Request',
  columnInitiatorUrl: 'Initiator Request',
  columnStartTime: 'Start',
  columnSelfTime: 'Exclusive Time',
  columnDuration: 'Total Time',
};

const str_ = i18n.createMessageInstanceIdFn(__filename, UIStrings);


/**
 * Table headings for audits details sections.
 * @type {LH.Audit.Details.Table['headings']}
 */
const HEADINGS = [
  {
    key: 'url',
    itemType: 'url',
    text: str_(UIStrings.columnUrl),
  },
  {
    key: 'selfTime',
    itemType: 'ms',
    text: str_(UIStrings.columnSelfTime),
    granularity: 1,
  },
  {
    key: 'duration',
    itemType: 'ms',
    text: str_(UIStrings.columnDuration),
    granularity: 1,
  },
];


/**
 * Audits any bottlneck requests in the path of loading ads.
 */
class BottleneckRequests extends Audit {
  /**
   * @return {LH.Audit.Meta}
   * @override
   */
  static get meta() {
    return {
      id: 'bottleneck-requests',
      title: str_(UIStrings.title),
      failureTitle: str_(UIStrings.failureTitle),
      description: str_(UIStrings.description),
      requiredArtifacts: ['devtoolsLogs', 'traces'],
    };
  }

  /**
   * @param {LH.Artifacts} artifacts
   * @param {LH.Audit.Context} context
   * @return {Promise<LH.Audit.Product>}
   */
  static async audit(artifacts, context) {
    const trace = artifacts.traces[Audit.DEFAULT_PASS];
    const devtoolsLog = artifacts.devtoolsLogs[Audit.DEFAULT_PASS];

    const waterfall =
      (await computeAdRequestWaterfall(trace, devtoolsLog, context))
          .filter((r) => r.startTime > 0);
    if (!waterfall.length) {
      return auditNotApplicable.NoAdRelatedReq;
    }
    const CRITICAL_SELF_TIME_MS = 250;
    const CRITICAL_DURATION_MS = 1000;
    /** @param {SimpleRequest} r @return {boolean} */
    const isBottleneck = (r) =>
      !isAdScript(toURL(r.url)) &&
      (r.selfTime > CRITICAL_SELF_TIME_MS || r.duration > CRITICAL_DURATION_MS);
    // selfTime is more costly than duration so weigh it more than duration.
    /** @param {SimpleRequest} r @return {number} */
    const cost = (r) => r.selfTime * 3 + r.duration;
    const criticalRequests = waterfall
        .filter(isBottleneck)
        .sort((a, b) => cost(b) - cost(a))
        // Only show the top critical requests for the sake of brevity.
        .slice(0, 5);
    const blockedTime =
      // @ts-ignore param types not inferred.
      criticalRequests.reduce((sum, r) => sum + r.selfTime, 0) / 1000;
    const failed = blockedTime * 1e3 > CRITICAL_SELF_TIME_MS * 4;

    for (const row of criticalRequests) {
      delete row.record; // Remove circular references before serialization.
    }
    return {
      numericValue: criticalRequests.length,
      numericUnit: 'unitless',
      score: failed ? 0 : 1,
      displayValue: failed ? str_(UIStrings.displayValue, {blockedTime}) : '',
      details:
        BottleneckRequests.makeTableDetails(HEADINGS, criticalRequests),
    };
  }
}

module.exports = BottleneckRequests;
module.exports.UIStrings = UIStrings;

}).call(this)}).call(this,"/node_modules/lighthouse-plugin-publisher-ads/audits/bottleneck-requests.js")
},{"../messages/common-strings":198,"../utils/graph":203,"../utils/resource-classification":206,"lighthouse":78,"lighthouse/lighthouse-core/lib/i18n/i18n":96}],"lighthouse-plugin-publisher-ads/audits/cumulative-ad-shift":[function(require,module,exports){
(function (__filename){(function (){
// Copyright 2020 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

const i18n = require('lighthouse/lighthouse-core/lib/i18n/i18n');
const {auditNotApplicable} = require('../messages/common-strings');
const {Audit} = require('lighthouse');
const {getScriptUrl} = require('../utils/network-timing');
const {isAdIframe, isImplTag} = require('../utils/resource-classification');
const {overlaps, toClientRect} = require('../utils/geometry');

const UIStrings = {
  title: 'Cumulative ad shift',
  failureTitle: 'Reduce ad-related layout shift',
  description:
      'Measures layout shifts that were caused by ads or happened near ads. ' +
          'Reducing cumulative ad-related layout shift will improve user ' +
          'experience. [Learn more]' +
          '(https://developers.google.com/publisher-ads-audits/reference/audits/cumulative-ad-shift).',
};

const str_ = i18n.createMessageInstanceIdFn(__filename, UIStrings);

/**
 * Audit to determine time for first ad request relative to page start.
 */
class CumulativeAdShift extends Audit {
  /**
   * @return {LH.Audit.Meta}
   * @override
   */
  static get meta() {
    return {
      id: 'cumulative-ad-shift',
      title: str_(UIStrings.title),
      failureTitle: str_(UIStrings.failureTitle),
      description: str_(UIStrings.description),
      // @ts-ignore
      scoreDisplayMode: Audit.SCORING_MODES.NUMERIC,
      requiredArtifacts: ['traces', 'IFrameElements'],
    };
  }

  /**
   * @return {LH.Audit.ScoreOptions}
   */
  static get defaultOptions() {
    // TODO tune this
    return {
      p10: 0.05,
      median: 0.25,
    };
  }

  /**
   * @param {LH.TraceEvent} shiftEvent
   * @param {Artifacts['IFrameElement'][]} ads
   */
  static isAdShift(shiftEvent, ads) {
    if (!shiftEvent.args || !shiftEvent.args.data) {
      return false;
    }
    for (const ad of ads) {
      // Names come from external JSON
      // eslint-disable-next-line camelcase
      for (const node of shiftEvent.args.data.impacted_nodes || []) {
        // eslint-disable-next-line camelcase
        const /* number[] */ oldRect = node.old_rect || [];
        const shiftRect = toClientRect(oldRect);
        const adRect = ad.clientRect;
        if (overlaps(shiftRect, adRect)) {
          return true;
        }
      }
    }
    return false;
  }

  /**
   * Computes the ad shift score for the page.
   * @param {LH.TraceEvent[]} shiftEvents
   * @param {Artifacts['IFrameElement'][]} ads
   * @param {number} tagLoadTs
   */
  static compute(shiftEvents, ads, tagLoadTs) {
    let cumulativeShift = 0;
    let numShifts = 0;
    let cumulativeAdShift = 0;
    let numAdShifts = 0;
    let cumulativePreImplTagAdShift = 0;
    let numPreImplTagAdShifts = 0;
    for (const event of shiftEvents) {
      if (!event.args || !event.args.data || !event.args.data.is_main_frame) {
        continue;
      }
      // @ts-ignore
      cumulativeShift += event.args.data.score;
      numShifts++;
      if (this.isAdShift(event, ads)) {
        // @ts-ignore
        cumulativeAdShift += event.args.data.score;
        numAdShifts++;
        if (event.ts < tagLoadTs) {
          // @ts-ignore
          cumulativePreImplTagAdShift += event.args.data.score;
          numPreImplTagAdShifts++;
        }
      }
    }
    return {
      cumulativeShift,
      numShifts,
      cumulativeAdShift,
      numAdShifts,
      cumulativePreImplTagAdShift,
      numPreImplTagAdShifts,
    };
  }

  /**
   * @param {LH.Artifacts} artifacts
   * @param {LH.Audit.Context} context
   * @return {Promise<LH.Audit.Product>}
   */
  static async audit(artifacts, context) {
    const trace = artifacts.traces[Audit.DEFAULT_PASS];
    const shiftEvents =
      trace.traceEvents.filter((e) => e.name === 'LayoutShift');
    if (!shiftEvents.length) {
      return auditNotApplicable.NoLayoutShifts;
    }

    const tagLoadEvent =
        trace.traceEvents.find((e) => isImplTag(getScriptUrl(e) || '')) ||
        {ts: Infinity};

    // Maybe we should look at the parent elements (created by the publisher and
    // passed to the ad tag) rather than the iframe itself.
    const ads = artifacts.IFrameElements.filter(isAdIframe);
    if (!ads.length) {
      // TODO count shifts for the container element here.
      return auditNotApplicable.NoAdRendered;
    }

    const details = this.compute(shiftEvents, ads, tagLoadEvent.ts);
    const rawScore = details.cumulativeAdShift;
    return {
      numericValue: rawScore,
      numericUnit: 'unitless',
      score: Audit.computeLogNormalScore(
        {p10: context.options.p10, median: context.options.median}, rawScore),
      displayValue: rawScore.toLocaleString(context.settings.locale),
      // @ts-ignore Add more fields for logging
      details,
    };
  }
}

module.exports = CumulativeAdShift;
module.exports.UIStrings = UIStrings;

}).call(this)}).call(this,"/node_modules/lighthouse-plugin-publisher-ads/audits/cumulative-ad-shift.js")
},{"../messages/common-strings":198,"../utils/geometry":202,"../utils/network-timing":204,"../utils/resource-classification":206,"lighthouse":78,"lighthouse/lighthouse-core/lib/i18n/i18n":96}],"lighthouse-plugin-publisher-ads/audits/deprecated-api-usage":[function(require,module,exports){
(function (__filename){(function (){
// Copyright 2021 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

const i18n = require('lighthouse/lighthouse-core/lib/i18n/i18n');
const {Audit} = require('lighthouse');
const {isGpt} = require('../utils/resource-classification');

const UIStrings = {
  title: 'Deprecated GPT API Usage',
  failureTitle: 'Avoid deprecated GPT APIs',
  description: 'Deprecated GPT API methods should be avoided to ensure your ' +
  'page is tagged correctly. [Learn more](' +
  'https://developers.google.com/publisher-ads-audits/reference/audits/deprecated-gpt-api-usage' +
  ').',
  displayValue: '{numErrors, plural, =1 {1 error} other {# errors}} found',
};

const str_ = i18n.createMessageInstanceIdFn(__filename, UIStrings);

/**
 * Audit that checks for the presence of warning and error messages which
 * pertain to deprecated API usage.
 */
class DeprecatedApiUsage extends Audit {
  /**
   * @return {LH.Audit.Meta}
   * @override
   */
  static get meta() {
    return {
      id: 'deprecated-gpt-api-usage',
      title: str_(UIStrings.title),
      failureTitle: str_(UIStrings.failureTitle),
      description: str_(UIStrings.description),
      scoreDisplayMode: 'informative',
      requiredArtifacts: ['ConsoleMessages'],
    };
  }

  /**
   * @param {LH.Artifacts} artifacts
   * @return {LH.Audit.Product}
   */
  static audit(artifacts) {
    /** @type {Array<{
     * source: string,
     * description: string|undefined,
     * url: string|undefined,
     * timestamp: number|undefined}>} */
    const tableRows = artifacts.ConsoleMessages
        .filter((item) => item.level === 'warning' || item.level === 'error')
        .filter((item) => item.url && isGpt(item.url))
        .filter((item) =>
          item.text.toLowerCase().includes('deprecated') ||
          item.text.toLowerCase().includes('discouraged'))
        .map((item) => ({
          source: item.source,
          description: item.text,
          url: item.url,
          timestamp: item.timestamp,
        }))
        .sort((a, b) => (a.timestamp || 0) - (b.timestamp || 0));

    /** @type {LH.Audit.Details.Table['headings']} */
    const headings = [
      {key: 'url', itemType: 'url', text: str_(i18n.UIStrings.columnURL)},
      {key: 'description', itemType: 'code', text: str_(i18n.UIStrings.columnDescription)},
    ];

    const details = Audit.makeTableDetails(headings, tableRows);
    const numErrors = tableRows.length;

    return {
      score: Number(numErrors === 0),
      details,
      displayValue: str_(UIStrings.displayValue, {numErrors}),
    };
  }
}

module.exports = DeprecatedApiUsage;
module.exports.UIStrings = UIStrings;

}).call(this)}).call(this,"/node_modules/lighthouse-plugin-publisher-ads/audits/deprecated-api-usage.js")
},{"../utils/resource-classification":206,"lighthouse":78,"lighthouse/lighthouse-core/lib/i18n/i18n":96}],"lighthouse-plugin-publisher-ads/audits/duplicate-tags":[function(require,module,exports){
(function (__filename){(function (){
// Copyright 2018 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

const i18n = require('lighthouse/lighthouse-core/lib/i18n/i18n');
// @ts-ignore
const MainResource = require('lighthouse/lighthouse-core/computed/main-resource');
const NetworkRecords = require('lighthouse/lighthouse-core/computed/network-records');
const NetworkRequest = require('lighthouse/lighthouse-core/lib/network-request');
const {auditNotApplicable} = require('../messages/common-strings');
const {Audit} = require('lighthouse');
const {containsAnySubstring} = require('../utils/resource-classification');
const {URL} = require('url');

const UIStrings = {
  title: 'No duplicate tags found',
  failureTitle: 'Load tags only once',
  description: 'Loading a tag more than once in the same page is redundant ' +
  'and adds overhead without benefit. [Learn more](' +
  'https://developers.google.com/publisher-ads-audits/reference/audits/duplicate-tags' +
  ').',
  failureDisplayValue: '{duplicateTags, plural, =1 {1 duplicate tag} other {# duplicate tags}}',
  columnScript: 'Script',
  columnNumReqs: 'Duplicate Requests',
  columnFrameId: 'Frame ID',
};

const str_ = i18n.createMessageInstanceIdFn(__filename, UIStrings);

const tags = [
  'googletagservices.com/tag/js/gpt.js',
  'securepubads.g.doubleclick.net/tag/js/gpt.js',
  'pagead2.googlesyndication.com/pagead/js/adsbygoogle.js',
  'pagead2.googlesyndication.com/pagead/js/show_ads.js',
  'cdn.ampproject.org/v0/amp-ad-0.1.js',
];

/**
 * Table headings for audits details sections.
 * @type {LH.Audit.Details.Table['headings']}
 */
const HEADINGS = [
  {key: 'script', itemType: 'url', text: str_(UIStrings.columnScript)},
  {key: 'numReqs', itemType: 'text', text: str_(UIStrings.columnNumReqs)},
];
/**
 * Simple audit that checks if any specified tags are duplicated within the same
 * frame.
 */
class DuplicateTags extends Audit {
  /**
   * @return {LH.Audit.Meta}
   * @override
   */
  static get meta() {
    return {
      id: 'duplicate-tags',
      title: str_(UIStrings.title),
      failureTitle: str_(UIStrings.failureTitle),
      description: str_(UIStrings.description),
      requiredArtifacts: ['devtoolsLogs', 'URL'],
    };
  }

  /**
   * @param {LH.Artifacts} artifacts
   * @param {LH.Audit.Context} context
   * @return {Promise<LH.Audit.Product>}
   */
  static async audit(artifacts, context) {
    const devtoolsLog = artifacts.devtoolsLogs[Audit.DEFAULT_PASS];
    const networkRecords = await NetworkRecords.request(devtoolsLog, context);
    const mainResource =
        await MainResource.request({URL: artifacts.URL, devtoolsLog}, context);
    const tagReqs = networkRecords
        .filter((r) => r.frameId === mainResource.frameId)
        .filter((r) => containsAnySubstring(r.url, tags))
        .filter((r) => (r.resourceType === NetworkRequest.TYPES.Script));

    if (!tagReqs.length) {
      return auditNotApplicable.NoTags;
    }
    /** @type {Map<string, number>} */
    const tagCounts = new Map;
    for (const record of tagReqs) {
      // Groups by path to account for scripts hosted on multiple domains.
      const script = new URL(record.url).pathname;
      const count = tagCounts.get(script) || 0;
      tagCounts.set(script, count + 1);
    }
    /** @type {LH.Audit.Details.Table['items']} */
    const dups = [];
    for (const [script, numReqs] of tagCounts) {
      if (numReqs > 1) {
        dups.push({script, numReqs});
      }
    }

    return {
      numericValue: dups.length,
      numericUnit: 'unitless',
      score: dups.length ? 0 : 1,
      details: DuplicateTags.makeTableDetails(HEADINGS, dups),
      displayValue: dups.length ?
        str_(UIStrings.failureDisplayValue, {duplicateTags: dups.length}) :
        '',
    };
  }
}

module.exports = DuplicateTags;
module.exports.UIStrings = UIStrings;

}).call(this)}).call(this,"/node_modules/lighthouse-plugin-publisher-ads/audits/duplicate-tags.js")
},{"../messages/common-strings":198,"../utils/resource-classification":206,"lighthouse":78,"lighthouse/lighthouse-core/computed/main-resource":14,"lighthouse/lighthouse-core/computed/network-records":40,"lighthouse/lighthouse-core/lib/i18n/i18n":96,"lighthouse/lighthouse-core/lib/network-request":109,"url":"url"}],"lighthouse-plugin-publisher-ads/audits/first-ad-render":[function(require,module,exports){
(function (__filename){(function (){
// Copyright 2019 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

const ComputedAdRenderTime = require('../computed/ad-render-time');
const i18n = require('lighthouse/lighthouse-core/lib/i18n/i18n');
const {auditNotApplicable, runWarning} = require('../messages/common-strings');
const {Audit} = require('lighthouse');

const UIStrings = {
  title: 'Latency of first ad render',
  failureTitle: 'Reduce time to render first ad',
  description: 'This metric measures the time for the first ad iframe to ' +
  'render from page navigation. [Learn more](' +
  'https://developers.google.com/publisher-ads-audits/reference/audits/first-ad-render' +
  ').',
  displayValue: '{timeInMs, number, seconds} s',
};

const str_ = i18n.createMessageInstanceIdFn(__filename, UIStrings);

/**
 * Measures the first ad render time.
 */
class FirstAdRender extends Audit {
  /**
   * @return {LH.Audit.Meta}
   * @override
   */
  static get meta() {
    // @ts-ignore
    return {
      id: 'first-ad-render',
      title: str_(UIStrings.title),
      failureTitle: str_(UIStrings.failureTitle),
      description: str_(UIStrings.description),
      // @ts-ignore
      scoreDisplayMode: Audit.SCORING_MODES.NUMERIC,
      // @ts-ignore
      requiredArtifacts: ['devtoolsLogs', 'traces'],
    };
  }

  /**
   * @return {{
   *   simulate: LH.Audit.ScoreOptions,
   *   provided: LH.Audit.ScoreOptions
   * }}
   */
  static get defaultOptions() {
    return {
      simulate: {
        p10: 12900,
        median: 22000,
      },
      provided: {
        p10: 2750,
        median: 3700,
      },

    };
  }
  /**
   * @param {Artifacts} artifacts
   * @param {LH.Audit.Context} context
   * @return {Promise<LH.Audit.Product>}
   */
  static async audit(artifacts, context) {
    const trace = artifacts.traces[Audit.DEFAULT_PASS];
    const devtoolsLog = artifacts.devtoolsLogs[Audit.DEFAULT_PASS];
    const metricData = {
      devtoolsLog,
      trace,
      settings: context.settings,
    };
    const {timing} = await ComputedAdRenderTime.request(metricData, context);

    if (!(timing > 0)) { // Handle NaN, etc.
      const naAuditProduct = auditNotApplicable.NoAdRendered;
      naAuditProduct.runWarnings = [runWarning.NoAdRendered];
      return naAuditProduct;
    }

    const scoreOptions = context.options[
        context.settings.throttlingMethod == 'provided' ?
          'provided' :
          'simulate'
    ];

    return {
      numericValue: timing,
      numericUnit: 'millisecond',
      score: Audit.computeLogNormalScore(
        scoreOptions,
        timing,
      ),
      displayValue:
      str_(UIStrings.displayValue, {timeInMs: timing}),
    };
  }
}
module.exports = FirstAdRender;
module.exports.UIStrings = UIStrings;

}).call(this)}).call(this,"/node_modules/lighthouse-plugin-publisher-ads/audits/first-ad-render.js")
},{"../computed/ad-render-time":193,"../messages/common-strings":198,"lighthouse":78,"lighthouse/lighthouse-core/lib/i18n/i18n":96}],"lighthouse-plugin-publisher-ads/audits/full-width-slots":[function(require,module,exports){
(function (__filename){(function (){
// Copyright 2018 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

const i18n = require('lighthouse/lighthouse-core/lib/i18n/i18n');
const NetworkRecords = require('lighthouse/lighthouse-core/computed/network-records');
const {auditNotApplicable} = require('../messages/common-strings');
const {Audit} = require('lighthouse');
const {isAdRequest} = require('../utils/resource-classification');
const {URL} = require('url');

const UIStrings = {
  title: 'Ad slots effectively use horizontal space',
  failureTitle: 'Increase the width of ad slots',
  description: 'Ad slots that utilize most of the page width generally ' +
  'experience increased click-through rate over smaller ad sizes. We ' +
  'recommend leaving no more than 25% of the viewport width unutilized on ' +
  'mobile devices.',
  failureDisplayValue: '{percentUnused, number, percent} of viewport width ' +
  'is underutilized',
};

const str_ = i18n.createMessageInstanceIdFn(__filename, UIStrings);

/** @inheritDoc */
class FullWidthSlots extends Audit {
  /**
   * @return {LH.Audit.Meta}
   * @override
   */
  static get meta() {
    return {
      id: 'full-width-slots',
      title: str_(UIStrings.title),
      failureTitle: str_(UIStrings.failureTitle),
      description: str_(UIStrings.description),
      requiredArtifacts: ['ViewportDimensions', 'devtoolsLogs'],
    };
  }

  /**
   * @param {LH.Artifacts} artifacts
   * @param {LH.Audit.Context} context
   * @return {Promise<LH.Audit.Product>}
   */
  static async audit(artifacts, context) {
    const devtoolsLogs = artifacts.devtoolsLogs[Audit.DEFAULT_PASS];
    const networkRecords = await NetworkRecords.request(devtoolsLogs, context);
    const viewport = artifacts.ViewportDimensions;
    const vpWidth = viewport.innerWidth;

    /** @type {Array<URL>} */
    const adRequestUrls = networkRecords
        .filter(isAdRequest)
        .map((record) => new URL(record.url));

    if (!adRequestUrls.length) {
      return auditNotApplicable.NoAds;
    }

    const sizeArrs = adRequestUrls.map((url) =>
      url.searchParams.get('prev_iu_szs') || url.searchParams.get('sz'));

    // Converts to array of widths, filtering out those larger than viewport
    // that are at least 1px wide.
    const sizes = sizeArrs.join('|').split(/[|,]/);

    const widths = sizes.map((size) => parseInt(size.split('x')[0]))
        .filter((w) => w <= vpWidth && w > 1);

    if (!widths.length) {
      return auditNotApplicable.NoValidAdWidths;
    }

    const maxWidth = Math.max(...widths);

    const pctUnoccupied = 1 - (maxWidth / vpWidth);

    const score = pctUnoccupied > .25 ? 0 : 1;


    return {
      score,
      numericValue: pctUnoccupied,
      numericUnit: 'unitless',
      // No displayValue if passing, no changes to be made.
      displayValue: score ?
        '' :
        str_(UIStrings.failureDisplayValue, {percentUnused: pctUnoccupied}),
    };
  }
}

module.exports = FullWidthSlots;
module.exports.UIStrings = UIStrings;

}).call(this)}).call(this,"/node_modules/lighthouse-plugin-publisher-ads/audits/full-width-slots.js")
},{"../messages/common-strings":198,"../utils/resource-classification":206,"lighthouse":78,"lighthouse/lighthouse-core/computed/network-records":40,"lighthouse/lighthouse-core/lib/i18n/i18n":96,"url":"url"}],"lighthouse-plugin-publisher-ads/audits/gpt-bids-parallel":[function(require,module,exports){
// Copyright 2019 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

const NetworkRecords = require('lighthouse/lighthouse-core/computed/network-records');
const {assert} = require('../utils/asserts');
const {auditNotApplicable} = require('../messages/common-strings');
const {Audit} = require('lighthouse');
const {getCriticalGraph} = require('../utils/graph');
const {getTimingsByRecord} = require('../utils/network-timing');
const {isGptImplTag, isBidRequest, getHeaderBidder} = require('../utils/resource-classification');

/** @typedef {LH.Artifacts.NetworkRequest} NetworkRequest */
/** @typedef {LH.Gatherer.Simulation.NodeTiming} NodeTiming */

const id = 'gpt-bids-parallel';
const UIStrings = {
  title: 'GPT and bids loaded in parallel',
  failureTitle: 'Load GPT and bids in parallel',
  description: 'To optimize ad loading, bid requests should not wait on GPT ' +
  'to load. This issue can often be fixed by making sure that bid requests ' +
  'do not wait on `googletag.pubadsReady` or `googletag.cmd.push`. ' +
  '[Learn More](' +
  'https://developers.google.com/publisher-ads-audits/reference/audits/gpt-bids-parallel' +
  ').',
  columnBidder: 'Bidder',
  columnUrl: 'URL',
  columnStartTime: 'Start',
  columnDuration: 'Duration',
};

/**
 * Table headings for audits details sections.
 * @type {LH.Audit.Details.Table['headings']}
 */
const HEADINGS = [
  {key: 'bidder', itemType: 'text', text: UIStrings.columnBidder},
  {key: 'url', itemType: 'url', text: UIStrings.columnUrl},
  {key: 'startTime', itemType: 'ms', text: UIStrings.columnStartTime},
  {key: 'duration', itemType: 'ms', text: UIStrings.columnDuration},
];

/**
 * Audit to check if serial header bidding occurs
 */
class GptBidsInParallel extends Audit {
  /**
   * @return {LH.Audit.Meta}
   * @override
   */
  static get meta() {
    return {
      id,
      title: UIStrings.title,
      failureTitle: UIStrings.failureTitle,
      description: UIStrings.description,
      requiredArtifacts: ['devtoolsLogs', 'traces'],
    };
  }

  /**
   * @param {LH.Artifacts} artifacts
   * @param {LH.Audit.Context} context
   * @return {Promise<LH.Audit.Product>}
   */
  static async audit(artifacts, context) {
    const devtoolsLog = artifacts.devtoolsLogs[Audit.DEFAULT_PASS];
    const trace = artifacts.traces[Audit.DEFAULT_PASS];
    const network = await NetworkRecords.request(devtoolsLog, context);

    const pubadsImpl = network.find((r) => isGptImplTag(r.url));
    if (!pubadsImpl) {
      return auditNotApplicable.NoGpt;
    }

    const bids = network.filter(isBidRequest)
        .filter((b) => b.frameId == pubadsImpl.frameId);
    if (!bids.length) {
      return auditNotApplicable.NoBids;
    }

    /** @type {Map<NetworkRequest, NodeTiming>} */
    const timingsByRecord = await getTimingsByRecord(
      trace, devtoolsLog, context);
    const tableView = [];
    /** @type {Set<string>} */ const seen = new Set();
    for (const bid of bids) {
      if (getCriticalGraph(network, trace.traceEvents, bid).has(pubadsImpl)) {
        const {startTime, endTime} = timingsByRecord.get(bid) || bid;
        const bidder = assert(getHeaderBidder(bid.url));
        if (seen.has(bidder)) {
          // Don't include multiple requests from the same bidder in the results
          // table.
          continue;
        }
        seen.add(bidder);
        tableView.push({
          bidder,
          url: bid.url,
          startTime,
          duration: endTime - startTime,
        });
      }
    }
    const failed = tableView.length > 0;
    return {
      numericValue: tableView.length,
      numericUnit: 'unitless',
      score: failed ? 0 : 1,
      details: failed ?
        GptBidsInParallel.makeTableDetails(HEADINGS, tableView) : undefined,
    };
  }
}

module.exports = GptBidsInParallel;
module.exports.UIStrings = UIStrings;

},{"../messages/common-strings":198,"../utils/asserts":200,"../utils/graph":203,"../utils/network-timing":204,"../utils/resource-classification":206,"lighthouse":78,"lighthouse/lighthouse-core/computed/network-records":40}],"lighthouse-plugin-publisher-ads/audits/gpt-errors-overall":[function(require,module,exports){
(function (__filename){(function (){
// Copyright 2021 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

const i18n = require('lighthouse/lighthouse-core/lib/i18n/i18n');
const {Audit} = require('lighthouse');
const {isGpt} = require('../utils/resource-classification');

const UIStrings = {
  title: 'GPT Errors',
  failureTitle: 'Fix GPT errors',
  description: 'Fix GPT errors to ensure your page is tagged as intended. ' +
  '[Learn more](' +
  'https://developers.google.com/publisher-ads-audits/reference/audits/gpt-errors-overall' +
  ').',
  displayValue: '{numErrors, plural, =1 {1 error} other {# errors}} found',
};

const str_ = i18n.createMessageInstanceIdFn(__filename, UIStrings);

/**
 * Audit that checks for the presence of errors and exceptions from the console
 * as well as other audits.
 */
class GptErrorsOverall extends Audit {
  /**
   * @return {LH.Audit.Meta}
   * @override
   */
  static get meta() {
    return {
      id: 'gpt-errors-overall',
      title: str_(UIStrings.title),
      failureTitle: str_(UIStrings.failureTitle),
      description: str_(UIStrings.description),
      scoreDisplayMode: 'informative',
      requiredArtifacts: ['ConsoleMessages'],
    };
  }

  /**
   * @param {LH.Artifacts} artifacts
   * @return {LH.Audit.Product}
   */
  static audit(artifacts) {
    /** @type {Array<{
     * source: string,
     * description: string|undefined,
     * url: string|undefined}>} */
    const tableRows = artifacts.ConsoleMessages
        .filter((item) =>
          item.level === 'error' || item.level === 'warning')
        .filter((item) => item.url && isGpt(item.url))
        .filter((item) =>
          !item.text.toLowerCase().includes('deprecated') &&
          !item.text.toLowerCase().includes('discouraged'))
        .map((item) => ({
          source: item.source,
          description: item.text,
          url: item.url,
          timestamp: item.timestamp,
        }))
        .sort((a, b) => (a.timestamp || 0) - (b.timestamp || 0));

    /** @type {LH.Audit.Details.Table['headings']} */
    const headings = [
      {key: 'url', itemType: 'url', text: str_(i18n.UIStrings.columnURL)},
      {key: 'description', itemType: 'code', text: str_(i18n.UIStrings.columnDescription)},
    ];

    const details = Audit.makeTableDetails(headings, tableRows);
    const numErrors = tableRows.length;

    return {
      score: Number(numErrors === 0),
      details,
      displayValue: str_(UIStrings.displayValue, {numErrors}),
    };
  }
}

module.exports = GptErrorsOverall;
module.exports.UIStrings = UIStrings;

}).call(this)}).call(this,"/node_modules/lighthouse-plugin-publisher-ads/audits/gpt-errors-overall.js")
},{"../utils/resource-classification":206,"lighthouse":78,"lighthouse/lighthouse-core/lib/i18n/i18n":96}],"lighthouse-plugin-publisher-ads/audits/loads-ad-tag-over-https":[function(require,module,exports){
(function (__filename){(function (){
// Copyright 2018 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

const i18n = require('lighthouse/lighthouse-core/lib/i18n/i18n');
const NetworkRecords = require('lighthouse/lighthouse-core/computed/network-records');
const {auditNotApplicable} = require('../messages/common-strings');
const {Audit} = require('lighthouse');
const {isAdTag} = require('../utils/resource-classification');
const {URL} = require('url');

const UIStrings = {
  title: 'Ad tag is loaded over HTTPS',
  failureTitle: 'Load ad tag over HTTPS',
  description: 'For privacy and security, always load GPT/AdSense over ' +
  'HTTPS. Insecure pages should explicitly request the ad script securely. ' +
  'GPT Example: `<script async ' +
  'src=\"https://securepubads.g.doubleclick.net/tag/js/gpt.js\">` ' +
  'AdSense Example: `<script async ' +
  'src=\"https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js\">`' +
  '. [Learn more](' +
  'https://developers.google.com/publisher-ads-audits/reference/audits/loads-ad-tag-over-https' +
  ').',
};

const str_ = i18n.createMessageInstanceIdFn(__filename, UIStrings);


/**
 * Simple audit that checks if GPT/AdSense is loaded over https.
 * Currently based on network logs since it covers statically and dynamically
 * loaded scripts from the main page and iframes.
 */
class LoadsAdTagOverHttps extends Audit {
  /**
   * @return {LH.Audit.Meta}
   * @override
   */
  static get meta() {
    return {
      id: 'loads-ad-tag-over-https',
      title: str_(UIStrings.title),
      failureTitle: str_(UIStrings.failureTitle),
      description: str_(UIStrings.description),
      requiredArtifacts: ['devtoolsLogs'],
    };
  }

  /**
   * @param {LH.Artifacts} artifacts
   * @param {LH.Audit.Context} context
   * @return {Promise<LH.Audit.Product>}
   */
  static async audit(artifacts, context) {
    const devtoolsLogs = artifacts.devtoolsLogs[Audit.DEFAULT_PASS];
    const networkRecords = await NetworkRecords.request(devtoolsLogs, context);

    const pageReq = networkRecords.find((record) => record.statusCode == 200);
    if (!pageReq) {
      return auditNotApplicable.NoRecords;
    }

    const adRequests = networkRecords
        .filter((record) => isAdTag(new URL(record.url)));

    const secureAdRequests = adRequests.filter((request) => request.isSecure);

    /** @type {LH.Audit.Details.DebugData} */
    const details = {
      type: 'debugdata',
      numAdTagHttpReqs: adRequests.length - secureAdRequests.length,
      numAdTagHttpsReqs: secureAdRequests.length,
    };

    if (!adRequests.length) {
      const returnVal = auditNotApplicable.NoTag;
      returnVal.details = details;
      return returnVal;
    }

    // TODO(jonkeller): Add a details table indicating which scripts are loaded
    // over HTTP.
    return {
      numericValue: details.numAdTagHttpReqs,
      score: details.numAdTagHttpReqs ? 0 : 1,
      details,
    };
  }
}

module.exports = LoadsAdTagOverHttps;
module.exports.UIStrings = UIStrings;

}).call(this)}).call(this,"/node_modules/lighthouse-plugin-publisher-ads/audits/loads-ad-tag-over-https.js")
},{"../messages/common-strings":198,"../utils/resource-classification":206,"lighthouse":78,"lighthouse/lighthouse-core/computed/network-records":40,"lighthouse/lighthouse-core/lib/i18n/i18n":96,"url":"url"}],"lighthouse-plugin-publisher-ads/audits/loads-gpt-from-official-source":[function(require,module,exports){
(function (__filename){(function (){
// Copyright 2019 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

const i18n = require('lighthouse/lighthouse-core/lib/i18n/i18n');
const NetworkRecords = require('lighthouse/lighthouse-core/computed/network-records');
const {auditNotApplicable} = require('../messages/common-strings');
const {Audit} = require('lighthouse');
const {isGptTag} = require('../utils/resource-classification');
const {URL} = require('url');

const UIStrings = {
  title: 'GPT tag is loaded from an official source',
  failureTitle: 'Load GPT from an official source',
  description:
  'Load GPT from \'securepubads.g.doubleclick.net\' for standard ' +
  'integrations or from \'pagead2.googlesyndication.com\' for limited ads. ' +
  '[Learn more](' +
  'https://developers.google.com/publisher-ads-audits/reference/audits/loads-gpt-from-official-source' +
  ').',
};

const str_ = i18n.createMessageInstanceIdFn(__filename, UIStrings);

/**
 * Simple audit that checks if gpt is loaded over from updated host.
 */
class LoadsGptFromOfficalSource extends Audit {
  /**
   * @return {LH.Audit.Meta}
   * @override
   */
  static get meta() {
    return {
      id: 'loads-gpt-from-official-source',
      title: str_(UIStrings.title),
      failureTitle: str_(UIStrings.failureTitle),
      description: str_(UIStrings.description),
      requiredArtifacts: ['devtoolsLogs'],
    };
  }

  /**
   * @param {LH.Artifacts} artifacts
   * @param {LH.Audit.Context} context
   * @return {Promise<LH.Audit.Product>}
   */
  static async audit(artifacts, context) {
    const devtoolsLog = artifacts.devtoolsLogs[Audit.DEFAULT_PASS];
    const networkRecords = await NetworkRecords.request(devtoolsLog, context);
    const gptUrl = networkRecords.map((r) => new URL(r.url)).find(isGptTag);
    if (!gptUrl) {
      return auditNotApplicable.NoGpt;
    }
    const passed = [
      'securepubads.g.doubleclick.net',
      'pagead2.googlesyndication.com',
    ].includes(gptUrl.host);
    return {
      score: Number(passed),
      numericValue: Number(!passed),
      numericUnit: 'unitless',
    };
  }
}

module.exports = LoadsGptFromOfficalSource;
module.exports.UIStrings = UIStrings;

}).call(this)}).call(this,"/node_modules/lighthouse-plugin-publisher-ads/audits/loads-gpt-from-official-source.js")
},{"../messages/common-strings":198,"../utils/resource-classification":206,"lighthouse":78,"lighthouse/lighthouse-core/computed/network-records":40,"lighthouse/lighthouse-core/lib/i18n/i18n":96,"url":"url"}],"lighthouse-plugin-publisher-ads/audits/script-injected-tags":[function(require,module,exports){
(function (__filename){(function (){
// Copyright 2019 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

const array = require('../utils/array.js');
const i18n = require('lighthouse/lighthouse-core/lib/i18n/i18n');
const PageDependencyGraph = require('lighthouse/lighthouse-core/computed/page-dependency-graph');
const {auditNotApplicable} = require('../messages/common-strings');
const {Audit} = require('lighthouse');
const {computeAdRequestWaterfall} = require('../utils/graph');
const {getScriptEvaluationTimes} = require('../utils/network-timing');

/** @typedef {LH.Artifacts.NetworkRequest} NetworkRequest */
/** @typedef {LH.Gatherer.Simulation.NodeTiming} NodeTiming */

// Don't bother failing on scripts that are dynamically inserted but load
// quickly.
const MINIMUM_LOAD_TIME_MS = 400;

const UIStrings = {
  title: 'Ad scripts are loaded statically',
  failureTitle: 'Load ad scripts statically',
  description: 'Load the following scripts directly with ' +
  '`<script async src=...>` instead of injecting scripts with JavaScript. ' +
  'Doing so allows the browser to preload scripts sooner. [Learn more](' +
  'https://developers.google.com/publisher-ads-audits/reference/audits/script-injected-tags' +
  ').',
  failureDisplayValue: 'Load {tags, plural, =1 {1 script} other {# scripts}} statically',
  columnUrl: 'Script',
  columnLoadTime: 'Load Time',
};

const str_ = i18n.createMessageInstanceIdFn(__filename, UIStrings);

/**
 * Table headings for audits details sections.
 * @type {LH.Audit.Details.Table['headings']}
 */
const HEADINGS = [
  {
    key: 'url',
    itemType: 'url',
    text: str_(UIStrings.columnUrl),
  },
  {
    key: 'loadTime',
    itemType: 'ms',
    granularity: 1,
    text: str_(UIStrings.columnLoadTime),
  },
];

const STATICALLY_LOADABLE_TAGS = [
  /amazon-adsystem\.com\/aax2\/apstag.js/,
  /js-sec\.indexww\.com\/ht\/p\/.*\.js/,
  /pubads\.g\.doubleclick\.net\/tag\/js\/gpt\.js/,
  /static\.criteo\.net\/js\/.*\/publishertag\.js/,
  /www\.googletagservices\.com\/tag\/js\/gpt\.js/,
  /pagead2\.googlesyndication\.com\/pagead\/js\/adsbygoogle\.js/,
  /cdn\.ampproject\.org\/v0\/amp-ad-\d+\.\d+\.js/,
];

/**
 * Checks if the given record was initiated by an inline script with
 * dependencies on any other resource.
 * That is, the record was initiated by another script insert a <script> tag
 * into the DOM using doc.write or body.appendChild, for example.
 * @param {NetworkRequest} record
 * @return {boolean}
 */
function initiatedByInlineScript(record) {
  if (record.initiator.type !== 'script') {
    // Initiated by some other means, e.g. preload link or static script tag.
    return false;
  }
  const initiators = PageDependencyGraph.getNetworkInitiators(record);
  if (initiators.length !== 1 || initiators[0] !== record.documentURL) {
    // Depends on some other script.
    return false;
  }
  return true;
}

/**
 * Finds requests for tags that could have been loaded statically but were not.
 * @param {LH.Artifacts} artifacts
 * @param {LH.Audit.Context} context
 * @return {Promise<NetworkRequest[]>}
 */
async function findStaticallyLoadableTags(artifacts, context) {
  const devtoolsLog = artifacts.devtoolsLogs[Audit.DEFAULT_PASS];
  const trace = artifacts.traces[Audit.DEFAULT_PASS];

  const tagReqs = [];

  // Next add any scripts that appear that they can be loaded statically based
  // on page analysis.
  const criticalRequests =
    await computeAdRequestWaterfall(trace, devtoolsLog, context);
  for (const {record} of criticalRequests) {
    if (!record || record.resourceType !== 'Script') {
      // Don't count resources that aren't scripts.
      continue;
    }
    if (initiatedByInlineScript(record) ||
      STATICALLY_LOADABLE_TAGS.find((t) => record.url.match(t))) {
      tagReqs.push(record);
    }
  }
  return tagReqs;
}

/** @inheritDoc */
class StaticAdTags extends Audit {
  /**
   * @return {LH.Audit.Meta}
   * @override
   */
  static get meta() {
    return {
      id: 'script-injected-tags',
      title: str_(UIStrings.title),
      failureTitle: str_(UIStrings.failureTitle),
      description: str_(UIStrings.description),
      requiredArtifacts: ['devtoolsLogs', 'traces'],
    };
  }

  /**
   * @param {LH.Artifacts} artifacts
   * @param {LH.Audit.Context} context
   * @return {Promise<LH.Audit.Product>}
   */
  static async audit(artifacts, context) {
    const tagReqs = await findStaticallyLoadableTags(artifacts, context);
    if (!tagReqs.length) {
      return auditNotApplicable.NoTag;
    }

    const seenUrls = new Set();
    const tableView = [];

    const devtoolsLog = artifacts.devtoolsLogs[Audit.DEFAULT_PASS];
    const trace = artifacts.traces[Audit.DEFAULT_PASS];
    const scriptTimes =
      await getScriptEvaluationTimes(trace, devtoolsLog, context);
    for (const tag of tagReqs) {
      if (seenUrls.has(tag.url)) continue;
      seenUrls.add(tag.url);
      const relatedTags = tagReqs.filter((t) => t.url === tag.url);

      const numStatic = array.count(
        relatedTags, (t) => t.initiator.type === 'parser' && !t.isLinkPreload);
      if (numStatic === 0) {
        const loadTime = scriptTimes.get(tag.url) || 0;
        if (loadTime < MINIMUM_LOAD_TIME_MS) {
          continue;
        }
        tableView.push({
          url: tag.url,
          loadTime,
        });
      }
    }
    tableView.sort((a, b) => a.loadTime - b.loadTime);

    const failed = tableView.length > 0;
    return {
      displayValue: failed ?
        str_(UIStrings.failureDisplayValue, {tags: tableView.length}) : '',
      score: Number(!failed),
      numericValue: tableView.length,
      numericUnit: 'unitless',
      details: StaticAdTags.makeTableDetails(HEADINGS, tableView),
    };
  }
}

module.exports = StaticAdTags;
module.exports.UIStrings = UIStrings;

}).call(this)}).call(this,"/node_modules/lighthouse-plugin-publisher-ads/audits/script-injected-tags.js")
},{"../messages/common-strings":198,"../utils/array.js":199,"../utils/graph":203,"../utils/network-timing":204,"lighthouse":78,"lighthouse/lighthouse-core/computed/page-dependency-graph":41,"lighthouse/lighthouse-core/lib/i18n/i18n":96}],"lighthouse-plugin-publisher-ads/audits/serial-header-bidding":[function(require,module,exports){
(function (__filename){(function (){
// Copyright 2018 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

const ComputedAdRequestTime = require('../computed/ad-request-time');
const i18n = require('lighthouse/lighthouse-core/lib/i18n/i18n');
// @ts-ignore
const MainResource = require('lighthouse/lighthouse-core/computed/main-resource');
const NetworkRecords = require('lighthouse/lighthouse-core/computed/network-records');
const {auditNotApplicable} = require('../messages/common-strings');
const {Audit} = require('lighthouse');
const {bucket} = require('../utils/array');
const {getTimingsByRecord} = require('../utils/network-timing');
const {isCacheable} = require('../utils/network');
const {isGoogleAds, getHeaderBidder} = require('../utils/resource-classification');
const {URL} = require('url');

/** @typedef {LH.Artifacts.NetworkRequest} NetworkRequest */
/** @typedef {LH.Gatherer.Simulation.NodeTiming} NodeTiming */

const UIStrings = {
  title: 'Header bidding is parallelized',
  failureTitle: 'Parallelize bid requests',
  description: 'Send header bidding requests simultaneously, rather than ' +
  'serially, to retrieve bids more quickly. [Learn more](' +
  'https://developers.google.com/publisher-ads-audits/reference/audits/serial-header-bidding' +
  ').',
  columnBidder: 'Bidder',
  columnUrl: 'URL',
  columnStartTime: 'Start',
  columnDuration: 'Duration',
};

const str_ = i18n.createMessageInstanceIdFn(__filename, UIStrings);

// Min record duration (s) to be considered a bid.
const MIN_BID_DURATION = .05;

/**
 * @typedef {Object} BidRequest
 * @property {string | boolean} bidder
 * @property {string} url
 * @property {number} startTime
 * @property {number} endTime
 * @property {number} duration
 */

/**
 * Table headings for audits details sections.
 * @type {LH.Audit.Details.Table['headings']}
 */
const HEADINGS = [
  {key: 'bidder', itemType: 'text', text: str_(UIStrings.columnBidder)},
  {key: 'url', itemType: 'url', text: str_(UIStrings.columnUrl)},
  {key: 'startTime', itemType: 'ms', text: str_(UIStrings.columnStartTime)},
  {key: 'duration', itemType: 'ms', text: str_(UIStrings.columnDuration)},
];

/**
 * Enum for type of request.
 * @readonly
 * @enum {string}
 */
const RequestType = {
  AD: 'ad',
  BID: 'bid',
  UNKNOWN: 'unknown',
};

/**
 * Makes shallow copy of records.
 * @param {Array<LH.Artifacts.NetworkRequest>} records
 * @param {string} recordType
 * @param {Map<NetworkRequest, NodeTiming>} timings
 * @return {Array<NetworkDetails.RequestRecord>}
 */
function constructRecords(records, recordType, timings) {
  /** @type {NetworkDetails.RequestRecord[]} */
  const results = [];
  for (const record of records) {
    const timing = timings.get(record);
    if (!timing) continue;
    results.push(Object.assign({}, timing, {
      url: record.url,
      type: recordType,
    }));
  }
  return results;
}

/**
 * Checks the type of record.
 * @param {LH.Artifacts.NetworkRequest} record
 * @return {string}
 */
function checkRecordType(record) {
  if (isGoogleAds(new URL(record.url))) {
    return RequestType.AD;
  } else if (getHeaderBidder(record.url)) {
    return RequestType.BID;
  } else {
    return RequestType.UNKNOWN;
  }
}

/**
 * Filter out requests without responses, image responses, and responses
 * taking less than 50ms.
 * @param {LH.Artifacts.NetworkRequest} rec
 * @return {boolean}
 */
function isPossibleBid(rec) {
  return (rec.resourceSize == null || rec.resourceSize > 0) &&
      (rec.resourceType != 'Image') &&
      (rec.endTime - rec.startTime >= MIN_BID_DURATION) &&
      !isCacheable(rec);
}

/**
 * Returns a copy of the given urls with the query string removed, if present.
 * @param {string} url
 * @return {string}
 */
function clearQueryString(url) {
  const u = new URL(url);
  u.search = '';
  return u.toString();
}


/**
 * Audit to check if serial header bidding occurs
 */
class SerialHeaderBidding extends Audit {
  /**
   * @return {LH.Audit.Meta}
   * @override
   */
  static get meta() {
    return {
      id: 'serial-header-bidding',
      title: str_(UIStrings.title),
      failureTitle: str_(UIStrings.failureTitle),
      description: str_(UIStrings.description),
      requiredArtifacts: ['devtoolsLogs', 'traces', 'URL'],
    };
  }

  /**
   * @param {LH.Artifacts} artifacts
   * @param {LH.Audit.Context} context
   * @return {Promise<LH.Audit.Product>}
   */
  static async audit(artifacts, context) {
    const devtoolsLog = artifacts.devtoolsLogs[Audit.DEFAULT_PASS];
    const trace = artifacts.traces[Audit.DEFAULT_PASS];
    const unfilteredNetworkRecords =
      await NetworkRecords.request(devtoolsLog, context);
    if (!unfilteredNetworkRecords.length) {
      return auditNotApplicable.NoRecords;
    }

    const mainResource =
        await MainResource.request({URL: artifacts.URL, devtoolsLog}, context);

    // Filter out requests without responses, image responses, and responses
    // taking less than 50ms.
    const networkRecords = unfilteredNetworkRecords
        .filter(isPossibleBid)
        .filter((r) => r.frameId == mainResource.frameId);

    // We filter for URLs that are related to header bidding.
    // Then we create shallow copies of each record. This is because the records
    // by default have circular structure, which causes an error to be thrown
    // when we return them unmodified in the details field of the audit.
    // So, we create objects that only have the relevant information, and return
    // in the details field.
    const recordsByType = bucket(networkRecords, checkRecordType);

    if (!recordsByType.has(RequestType.BID)) {
      return auditNotApplicable.NoBids;
    }

    const metricData = {trace, devtoolsLog, settings: context.settings};
    const {timing: adRequestTime} =
      await ComputedAdRequestTime.request(metricData, context);

    /** @type {Map<NetworkRequest, NodeTiming>} */
    const timingsByRecord = await getTimingsByRecord(
      trace, devtoolsLog, context);

    const headerBiddingRecords = constructRecords(
      recordsByType.get(RequestType.BID) || [], RequestType.BID,
      timingsByRecord);
    /** @type {NetworkDetails.RequestRecord[]} */
    let serialBids = [];
    let previousBid;

    // Iterate forward in order of start time.
    for (const record of headerBiddingRecords) {
      // We don't check the bid time against ad request time if there are no ad
      // requests.
      if (adRequestTime > 0 && record.endTime > adRequestTime) {
        continue;
      }
      record.bidder = getHeaderBidder(record.url);
      record.url = clearQueryString(record.url);

      if (previousBid && record.startTime >= previousBid.endTime) {
        serialBids.push(previousBid);
        serialBids.push(record);
      }
      // Point previousBid to the most the one with the earliest end time.
      if (!previousBid || record.endTime < previousBid.endTime ||
          // But move on if this bid does not overlap with the previous one.
          record.startTime >= previousBid.endTime) {
        previousBid = record;
      }
    }

    // De-dupe bid requests.
    serialBids = Array.from(new Set(serialBids));

    // At least two bids must be serial w.r.t. each other.
    const hasSerialHeaderBidding = serialBids.length > 1;
    return {
      numericValue: Number(hasSerialHeaderBidding),
      numericUnit: 'unitless',
      score: hasSerialHeaderBidding ? 0 : 1,
      details: hasSerialHeaderBidding ?
        SerialHeaderBidding.makeTableDetails(HEADINGS, serialBids) : undefined,
    };
  }
}

module.exports = SerialHeaderBidding;
module.exports.UIStrings = UIStrings;

}).call(this)}).call(this,"/node_modules/lighthouse-plugin-publisher-ads/audits/serial-header-bidding.js")
},{"../computed/ad-request-time":194,"../messages/common-strings":198,"../utils/array":199,"../utils/network":205,"../utils/network-timing":204,"../utils/resource-classification":206,"lighthouse":78,"lighthouse/lighthouse-core/computed/main-resource":14,"lighthouse/lighthouse-core/computed/network-records":40,"lighthouse/lighthouse-core/lib/i18n/i18n":96,"url":"url"}],"lighthouse-plugin-publisher-ads/audits/tag-load-time":[function(require,module,exports){
(function (__filename){(function (){
// Copyright 2018 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

const ComputedTagLoadTime = require('../computed/tag-load-time');
const i18n = require('lighthouse/lighthouse-core/lib/i18n/i18n');
const {auditNotApplicable, runWarning} = require('../messages/common-strings');
const {Audit} = require('lighthouse');

const UIStrings = {
  title: 'Tag load time',
  failureTitle: 'Reduce tag load time',
  description: 'This metric measures the time for the ad tag\'s ' +
  'implementation script (pubads_impl.js for GPT; adsbygoogle.js for ' +
  'AdSense) to load after the page loads. [Learn more](' +
  'https://developers.google.com/publisher-ads-audits/reference/audits/tag-load-time' +
  ').',
  displayValue: '{timeInMs, number, seconds} s',
};

const str_ = i18n.createMessageInstanceIdFn(__filename, UIStrings);

/**
 * Audit to determine time for tag to load relative to page start.
 */
class TagLoadTime extends Audit {
  /**
   * @return {LH.Audit.Meta}
   * @override
   */
  static get meta() {
    return {
      id: 'tag-load-time',
      title: str_(UIStrings.title),
      failureTitle: str_(UIStrings.failureTitle),
      description: str_(UIStrings.description),
      // @ts-ignore
      scoreDisplayMode: Audit.SCORING_MODES.NUMERIC,
      requiredArtifacts: ['devtoolsLogs', 'traces'],
    };
  }

  /**
   * @return {{
   *  simulate: LH.Audit.ScoreOptions, provided: LH.Audit.ScoreOptions
   * }}
   */
  static get defaultOptions() {
    return {
      simulate: {
        p10: 4350,
        median: 8000,
      },
      provided: {
        p10: 1200,
        median: 2000,
      },
    };
  }

  /**
   * @param {LH.Artifacts} artifacts
   * @param {LH.Audit.Context} context
   * @return {Promise<LH.Audit.Product>}
   */
  static async audit(artifacts, context) {
    const trace = artifacts.traces[Audit.DEFAULT_PASS];
    const devtoolsLog = artifacts.devtoolsLogs[Audit.DEFAULT_PASS];
    const metricData = {trace, devtoolsLog, settings: context.settings};
    const scoreOptions = context.options[
        context.settings.throttlingMethod == 'provided' ?
          'provided' :
          'simulate'
    ];

    const {timing} = await ComputedTagLoadTime.request(metricData, context);
    if (!(timing > 0)) { // Handle NaN, etc.
      const naAuditProduct = auditNotApplicable.NoTag;
      naAuditProduct.runWarnings = [runWarning.NoTag];
      return naAuditProduct;
    }

    // NOTE: score is relative to page response time to avoid counting time for
    // first party rendering.
    return {
      numericValue: timing,
      numericUnit: 'millisecond',
      score: Audit.computeLogNormalScore(
        scoreOptions,
        timing,
      ),
      displayValue: str_(UIStrings.displayValue, {timeInMs: timing}),
    };
  }
}
module.exports = TagLoadTime;
module.exports.UIStrings = UIStrings;

}).call(this)}).call(this,"/node_modules/lighthouse-plugin-publisher-ads/audits/tag-load-time.js")
},{"../computed/tag-load-time":197,"../messages/common-strings":198,"lighthouse":78,"lighthouse/lighthouse-core/lib/i18n/i18n":96}],"lighthouse-plugin-publisher-ads/audits/viewport-ad-density":[function(require,module,exports){
(function (__filename){(function (){
// Copyright 2018 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

const i18n = require('lighthouse/lighthouse-core/lib/i18n/i18n');
const {auditNotApplicable, auditError} = require('../messages/common-strings');
const {Audit} = require('lighthouse');
const {isAdIframe} = require('../utils/resource-classification');

const UIStrings = {
  title: 'Ad density is within recommended range',
  failureTitle: 'Reduce ad density',
  description: 'Ad density, the ads-to-content ratio, can impact user ' +
  'experience and ultimately user retention. The Better Ads ' +
  'Standard [recommends having an ad density below 30%]' +
  '(https://www.betterads.org/mobile-ad-density-higher-than-30/). ' +
  '[Learn more](' +
  'https://developers.google.com/publisher-ads-audits/reference/audits/viewport-ad-density' +
  ').',
  displayValue: '{adDensity, number, percent} ad density',
};

const str_ = i18n.createMessageInstanceIdFn(__filename, UIStrings);

/**
 * @param {LH.Artifacts.IFrameElement[]} slots
 * @param {LH.Artifacts.ViewportDimensions} viewport
 * @return {number}
 */
function computeAdLength(slots, viewport) {
  // We compute ad density along the vertical axis per the spec. On mobile
  // this is straightforward since we can assume single-column layouts, but not
  // so on desktop. On desktop we take a sample of various vertical lines and
  // return the greatest sum of ad heights along one of those lines.

  /** @type {Set<number>} */
  const scanLines = new Set([
    ...slots.map((s) => s.clientRect.left),
    ...slots.map((s) => s.clientRect.right),
  ].map((x) => Math.min(Math.max(1, x), viewport.innerWidth - 1)));

  slots = slots.sort((a, b) => a.clientRect.top !== b.clientRect.top ?
    a.clientRect.top - b.clientRect.top :
    a.clientRect.bottom - b.clientRect.bottom);

  let result = 0;
  for (const x of scanLines) {
    let adLengthAlongAxis = 0;
    let bottomSoFar = 0;
    for (const slot of slots) {
      if (x < slot.clientRect.left || x > slot.clientRect.right) {
        continue;
      }
      if (slot.isPositionFixed) {
        // Count position:fixed ads towards ad density even if they overlap.
        adLengthAlongAxis += slot.clientRect.height;
        continue;
      }
      // Else we exclude overlapping heights from density calculation.
      const delta =
        slot.clientRect.bottom - Math.max(bottomSoFar, slot.clientRect.top);
      if (delta > 0) {
        adLengthAlongAxis += delta;
      }
      bottomSoFar = Math.max(bottomSoFar, slot.clientRect.bottom);
    }
    result = Math.max(result, adLengthAlongAxis);
  }
  return result;
}

/** @inheritDoc */
class ViewportAdDensity extends Audit {
  /**
   * @return {AuditMetadata}
   * @override
   */
  static get meta() {
    return {
      id: 'viewport-ad-density',
      title: str_(UIStrings.title),
      failureTitle: str_(UIStrings.failureTitle),
      description: str_(UIStrings.description),
      requiredArtifacts: ['ViewportDimensions', 'IFrameElements'],
    };
  }

  /**
   * @override
   * @param {Artifacts} artifacts
   * @return {LH.Audit.Product}
   */
  static audit(artifacts) {
    const viewport = artifacts.ViewportDimensions;
    const slots = artifacts.IFrameElements.filter(
      (slot) => isAdIframe(slot) &&
      slot.clientRect.width * slot.clientRect.height > 1 );

    if (!slots.length) {
      return auditNotApplicable.NoVisibleSlots;
    }

    if (viewport.innerHeight <= 0) {
      throw new Error(auditError.ViewportAreaZero);
    }

    const adsLength = computeAdLength(slots, viewport);

    // We measure document length based on the bottom ad so that it isn't skewed
    // by lazy loading.
    const adsBottom =
      Math.max(...slots.map((s) => s.clientRect.top + s.clientRect.height / 2));
    // TODO(warrengm): Implement a DocumentDimensions gatherer to ensure that
    // we don't exceed the footer.
    const documentLength = adsBottom + viewport.innerHeight;

    const adDensity = Math.min(1, adsLength / documentLength);
    const score = adDensity > 0.3 ? 0 : 1;
    return {
      score,
      numericValue: adDensity,
      numericUnit: 'unitless',
      displayValue: str_(UIStrings.displayValue, {adDensity}),
    };
  }
}

module.exports = ViewportAdDensity;
module.exports.UIStrings = UIStrings;

}).call(this)}).call(this,"/node_modules/lighthouse-plugin-publisher-ads/audits/viewport-ad-density.js")
},{"../messages/common-strings":198,"../utils/resource-classification":206,"lighthouse":78,"lighthouse/lighthouse-core/lib/i18n/i18n":96}],"lighthouse-plugin-publisher-ads":[function(require,module,exports){
(function (__filename){(function (){
// Copyright 2018 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

const i18n = require('lighthouse/lighthouse-core/lib/i18n/i18n');
const {group} = require('./messages/common-strings');

const PLUGIN_PATH = 'lighthouse-plugin-publisher-ads';

const UIStrings = {
  categoryDescription: 'A Lighthouse plugin to improve ad speed and overall quality that is targeted at sites using GPT or AdSense tag. ' +
      '[Learn more](https://developers.google.com/publisher-ads-audits/reference)',
};
const str_ = i18n.createMessageInstanceIdFn(__filename, UIStrings);

/** @type {LH.Config.Plugin} */
module.exports = {
  audits: [
    {path: `${PLUGIN_PATH}/audits/ad-blocking-tasks`},
    {path: `${PLUGIN_PATH}/audits/ad-render-blocking-resources`},
    {path: `${PLUGIN_PATH}/audits/ad-request-critical-path`},
    {path: `${PLUGIN_PATH}/audits/bid-request-from-page-start`},
    {path: `${PLUGIN_PATH}/audits/ad-request-from-page-start`},
    {path: `${PLUGIN_PATH}/audits/ad-top-of-viewport`},
    {path: `${PLUGIN_PATH}/audits/ads-in-viewport`},
    {path: `${PLUGIN_PATH}/audits/async-ad-tags`},
    {path: `${PLUGIN_PATH}/audits/blocking-load-events`},
    {path: `${PLUGIN_PATH}/audits/bottleneck-requests`},
    {path: `${PLUGIN_PATH}/audits/duplicate-tags`},
    {path: `${PLUGIN_PATH}/audits/first-ad-render`},
    {path: `${PLUGIN_PATH}/audits/full-width-slots`},
    {path: `${PLUGIN_PATH}/audits/gpt-bids-parallel`},
    {path: `${PLUGIN_PATH}/audits/loads-gpt-from-official-source`},
    {path: `${PLUGIN_PATH}/audits/loads-ad-tag-over-https`},
    {path: `${PLUGIN_PATH}/audits/script-injected-tags`},
    {path: `${PLUGIN_PATH}/audits/serial-header-bidding`},
    {path: `${PLUGIN_PATH}/audits/tag-load-time`},
    {path: `${PLUGIN_PATH}/audits/viewport-ad-density`},
    {path: `${PLUGIN_PATH}/audits/cumulative-ad-shift`},
    {path: `${PLUGIN_PATH}/audits/deprecated-api-usage`},
    {path: `${PLUGIN_PATH}/audits/gpt-errors-overall`},
  ],
  groups: {
    'metrics': {
      title: group.Metrics,
    },
    'ads-performance': {
      title: group.AdsPerformance,
    },
    'ads-best-practices': {
      title: group.AdsBestPractices,
    },
  },
  category: {
    title: 'Publisher Ads',
    description: str_(UIStrings.categoryDescription),
    auditRefs: [
      // Measurements group.
      {id: 'tag-load-time', weight: 5, group: 'metrics'},
      {id: 'bid-request-from-page-start', weight: 5, group: 'metrics'},
      {id: 'ad-request-from-page-start', weight: 25, group: 'metrics'},
      {id: 'first-ad-render', weight: 10, group: 'metrics'},
      {id: 'cumulative-ad-shift', weight: 5, group: 'metrics'},
      // Performance group.
      {id: 'gpt-bids-parallel', weight: 1, group: 'ads-performance'},
      {id: 'serial-header-bidding', weight: 1, group: 'ads-performance'},
      {id: 'bottleneck-requests', weight: 1, group: 'ads-performance'},
      {id: 'script-injected-tags', weight: 1, group: 'ads-performance'},
      {id: 'blocking-load-events', weight: 1, group: 'ads-performance'},
      {id: 'ad-render-blocking-resources', weight: 1, group: 'ads-performance'},
      {id: 'ad-blocking-tasks', weight: 1, group: 'ads-performance'},
      {id: 'ad-request-critical-path', weight: 0, group: 'ads-performance'},
      // Best Practices group.
      {id: 'ads-in-viewport', weight: 4, group: 'ads-best-practices'},
      {id: 'async-ad-tags', weight: 2, group: 'ads-best-practices'},
      {id: 'loads-ad-tag-over-https', weight: 1, group: 'ads-best-practices'},
      {id: 'loads-gpt-from-official-source', weight: 4, group: 'ads-best-practices'},
      {id: 'viewport-ad-density', weight: 2, group: 'ads-best-practices'},
      {id: 'ad-top-of-viewport', weight: 2, group: 'ads-best-practices'},
      {id: 'duplicate-tags', weight: 1, group: 'ads-best-practices'},
      {id: 'deprecated-gpt-api-usage', weight: 0, group: 'ads-best-practices'},
      {id: 'gpt-errors-overall', weight: 0, group: 'ads-best-practices'},
    ],
  },
};

// @ts-ignore Use `defineProperty` so that the strings can be referenced but not
// iterated over (i.e. set enumerable=false). Otherwise the config would be
// invalid for having additional keys.
Object.defineProperty(module.exports, 'UIStrings', {
  enumerable: false,
  get: () => UIStrings,
});

}).call(this)}).call(this,"/node_modules/lighthouse-plugin-publisher-ads/plugin.js")
},{"./messages/common-strings":198,"lighthouse/lighthouse-core/lib/i18n/i18n":96}],"url":[function(require,module,exports){
/**
 * @license Copyright 2016 The Lighthouse Authors. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.
 */
'use strict';

/**
 * URL shim so we keep our code DRY
 */

const Util = require('../util-commonjs.js');

/** @typedef {import('./network-request.js')} NetworkRequest */

const allowedProtocols = [
  'https:', 'http:', 'chrome:', 'chrome-extension:',
];

const SECURE_SCHEMES = ['data', 'https', 'wss', 'blob', 'chrome', 'chrome-extension', 'about',
  'filesystem'];
const SECURE_LOCALHOST_DOMAINS = ['localhost', '127.0.0.1'];
const NON_NETWORK_SCHEMES = ['blob', 'data', 'intent'];

/**
 * There is fancy URL rewriting logic for the chrome://settings page that we need to work around.
 * Why? Special handling was added by Chrome team to allow a pushState transition between chrome:// pages.
 * As a result, the network URL (chrome://chrome/settings/) doesn't match the final document URL (chrome://settings/).
 * @param {string} url
 * @return {string}
 */
function rewriteChromeInternalUrl(url) {
  if (!url || !url.startsWith('chrome://')) return url;
  // Chrome adds a trailing slash to `chrome://` URLs, but the spec does not.
  //   https://github.com/GoogleChrome/lighthouse/pull/3941#discussion_r154026009
  if (url.endsWith('/')) url = url.replace(/\/$/, '');
  return url.replace(/^chrome:\/\/chrome\//, 'chrome://');
}

// URL is global as of node 10. https://nodejs.org/api/globals.html#globals_url
class URLShim extends URL {
  /**
   * @param {string} url
   * @return {boolean}
   */
  static isValid(url) {
    try {
      new URL(url);
      return true;
    } catch (e) {
      return false;
    }
  }

  /**
   * @param {string} urlA
   * @param {string} urlB
   * @return {boolean}
   */
  static hostsMatch(urlA, urlB) {
    try {
      return new URL(urlA).host === new URL(urlB).host;
    } catch (e) {
      return false;
    }
  }

  /**
   * @param {string} urlA
   * @param {string} urlB
   * @return {boolean}
   */
  static originsMatch(urlA, urlB) {
    try {
      return new URL(urlA).origin === new URL(urlB).origin;
    } catch (e) {
      return false;
    }
  }

  /**
   * @param {string} url
   * @return {?string}
   */
  static getOrigin(url) {
    try {
      const urlInfo = new URL(url);
      // check for both host and origin since some URLs schemes like data and file set origin to the
      // string "null" instead of the object
      return (urlInfo.host && urlInfo.origin) || null;
    } catch (e) {
      return null;
    }
  }

  /**
   * Check if rootDomains matches
   *
   * @param {string|URL} urlA
   * @param {string|URL} urlB
   */
  static rootDomainsMatch(urlA, urlB) {
    let urlAInfo;
    let urlBInfo;
    try {
      urlAInfo = Util.createOrReturnURL(urlA);
      urlBInfo = Util.createOrReturnURL(urlB);
    } catch (err) {
      return false;
    }

    if (!urlAInfo.hostname || !urlBInfo.hostname) {
      return false;
    }

    // get the string before the tld
    const urlARootDomain = Util.getRootDomain(urlAInfo);
    const urlBRootDomain = Util.getRootDomain(urlBInfo);

    return urlARootDomain === urlBRootDomain;
  }

  /**
   * @param {string} url
   * @param {{numPathParts: number, preserveQuery: boolean, preserveHost: boolean}=} options
   * @return {string}
   */
  static getURLDisplayName(url, options) {
    return Util.getURLDisplayName(new URL(url), options);
  }

  /**
   * Limits data URIs to 100 characters, returns all other strings untouched.
   * @param {string} url
   * @return {string}
   */
  static elideDataURI(url) {
    try {
      const parsed = new URL(url);
      return parsed.protocol === 'data:' ? url.slice(0, 100) : url;
    } catch (e) {
      return url;
    }
  }

  /**
   * Determine if url1 equals url2, ignoring URL fragments.
   * @param {string} url1
   * @param {string} url2
   * @return {boolean}
   */
  static equalWithExcludedFragments(url1, url2) {
    [url1, url2] = [url1, url2].map(rewriteChromeInternalUrl);
    try {
      const urla = new URL(url1);
      urla.hash = '';

      const urlb = new URL(url2);
      urlb.hash = '';

      return urla.href === urlb.href;
    } catch (e) {
      return false;
    }
  }

  /**
   * Determine if the url has a protocol that we're able to test
   * @param {string} url
   * @return {boolean}
   */
  static isProtocolAllowed(url) {
    try {
      const parsed = new URL(url);
      return allowedProtocols.includes(parsed.protocol);
    } catch (e) {
      return false;
    }
  }

  /**
   * Is the host localhost-enough to satisfy the "secure context" definition
   * https://github.com/GoogleChrome/lighthouse/pull/11766#discussion_r582340683
   * @param {string} hostname Either a `new URL(url).hostname` or a `networkRequest.parsedUrl.host`
   * @return {boolean}
   */
  static isLikeLocalhost(hostname) {
    // Any hostname terminating in `.localhost` is considered to be local.
    // https://w3c.github.io/webappsec-secure-contexts/#localhost
    // This method doesn't consider IPs that resolve to loopback, IPv6 or other loopback edgecases
    return SECURE_LOCALHOST_DOMAINS.includes(hostname) || hostname.endsWith('.localhost');
  }

  /**
   * @param {NetworkRequest['parsedURL']['scheme']} scheme
   * @return {boolean}
   */
  static isSecureScheme(scheme) {
    return SECURE_SCHEMES.includes(scheme);
  }

  /**
   * Use `NetworkRequest.isNonNetworkRequest(req)` if working with a request.
   * Note: the `protocol` field from CDP can be 'h2', 'http', (not 'https'!) or it'll be url's scheme.
   *   https://source.chromium.org/chromium/chromium/src/+/main:content/browser/devtools/protocol/network_handler.cc;l=598-611;drc=56d4a9a9deb30be73adcee8737c73bcb2a5ab64f
   * However, a `new URL(href).protocol` has a colon suffix.
   *   https://url.spec.whatwg.org/#dom-url-protocol
   * A URL's `scheme` is specced as the `protocol` sans-colon, but isn't exposed on a URL object.
   * This method can take all 3 of these string types as a parameter.
   * @param {NetworkRequest['protocol'] | URL['protocol']} protocol Either a networkRequest's `protocol` per CDP or a `new URL(href).protocol`
   * @return {boolean}
   */
  static isNonNetworkProtocol(protocol) {
    // Strip off any colon
    const urlScheme = protocol.includes(':') ? protocol.slice(0, protocol.indexOf(':')) : protocol;
    return NON_NETWORK_SCHEMES.includes(urlScheme);
  }

  /**
   * @param {string} src
   * @return {string|undefined}
   */
  static guessMimeType(src) {
    let url;
    try {
      url = new URL(src);
    } catch {
      return undefined;
    }

    if (url.protocol === 'data:') {
      const match = url.pathname.match(/image\/(png|jpeg|svg\+xml|webp|gif|avif)(?=;)/);
      if (!match) return undefined;
      return match[0];
    }

    const match = url.pathname.toLowerCase().match(/\.(png|jpeg|jpg|svg|webp|gif|avif)$/);
    if (!match) return undefined;

    const ext = match[1];
    if (ext === 'svg') return 'image/svg+xml';
    if (ext === 'jpg') return 'image/jpeg';
    return `image/${ext}`;
  }
}

URLShim.URL = URL;

URLShim.INVALID_URL_DEBUG_STRING =
    'Lighthouse was unable to determine the URL of some script executions. ' +
    'It\'s possible a Chrome extension or other eval\'d code is the source.';

module.exports = URLShim;

},{"../util-commonjs.js":124}]},{},[1]);
