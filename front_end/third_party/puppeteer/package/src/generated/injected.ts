/**
 * JavaScript code that provides the puppeteer utilities. See the
 * [README](https://github.com/puppeteer/puppeteer/blob/main/src/injected/README.md)
 * for injection for more information.
 *
 * @internal
 */
export const source = "\"use strict\";\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __export = (target, all) => {\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\nvar __copyProps = (to, from, except, desc) => {\n  if (from && typeof from === \"object\" || typeof from === \"function\") {\n    for (let key of __getOwnPropNames(from))\n      if (!__hasOwnProp.call(to, key) && key !== except)\n        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });\n  }\n  return to;\n};\nvar __toCommonJS = (mod) => __copyProps(__defProp({}, \"__esModule\", { value: true }), mod);\n\n// src/injected/injected.ts\nvar injected_exports = {};\n__export(injected_exports, {\n  default: () => injected_default\n});\nmodule.exports = __toCommonJS(injected_exports);\n\n// src/common/Errors.ts\nvar CustomError = class extends Error {\n  /**\n   * @internal\n   */\n  constructor(message) {\n    super(message);\n    this.name = this.constructor.name;\n    Error.captureStackTrace(this, this.constructor);\n  }\n};\nvar TimeoutError = class extends CustomError {\n};\nvar ProtocolError = class extends CustomError {\n  #code;\n  #originalMessage = \"\";\n  set code(code) {\n    this.#code = code;\n  }\n  /**\n   * @readonly\n   * @public\n   */\n  get code() {\n    return this.#code;\n  }\n  set originalMessage(originalMessage) {\n    this.#originalMessage = originalMessage;\n  }\n  /**\n   * @readonly\n   * @public\n   */\n  get originalMessage() {\n    return this.#originalMessage;\n  }\n};\nvar errors = Object.freeze({\n  TimeoutError,\n  ProtocolError\n});\n\n// src/util/Deferred.ts\nvar Deferred = class {\n  #isResolved = false;\n  #isRejected = false;\n  #value;\n  #resolver = () => {\n  };\n  #taskPromise = new Promise((resolve) => {\n    this.#resolver = resolve;\n  });\n  #timeoutId;\n  constructor(opts) {\n    this.#timeoutId = opts && opts.timeout > 0 ? setTimeout(() => {\n      this.reject(new TimeoutError(opts.message));\n    }, opts.timeout) : void 0;\n  }\n  #finish(value) {\n    clearTimeout(this.#timeoutId);\n    this.#value = value;\n    this.#resolver();\n  }\n  resolve(value) {\n    if (this.#isRejected || this.#isResolved) {\n      return;\n    }\n    this.#isResolved = true;\n    this.#finish(value);\n  }\n  reject(error) {\n    if (this.#isRejected || this.#isResolved) {\n      return;\n    }\n    this.#isRejected = true;\n    this.#finish(error);\n  }\n  resolved() {\n    return this.#isResolved;\n  }\n  finished() {\n    return this.#isResolved || this.#isRejected;\n  }\n  value() {\n    return this.#value;\n  }\n  async valueOrThrow() {\n    await this.#taskPromise;\n    if (this.#isRejected) {\n      throw this.#value;\n    }\n    return this.#value;\n  }\n  static create(opts) {\n    return new Deferred(opts);\n  }\n  static async race(awaitables) {\n    const deferredWithTimeout = /* @__PURE__ */ new Set();\n    try {\n      const promises = awaitables.map((value) => {\n        if (value instanceof Deferred) {\n          if (value.#timeoutId) {\n            deferredWithTimeout.add(value);\n          }\n          return value.valueOrThrow();\n        }\n        return value;\n      });\n      return await Promise.race(promises);\n    } finally {\n      for (const deferred of deferredWithTimeout) {\n        deferred.reject(new Error(\"Timeout cleared\"));\n      }\n    }\n  }\n};\n\n// src/util/Function.ts\nvar createdFunctions = /* @__PURE__ */ new Map();\nvar createFunction = (functionValue) => {\n  let fn = createdFunctions.get(functionValue);\n  if (fn) {\n    return fn;\n  }\n  fn = new Function(`return ${functionValue}`)();\n  createdFunctions.set(functionValue, fn);\n  return fn;\n};\n\n// src/injected/ARIAQuerySelector.ts\nvar ARIAQuerySelector_exports = {};\n__export(ARIAQuerySelector_exports, {\n  ariaQuerySelector: () => ariaQuerySelector,\n  ariaQuerySelectorAll: () => ariaQuerySelectorAll\n});\nvar ariaQuerySelector = (root, selector) => {\n  return window.__ariaQuerySelector(root, selector);\n};\nvar ariaQuerySelectorAll = async function* (root, selector) {\n  yield* await window.__ariaQuerySelectorAll(root, selector);\n};\n\n// src/injected/CustomQuerySelector.ts\nvar CustomQuerySelector_exports = {};\n__export(CustomQuerySelector_exports, {\n  customQuerySelectors: () => customQuerySelectors\n});\nvar CustomQuerySelectorRegistry = class {\n  #selectors = /* @__PURE__ */ new Map();\n  register(name, handler) {\n    if (!handler.queryOne && handler.queryAll) {\n      const querySelectorAll = handler.queryAll;\n      handler.queryOne = (node, selector) => {\n        for (const result of querySelectorAll(node, selector)) {\n          return result;\n        }\n        return null;\n      };\n    } else if (handler.queryOne && !handler.queryAll) {\n      const querySelector = handler.queryOne;\n      handler.queryAll = (node, selector) => {\n        const result = querySelector(node, selector);\n        return result ? [result] : [];\n      };\n    } else if (!handler.queryOne || !handler.queryAll) {\n      throw new Error(\"At least one query method must be defined.\");\n    }\n    this.#selectors.set(name, {\n      querySelector: handler.queryOne,\n      querySelectorAll: handler.queryAll\n    });\n  }\n  unregister(name) {\n    this.#selectors.delete(name);\n  }\n  get(name) {\n    return this.#selectors.get(name);\n  }\n  clear() {\n    this.#selectors.clear();\n  }\n};\nvar customQuerySelectors = new CustomQuerySelectorRegistry();\n\n// src/injected/PierceQuerySelector.ts\nvar PierceQuerySelector_exports = {};\n__export(PierceQuerySelector_exports, {\n  pierceQuerySelector: () => pierceQuerySelector,\n  pierceQuerySelectorAll: () => pierceQuerySelectorAll\n});\nvar pierceQuerySelector = (root, selector) => {\n  let found = null;\n  const search = (root2) => {\n    const iter = document.createTreeWalker(root2, NodeFilter.SHOW_ELEMENT);\n    do {\n      const currentNode = iter.currentNode;\n      if (currentNode.shadowRoot) {\n        search(currentNode.shadowRoot);\n      }\n      if (currentNode instanceof ShadowRoot) {\n        continue;\n      }\n      if (currentNode !== root2 && !found && currentNode.matches(selector)) {\n        found = currentNode;\n      }\n    } while (!found && iter.nextNode());\n  };\n  if (root instanceof Document) {\n    root = root.documentElement;\n  }\n  search(root);\n  return found;\n};\nvar pierceQuerySelectorAll = (element, selector) => {\n  const result = [];\n  const collect = (root) => {\n    const iter = document.createTreeWalker(root, NodeFilter.SHOW_ELEMENT);\n    do {\n      const currentNode = iter.currentNode;\n      if (currentNode.shadowRoot) {\n        collect(currentNode.shadowRoot);\n      }\n      if (currentNode instanceof ShadowRoot) {\n        continue;\n      }\n      if (currentNode !== root && currentNode.matches(selector)) {\n        result.push(currentNode);\n      }\n    } while (iter.nextNode());\n  };\n  if (element instanceof Document) {\n    element = element.documentElement;\n  }\n  collect(element);\n  return result;\n};\n\n// src/util/assert.ts\nvar assert = (value, message) => {\n  if (!value) {\n    throw new Error(message);\n  }\n};\n\n// src/injected/Poller.ts\nvar MutationPoller = class {\n  #fn;\n  #root;\n  #observer;\n  #deferred;\n  constructor(fn, root) {\n    this.#fn = fn;\n    this.#root = root;\n  }\n  async start() {\n    const deferred = this.#deferred = Deferred.create();\n    const result = await this.#fn();\n    if (result) {\n      deferred.resolve(result);\n      return;\n    }\n    this.#observer = new MutationObserver(async () => {\n      const result2 = await this.#fn();\n      if (!result2) {\n        return;\n      }\n      deferred.resolve(result2);\n      await this.stop();\n    });\n    this.#observer.observe(this.#root, {\n      childList: true,\n      subtree: true,\n      attributes: true\n    });\n  }\n  async stop() {\n    assert(this.#deferred, \"Polling never started.\");\n    if (!this.#deferred.finished()) {\n      this.#deferred.reject(new Error(\"Polling stopped\"));\n    }\n    if (this.#observer) {\n      this.#observer.disconnect();\n      this.#observer = void 0;\n    }\n  }\n  result() {\n    assert(this.#deferred, \"Polling never started.\");\n    return this.#deferred.valueOrThrow();\n  }\n};\nvar RAFPoller = class {\n  #fn;\n  #deferred;\n  constructor(fn) {\n    this.#fn = fn;\n  }\n  async start() {\n    const deferred = this.#deferred = Deferred.create();\n    const result = await this.#fn();\n    if (result) {\n      deferred.resolve(result);\n      return;\n    }\n    const poll = async () => {\n      if (deferred.finished()) {\n        return;\n      }\n      const result2 = await this.#fn();\n      if (!result2) {\n        window.requestAnimationFrame(poll);\n        return;\n      }\n      deferred.resolve(result2);\n      await this.stop();\n    };\n    window.requestAnimationFrame(poll);\n  }\n  async stop() {\n    assert(this.#deferred, \"Polling never started.\");\n    if (!this.#deferred.finished()) {\n      this.#deferred.reject(new Error(\"Polling stopped\"));\n    }\n  }\n  result() {\n    assert(this.#deferred, \"Polling never started.\");\n    return this.#deferred.valueOrThrow();\n  }\n};\nvar IntervalPoller = class {\n  #fn;\n  #ms;\n  #interval;\n  #deferred;\n  constructor(fn, ms) {\n    this.#fn = fn;\n    this.#ms = ms;\n  }\n  async start() {\n    const deferred = this.#deferred = Deferred.create();\n    const result = await this.#fn();\n    if (result) {\n      deferred.resolve(result);\n      return;\n    }\n    this.#interval = setInterval(async () => {\n      const result2 = await this.#fn();\n      if (!result2) {\n        return;\n      }\n      deferred.resolve(result2);\n      await this.stop();\n    }, this.#ms);\n  }\n  async stop() {\n    assert(this.#deferred, \"Polling never started.\");\n    if (!this.#deferred.finished()) {\n      this.#deferred.reject(new Error(\"Polling stopped\"));\n    }\n    if (this.#interval) {\n      clearInterval(this.#interval);\n      this.#interval = void 0;\n    }\n  }\n  result() {\n    assert(this.#deferred, \"Polling never started.\");\n    return this.#deferred.valueOrThrow();\n  }\n};\n\n// src/injected/PQuerySelector.ts\nvar PQuerySelector_exports = {};\n__export(PQuerySelector_exports, {\n  pQuerySelector: () => pQuerySelector,\n  pQuerySelectorAll: () => pQuerySelectorAll\n});\n\n// src/util/AsyncIterableUtil.ts\nvar AsyncIterableUtil = class {\n  static async *map(iterable, map) {\n    for await (const value of iterable) {\n      yield await map(value);\n    }\n  }\n  static async *flatMap(iterable, map) {\n    for await (const value of iterable) {\n      yield* map(value);\n    }\n  }\n  static async collect(iterable) {\n    const result = [];\n    for await (const value of iterable) {\n      result.push(value);\n    }\n    return result;\n  }\n  static async first(iterable) {\n    for await (const value of iterable) {\n      return value;\n    }\n    return;\n  }\n};\n\n// ../../node_modules/parsel-js/dist/parsel.js\nvar TOKENS = {\n  attribute: /\\[\\s*(?:(?<namespace>\\*|[-\\w\\P{ASCII}]*)\\|)?(?<name>[-\\w\\P{ASCII}]+)\\s*(?:(?<operator>\\W?=)\\s*(?<value>.+?)\\s*(\\s(?<caseSensitive>[iIsS]))?\\s*)?\\]/gu,\n  id: /#(?<name>[-\\w\\P{ASCII}]+)/gu,\n  class: /\\.(?<name>[-\\w\\P{ASCII}]+)/gu,\n  comma: /\\s*,\\s*/g,\n  combinator: /\\s*[\\s>+~]\\s*/g,\n  \"pseudo-element\": /::(?<name>[-\\w\\P{ASCII}]+)(?:\\((?<argument>¶+)\\))?/gu,\n  \"pseudo-class\": /:(?<name>[-\\w\\P{ASCII}]+)(?:\\((?<argument>¶+)\\))?/gu,\n  universal: /(?:(?<namespace>\\*|[-\\w\\P{ASCII}]*)\\|)?\\*/gu,\n  type: /(?:(?<namespace>\\*|[-\\w\\P{ASCII}]*)\\|)?(?<name>[-\\w\\P{ASCII}]+)/gu\n  // this must be last\n};\nvar TRIM_TOKENS = /* @__PURE__ */ new Set([\"combinator\", \"comma\"]);\nvar getArgumentPatternByType = (type) => {\n  switch (type) {\n    case \"pseudo-element\":\n    case \"pseudo-class\":\n      return new RegExp(TOKENS[type].source.replace(\"(?<argument>\\xB6+)\", \"(?<argument>.+)\"), \"gu\");\n    default:\n      return TOKENS[type];\n  }\n};\nfunction gobbleParens(text, offset) {\n  let nesting = 0;\n  let result = \"\";\n  for (; offset < text.length; offset++) {\n    const char = text[offset];\n    switch (char) {\n      case \"(\":\n        ++nesting;\n        break;\n      case \")\":\n        --nesting;\n        break;\n    }\n    result += char;\n    if (nesting === 0) {\n      return result;\n    }\n  }\n  return result;\n}\nfunction tokenizeBy(text, grammar = TOKENS) {\n  if (!text) {\n    return [];\n  }\n  const tokens = [text];\n  for (const [type, pattern] of Object.entries(grammar)) {\n    for (let i = 0; i < tokens.length; i++) {\n      const token = tokens[i];\n      if (typeof token !== \"string\") {\n        continue;\n      }\n      pattern.lastIndex = 0;\n      const match = pattern.exec(token);\n      if (!match) {\n        continue;\n      }\n      const from = match.index - 1;\n      const args = [];\n      const content = match[0];\n      const before = token.slice(0, from + 1);\n      if (before) {\n        args.push(before);\n      }\n      args.push({\n        ...match.groups,\n        type,\n        content\n      });\n      const after = token.slice(from + content.length + 1);\n      if (after) {\n        args.push(after);\n      }\n      tokens.splice(i, 1, ...args);\n    }\n  }\n  let offset = 0;\n  for (const token of tokens) {\n    switch (typeof token) {\n      case \"string\":\n        throw new Error(`Unexpected sequence ${token} found at index ${offset}`);\n      case \"object\":\n        offset += token.content.length;\n        token.pos = [offset - token.content.length, offset];\n        if (TRIM_TOKENS.has(token.type)) {\n          token.content = token.content.trim() || \" \";\n        }\n        break;\n    }\n  }\n  return tokens;\n}\nvar STRING_PATTERN = /(['\"])([^\\\\\\n]+?)\\1/g;\nvar ESCAPE_PATTERN = /\\\\./g;\nfunction tokenize(selector, grammar = TOKENS) {\n  selector = selector.trim();\n  if (selector === \"\") {\n    return [];\n  }\n  const replacements = [];\n  selector = selector.replace(ESCAPE_PATTERN, (value, offset) => {\n    replacements.push({ value, offset });\n    return \"\\uE000\".repeat(value.length);\n  });\n  selector = selector.replace(STRING_PATTERN, (value, quote, content, offset) => {\n    replacements.push({ value, offset });\n    return `${quote}${\"\\uE001\".repeat(content.length)}${quote}`;\n  });\n  {\n    let pos = 0;\n    let offset;\n    while ((offset = selector.indexOf(\"(\", pos)) > -1) {\n      const value = gobbleParens(selector, offset);\n      replacements.push({ value, offset });\n      selector = `${selector.substring(0, offset)}(${\"\\xB6\".repeat(value.length - 2)})${selector.substring(offset + value.length)}`;\n      pos = offset + value.length;\n    }\n  }\n  const tokens = tokenizeBy(selector, grammar);\n  const changedTokens = /* @__PURE__ */ new Set();\n  for (const replacement of replacements.reverse()) {\n    for (const token of tokens) {\n      const { offset, value } = replacement;\n      if (!(token.pos[0] <= offset && offset + value.length <= token.pos[1])) {\n        continue;\n      }\n      const { content } = token;\n      const tokenOffset = offset - token.pos[0];\n      token.content = content.slice(0, tokenOffset) + value + content.slice(tokenOffset + value.length);\n      if (token.content !== content) {\n        changedTokens.add(token);\n      }\n    }\n  }\n  for (const token of changedTokens) {\n    const pattern = getArgumentPatternByType(token.type);\n    if (!pattern) {\n      throw new Error(`Unknown token type: ${token.type}`);\n    }\n    pattern.lastIndex = 0;\n    const match = pattern.exec(token.content);\n    if (!match) {\n      throw new Error(`Unable to parse content for ${token.type}: ${token.content}`);\n    }\n    Object.assign(token, match.groups);\n  }\n  return tokens;\n}\nfunction* flatten(node, parent) {\n  switch (node.type) {\n    case \"list\":\n      for (let child of node.list) {\n        yield* flatten(child, node);\n      }\n      break;\n    case \"complex\":\n      yield* flatten(node.left, node);\n      yield* flatten(node.right, node);\n      break;\n    case \"compound\":\n      yield* node.list.map((token) => [token, node]);\n      break;\n    default:\n      yield [node, parent];\n  }\n}\nfunction stringify(listOrNode) {\n  let tokens;\n  if (Array.isArray(listOrNode)) {\n    tokens = listOrNode;\n  } else {\n    tokens = [...flatten(listOrNode)].map(([token]) => token);\n  }\n  return tokens.map((token) => token.content).join(\"\");\n}\n\n// src/injected/PSelectorParser.ts\nTOKENS[\"combinator\"] = /\\s*(>>>>?|[\\s>+~])\\s*/g;\nvar ESCAPE_REGEXP = /\\\\[\\s\\S]/g;\nvar unquote = (text) => {\n  if (text.length > 1) {\n    for (const char of ['\"', \"'\"]) {\n      if (!text.startsWith(char) || !text.endsWith(char)) {\n        continue;\n      }\n      return text.slice(char.length, -char.length).replace(ESCAPE_REGEXP, (match) => {\n        return match.slice(1);\n      });\n    }\n  }\n  return text;\n};\nfunction parsePSelectors(selector) {\n  let isPureCSS = true;\n  const tokens = tokenize(selector);\n  if (tokens.length === 0) {\n    return [[], isPureCSS];\n  }\n  let compoundSelector = [];\n  let complexSelector = [compoundSelector];\n  const selectors = [complexSelector];\n  const storage = [];\n  for (const token of tokens) {\n    switch (token.type) {\n      case \"combinator\":\n        switch (token.content) {\n          case \">>>\" /* Descendent */:\n            isPureCSS = false;\n            if (storage.length) {\n              compoundSelector.push(stringify(storage));\n              storage.splice(0);\n            }\n            compoundSelector = [];\n            complexSelector.push(\">>>\" /* Descendent */);\n            complexSelector.push(compoundSelector);\n            continue;\n          case \">>>>\" /* Child */:\n            isPureCSS = false;\n            if (storage.length) {\n              compoundSelector.push(stringify(storage));\n              storage.splice(0);\n            }\n            compoundSelector = [];\n            complexSelector.push(\">>>>\" /* Child */);\n            complexSelector.push(compoundSelector);\n            continue;\n        }\n        break;\n      case \"pseudo-element\":\n        if (!token.name.startsWith(\"-p-\")) {\n          break;\n        }\n        isPureCSS = false;\n        if (storage.length) {\n          compoundSelector.push(stringify(storage));\n          storage.splice(0);\n        }\n        compoundSelector.push({\n          name: token.name.slice(3),\n          value: unquote(token.argument ?? \"\")\n        });\n        continue;\n      case \"comma\":\n        if (storage.length) {\n          compoundSelector.push(stringify(storage));\n          storage.splice(0);\n        }\n        compoundSelector = [];\n        complexSelector = [compoundSelector];\n        selectors.push(complexSelector);\n        continue;\n    }\n    storage.push(token);\n  }\n  if (storage.length) {\n    compoundSelector.push(stringify(storage));\n  }\n  return [selectors, isPureCSS];\n}\n\n// src/injected/TextQuerySelector.ts\nvar TextQuerySelector_exports = {};\n__export(TextQuerySelector_exports, {\n  textQuerySelectorAll: () => textQuerySelectorAll\n});\n\n// src/injected/TextContent.ts\nvar TRIVIAL_VALUE_INPUT_TYPES = /* @__PURE__ */ new Set([\"checkbox\", \"image\", \"radio\"]);\nvar isNonTrivialValueNode = (node) => {\n  if (node instanceof HTMLSelectElement) {\n    return true;\n  }\n  if (node instanceof HTMLTextAreaElement) {\n    return true;\n  }\n  if (node instanceof HTMLInputElement && !TRIVIAL_VALUE_INPUT_TYPES.has(node.type)) {\n    return true;\n  }\n  return false;\n};\nvar UNSUITABLE_NODE_NAMES = /* @__PURE__ */ new Set([\"SCRIPT\", \"STYLE\"]);\nvar isSuitableNodeForTextMatching = (node) => {\n  return !UNSUITABLE_NODE_NAMES.has(node.nodeName) && !document.head?.contains(node);\n};\nvar textContentCache = /* @__PURE__ */ new WeakMap();\nvar eraseFromCache = (node) => {\n  while (node) {\n    textContentCache.delete(node);\n    if (node instanceof ShadowRoot) {\n      node = node.host;\n    } else {\n      node = node.parentNode;\n    }\n  }\n};\nvar observedNodes = /* @__PURE__ */ new WeakSet();\nvar textChangeObserver = new MutationObserver((mutations) => {\n  for (const mutation of mutations) {\n    eraseFromCache(mutation.target);\n  }\n});\nvar createTextContent = (root) => {\n  let value = textContentCache.get(root);\n  if (value) {\n    return value;\n  }\n  value = { full: \"\", immediate: [] };\n  if (!isSuitableNodeForTextMatching(root)) {\n    return value;\n  }\n  let currentImmediate = \"\";\n  if (isNonTrivialValueNode(root)) {\n    value.full = root.value;\n    value.immediate.push(root.value);\n    root.addEventListener(\n      \"input\",\n      (event) => {\n        eraseFromCache(event.target);\n      },\n      { once: true, capture: true }\n    );\n  } else {\n    for (let child = root.firstChild; child; child = child.nextSibling) {\n      if (child.nodeType === Node.TEXT_NODE) {\n        value.full += child.nodeValue ?? \"\";\n        currentImmediate += child.nodeValue ?? \"\";\n        continue;\n      }\n      if (currentImmediate) {\n        value.immediate.push(currentImmediate);\n      }\n      currentImmediate = \"\";\n      if (child.nodeType === Node.ELEMENT_NODE) {\n        value.full += createTextContent(child).full;\n      }\n    }\n    if (currentImmediate) {\n      value.immediate.push(currentImmediate);\n    }\n    if (root instanceof Element && root.shadowRoot) {\n      value.full += createTextContent(root.shadowRoot).full;\n    }\n    if (!observedNodes.has(root)) {\n      textChangeObserver.observe(root, {\n        childList: true,\n        characterData: true\n      });\n      observedNodes.add(root);\n    }\n  }\n  textContentCache.set(root, value);\n  return value;\n};\n\n// src/injected/TextQuerySelector.ts\nvar textQuerySelectorAll = function* (root, selector) {\n  let yielded = false;\n  for (const node of root.childNodes) {\n    if (node instanceof Element && isSuitableNodeForTextMatching(node)) {\n      let matches;\n      if (!node.shadowRoot) {\n        matches = textQuerySelectorAll(node, selector);\n      } else {\n        matches = textQuerySelectorAll(node.shadowRoot, selector);\n      }\n      for (const match of matches) {\n        yield match;\n        yielded = true;\n      }\n    }\n  }\n  if (yielded) {\n    return;\n  }\n  if (root instanceof Element && isSuitableNodeForTextMatching(root)) {\n    const textContent = createTextContent(root);\n    if (textContent.full.includes(selector)) {\n      yield root;\n    }\n  }\n};\n\n// src/injected/util.ts\nvar util_exports = {};\n__export(util_exports, {\n  checkVisibility: () => checkVisibility,\n  pierce: () => pierce,\n  pierceAll: () => pierceAll\n});\nvar HIDDEN_VISIBILITY_VALUES = [\"hidden\", \"collapse\"];\nvar checkVisibility = (node, visible) => {\n  if (!node) {\n    return visible === false;\n  }\n  if (visible === void 0) {\n    return node;\n  }\n  const element = node.nodeType === Node.TEXT_NODE ? node.parentElement : node;\n  const style = window.getComputedStyle(element);\n  const isVisible = style && !HIDDEN_VISIBILITY_VALUES.includes(style.visibility) && !isBoundingBoxEmpty(element);\n  return visible === isVisible ? node : false;\n};\nfunction isBoundingBoxEmpty(element) {\n  const rect = element.getBoundingClientRect();\n  return rect.width === 0 || rect.height === 0;\n}\nvar hasShadowRoot = (node) => {\n  return \"shadowRoot\" in node && node.shadowRoot instanceof ShadowRoot;\n};\nfunction* pierce(root) {\n  if (hasShadowRoot(root)) {\n    yield root.shadowRoot;\n  } else {\n    yield root;\n  }\n}\nfunction* pierceAll(root) {\n  root = pierce(root).next().value;\n  yield root;\n  const walkers = [document.createTreeWalker(root, NodeFilter.SHOW_ELEMENT)];\n  for (const walker of walkers) {\n    let node;\n    while (node = walker.nextNode()) {\n      if (!node.shadowRoot) {\n        continue;\n      }\n      yield node.shadowRoot;\n      walkers.push(\n        document.createTreeWalker(node.shadowRoot, NodeFilter.SHOW_ELEMENT)\n      );\n    }\n  }\n}\n\n// src/injected/XPathQuerySelector.ts\nvar XPathQuerySelector_exports = {};\n__export(XPathQuerySelector_exports, {\n  xpathQuerySelectorAll: () => xpathQuerySelectorAll\n});\nvar xpathQuerySelectorAll = function* (root, selector) {\n  const doc = root.ownerDocument || document;\n  const iterator = doc.evaluate(\n    selector,\n    root,\n    null,\n    XPathResult.ORDERED_NODE_ITERATOR_TYPE\n  );\n  let item;\n  while (item = iterator.iterateNext()) {\n    yield item;\n  }\n};\n\n// src/injected/PQuerySelector.ts\nvar IDENT_TOKEN_START = /[-\\w\\P{ASCII}*]/;\nvar isQueryableNode = (node) => {\n  return \"querySelectorAll\" in node;\n};\nvar SelectorError = class extends Error {\n  constructor(selector, message) {\n    super(`${selector} is not a valid selector: ${message}`);\n  }\n};\nvar PQueryEngine = class {\n  #input;\n  #complexSelector;\n  #compoundSelector = [];\n  #selector = void 0;\n  elements;\n  constructor(element, input, complexSelector) {\n    this.elements = [element];\n    this.#input = input;\n    this.#complexSelector = complexSelector;\n    this.#next();\n  }\n  async run() {\n    if (typeof this.#selector === \"string\") {\n      switch (this.#selector.trimStart()) {\n        case \":scope\":\n          this.#next();\n          break;\n      }\n    }\n    for (; this.#selector !== void 0; this.#next()) {\n      const selector = this.#selector;\n      const input = this.#input;\n      if (typeof selector === \"string\") {\n        if (selector[0] && IDENT_TOKEN_START.test(selector[0])) {\n          this.elements = AsyncIterableUtil.flatMap(\n            this.elements,\n            async function* (element) {\n              if (isQueryableNode(element)) {\n                yield* element.querySelectorAll(selector);\n              }\n            }\n          );\n        } else {\n          this.elements = AsyncIterableUtil.flatMap(\n            this.elements,\n            async function* (element) {\n              if (!element.parentElement) {\n                if (!isQueryableNode(element)) {\n                  return;\n                }\n                yield* element.querySelectorAll(selector);\n                return;\n              }\n              let index = 0;\n              for (const child of element.parentElement.children) {\n                ++index;\n                if (child === element) {\n                  break;\n                }\n              }\n              yield* element.parentElement.querySelectorAll(\n                `:scope>:nth-child(${index})${selector}`\n              );\n            }\n          );\n        }\n      } else {\n        this.elements = AsyncIterableUtil.flatMap(\n          this.elements,\n          async function* (element) {\n            switch (selector.name) {\n              case \"text\":\n                yield* textQuerySelectorAll(element, selector.value);\n                break;\n              case \"xpath\":\n                yield* xpathQuerySelectorAll(element, selector.value);\n                break;\n              case \"aria\":\n                yield* ariaQuerySelectorAll(element, selector.value);\n                break;\n              default:\n                const querySelector = customQuerySelectors.get(selector.name);\n                if (!querySelector) {\n                  throw new SelectorError(\n                    input,\n                    `Unknown selector type: ${selector.name}`\n                  );\n                }\n                yield* querySelector.querySelectorAll(element, selector.value);\n            }\n          }\n        );\n      }\n    }\n  }\n  #next() {\n    if (this.#compoundSelector.length !== 0) {\n      this.#selector = this.#compoundSelector.shift();\n      return;\n    }\n    if (this.#complexSelector.length === 0) {\n      this.#selector = void 0;\n      return;\n    }\n    const selector = this.#complexSelector.shift();\n    switch (selector) {\n      case \">>>>\" /* Child */: {\n        this.elements = AsyncIterableUtil.flatMap(this.elements, pierce);\n        this.#next();\n        break;\n      }\n      case \">>>\" /* Descendent */: {\n        this.elements = AsyncIterableUtil.flatMap(this.elements, pierceAll);\n        this.#next();\n        break;\n      }\n      default:\n        this.#compoundSelector = selector;\n        this.#next();\n        break;\n    }\n  }\n};\nvar DepthCalculator = class {\n  #cache = /* @__PURE__ */ new WeakMap();\n  calculate(node, depth = []) {\n    if (node === null) {\n      return depth;\n    }\n    if (node instanceof ShadowRoot) {\n      node = node.host;\n    }\n    const cachedDepth = this.#cache.get(node);\n    if (cachedDepth) {\n      return [...cachedDepth, ...depth];\n    }\n    let index = 0;\n    for (let prevSibling = node.previousSibling; prevSibling; prevSibling = prevSibling.previousSibling) {\n      ++index;\n    }\n    const value = this.calculate(node.parentNode, [index]);\n    this.#cache.set(node, value);\n    return [...value, ...depth];\n  }\n};\nvar compareDepths = (a, b) => {\n  if (a.length + b.length === 0) {\n    return 0;\n  }\n  const [i = -1, ...otherA] = a;\n  const [j = -1, ...otherB] = b;\n  if (i === j) {\n    return compareDepths(otherA, otherB);\n  }\n  return i < j ? -1 : 1;\n};\nvar domSort = async function* (elements) {\n  const results = /* @__PURE__ */ new Set();\n  for await (const element of elements) {\n    results.add(element);\n  }\n  const calculator = new DepthCalculator();\n  yield* [...results.values()].map((result) => {\n    return [result, calculator.calculate(result)];\n  }).sort(([, a], [, b]) => {\n    return compareDepths(a, b);\n  }).map(([result]) => {\n    return result;\n  });\n};\nvar pQuerySelectorAll = function(root, selector) {\n  let selectors;\n  let isPureCSS;\n  try {\n    [selectors, isPureCSS] = parsePSelectors(selector);\n  } catch (error) {\n    return root.querySelectorAll(selector);\n  }\n  if (isPureCSS) {\n    return root.querySelectorAll(selector);\n  }\n  if (selectors.some((parts) => {\n    let i = 0;\n    return parts.some((parts2) => {\n      if (typeof parts2 === \"string\") {\n        ++i;\n      } else {\n        i = 0;\n      }\n      return i > 1;\n    });\n  })) {\n    throw new SelectorError(\n      selector,\n      \"Multiple deep combinators found in sequence.\"\n    );\n  }\n  return domSort(\n    AsyncIterableUtil.flatMap(selectors, (selectorParts) => {\n      const query = new PQueryEngine(root, selector, selectorParts);\n      void query.run();\n      return query.elements;\n    })\n  );\n};\nvar pQuerySelector = async function(root, selector) {\n  for await (const element of pQuerySelectorAll(root, selector)) {\n    return element;\n  }\n  return null;\n};\n\n// src/injected/injected.ts\nvar PuppeteerUtil = Object.freeze({\n  ...ARIAQuerySelector_exports,\n  ...CustomQuerySelector_exports,\n  ...PierceQuerySelector_exports,\n  ...PQuerySelector_exports,\n  ...TextQuerySelector_exports,\n  ...util_exports,\n  ...XPathQuerySelector_exports,\n  Deferred,\n  createFunction,\n  createTextContent,\n  IntervalPoller,\n  isSuitableNodeForTextMatching,\n  MutationPoller,\n  RAFPoller\n});\nvar injected_default = PuppeteerUtil;\n";
