// Copyright 2020 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

import * as Common from '../common/common.js';
import * as Host from '../host/host.js';
import * as UI from '../ui/ui.js';

import {CollectionsPane} from './collections-pane.js';
import {CollectionsStorage} from './collections-storage.js';
import {EnvironmentsPane} from './environments-pane.js';
import {NetworkConsoleView} from './network-console-view.js';  // eslint-disable-line no-unused-vars

const {Collections, Environments} = self.NCShared;

/**
 * @typedef {Object} IFileMetadata
 * @property {'collection' | 'environments'} type
 */

export class NetworkConsoleSidebar extends UI.Widget.VBox {
  /**
   * @param {!NetworkConsoleView} panel
   */
  constructor(panel) {
    super();
    this._view = panel;
    this._storage = CollectionsStorage.instance();
    this._sidebarPaneStack = UI.ViewManager.ViewManager.instance().createStackLocation();
    this._collectionsPane = new CollectionsPane(this);
    this._sidebarPaneStack.showView(this._collectionsPane);
    this._environmentsPane = new EnvironmentsPane(this);
    this._sidebarPaneStack.showView(this._environmentsPane);
    this._sidebarPaneStack.widget().show(this.element);
    this._restoreCollections();
  }

  /**
   * @param {string} name
   * @param {string} contents
   * @param {!IFileMetadata} metadata
   */
  async importFile(name, contents, metadata) {
    const succeeded = await this._restoreFile(name, contents, metadata);
    if (succeeded) {
      this._storage.createFile(name, contents, metadata, /* replaceIfExists: */ true);
    }
  }

  async _restoreCollections() {
    const files = this._storage.findAllFiles();

    const readFiles = files.map(file => {
      const entry = this._storage.readFile(file, true);
      return {file, content: entry.content, metadata: /** @type {!IFileMetadata} */ (entry.metadata)};
    });

    await Promise.all(readFiles.map(async file => {
      await this._restoreFile(file.file, file.content, file.metadata);
    }));

    const lastActivatedEnvironment = this._storage.lastActivatedEnvironment();
    if (lastActivatedEnvironment) {
      const environmentElement = this._environmentsPane.findEnvironmentById(lastActivatedEnvironment);
      if (environmentElement) {
        this._environmentsPane.activateEnvironment(environmentElement);
      }
    }
  }

  /**
   * @param {string} path
   * @param {string} content
   * @param {!IFileMetadata} metadata
   * @return {!Promise<boolean>}
   */
  async _restoreFile(path, content, metadata) {
    if (metadata.type === 'collection') {
      const reader = await Collections.tryReadCollectionAsync(path, content);
      if (reader) {
        this._collectionsPane.appendReader(path, reader);
        return true;
      }

      console.warn('Failed to restore reader for ' + path);

    } else if (metadata.type === 'environments') {
      const reader = await Environments.tryReadEnvironmentAsync(path, content);
      if (reader) {
        this._environmentsPane.addFromReader(path, reader, /* activate: */ false);
        return true;
      }

      console.warn('Failed to restore reader for ' + path);
    }

    return false;
  }

  /**
   *
   * @param {string} openApiUrl
   */
  async connectToOpenApi(openApiUrl) {
    const result = await loadAsync(openApiUrl);
    const reader = await Collections.tryReadCollectionAsync(openApiUrl, result.result);
    if (reader) {
      this._collectionsPane.appendReader(openApiUrl, reader);
      this._storage.createFile(openApiUrl, result.result, {type: 'collection'}, /* replaceIfExists: */ true);

      let environmentBaseUrl = reader.baseUrl;
      if (!environmentBaseUrl) {
        const parsed = Common.ParsedURL.ParsedURL.fromString(openApiUrl);
        if (parsed) {
          environmentBaseUrl = `${parsed.scheme}://${parsed.host}`;
          if (parsed.port) {
            environmentBaseUrl += ':' + parsed.port;
          }
        }
      }
      if (environmentBaseUrl) {
        const tempEnvironmentJson =
            Environments.serializeNativeEnvironmentFormat(reader.name, ls`${reader.name} (Automatic)`, [{
                                                            key: 'baseUri',
                                                            value: environmentBaseUrl,
                                                            description: 'Autogenerated base URI for a given service.',
                                                            isActive: true,
                                                          }]);
        const tempId = '$generated_environment::' + openApiUrl + '::.ncenv.json';
        const tempEnvironmentReader = await Environments.tryReadEnvironmentAsync(tempId, tempEnvironmentJson);
        this._environmentsPane.addFromReader(tempId, tempEnvironmentReader, /* activate: */ true);
        this._storage.createFile(tempId, tempEnvironmentJson, {type: 'environments'}, /* replaceIfExists: */ true);
      }
    }
  }

  networkConsoleView() {
    return this._view;
  }
}

/**
 * @param {string} url
 * @return {!Promise<!{success: boolean; headers: !Object.<string, string>; result: string; errorDescription: !LoadErrorDescription;}>}
 */
function loadAsync(url) {
  return new Promise(fulfill => {
    Host.ResourceLoader.load(url, {}, callback);

    /**
     *
     * @param {boolean} success
     * @param {!Object.<string, string>} headers
     * @param {string} content
     * @param {any} errorDescription
     */
    function callback(success, headers, content, errorDescription) {
      fulfill({success, headers, result: content, errorDescription});
    }
  });
}
