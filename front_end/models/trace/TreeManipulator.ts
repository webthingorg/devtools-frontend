// Copyright 2023 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.
import * as Platform from '../../core/platform/platform.js';

import type * as Handlers from './handlers/handlers.js';
import type * as Helpers from './helpers/helpers.js';
import type * as Types from './types/types.js';

type EntryToNodeMap = Map<Types.TraceEvents.TraceEntry, Helpers.TreeHelpers.TraceEntryNode>;

export const enum TreeAction {
  MERGE_FUNCTION = 'MERGE_FUNCTION',
  COLLAPSE_FUNCTION = 'COLLAPSE_FUNCTION',
  COLLAPSE_RECURSION = 'COLLAPSE_RECURSION',
}

export interface UserTreeAction {
  type: TreeAction;
  entry: Types.TraceEvents.TraceEntry;
}

/**
 * This class can take in a thread that has been generated by the
 * RendererHandler and apply certain actions to it in order to modify what is
 * shown to the user. These actions can be automatically applied by DevTools or
 * applied by the user.
 *
 * Once actions are applied, the invisibleEntries() method will return the
 * entries that are invisible, and this is the list of entries that should be
 * removed before rendering the resulting thread on the timeline.
 **/
export class TreeManipulator {
  #thread: Handlers.ModelHandlers.Renderer.RendererThread;
  // Maps from an individual TraceEvent entry to its representation as a
  // RendererEntryNode. We need this so we can then parse the tree structure
  // generated by the RendererHandler.
  #entryToNode: EntryToNodeMap;

  // Track the last calculated set of invisible entries. This means we can avoid
  // re-generating this if the set of actions that have been applied has not
  // changed.
  #lastInvisibleEntries: Types.TraceEvents.TraceEntry[]|null = null;
  #activeActions: UserTreeAction[] = [];

  constructor(
      thread: Handlers.ModelHandlers.Renderer.RendererThread,
      entryToNode: EntryToNodeMap,
  ) {
    this.#thread = thread;
    this.#entryToNode = entryToNode;
  }

  /**
   * Applies an action to the visible tree. This will also clear the cache of
   * invisible entries, ensuring that it will be recalculated with the latest set
   * of actions.
   **/
  applyAction(action: UserTreeAction): void {
    if (this.#actionIsActive(action)) {
      // If the action is already active there is no reason to apply it again.
      return;
    }

    this.#activeActions.push(action);
    // Clear the last list of invisible entries - this invalidates the cache and
    // ensures that the invisible list will be recalculated, which we have to do
    // now we have changed the list of actions.
    this.#lastInvisibleEntries = null;
  }

  /**
   * Removes a matching action, if one is found, from the active actions set.
   * Note that we do not match on action equality and instead search through
   * the set of active actions for one that is of the same type, and has the
   * same entry associated with it.
   *
   * This is a no-op if the action is not active.
   **/
  removeActiveAction(action: UserTreeAction): void {
    let removedAction = false;
    this.#activeActions = this.#activeActions.filter(activeAction => {
      if (activeAction.type === action.type && activeAction.entry === action.entry) {
        removedAction = true;
        return false;
      }
      return true;
    });

    if (removedAction) {
      // If we found and removed an action, we need to clear the cache to force
      // the set of invisible entries to be recalculcated.
      this.#lastInvisibleEntries = null;
    }
  }

  #actionIsActive(action: UserTreeAction): boolean {
    return this.#activeActions.some(activeAction => {
      return action.entry === activeAction.entry && action.type === activeAction.type;
    });
  }

  /**
   * The set of entries that are invisible given the set of applied actions. If
   * no actions are applied, this will return an empty list of entries.
   *
   * This method is cached, so it is safe to call multiple times.
   **/
  invisibleEntries(): Types.TraceEvents.TraceEventData[] {
    if (this.#activeActions.length === 0) {
      return [];
    }
    return this.#calculateInvisibleEntries();
  }

  #calculateInvisibleEntries(): Types.TraceEvents.TraceEventData[] {
    // When an action is added, we clear this cache. So if this cache is
    // present it means that the set of active actions has not changed, and so
    // we do not need to recalculate anything.
    if (this.#lastInvisibleEntries) {
      return this.#lastInvisibleEntries;
    }

    if (!this.#thread.tree) {
      // We need a tree to be able to calculate user actions, if we do not have
      // it, just return an empty list.
      return [];
    }

    // We apply each user action in turn to the set of all entries, and mark
    // any that should be hidden by adding them to this set. We do this to
    // ensure we minimise the amount of passes through the list of all entries.
    // Another approach would be to use splice() to remove items from the
    // array, but doing this would be a mutation of the arry for every hidden
    // event. Instead, we add entries to this set and return it as an array at the end.
    const entriesToHide = new Set<Types.TraceEvents.TraceEntry>();

    for (const action of this.#activeActions) {
      switch (action.type) {
        case TreeAction.MERGE_FUNCTION: {
          // The entry that was clicked on is merged into its parent. All its
          // children remain visible, so we just have to hide the entry that was
          // selected.
          entriesToHide.add(action.entry);
          break;
        }

        case TreeAction.COLLAPSE_FUNCTION: {
          // The entry itself remains visible, but all of its ancestors are hidden.
          const entryNode = this.#entryToNode.get(action.entry);
          if (!entryNode) {
            // Invalid node was given, just ignore and move on.
            continue;
          }
          const allAncestors = this.#findAllAncestorsOfNode(entryNode);
          allAncestors.forEach(ancestor => entriesToHide.add(ancestor));
          break;
        }

        case TreeAction.COLLAPSE_RECURSION: {
          // The entry itself remains visible, but all of its ancestors are hidden.
          const entryNode = this.#entryToNode.get(action.entry);
          if (!entryNode) {
            // Invalid node was given, just ignore and move on.
            continue;
          }
          const allAncestors = this.#findAllAncestorsOfNextRecursiveNode(entryNode);
          allAncestors.forEach(ancestor => entriesToHide.add(ancestor));
          console.log("hide ", allAncestors);
          break;
        }
        default:
          Platform.assertNever(action.type, `Unknown TreeManipulator action: ${action.type}`);
      }
    }

    // Now we have applied all actions, return the invisible entries.
    // We cache this under lastInvisibleEntries - if this function is called
    // again and the user actions have not changed, we can avoid recalculating
    // this and just return the last one. This cache is automatically cleared
    // when the user actions are changed.

    this.#lastInvisibleEntries = [...entriesToHide];

    return this.#lastInvisibleEntries;
  }

  #findAllAncestorsOfNode(root: Helpers.TreeHelpers.TraceEntryNode): Types.TraceEvents.TraceEntry[] {
    const ancestors: Types.TraceEvents.TraceEntry[] = [];

    // Walk through all the ancestors, starting at the root node.
    const children: Helpers.TreeHelpers.TraceEntryNode[] = root.children;
    while (children.length > 0) {
      const childNode = children.shift();
      if (childNode) {
        ancestors.push(childNode.entry);
        children.push(...childNode.children);
      }
    }

    return ancestors;
  }

  #findAllAncestorsOfNextRecursiveNode(root: Helpers.TreeHelpers.TraceEntryNode): Types.TraceEvents.TraceEntry[] {
    const ancestors: Types.TraceEvents.TraceEntry[] = [];
    let foundRecurion: boolean = false;

    // Walk through all the ancestors, starting at the root node.
    const children: Helpers.TreeHelpers.TraceEntryNode[] = root.children;
    while (children.length > 0) {
      const childNode = children.shift();
      if (childNode) {
        foundRecurion = JSON.stringify(childNode.entry.callFrame) == JSON.stringify(root.entry.callFrame);
        if(foundRecurion) {
          return this.#findAllAncestorsOfNode(childNode);
        }
        children.push(...childNode.children);
      }
    }

    return ancestors;
  }
}
