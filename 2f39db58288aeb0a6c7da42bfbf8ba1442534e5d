{
  "comments": [
    {
      "key": {
        "uuid": "71193513_88f3ccf2",
        "filename": "front_end/platform/string-utilities.js",
        "patchSetId": 1
      },
      "lineNbr": 370,
      "author": {
        "id": 1214214
      },
      "writtenOn": "2020-04-03T08:43:30Z",
      "side": 1,
      "message": "We could also avoid the need for calling codePointAt() by using string comparisons instead, and handling the surrogate pair case by checking the `length` of each symbol:\n\n    export const countWtf8Bytes \u003d inputString \u003d\u003e {\n      let count \u003d 0;\n      for (const symbol of inputString) {\n        if (symbol \u003c\u003d \u0027\\x7F\u0027) {\n          count++;\n        } else if (symbol \u003c\u003d \u0027\\u07FF\u0027) {\n          count +\u003d 2;\n        } else if (symbol.length \u003d\u003d\u003d 1) {\n          // Note that we don‚Äôt have to special-case the surrogate range\n          // (D800..DFFF) since for-of iteration on strings already takes\n          // care of combining surrogate pairs into a single character,\n          // while preserving any lone surrogates.\n          count +\u003d 3;\n        } else {\n          count +\u003d 4;\n        }\n      }\n      return count;\n    };\n\nThis is less readable and feels more \"clever\", though, so I\u0027m inclined to stick with the current approach. WDYT?",
      "revId": "2f39db58288aeb0a6c7da42bfbf8ba1442534e5d",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "ad936150_8018ccbd",
        "filename": "front_end/platform/string-utilities.js",
        "patchSetId": 1
      },
      "lineNbr": 370,
      "author": {
        "id": 1189020
      },
      "writtenOn": "2020-04-03T08:46:46Z",
      "side": 1,
      "message": "Stick with clearer imo. Out of interest, do we know how this compares counting long strings compared to -- say -- TextEncoder or Blob?",
      "parentUuid": "71193513_88f3ccf2",
      "revId": "2f39db58288aeb0a6c7da42bfbf8ba1442534e5d",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "842ac736_887dc3b3",
        "filename": "front_end/platform/string-utilities.js",
        "patchSetId": 1
      },
      "lineNbr": 370,
      "author": {
        "id": 1214214
      },
      "writtenOn": "2020-04-03T09:39:44Z",
      "side": 1,
      "message": "Performance test case with various implementations:\n\n    const countWtf8BytesWithEncoding \u003d inputString \u003d\u003e {\n      const encoder \u003d new TextEncoder();\n      const buffer \u003d encoder.encode(inputString);\n      return buffer.byteLength;\n    };\n\n    const countWtf8BytesWithoutEncoding \u003d inputString \u003d\u003e {\n      let count \u003d 0;\n      for (const symbol of inputString) {\n        const codePoint \u003d symbol.codePointAt(0);\n        if (codePoint \u003c\u003d 0x7F) {\n          count++;\n        } else if (codePoint \u003c\u003d 0x07FF) {\n          count +\u003d 2;\n        } else if (codePoint \u003c\u003d 0xFFFF) {\n          count +\u003d 3;\n        } else {\n          count +\u003d 4;\n        }\n      }\n      return count;\n    };\n\n    const countWtf8BytesWithoutEncodingMoarClever \u003d inputString \u003d\u003e {\n      let count \u003d 0;\n      for (const symbol of inputString) {\n        if (symbol \u003c\u003d \u0027\\x7F\u0027) {\n          count++;\n        } else if (symbol \u003c\u003d \u0027\\u07FF\u0027) {\n          count +\u003d 2;\n        } else if (symbol.length \u003d\u003d\u003d 1) {\n          count +\u003d 3;\n        } else {\n          count +\u003d 4;\n        }\n      }\n      return count;\n    };\n\n    const countWtf8BytesWithoutEncodingWithoutIterator \u003d inputString \u003d\u003e {\n      let count \u003d 0;\n      for (let i \u003d 0; i \u003c inputString.length; i++) {\n        const c \u003d inputString.charCodeAt(i);\n        if (c \u003c\u003d 0x7F) {\n          count++;\n        } else if (c \u003c\u003d 0x07FF) {\n          count +\u003d 2;\n        } else if (c \u003c 0xD800 || c \u003e 0xDFFF) {\n          count +\u003d 3;\n        } else {\n          // The current character is a leading surrogate, and there is a next character.\n          if (c \u003c\u003d 0xDBFF \u0026\u0026 i + 1 \u003c inputString.length) {\n            const next \u003d inputString.charCodeAt(i + 1);\n            if (next \u003e\u003d 0xDC00 \u0026\u0026 next \u003c\u003d 0xDFFF) {\n              // The next character is a trailing surrogate, meaning this is a\n              // surrogate pair.\n              count +\u003d 4;\n              i++;\n              continue;\n            }\n          }\n          count +\u003d 3;\n        }\n      }\n      return count;\n    };\n\n    const assert \u003d {\n      equal: function(a, b) { console.assert(a \u003d\u003d\u003d b); },\n    };\n\n    assert.equal(countWtf8BytesWithoutEncodingWithoutIterator(\u0027a\u0027), 1);\n    assert.equal(countWtf8BytesWithoutEncodingWithoutIterator(\u0027\\x7F\u0027), 1);\n    assert.equal(countWtf8BytesWithoutEncodingWithoutIterator(\u0027\\u07FF\u0027), 2);\n    assert.equal(countWtf8BytesWithoutEncodingWithoutIterator(\u0027\\uD800\u0027), 3);\n    assert.equal(countWtf8BytesWithoutEncodingWithoutIterator(\u0027\\uDBFF\u0027), 3);\n    assert.equal(countWtf8BytesWithoutEncodingWithoutIterator(\u0027\\uDC00\u0027), 3);\n    assert.equal(countWtf8BytesWithoutEncodingWithoutIterator(\u0027\\uDFFF\u0027), 3);\n    assert.equal(countWtf8BytesWithoutEncodingWithoutIterator(\u0027\\uFFFF\u0027), 3);\n    assert.equal(countWtf8BytesWithoutEncodingWithoutIterator(\u0027\\u{10FFFF}\u0027), 4);\n    assert.equal(countWtf8BytesWithoutEncodingWithoutIterator(\u0027I√±t√´rn√¢ti√¥n√†liz√¶ti√∏n‚òÉüí©\u0027), 34);\n\n    const string \u003d \u0027I√±t√´rn√¢ti√¥n√†liz√¶ti√∏n‚òÉüí©\u0027.repeat(1_000_000);\n    //const string \u003d \u0027ASCII-only\u0027.repeat(1_000_000);\n\n    console.time(\u0027countWtf8BytesWithEncoding\u0027);\n    globalThis.resultWithEncoding \u003d countWtf8BytesWithEncoding(string);\n    console.timeEnd(\u0027countWtf8BytesWithEncoding\u0027);\n\n    console.time(\u0027countWtf8BytesWithoutEncoding\u0027);\n    globalThis.resultWithoutEncoding \u003d countWtf8BytesWithoutEncoding(string);\n    console.timeEnd(\u0027countWtf8BytesWithoutEncoding\u0027);\n\n    console.time(\u0027countWtf8BytesWithoutEncodingMoarClever\u0027);\n    globalThis.resultWithoutEncodingMoarClever \u003d countWtf8BytesWithoutEncodingMoarClever(string);\n    console.timeEnd(\u0027countWtf8BytesWithoutEncodingMoarClever\u0027);\n\n    console.time(\u0027countWtf8BytesWithoutEncodingWithoutIterator\u0027);\n    globalThis.resultWithoutEncodingWithoutIterator \u003d countWtf8BytesWithoutEncodingWithoutIterator(string);\n    console.timeEnd(\u0027countWtf8BytesWithoutEncodingWithoutIterator\u0027);\n\nResults for `string \u003d \u0027I√±t√´rn√¢ti√¥n√†liz√¶ti√∏n‚òÉüí©\u0027.repeat(1_000_000)`:\n\n    countWtf8BytesWithEncoding:                   166.01611328125ms\n    countWtf8BytesWithoutEncoding:                385.34301757813ms\n    countWtf8BytesWithoutEncodingMoarClever:      535.68383789063ms\n    countWtf8BytesWithoutEncodingWithoutIterator:  98.18408203125ms\n\nResults for `string \u003d \u0027ASCII-only\u0027.repeat(1_000_000)`:\n\n    countWtf8BytesWithEncoding:                    41.830078125ms\n    countWtf8BytesWithoutEncoding:                145.895996094ms\n    countWtf8BytesWithoutEncodingMoarClever:      163.958984375ms\n    countWtf8BytesWithoutEncodingWithoutIterator:  45.334228516ms\n\nSo by avoiding the overhead of for-of and String.prototype[Symbol.iterator], we\u0027re significantly faster for non-ASCII text, and only slightly slower for ASCII-only text.\n\nI\u0027ll swap the CL\u0027s implementation with the new, unrolled one (countWtf8BytesWithoutEncodingWithoutIterator).",
      "parentUuid": "ad936150_8018ccbd",
      "revId": "2f39db58288aeb0a6c7da42bfbf8ba1442534e5d",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    }
  ]
}